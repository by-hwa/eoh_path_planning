{
     "algorithm": "Improved path planning algorithm inspired by RRT* with goal bias and adaptive rewiring:\n    - Uses goal-biased sampling to improve efficiency and success rate.\n    - Incorporates rewiring around new vertices to optimize path cost and smoothness.\n    - Employs adaptive max_dist based on distance to goal for finer expansion near goal.\n    - Path extraction includes shortcutting to smooth final path.\n    - Early stopping after 10 seconds to handle time constraints robustly.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, \n                                 Vertex(self._get_grid().agent.position), \n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow rewiring\n        self._init_displays()\n        # parameters\n        self._goal_sample_rate = 0.2  # 20% samples are goal biased\n        self._search_radius = 15.0     # radius for rewiring neighbors\n        self._max_iterations = 8000\n\n    def _get_max_dist(self, q_near: Vertex) -> float:\n        \"\"\"Adaptive max_dist based on distance from q_near to goal.\"\"\"\n        dist_to_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n        max_step = 15.0\n        min_step = 3.0\n        # linearly scale max_dist: bigger step far from goal, smaller near goal\n        max_dist = min_step + (max_step - min_step) * np.tanh(dist_to_goal / 30)\n        return max_dist\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: list) -> Vertex:\n        # Choose parent with minimum cost for q_new with valid line sequence\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = v.cost + self._get_grid().get_distance(v.position, q_new.position)\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = v\n        if best_parent is None:\n            return None\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: list) -> None:\n        # For each neighbor, try to improve their cost by rewiring through q_new\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, v.position)\n            if new_cost < v.cost:\n                # Remove previous parents edges to v, add new edge q_new -> v\n                parents = list(v.parents)\n                for p in parents:\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        # Try to shortcut the path by connecting non-adjacent vertices directly if line is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Find the farthest reachable vertex from i by valid line\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n    \n    def _extract_path(self, q_goal: Vertex):\n        # Trace back from goal to start and reconstruct path then shortcut it\n        path = [q_goal]\n        while path[-1].parents:\n            # Take any one parent (graph is a tree)\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n        root_start.cost = 0.0\n        self._graph.root_vertices = [root_start]\n\n        for iteration in range(self._max_iterations):\n            if time() - start_time > 10:\n                # Timeout, treat as failure to find path\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n            max_dist = self._get_max_dist(q_near)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find neighbors for rewiring (within radius)\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._search_radius)\n\n            # Choose best parent among neighbors\n            best_parent = self._choose_parent(q_new, near_vertices)\n            if best_parent is None:\n                continue  # no valid parent connection\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new if cost improves\n            self._rewire(q_new, near_vertices)\n\n            self._graph.root_vertices.append(q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Connect to goal vertex\n                goal_v = Vertex(self._get_grid().goal.position)\n                # Choose parent for goal vertex from neighbors near goal\n                near_goal_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, goal_v.position, self._search_radius)\n                best_goal_parent = self._choose_parent(goal_v, near_goal_vertices)\n                if best_goal_parent is not None:\n                    self._graph.add_edge(best_goal_parent, goal_v)\n                    goal_v.cost = best_goal_parent.cost + self._get_grid().get_distance(best_goal_parent.position, goal_v.position)\n                    self._graph.root_vertices.append(goal_v)\n                    self._extract_path(goal_v)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm inspired by RRT* with heuristic-biased sampling:\n    - Uses goal-biased sampling to increase chances of guided exploration toward the goal.\n    - Incorporates A*-style cost heuristics combining path cost and Euclidean distance to goal for vertex selection.\n    - Implements rewiring of vertices within a dynamic radius to optimize path quality.\n    - Adapts max step size based on local obstacle density to balance exploration and local refinement.\n    - Performs path shortcutting (smoothing) after path extraction to improve path quality.\n    - Employs early stopping via a 10-second time limit to enhance responsiveness.\n    - Uses Forest structure to maintain connectivity and support rewiring with efficient nearest neighbors and radius queries.\n    This algorithm aims to improve planning efficiency, path smoothness, and success rate compared to basic RRT and RRT-Connect.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position, True), Vertex(self._get_grid().goal.position, True), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_default = 15.0\n        self._iterations = 6000\n        self._goal_sample_rate = 0.15  # probability to sample goal point\n        self._rewire_radius_const = 25.0\n        self._smooth_iterations = 20\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples goal point with probability self._goal_sample_rate,\n        else uniform random valid sample in environment.\n        \"\"\"\n        if np.random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Generate new vertex from q_near toward q_sample limited by max_dist.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        \n        dir_normalized = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Adaptive max dist based on local obstacle density in vicinity.\n        More obstacles => smaller steps for fine navigation.\n        \"\"\"\n        radius = 5\n        obstacles = 0\n        total_checks = 0\n        for dx in range(-radius, radius+1):\n            for dy in range(-radius, radius+1):\n                check_pos = Point(pos.x + dx, pos.y + dy)\n                total_checks += 1\n                if not self._get_grid().is_agent_valid_pos(check_pos):\n                    obstacles += 1\n        density = obstacles / max(total_checks, 1)\n        max_dist = self._max_dist_default * (1.0 - 0.6 * density)\n        return max(3.0, min(self._max_dist_default, max_dist))\n\n    def _cost(self, vertex: Vertex) -> float:\n        \"\"\"\n        Returns cost-to-come from root start to vertex.\n        \"\"\"\n        return vertex.cost if vertex.cost is not None else float('inf')\n\n    def _heuristic(self, p: Point) -> float:\n        \"\"\"\n        Heuristic is Euclidean distance to goal.\n        \"\"\"\n        return self._get_grid().get_distance(p, self._get_grid().goal.position)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Choose parent vertex from near_vertices for q_new that minimizes (cost + distance).\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            new_cost = self._cost(v) + self._get_grid().get_distance(v.position, q_new.position)\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewire nearby vertices to q_new if it improves their cost.\n        \"\"\"\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = self._cost(q_new) + self._get_grid().get_distance(q_new.position, v.position)\n            if new_cost < self._cost(v):\n                # Remove old parent edge(s)\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _extract_path(self, q_final: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal by backtracking parents.\n        Then applies path shortcutting for smoothing.\n        \"\"\"\n        path: List[Vertex] = [q_final]\n        # Backtrack parents to root start vertex\n        current = q_final\n        while current.position != self._graph.root_vertex_start.position:\n            if not current.parents:\n                break  # no parent => broken path\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Smooth the path with simple shortcutting\n        smoothed_points = self._shortcut_path([v.position for v in path])\n\n        # Move agent along the smoothed path with keyframes\n        for pt in smoothed_points:\n            self.move_agent(pt)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, points: List[Point]) -> List[Point]:\n        \"\"\"\n        Attempt to shortcut the path by checking if direct lines between pairs of points are valid.\n        \"\"\"\n        if len(points) <= 2:\n            return points\n        \n        path = points[:]\n        for _ in range(self._smooth_iterations):\n            if len(path) <= 2:\n                break\n            i = np.random.randint(0, len(path) - 2)\n            j = np.random.randint(i+2, len(path))\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i], path[j])):\n                del path[i+1:j]\n        return path\n\n    def _get_nearest_vertex_heuristic(self, q_sample: Point) -> Vertex:\n        \"\"\"\n        Find vertex in forest minimizing cost-to-come plus heuristic-to-goal distance from q_sample.\n        \"\"\"\n        best_vertex = None\n        best_score = float('inf')\n        for v in self._graph.root_vertices:\n            dist_to_sample = self._get_grid().get_distance(v.position, q_sample)\n            if dist_to_sample == 0:\n                # Vertex same as sample\n                return v\n            cost_plus_heuristic = self._cost(v) + dist_to_sample + self._heuristic(q_sample)\n            if cost_plus_heuristic < best_score:\n                best_score = cost_plus_heuristic\n                best_vertex = v\n        return best_vertex if best_vertex is not None else self._graph.root_vertex_start\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        self._graph.root_vertex_start.cost = 0.0\n        found_path = False\n\n        for i in range(self._iterations):\n            if time() - start_time > 10.0:  # time limit 10s\n                break\n\n            q_sample: Point = self._get_random_sample()  \n\n            max_dist = self._adaptive_max_dist(self._graph.root_vertex_start.position)\n\n            # Select nearest vertex with heuristic guidance\n            q_near: Vertex = self._get_nearest_vertex_heuristic(q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius for neighborhood vertices for rewiring (shrinking with iteration)\n            radius = min(self._rewire_radius_const, max_dist * (np.log(self._graph.size + 1) / (self._graph.size + 1)) ** 0.5)\n\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = self._cost(q_near) + self._get_grid().get_distance(q_near.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors to q_new if beneficial\n            self._rewire(q_new, near_vertices)\n\n            # Add new vertex to forest roots for future expansion\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal radius reached\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                found_path = True\n                break\n\n            # Visualization update\n            self.key_frame()\n\n        # If path not found, mark keyframe to reflect failure\n        if not found_path:\n            self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved, heuristic-guided bidirectional RRT* variant \n    with goal-biased adaptive sampling and dynamic max step size adjustment based on nearest obstacle distance. \n    It grows two trees from start and goal concurrently, attempts connection often, and rewires for cost optimization. \n    A heuristic (Euclidean + cost so far) aids in selecting best parents and rewiring. \n    After connection, a shortcut smoothing is applied on the extracted path. \n    Early stopping includes a time limit of 10 seconds and immediate path extraction once trees connect.\n    This approach aims to improve efficiency, path quality, and robustness in complex obstacle environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_iterations: int\n    _dimension: int\n    _max_step_base: float\n    _goal_bias: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 5000\n        self._dimension = 2\n        self._max_step_base = 12.0\n        self._goal_bias = 0.2\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling (sample goal with probability self._goal_bias)\n        import random\n\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point, roots: list) -> Vertex:\n        return self._graph.get_nearest_vertex(roots, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float, roots: list) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(roots, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_point)\n\n    def _calc_heuristic_cost(self, from_v: Vertex, to: Point) -> float:\n        # Simple Euclidean distance heuristic\n        return Map.get_distance(from_v.position, to)\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex], roots: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + Map.get_distance(q_new.position, q_near.position)\n            if q_near.cost is None or new_cost < q_near.cost:\n                # Remove old parent edge\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge\n                q_near.cost = new_cost\n                self._graph.add_edge(q_new, q_near)\n\n    def _choose_best_parent(self, q_new: Vertex, Q_near: List[Vertex]) -> Vertex:\n        min_cost = None\n        best_parent = None\n        for q_near in Q_near:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = (q_near.cost if q_near.cost is not None else float('inf')) + Map.get_distance(q_near.position, q_new.position)\n            if min_cost is None or cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return best_parent\n\n    def _attempt_connect(self, q_new: Vertex, roots_from: list, roots_to: list, connect_radius: float) -> Vertex:\n        # Try to connect q_new to vertices in roots_to within connect_radius\n        candidates = self._graph.get_vertices_within_radius(roots_to, q_new.position, connect_radius)\n        best_connect = None\n        best_cost = None\n        for q_other in candidates:\n            if q_other == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_other.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            total_cost = (q_new.cost if q_new.cost is not None else float('inf')) + Map.get_distance(q_new.position, q_other.position) + (q_other.cost if q_other.cost is not None else float('inf'))\n            if best_cost is None or total_cost < best_cost:\n                best_cost = total_cost\n                best_connect = q_other\n        if best_connect:\n            # Add connecting edges\n            self._graph.add_edge(q_new, best_connect)\n            self._graph.add_edge(best_connect, q_new)\n            return best_connect\n        return None\n\n    def _extract_bidirectional_path(self, connect_v1: Vertex, connect_v2: Vertex) -> List[Vertex]:\n        # Build path from start to connect_v1\n        path_start = []\n        cur = connect_v1\n        while True:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            cur = next(iter(cur.parents))\n        path_start.reverse()\n\n        # Build path from connect_v2 to goal\n        path_goal = []\n        cur = connect_v2\n        while True:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            cur = next(iter(cur.parents))\n        # concatenate\n        full_path = path_start + path_goal\n        return full_path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iter = self._max_iterations\n        max_step = self._max_step_base\n        lam = 50  # for radius calculation similar to RRT*\n        d = self._dimension\n\n        start_tree_roots = [self._graph.root_vertex_start]\n        goal_tree_roots = [self._graph.root_vertex_goal]\n\n        # For convenient references\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        for itr in range(max_iter):\n            if time.time() - start_time > 10.0:\n                # Timeout - no path found\n                break\n\n            # Alternate trees for expansion: even itr -> start tree, odd itr -> goal tree\n            if itr % 2 == 0:\n                tree_from = start_tree_roots\n                tree_to = goal_tree_roots\n            else:\n                tree_from = goal_tree_roots\n                tree_to = start_tree_roots\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample, tree_from)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Dynamically adjust max_step based on proximity to obstacles (approximate)\n            # Find min obstacle dist at q_nearest, fallback if none found\n            min_obs_dist = max_step\n            for obstacle in self._get_grid().obstacles:\n                dist_obs = Map.get_distance(q_nearest.position, obstacle.position)\n                if dist_obs < min_obs_dist:\n                    min_obs_dist = dist_obs\n            adaptive_max_step = max(4.0, min(max_step, min_obs_dist * 0.5))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, adaptive_max_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors to rewire and choose best parent\n            n = max(1, self._graph.size)\n            r = min(lam * ((torch.log(torch.tensor(n).float()) / torch.tensor(n)) ** (1 / d)).item(), 30)\n\n            Q_near = self._get_vertices_within_radius(q_new, r, tree_from)\n\n            q_min = self._choose_best_parent(q_new, Q_near)\n            if q_min is None:\n                q_min = q_nearest\n\n            cost_min = q_min.cost + Map.get_distance(q_min.position, q_new.position) if q_min.cost is not None else float('inf')\n            q_new.cost = cost_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors using q_new as parent if better\n            self._rewire(q_new, Q_near, tree_from)\n\n            # Add new vertex to tree\n            tree_from.append(q_new)\n\n            # Attempt connection to opposite tree\n            connect_radius = 15.0\n            q_connect = self._attempt_connect(q_new, tree_from, tree_to, connect_radius)\n            if q_connect is not None:\n                # Connected trees, extract path\n                # Determine which vertex belongs to which tree to correctly extract\n                if tree_from is start_tree_roots:\n                    path_vertices = self._extract_bidirectional_path(q_new, q_connect)\n                else:\n                    path_vertices = self._extract_bidirectional_path(q_connect, q_new)\n\n                # Path shortcutting for smoothing\n                path_vertices = self._shortcut_path(path_vertices)\n\n                # Move agent through path\n                for vert in path_vertices:\n                    self.move_agent(vert.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "A Hybrid Heuristic-Driven Forest Sampling (HHDFS) Algorithm.\n\n    The algorithm builds a forest of trees rooted at both the start and goal positions.\n    It uses goal-biased sampling with adaptive probability to efficiently explore the space,\n    progressively increasing exploration near the goal and agent as the search proceeds.\n\n    Expansion of vertices is guided by a combined heuristic cost (actual path cost + Euclidean distance to goal)\n    to prioritize nodes closer to optimum path and reduce expansions of less promising nodes.\n\n    Adaptive max step size (max_dist) adjusts based on success of connection attempts to balance exploration/exploitation.\n\n    The algorithm continuously attempts to connect the forest trees from start and goal to rapidly close gaps.\n    When a path is found, shortcut smoothing is applied by attempting to replace segments via collision-free direct edges,\n    improving path quality.\n\n    Early stopping is enforced by a maximum planning time (10 seconds), ensuring practical compute limits.\n\n    This approach aims to improve path quality, planning efficiency, robustness, and success rate over classic RRT* and SPRM.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        # Initialize forest with vertices at start and goal positions\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Parameters for adaptive sampling and step size\n        self._max_dist_init = 12.0\n        self._max_dist = self._max_dist_init\n        self._goal_sample_rate = 0.2  # Probability of sampling goal directly (goal bias)\n        self._exploration_rate = 0.05  # Initial exploration bias around random points\n        self._exploration_increase = 0.001  # Increase exploration rate per iteration\n        self._max_radius = 20.0\n        self._dimension = self._get_grid().size.n_dim\n        self._lambda_rrt_star = 50.0\n        self._max_iterations = 8000\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Goal-biased and adaptive region sampling to improve planning efficiency.\"\"\"\n        import random\n        grid = self._get_grid()\n        if random.random() < self._goal_sample_rate:\n            # Directly sample the goal position with small perturbation\n            goal_pos = grid.goal.position\n            noise = Point(*(torch.randint(-1, 2, (self._dimension,)).tolist()))\n            sample = Point(*(goal_pos.to_tensor() + noise.to_tensor()).int().tolist())\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            else:\n                # Fall back to uniform random if perturbation invalid\n                pass\n\n        # Sample near start or goal with some increasing exploration chance\n        if random.random() < self._exploration_rate:\n            # Exploration towards a random free valid position in map\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Otherwise sample uniformly around start or goal with bias\n        use_start = random.random() < 0.5\n        center_pos = self._graph.root_vertex_start.position if use_start else self._graph.root_vertex_goal.position\n        # Sample inside a cube around center_pos with max radius radius\n        candidate = None\n        trials = 0\n        while trials < 20:\n            offset_coords = [torch.randint(-self._max_radius, self._max_radius + 1, (1,)).item() for _ in range(self._dimension)]\n            candidate_coords = (center_pos.to_tensor() + torch.tensor(offset_coords)).clamp(min=0)\n            for i in range(self._dimension):\n                candidate_coords[i] = min(candidate_coords[i], grid.size[i] - 1)\n            candidate = Point.from_tensor(candidate_coords)\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n            trials += 1\n\n        # Fallback uniform random\n        while True:\n            sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*sample_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex_unified(self, q_sample: Point) -> Vertex:\n        \"\"\"Get nearest vertex considering both start and goal roots, \n           selecting vertex with minimal heuristic cost.\"\"\"\n        candidates = self._graph.root_vertices\n        nearest = None\n        best_dist = None\n        for root in candidates:\n            v = self._graph.get_nearest_vertex([root], q_sample)\n            dist = self._heuristic_cost(v, q_sample)\n            if best_dist is None or dist < best_dist:\n                best_dist = dist\n                nearest = v\n        return nearest\n\n    def _heuristic_cost(self, vertex: Vertex, point: Point) -> float:\n        \"\"\"Heuristic is cost from root + Euclidean distance to given point.\"\"\"\n        current_cost = vertex.cost if vertex.cost is not None else float('inf')\n        heuristic_dist = self._get_grid().get_distance(vertex.position, point)\n        return current_cost + heuristic_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_tensor / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point.from_tensor(new_pos_tensor.int()))\n        return q_new\n\n    def _connect_trees(self, q_new: Vertex) -> bool:\n        \"\"\"\n        Attempt to connect the new vertex to the opposite root tree,\n        returning True if a connection to goal is established.\n        \"\"\"\n        opposite_roots = [self._graph.root_vertex_goal] if q_new in self._graph.root_vertex_start.children or q_new == self._graph.root_vertex_start else [self._graph.root_vertex_start]\n\n        # Actually, let's consider both roots for robustness\n        opposite_roots = self._graph.root_vertices.copy()\n        opposite_roots.remove(q_new.parents and next(iter(q_new.parents), None) or None)\n        if None in opposite_roots:\n            opposite_roots.remove(None)\n\n        # Instead, get all root vertices other than where q_new came from\n        # So just attempt nearest vertex from opposite root\n        best_vertex = None\n        best_cost = float('inf')\n        for root in opposite_roots:\n            q_nearest = self._graph.get_nearest_vertex([root], q_new.position)\n            if q_nearest == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_nearest.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_nearest.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_vertex = q_nearest\n        if best_vertex is not None:\n            # Connect q_new to best_vertex\n            self._graph.add_edge(q_new, best_vertex)\n            self._graph.add_edge(best_vertex, q_new)\n            # Propagate cost updates\n            self._rewire_costs(q_new)\n            # Check if goal reached (new vertex or best_vertex near goal)\n            if self._get_grid().is_agent_in_goal_radius(q_new.position) or self._get_grid().is_agent_in_goal_radius(best_vertex.position):\n                return True\n        return False\n\n    def _rewire_costs(self, root: Vertex) -> None:\n        \"\"\"Update costs of descendants in the tree rooted at root vertex.\"\"\"\n        stack = [root]\n        while stack:\n            current = stack.pop()\n            min_cost = float('inf')\n            # Update cost based on parents costs\n            for parent in current.parents:\n                dist = self._get_grid().get_distance(parent.position, current.position)\n                parent_cost = parent.cost if parent.cost is not None else float('inf')\n                c = parent_cost + dist\n                if c < min_cost:\n                    min_cost = c\n            if current.cost is None or min_cost < current.cost:\n                current.cost = min_cost\n                # Propagate to children only if cost improved\n                for child in current.children:\n                    stack.append(child)\n\n    def _extract_raw_path(self, last_vertex: Vertex) -> list:\n        \"\"\"Trace back path from last_vertex to root_vertex_start.\"\"\"\n        path = [last_vertex]\n        current = last_vertex\n        while current != self._graph.root_vertex_start:\n            if len(current.parents) == 0:\n                break\n            # Choose parent with smallest cost if multiple\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        return path\n\n    def _path_shortcut(self, path: list) -> list:\n        \"\"\"Attempt shortcut smoothing by connecting distant vertices directly if collision-free.\"\"\"\n        new_path = []\n        i = 0\n        while i < len(path):\n            new_path.append(path[i])\n            # Find furthest reachable vertex from current without collision\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            i = j\n        return new_path\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        # Extract path from start root to last vertex\n        raw_path = self._extract_raw_path(last_vertex)\n        # Smooth by shortcutting\n        smoothed_path = self._path_shortcut(raw_path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        iteration = 0\n\n        while iteration < self._max_iterations:\n            iteration += 1\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10:\n                # Timeout condition - path not found within 10 seconds\n                return\n\n            # Sample point with goal bias and exploration\n            q_sample = self._get_random_sample()\n            # Get nearest vertex on both trees (start/goal)\n            q_nearest = self._get_nearest_vertex_unified(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            # Validate path segment\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                # Decrease step size adaptively on failure but cap min size\n                self._max_dist = max(4.0, self._max_dist * 0.85)\n                continue\n            else:\n                # On success, slightly increase step size up to initial max\n                self._max_dist = min(self._max_dist_init, self._max_dist * 1.05)\n\n            # Compute cost and add edge\n            dist = self._get_grid().get_distance(q_nearest.position, q_new.position)\n            q_new.cost = (q_nearest.cost if q_nearest.cost is not None else 0) + dist\n            self._graph.add_edge(q_nearest, q_new)\n\n            # Try to rewire nearby vertices to improve costs (like RRT*)\n            # Calculate dynamic radius\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            radius = min(self._lambda_rrt_star * ((torch.log(card_v) / card_v) ** (1 / self._dimension)), self._max_radius)\n            nearby_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n            for q_near in nearby_vertices:\n                if q_near == q_nearest:\n                    continue\n                line_seq_between = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_between):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                if cost_through_new < (q_near.cost if q_near.cost is not None else float('inf')):\n                    # Rewire\n                    parents = list(q_near.parents)\n                    for p in parents:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = None  # reset cost\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n                    self._rewire_costs(q_near)\n\n            # Add new vertex to the forest roots for future nearest calculations to allow bidirectional growth\n            self._graph.root_vertices.append(q_new)\n\n            # Try to connect the newly added vertex to opposite tree (start / goal)\n            if self._connect_trees(q_new):\n                # If connection successful, extract and return path\n                self._extract_path(q_new)\n                break\n\n            # Increase exploration over time to avoid stagnation\n            self._exploration_rate = min(0.4, self._exploration_rate + self._exploration_increase)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an advanced heuristic-guided forest-based path planner \n     that integrates goal-biased adaptive sampling, dynamic step sizing, and \n     iterative rewiring similar to RRT*, but also ensures robustness via early \n     stopping and adaptive exploration/exploitation balance. It maintains two \n     growing trees (start and goal) and tries to connect them efficiently using \n     heuristic costs combining actual cost and estimated cost-to-go (A*-like). \n     It applies adaptive max_dist depending on the local density of vertices \n     to improve expansion speed in open areas and granularity near obstacles. \n     The extracted path is smoothened with shortcutting to improve quality \n     before execution. It also enforces a 10-second time limit on planning to \n     improve practical usability and increase success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph as bidirectional forest with start and goal vertices\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_base_dist = 12.0  # Base max step size\n        self._goal_bias = 0.15      # Probability of sampling goal directly\n        self._rewire_radius_factor = 40.0  # Rewiring neighborhood radius multiplier\n        self._dimension = self._get_grid().size.n_dim\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        from random import random\n        if random() < self._goal_bias:\n            # Goal-biased sampling\n            return self._get_grid().goal.position\n        else:\n            while True:\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() \n                                 for i in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Use Euclidean distance to goal as heuristic\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _adaptive_max_dist(self) -> float:\n        # Adapt step size based on tree size and environment dimension (inverse sqrt growth)\n        c = self._max_base_dist\n        size = max(1, self._graph.size)\n        adapted = c / (size ** (1/(self._dimension*2)))  # Slower decay for finer resolution as size grows\n        return max(3.0, adapted)  # Keep minimum step size to avoid stagnation\n\n    def _get_nearest_vertex(self, vertices: list, q_sample: Point) -> Vertex:\n        # Use heuristic + cost to pick the best parent candidate:\n        nearest = self._graph.get_nearest_vertex(vertices, q_sample)\n        # This method kept simple; heuristic guided rewiring is handled later\n        return nearest\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir_vec)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / norm_dir\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _rewire(self, q_new: Vertex, Q_near: list):\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist_near_new = Map.get_distance(q_new.position, q_near.position)\n            c_new_to_near = q_new.cost + dist_near_new\n            # Check if edge q_new->q_near improves q_near cost\n            is_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n            if is_collision_free and c_new_to_near < q_near.cost:\n                # Remove old parent edge(s)\n                old_parent = next(iter(q_near.parents), None)\n                if old_parent:\n                    self._graph.remove_edge(old_parent, q_near)\n                # Add new edge and update cost\n                q_near.cost = c_new_to_near\n                self._graph.add_edge(q_new, q_near)\n                # Propagate updated costs downstream\n                self._propagate_cost_downstream(q_near)\n\n    def _propagate_cost_downstream(self, vertex: Vertex):\n        stack = [vertex]\n        while stack:\n            v = stack.pop()\n            for child in v.children:\n                new_cost = v.cost + Map.get_distance(v.position, child.position)\n                if child.cost is None or new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex):\n        # Build path from start tree\n        path_start = []\n        v = connecting_vertex_start\n        while True:\n            path_start.append(v)\n            if not v.parents:\n                break\n            v = next(iter(v.parents))\n        path_start.reverse()\n\n        # Build path from goal tree\n        path_goal = []\n        v = connecting_vertex_goal\n        while True:\n            path_goal.append(v)\n            if not v.parents:\n                break\n            v = next(iter(v.parents))\n        # The goal tree edges are from child to parent, reverse to go from connect point to goal\n        path_goal = path_goal\n\n        # Combine paths (start->connect + connect->goal)\n        full_path = path_start + path_goal\n\n        # Smooth path using shortcutting\n        smooth_path = self._smooth_path(full_path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: list) -> list:\n        # Attempt shortcutting path segments to reduce waypoints and smooth path\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        iterations = 10000\n        radius_const = self._rewire_radius_factor\n        max_radius = 60.0\n        dimension = self._dimension\n\n        start_vertices = [self._graph.root_vertex_start]\n        goal_vertices = [self._graph.root_vertex_goal]\n\n        connected = False\n\n        for iter_i in range(iterations):\n            if time.time() - start_time > 10.0:  # Enforce 10 seconds timeout\n                break\n\n            max_dist = self._adaptive_max_dist()\n\n            # Alternate sampling between start and goal trees for bidirectional growth\n            if iter_i % 2 == 0:\n                # Sample from start tree direction\n                q_sample = self._get_random_sample()\n                q_nearest = self._graph.get_nearest_vertex(start_vertices, q_sample)\n                if q_nearest.position == q_sample:\n                    continue\n                q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                    continue\n\n                # Rewiring radius calculation with heuristic scaling\n                card_v = torch.tensor(float(self._graph.size))\n                log_card_v = torch.log(card_v)\n                radius = min(radius_const * ((log_card_v / card_v) ** (1/dimension)), max_radius)\n                Q_near = self._graph.get_vertices_within_radius(start_vertices, q_new.position, radius)\n\n                # Find best parent to minimize cost + heuristic (A*-style)\n                q_min = q_nearest\n                c_min = q_nearest.cost + Map.get_distance(q_nearest.position, q_new.position) + self._heuristic_cost(q_new.position)\n                for q_near in Q_near:\n                    if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                        continue\n                    cost_to_new = q_near.cost + Map.get_distance(q_near.position, q_new.position)\n                    est_total = cost_to_new + self._heuristic_cost(q_new.position)\n                    if est_total < c_min:\n                        q_min = q_near\n                        c_min = est_total\n                edge_cost = Map.get_distance(q_min.position, q_new.position)\n                q_new.cost = q_min.cost + edge_cost\n                self._graph.add_edge(q_min, q_new)\n                start_vertices.append(q_new)\n\n                # Rewire neighbors for better connectivity and cost improvements\n                self._rewire(q_new, Q_near)\n\n                # Try to connect the goal tree to q_new\n                q_connect_goal = self._graph.get_nearest_vertex(goal_vertices, q_new.position)\n                dist_connect = Map.get_distance(q_connect_goal.position, q_new.position)\n                if dist_connect <= max_dist:\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_connect_goal.position, q_new.position)):\n                        # Connect goal tree vertex as child of q_new (bidirectional link)\n                        q_connect_goal.cost = dist_connect  # cost from q_new to goal vertex for path extraction\n                        self._graph.add_edge(q_new, q_connect_goal)\n                        connected = True\n                        self._extract_path(q_new, q_connect_goal)\n                        break\n\n            else:\n                # Sample from goal tree direction (reverse growth)\n                q_sample = self._get_random_sample()\n                q_nearest = self._graph.get_nearest_vertex(goal_vertices, q_sample)\n                if q_nearest.position == q_sample:\n                    continue\n                q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                    continue\n\n                card_v = torch.tensor(float(self._graph.size))\n                log_card_v = torch.log(card_v)\n                radius = min(radius_const * ((log_card_v / card_v) ** (1/dimension)), max_radius)\n                Q_near = self._graph.get_vertices_within_radius(goal_vertices, q_new.position, radius)\n\n                q_min = q_nearest\n                c_min = q_nearest.cost + Map.get_distance(q_nearest.position, q_new.position) + self._heuristic_cost(q_new.position)\n                for q_near in Q_near:\n                    if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                        continue\n                    cost_to_new = q_near.cost + Map.get_distance(q_near.position, q_new.position)\n                    est_total = cost_to_new + self._heuristic_cost(q_new.position)\n                    if est_total < c_min:\n                        q_min = q_near\n                        c_min = est_total\n\n                edge_cost = Map.get_distance(q_min.position, q_new.position)\n                q_new.cost = q_min.cost + edge_cost\n                self._graph.add_edge(q_min, q_new)\n                goal_vertices.append(q_new)\n\n                self._rewire(q_new, Q_near)\n\n                # Try to connect the start tree to q_new\n                q_connect_start = self._graph.get_nearest_vertex(start_vertices, q_new.position)\n                dist_connect = Map.get_distance(q_connect_start.position, q_new.position)\n                if dist_connect <= max_dist:\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_connect_start.position, q_new.position)):\n                        q_connect_start.cost = dist_connect\n                        self._graph.add_edge(q_connect_start, q_new)\n                        connected = True\n                        self._extract_path(q_connect_start, q_new)\n                        break\n\n            self.key_frame()\n\n        if not connected:\n            # Mark as failed or leave agent as is\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Enhanced heuristic-biased RRT* with adaptive step size and smoothing:\n    - Uses goal-biased sampling to improve success in directed exploration.\n    - Adaptive max step size: dynamically adjusts based on closest obstacles or previous progress.\n    - Heuristic cost guide combines actual path cost and Euclidean heuristic (inspired by A*).\n    - Incorporates rewiring similar to RRT* for path quality improvement.\n    - Uses shortcut smoothing on the extracted path for smoother final trajectory.\n    - Early stopping if solution found or time exceeds 10 seconds to improve efficiency.\n    - Novel adaptive radius for neighbor search based on vertex count and environment scale.\n    - Attempts direct connection to goal when close, increasing robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_iterations: int\n    _max_time_seconds: float\n    _goal_sample_rate: float\n    _max_step_base: float\n    _smooth_iterations: int\n    _lambda_rrt_star: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 5000\n        self._max_time_seconds = 10.0\n        self._goal_sample_rate = 0.2  # 20% samples directed to goal\n        self._max_step_base = 12.0\n        self._smooth_iterations = 30\n        self._lambda_rrt_star = 40.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_sample_rate:\n            # Biased sampling towards goal\n            return self._get_grid().goal.position\n        else:\n            # Uniform random sampling in free space\n            while True:\n                dims = self._get_grid().size.n_dim\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dims)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_adaptive_step_size(self, q_nearest: Vertex) -> float:\n        # Estimate adaptive max step size based on nearby obstacle density:\n        radius_check = self._max_step_base\n        neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_nearest.position, radius_check)\n        obstacles_near = 0\n        grid = self._get_grid()\n        # Count nearby obstacles within small radius\n        obstacle_radius = self._max_step_base / 2\n        for obs in grid.obstacles:\n            dist = Map.get_distance(q_nearest.position, obs.position)\n            if dist < obstacle_radius + obs.radius:\n                obstacles_near += 1\n        # Shrink step if many obstacles nearby, else keep max\n        step = self._max_step_base if obstacles_near == 0 else max(self._max_step_base / (2 * obstacles_near), 3.0)\n        return step\n\n    def _heuristic_cost(self, vertex: Vertex) -> float:\n        # Estimated cost = actual cost + heuristic distance to goal\n        h = Map.get_distance(vertex.position, self._get_grid().goal.position)\n        return vertex.cost + h\n\n    def _get_neighbors_radius(self, card_v: int, dimension: int = 2) -> float:\n        # Adaptive radius ($r_n$) for RRT* style rewiring\n        import math\n        return min(self._lambda_rrt_star * ((math.log(card_v) / card_v) ** (1/dimension)), 50)\n\n    def _get_new_vertex(self, q_nearest: Vertex, q_sample: Point, step_size: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_nearest.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= step_size:\n            return Vertex(q_sample)\n        else:\n            direction_normalized = direction / dist\n            new_pos_tensor = q_nearest.position.to_tensor() + step_size * direction_normalized\n            new_pos = Point.from_tensor(new_pos_tensor)\n            return Vertex(new_pos)\n\n    def _try_shortcut(self, path: list) -> list:\n        # Path smoothing via shortcutting: try connecting non-consecutive path vertices directly\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, just go to next vertex\n                smoothed_path.append(path[i+1])\n                i += 1\n        return smoothed_path\n\n    def _extract_path(self, q_new: Vertex):\n        # Perform path extraction from q_new back to start\n        path = [q_new]\n        current = q_new\n        while len(current.parents) != 0:\n            for parent in current.parents:\n                current = parent\n                path.append(current)\n                break\n        path.reverse()\n\n        # Smooth the extracted path using shortcutting\n        for _ in range(self._smooth_iterations):\n            path = self._try_shortcut(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            # Support ROS waypoint publishing if available\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        grid = self._get_grid()\n        start_time = time.time()\n        dimension = grid.size.n_dim\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._max_time_seconds:\n                # Exceeded max allowed planning time - abort\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            step_size = self._get_adaptive_step_size(q_nearest)\n            q_new = self._get_new_vertex(q_nearest, q_sample, step_size)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = self._graph.size if self._graph.size > 0 else 1\n            radius = self._get_neighbors_radius(card_v, dimension)\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose parent with minimal cost + heuristic\n            q_min = q_nearest\n            dist_min = q_nearest.cost + Map.get_distance(q_nearest.position, q_new.position)\n            for neighbor in neighbors:\n                n_cost = neighbor.cost + Map.get_distance(neighbor.position, q_new.position)\n                line_seq_n = grid.get_line_sequence(neighbor.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq_n) and n_cost < dist_min:\n                    q_min = neighbor\n                    dist_min = n_cost\n\n            q_new.cost = dist_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves\n            for neighbor in neighbors:\n                line_seq_n2 = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq_n2):\n                    new_cost = q_new.cost + Map.get_distance(q_new.position, neighbor.position)\n                    if new_cost < neighbor.cost:\n                        # Remove old parent edge\n                        old_parent = None\n                        for p in neighbor.parents:\n                            old_parent = p\n                            break\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, neighbor)\n                        # Add new parent q_new\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n            # Check if q_new is close enough to goal for direct connection\n            dist_to_goal = Map.get_distance(q_new.position, grid.goal.position)\n            if dist_to_goal <= step_size:\n                line_seq_goal = grid.get_line_sequence(q_new.position, grid.goal.position)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(q_new)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning:\n    This algorithm builds upon sample-based planning with a goal-biased RRT* inspired approach emphasizing:\n    - Goal-biased sampling: with a probability to sample the goal directly, increasing convergence speed.\n    - Adaptive max step radius: dynamically adjusted based on agent-to-goal distance to improve expansion efficiency.\n    - Rewiring: improving path quality by reattaching vertices to better parents within radius (RRT* style).\n    - Heuristic cost: combining actual cost and heuristic (Euclidean distance) for vertex expansion guidance.\n    - Early stopping: terminates when goal connection found or 10 seconds exceeded.\n    - Path shortcutting: post-processing attempts to shortcut path segments for smoother path.\n    This results in a faster, smoother, and more robust path planning method than pure SPRM or naive sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 300  # More vertices for better graph density\n        self._goal_sample_rate = 0.2  # 20% goal bias\n        self._base_max_radius = 15.0\n        self._graph = None\n        self._vertices = []\n        # Setup graph with vertices and root vertices empty initially,\n        # initialized in setup_graph method so that _get_random_sample is ready.\n        self._init_displays()\n\n    def _init_graph(self) -> None:\n        # Initialize vertices with random samples that are valid, no connectivity yet\n        V: list[Vertex] = []\n        for _ in range(self._V_size):\n            p = self._get_random_sample()\n            V.append(Vertex(p))\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=False)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=False)\n        # Forest instead of CyclicGraph enables easier rewiring without cycles\n        self._graph = Forest(start_vertex, goal_vertex, V)\n        self._vertices = [start_vertex, goal_vertex] + V\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            point = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(point):\n                return point\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _cost(self, vertex: Vertex) -> float:\n        # Cost from root start to this vertex, accumulated costs\n        return getattr(vertex, \"cost\", float(\"inf\"))\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance heuristic to goal\n        return self._distance(p, self._get_grid().goal.position)\n\n    def _max_dist_adaptive(self, current_pos: Point) -> float:\n        # Adapt max step radius based on distance to goal (at least 5, at most base_max_radius)\n        dist = self._distance(current_pos, self._get_grid().goal.position)\n        radius = min(self._base_max_radius, max(5, dist / 5))\n        return radius\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_vertex.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(to_point)\n        dir_normalized = dir_vec / norm\n        new_pos_tensor = from_vertex.position.to_tensor() + dir_normalized * max_dist\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _near_vertices(self, point: Point, radius: float) -> list[Vertex]:\n        # Return vertices within radius of point in entire graph\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices + self._graph.root_vertices[0].children.union(self._graph.root_vertices[1].children), point, radius)\n\n    def _line_valid(self, p1: Point, p2: Point) -> bool:\n        # Check if direct path between two points is collision free\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, new_vertex: Vertex, radius: float) -> None:\n        # RRT* style rewiring: try to connect nearby vertices through new_vertex if cheaper\n        near_verts = self._graph.get_vertices_within_radius(self._graph.root_vertices, new_vertex.position, radius)\n        for near_v in near_verts:\n            if near_v is new_vertex:\n                continue\n            if self._line_valid(new_vertex.position, near_v.position):\n                cost_through_new = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if cost_through_new < near_v.cost:\n                    # Reattach near_v to new_vertex by removing old edges and adding new edge\n                    # Remove old parents connections to near_v\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = cost_through_new\n\n    def _choose_parent(self, near_vertices: list[Vertex], new_vertex: Vertex) -> Vertex:\n        # Choose best parent from near vertices by cost + movement cost if line collision free\n        min_cost = float(\"inf\")\n        best_parent = None\n        for near_v in near_vertices:\n            if self._line_valid(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is None:\n            # Fallback if none found: connect to nearest vertex anyway (should rarely happen)\n            best_parent = near_vertices[0]\n            min_cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, new_vertex.position)\n        new_vertex.cost = min_cost\n        return best_parent\n\n    def _extract_path(self, goal_vertex: Vertex) -> list[Point]:\n        path = []\n        current = goal_vertex\n        while current is not None and current != self._graph.root_vertex_start:\n            path.append(current.position)\n            # choose one parent with minimum cost (should be only one parent in tree)\n            if current.parents:\n                current = min(current.parents, key=lambda v: v.cost)\n            else:\n                current = None\n        path.append(self._graph.root_vertex_start.position)\n        path.reverse()\n        # Path shortcutting: try shortcuts by removing intermediate points where line is clear\n        path = self._shortcut_path(path)\n        return path\n\n    def _shortcut_path(self, path: list[Point]) -> list[Point]:\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                if self._line_valid(path[idx], path[next_idx]):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        self._init_graph()\n        start_time = time.time()\n        max_duration = 10  # seconds\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Initialize cost for start\n        start_vertex.cost = 0.0\n\n        # Add start and goal to forest root vertices\n        self._graph.root_vertices = [start_vertex, goal_vertex]\n\n        # Start by connecting start vertex to nearby\n        vertices = self._vertices.copy()\n        vertices_set = set(vertices)\n\n        # Use a priority queue to implement heuristic-guided exploration (like A*)\n        # queue entries = (priority, vertex)\n        open_set = []\n        heapq.heappush(open_set, (self._heuristic(start_vertex.position), start_vertex))\n\n        found_path_vertex = None\n\n        iterations = 0\n        while open_set:\n            if time.time() - start_time > max_duration:\n                # Timeout fail safe\n                break\n            _, current_vertex = heapq.heappop(open_set)\n            iterations += 1\n\n            # Early stop if current vertex close enough to goal with collision free\n            dist_to_goal = self._distance(current_vertex.position, goal_vertex.position)\n            dist_threshold = 2.0  # Reasonable neighborhood distance threshold\n\n            if dist_to_goal <= dist_threshold:\n                # Check line validity start-to-goal from current vertex\n                if self._line_valid(current_vertex.position, goal_vertex.position):\n                    # Connect current to goal\n                    goal_vertex.cost = current_vertex.cost + self._get_grid().get_movement_cost(current_vertex.position, goal_vertex.position)\n                    self._graph.add_edge(current_vertex, goal_vertex)\n                    found_path_vertex = goal_vertex\n                    break\n\n            max_dist = self._max_dist_adaptive(current_vertex.position)\n\n            # Sample a batch of points (goal biased) and try to connect\n            batch_samples = []\n            batch_size = 10\n            for _ in range(batch_size):\n                sample_point = self._get_random_sample()\n                new_vertex = self._steer(current_vertex, sample_point, max_dist)\n                if not self._get_grid().is_agent_valid_pos(new_vertex.position):\n                    continue\n                if not self._line_valid(current_vertex.position, new_vertex.position):\n                    continue\n                new_vertex.cost = current_vertex.cost + self._get_grid().get_movement_cost(current_vertex.position, new_vertex.position)\n\n                # Gather near vertices for possible better connection and rewiring\n                radius = max_dist * 1.5\n                near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, new_vertex.position, radius)\n                if near_vertices:\n                    best_parent = self._choose_parent(near_vertices, new_vertex)\n                    new_vertex.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, new_vertex.position)\n                    self._graph.add_edge(best_parent, new_vertex)\n                else:\n                    # No near vertices found, just connect to current vertex\n                    best_parent = current_vertex\n                    self._graph.add_edge(best_parent, new_vertex)\n\n                self._graph.root_vertices.append(new_vertex)\n                heapq.heappush(open_set, (new_vertex.cost + self._heuristic(new_vertex.position), new_vertex))\n\n                # Rewire nearby vertices if cheaper path through new_vertex\n                self._rewire(new_vertex, radius)\n\n                # Early check for connection to goal vertex near this new vertex\n                dist_to_goal_new = self._distance(new_vertex.position, goal_vertex.position)\n                if dist_to_goal_new <= radius and self._line_valid(new_vertex.position, goal_vertex.position):\n                    cost_to_goal = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, goal_vertex.position)\n                    if cost_to_goal < getattr(goal_vertex, \"cost\", float(\"inf\")):\n                        goal_vertex.cost = cost_to_goal\n                        if goal_vertex.parents:\n                            for p in list(goal_vertex.parents):\n                                self._graph.remove_edge(p, goal_vertex)\n                        self._graph.add_edge(new_vertex, goal_vertex)\n                        found_path_vertex = goal_vertex\n                        break\n\n            self.key_frame()\n\n        # If path found, extract and move agent along it\n        if found_path_vertex is not None:\n            path_points = self._extract_path(found_path_vertex)\n            for point in path_points:\n                self.move_agent(point)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No path found within time limit; might consider partial solution or report failure\n            # Here simply keyframe to indicate no path found\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning: An improved sample-based path planning algorithm combining goal-biased adaptive sampling,\n    heuristic (A*-like) cost guidance, and iterative rewiring for path optimization (inspired by RRT*), \n    designed to improve planning efficiency, path quality, robustness, and success rate.\n\n    Key features:\n    - Adaptive step size: max_dist adjusts based on distance to goal to allow coarse exploration far away and finer near goal.\n    - Goal biasing with high probability to favor samples near the goal.\n    - Uses cost-to-go heuristic for nearest neighbor search, improving vertex expansions towards promising directions.\n    - Rewiring: When inserting a new vertex, attempts to reconnect nearby vertices if that improves costs.\n    - Shortcut path smoothing after a connection to goal.\n    - Timeout of 10 seconds to abort lengthy searches.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias_prob=0.2) -> Point:\n        \"\"\"\n        Sampling with goal bias:\n        With probability goal_bias_prob, sample close to the goal (random point within goal radius).\n        Otherwise uniform random sample.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        goal_radius = grid.goal.radius if hasattr(grid.goal, \"radius\") else 0\n\n        if np.random.rand() < goal_bias_prob:\n            # Sample near goal within goal radius + small margin (say 2)\n            margin = 2\n            for _ in range(30):\n                # Random offset in each dimension within radius + margin\n                dims = grid.size.n_dim\n                random_offsets = (np.random.rand(dims) * 2 - 1) * (goal_radius + margin)\n                sample_coords = np.array(goal_pos.to_tuple()) + random_offsets\n                sample_coords_clipped = np.clip(sample_coords, 0, grid.size - 1).astype(int)\n                sample_point = Point(*sample_coords_clipped)\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n\n        # Otherwise uniform random valid sample\n        for _ in range(100):\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample_point = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback (rare)\n        return goal_pos\n\n    def _get_nearest_vertex_with_heuristic(self, vertices: list, q_sample: Point) -> Vertex:\n        \"\"\"\n        Get nearest vertex to q_sample according to combined cost:\n        cost(v) + heuristic distance from v to sample.\n        This biases toward vertices with better cost-to-come and closer to sample.\n        \"\"\"\n        min_cost = float('inf')\n        nearest_vertex = None\n        heuristic_weight = 1.5  # Weight for heuristic distance component\n\n        for v in vertices:\n            cost_to_go = v.cost if v.cost is not None else 0\n            dist = self._get_grid().get_distance(v.position, q_sample)\n            total_cost = cost_to_go + heuristic_weight * dist\n            if total_cost < min_cost:\n                min_cost = total_cost\n                nearest_vertex = v\n        return nearest_vertex\n\n    def _get_near_vertices(self, vertices: list, q_new: Vertex, radius: float) -> list:\n        \"\"\"\n        Return vertices within radius of q_new.position.\n        \"\"\"\n        return [v for v in vertices if self._get_grid().get_distance(v.position, q_new.position) <= radius]\n\n    def _rewire(self, q_new: Vertex, near_vertices: list) -> None:\n        \"\"\"\n        Reconnect near vertices to q_new if it improves cost.\n        \"\"\"\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_new = q_new.cost + grid.get_movement_cost(q_new.position, v.position)\n            if v.cost is None or cost_through_new < v.cost:\n                # Remove old parents edges for v, then add edge q_new->v\n                # Remove all parents edges (assuming forest structure)\n                parents_to_remove = list(v.parents)\n                for p in parents_to_remove:\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_new\n\n    def _extract_path(self, q_new: Vertex):\n        \"\"\"\n        Extract path from start to goal by following parents.\n        Performs shortcut smoothing by skipping intermediate vertices if direct line is valid.\n        \"\"\"\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_vertex)\n        path = [goal_vertex]\n        current = goal_vertex\n        while current.parents:\n            # Just pick the parent with minimal cost (if multiple)\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut smoothing between path points: try skip intermediate verts if direct path valid\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        # Animate path traversal\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        max_iterations = 5000\n        base_max_dist = 12.0\n        near_radius_factor = 3.0  # Radius for rewiring\n\n        start_time = time.time()\n\n        for i in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:\n                # Timeout reached - no path found\n                break\n\n            # Adaptive max_dist: proportional to distance to goal but bounded\n            dist_agent_to_goal = grid.get_distance(agent_pos, goal_pos)\n            max_dist = min(base_max_dist, max(4.0, dist_agent_to_goal / 2))\n\n            # Sample with goal biasing\n            q_sample = self._get_random_sample(goal_bias_prob=0.25)\n\n            all_vertices = self._graph.root_vertices\n\n            q_near = self._get_nearest_vertex_with_heuristic(all_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            movement_cost = grid.get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = q_near.cost + movement_cost if q_near.cost is not None else movement_cost\n\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewiring step to improve paths\n            near_radius = max_dist * near_radius_factor\n            near_vertices = self._get_near_vertices(all_vertices, q_new, near_radius)\n            self._rewire(q_new, near_vertices)\n\n            # Check goal reach\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm combines informed sampling via an ellipsoidal region around the start and goal to bias sampling (inspired by Informed RRT*), \n    adaptive step sizes based on local obstacle density to improve exploration efficiency, \n    heuristic-guided vertex expansion prioritizing promising directions, \n    and shortcut smoothing after path extraction. \n\n    The algorithm uses a Forest structure for the tree representation starting from the agent. \n    Sampling is biased increasingly towards the goal region to improve success rate and planning speed. \n\n    It uses dynamic max_dist that shrinks near obstacles to ensure robust connections,\n    and an early stopping condition based on timeout (10s max) and goal connection.\n\n    After finding a path, it applies a shortcut path smoothing heuristic by trying to replace short sub-paths with direct connections\n    if they are collision-free, thus improving path quality.\n\n    This approach aims for fewer iterations, better path quality, improved success rate, and robustness in complex grid scenarios.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.root_vertex_start.cost = 0\n        self._goal_bias_prob = 0.2  # Probability to bias sample toward goal\n        self._max_iterations = 8000\n        self._base_max_dist = 12  # base max distance for new vertices\n        self._min_max_dist = 3    # minimum step near obstacles\n        self._goal_radius = max(self._get_grid().goal.radius, 1)\n        self._dimension = self._get_grid().size.n_dim\n        self._lambda_rrt_star = 50\n        self._max_radius = 45\n        self._time_limit_sec = 10.0  # time limit for planning in seconds\n\n        self._init_displays()\n\n    # --- Helpers --- #\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        \"\"\"Heuristic cost estimate (Euclidean) from frm to to.\"\"\"\n        return self._distance(frm, to)\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Dynamically adjust max_dist based on proximity to obstacles.\n        Shrink max_dist when near obstacles for safer smaller steps.\n        \"\"\"\n        grid = self._get_grid()\n        # Check next neighbors to estimate proximity to obstacles\n        neighbors = grid.get_next_positions(pos)\n        obstacle_count = 0\n        for nbr in neighbors:\n            if not grid.is_agent_valid_pos(nbr):\n                obstacle_count += 1\n        # More obstacles nearby means smaller step size\n        dist = self._base_max_dist - obstacle_count * 3\n        return max(dist, self._min_max_dist)\n\n    def _sample_informed(self, iterations_done: int) -> Point:\n        \"\"\"\n        Sample biased towards ellipsoidal region defined by start-goal,\n        with a goal bias probability.\n        \"\"\"\n        grid = self._get_grid()\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = grid.goal.position\n\n        # Goal biasing\n        if np.random.rand() < self._goal_bias_prob:\n            return Point(*goal_pos)\n\n        # Compute ellipse parameters for Informed RRT* style sampling:\n        dist_start_goal = self._distance(start_pos, goal_pos)\n        c_best = dist_start_goal  # initial best cost is heuristic distance\n        c_min = dist_start_goal\n        if iterations_done == 0 or c_best == float('inf'):\n            # Before path found, sample uniformly random:\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Ellipsoidal sampling centered between start and goal:\n            center = Point(*(((start_pos.to_tensor() + goal_pos.to_tensor()) / 2).tolist()))\n            a1 = (goal_pos.to_tensor() - start_pos.to_tensor()) / torch.linalg.norm(goal_pos.to_tensor() - start_pos.to_tensor())\n            id_matrix = torch.eye(self._dimension)\n            U = torch.zeros((self._dimension, self._dimension))\n            U[:, 0] = a1\n            for i in range(1, self._dimension):\n                orth_dir = id_matrix[:, i]\n                U[:, i] = orth_dir\n\n            # Radii of ellipse (longest axis = c_best/2, others large enough)\n            r1 = c_best / 2\n            r_other = torch.sqrt(torch.tensor(c_best ** 2 - c_min ** 2)) / 2 if c_best > c_min else r1\n            radii = torch.tensor([r1] + [r_other] * (self._dimension - 1))\n\n            # Sample random unit ball point\n            while True:\n                x_ball = torch.randn(self._dimension)\n                x_ball = x_ball / torch.norm(x_ball)\n                rho = torch.rand(1).item()\n                x_ball = x_ball * (rho ** (1 / self._dimension))\n\n                # Map back from unit ball to ellipse\n                sample_t = center.to_tensor() + U @ torch.diag(radii) @ x_ball\n                sample_list = sample_t.tolist()\n                sample_point = Point(*[int(round(x)) for x in sample_list])\n\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir_vec)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dir_norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new_pos = Point(*[int(round(x)) for x in new_pos_tensor.tolist()])\n        return Vertex(q_new_pos)\n\n    def _is_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from q_goal to root and apply shortcut smoothing.\n        Then move agent along the path.\n        \"\"\"\n        # Backtrack path from goal to start\n        path: list = [q_goal]\n        curr = q_goal\n        while len(curr.parents) > 0:\n            # Take any parent (should have one)\n            parent = next(iter(curr.parents))\n            path.append(parent)\n            curr = parent\n\n        path.reverse()\n        # Shortcut smoothing: try to replace intermediate segments with direct edges if collision free\n        smoothed_path = [path[0]]\n        for i in range(1, len(path)):\n            last_smoothed = smoothed_path[-1]\n            # Try to skip intermediate vertices and connect directly to path[i]\n            # but only if collision free\n            if self._is_collision_free(last_smoothed.position, path[i].position):\n                # skip all intermediate vertices, keep only last one\n                smoothed_path.append(path[i])\n            else:\n                # If no direct line, add previous vertex and continue normally\n                # This happens only if current is connectivity broken, so also add previous vertex\n                if smoothed_path[-1] != path[i - 1]:\n                    smoothed_path.append(path[i - 1])\n                smoothed_path.append(path[i])\n\n        # Remove duplicates if any due to construction\n        unique_smoothed = []\n        last_p = None\n        for v in smoothed_path:\n            if last_p is None or v.position != last_p.position:\n                unique_smoothed.append(v)\n            last_p = v.position\n\n        # Execute move commands on agent for each point in path\n        for vertex in unique_smoothed:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            from algorithms.configuration.maps.ros_map import RosMap\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # --- Core Algorithm --- #\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit_sec:\n                # Time limit exceeded, fail gracefully\n                break\n\n            q_sample = self._sample_informed(iteration)\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on proximity to obstacles\n            max_dist = self._adaptive_max_dist(q_nearest.position)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._is_collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Near vertices within adaptive radius for informed rewiring\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent for q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._heuristic_cost(q_nearest.position, q_new.position)\n\n            for q_near in Q_near:\n                if not self._is_collision_free(q_near.position, q_new.position):\n                    continue\n                cost = q_near.cost + self._heuristic_cost(q_near.position, q_new.position)\n                if cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices through q_new when beneficial\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if not self._is_collision_free(q_new.position, q_near.position):\n                    continue\n                cost_through_new = q_new.cost + self._heuristic_cost(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    # Remove old edge from old parent\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add edge from q_new to q_near\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Early stopping if goal reached within radius\n            if self._distance(q_new.position, grid.goal.position) <= self._goal_radius:\n                q_goal = Vertex(grid.goal.position)\n                if self._is_collision_free(q_new.position, q_goal.position):\n                    # Connect goal vertex and extract path\n                    q_goal.cost = q_new.cost + self._heuristic_cost(q_new.position, q_goal.position)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    return\n\n            self.key_frame()\n\n        # If no path found within time or iterations, no movement is made (fail silently)\n        return",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning: An improved, hybrid sample-based planner combining adaptive goal-biased sampling, \n    heuristic-driven expansion (A* style cost with Euclidean + cost-to-go heuristics), adaptive step size, \n    and path shortcutting for smoother results. The algorithm grows a forest initialized with start and goal, \n    grows bidirectionally using incremental sampling with goal bias, rewires locally for shorter paths,\n    adapts max step size based on environment clearance, terminates early on timeout or path found,\n    and performs shortcut smoothing on the extracted path before execution.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {PathPlanning: An improved, hybrid sample-based planner combining adaptive goal-biased sampling, \n    heuristic-driven expansion (A* style cost with Euclidean + cost-to-go heuristics), adaptive step size, \n    and path shortcutting for smoother results. The algorithm grows a forest initialized with start and goal, \n    grows bidirectionally using incremental sampling with goal bias, rewires locally for shorter paths,\n    adapts max step size based on environment clearance, terminates early on timeout or path found,\n    and performs shortcut smoothing on the extracted path before execution.}\n\n    The algorithm dynamically adjusts the step size based on obstacle proximity at the nearest vertex,\n    enriches sampling distribution towards the goal 20% of the time to accelerate convergence, and \n    maintains a balanced bidirectional tree expansion. \n    It uses a heuristic cost combining actual tree cost and direct distance to goal to guide tree connections.\n    Path smoothing shortcuts by validating straight-line traversals across path points to reduce unnecessary turns.\n    Timeout is enforced at 10 seconds to ensure no infinite loops.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_default_dist = 15.0\n        self._goal_bias = 0.2  # 20% chance to sample goal directly\n        self._iteration_limit = 10000\n        self._search_timeout = 10.0  # seconds\n\n    def _get_random_sample(self) -> Point:\n        import time\n        import random\n        grid = self._get_grid()\n        # Goal biased sampling: 20% samples come exactly from the goal to accelerate convergence\n        if random.random() < self._goal_bias:\n            return grid.goal.position\n        while True:\n            sample = Point(*[torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)])\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, vertex: Vertex) -> float:\n        \"\"\"\n        Adapt step size proportional to local obstacle clearance.\n        Checks radius around vertex to determine a safe max step size.\n        \"\"\"\n        grid = self._get_grid()\n        max_dist = self._max_default_dist\n        clearance_radii = [20, 15, 10, 5]\n        # Sample outwards until finding close obstacle, then reduce max_dist\n        for rad in clearance_radii:\n            neighbors = grid.get_vertices_within_radius([vertex], vertex.position, rad) if hasattr(grid, 'get_vertices_within_radius') else []\n            # Instead we estimate clearance by checking if surroundings within rad are valid positions\n            cleared = True\n            for dx in range(-rad, rad + 1):\n                for dy in range(-rad, rad + 1):\n                    pos = Point(vertex.position.x + dx, vertex.position.y + dy)\n                    if not grid.is_agent_valid_pos(pos):\n                        cleared = False\n                        break\n                if not cleared:\n                    break\n            if cleared:\n                max_dist = rad\n                break\n        return max_dist\n\n    def _compute_heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        \"\"\"\n        Heuristic combining actual cost + Euclidean distance heuristic\n        \"\"\"\n        cost_so_far = from_vertex.cost if from_vertex.cost is not None else float(\"inf\")\n        direct_dist = self._get_grid().get_distance(from_vertex.position, to_point)\n        return cost_so_far + direct_dist\n\n    def _rewire(self, q_new: Vertex, radius: float) -> None:\n        \"\"\"\n        Attempt to rewire nearby vertices to q_new if it reduces cost\n        \"\"\"\n        Q_near = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n        grid = self._get_grid()\n\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                continue\n            cost_to_near = q_new.cost + grid.get_distance(q_new.position, q_near.position)\n            if q_near.cost is None or cost_to_near < q_near.cost:\n                # Remove old edge\n                old_parent = None\n                for parent in q_near.parents:\n                    old_parent = parent\n                    break\n                if old_parent is not None:\n                    self._graph.remove_edge(old_parent, q_near)\n                # Add new edge via q_new\n                q_near.cost = cost_to_near\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Path extraction backtracking from goal to start. Then perform shortcut smoothing.\n        \"\"\"\n        grid = self._get_grid()\n        goal_vertex = Vertex(grid.goal.position)\n        # Add virtual edge q_new -> goal if not present\n        dist_to_goal = grid.get_distance(q_new.position, goal_vertex.position)\n        goal_vertex.cost = q_new.cost + dist_to_goal\n        self._graph.add_edge(q_new, goal_vertex)\n\n        # Backtracking path from goal to start\n        path = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            # Just pick the first parent (lowest cost ensured by rewiring)\n            for par in path[-1].parents:\n                path.append(par)\n                break\n        path.pop()  # Remove start duplicate\n        path.reverse()\n\n        # Smooth path shortcutting to reduce unnecessary points and sharp turns\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = grid.get_line_sequence(path[idx].position, path[test_idx].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    next_idx = test_idx\n                    break\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # publish waypoint in ros extension if applicable\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n        max_dist_default = self._max_default_dist\n        iterations = self._iteration_limit\n        dimension = 2\n        lambda_rrt_star = 30  # For adaptive radius like RRT*\n\n        for i in range(iterations):\n            # Timeout check\n            if (time.time() - start_time) > self._search_timeout:\n                # Timeout - treat as failure to find path\n                return\n\n            q_sample = self._get_random_sample()\n\n            # Bidirectional extended tree expansion:\n            # Alternate growth from start and goal trees to improve connectivity chances\n            if i % 2 == 0:\n                tree_vertices = [self._graph.root_vertex_start]\n                other_tree_root = self._graph.root_vertex_goal\n            else:\n                tree_vertices = [self._graph.root_vertex_goal]\n                other_tree_root = self._graph.root_vertex_start\n\n            q_nearest = self._graph.get_nearest_vertex(tree_vertices, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max_dist computation - adjusted to local clearance\n            max_dist = self._adaptive_max_dist(q_nearest)\n            if max_dist < 3:  # enforce minimal movement step\n                max_dist = 3\n\n            # Generate new vertex along direction but limited to max_dist\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dist_dir = torch.norm(dir_vec)\n            if dist_dir <= max_dist:\n                q_new = Vertex(q_sample)\n            else:\n                dir_normalized = dir_vec / dist_dir\n                q_new_pos = Point.from_tensor(q_nearest.position.to_tensor() + dir_normalized * max_dist)\n                q_new = Vertex(q_new_pos)\n\n            # Check line-of-sight free (collision free)\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Heuristic radius for rewiring and finding neighbors\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            log_card_v = torch.log(card_v + 1)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)), 50)\n\n            # Find near vertices for rewiring / best parent search\n            Q_near = self._graph.get_vertices_within_radius(tree_vertices, q_new.position, radius)\n            if not Q_near:\n                Q_near = [q_nearest]\n\n            # Choose best parent with lowest cost + heuristics\n            c_min = float(\"inf\")\n            q_min = None\n            for q_near in Q_near:\n                line_seq_near = grid.get_line_sequence(q_near.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_near):\n                    continue\n                cost = q_near.cost if q_near.cost is not None else float(\"inf\")\n                edge_cost = grid.get_distance(q_near.position, q_new.position)\n                if cost + edge_cost < c_min:\n                    q_min = q_near\n                    c_min = cost + edge_cost\n\n            if q_min is None:\n                continue\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new if beneficial\n            self._rewire(q_new, radius)\n\n            # Check connection possibility with opposite tree root for early goal connection\n            q_connect = self._graph.get_nearest_vertex([other_tree_root], q_new.position)\n            dist_connect = grid.get_distance(q_new.position, q_connect.position)\n            if dist_connect < max_dist:\n                # Validate connection line\n                line_seq_connect = grid.get_line_sequence(q_new.position, q_connect.position)\n                if grid.is_valid_line_sequence(line_seq_connect):\n                    # Connect trees by edges (bidirectional)\n                    # Add edge q_new -> q_connect and q_connect -> q_new\n                    self._graph.add_edge(q_new, q_connect)\n                    self._graph.add_edge(q_connect, q_new)\n\n                    # Compute combined path cost for connection vertex on start tree side\n                    if q_connect.cost is None or q_new.cost + dist_connect < q_connect.cost:\n                        q_connect.cost = q_new.cost + dist_connect\n\n                    # Extract and smooth combined path from start to goal through this connection\n                    # Use q_new as last vertex of start tree side before goal connection\n                    self._extract_path(q_new)\n                    return\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is an advanced sample-based path planning algorithm that integrates heuristic-guided \n    sampling, adaptive step sizing, goal biasing, and dynamic rewiring inspired by RRT* and A*. \n    It uses a Forest graph structure to maintain tree connectivity. The algorithm focuses on efficiency by \n    biasing sampling towards the goal with adaptive probability, dynamically adjusting step size based on \n    environment complexity around the current node, and employs heuristic cost (cost-to-come + straight-line \n    cost-to-go) to select parents and rewire neighbors for optimal paths. It includes smoothing shortcuts \n    during path extraction for high-quality, smooth paths. It also uses a 10-second time limit for early \n    termination to improve robustness and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_sample_rate: float\n    _max_radius: float\n    _timeout_sec: float\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n\n        self._max_dist_base = 15.0  # base step size\n        self._goal_sample_rate = 0.2  # 20% goal biasing\n        self._max_radius = 20.0  # max radius for neighbor search, controls rewiring range\n        self._timeout_sec = 10.0  # maximum allowed planning time in seconds\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._init_displays()\n\n    def _get_heuristic_cost(self, vertex: Vertex) -> float:\n        # cost-to-come + heuristic cost-to-go (Euclidean)\n        h_cost = self._graph.root_vertex_goal.position.distance(vertex.position)\n        return vertex.cost + h_cost\n\n    def _adaptive_step_size(self, q_near: Vertex) -> float:\n        \"\"\"\n        Adapt step size based on some simple environment heuristic:\n        The denser obstacles are around q_near, the smaller the step size.\n        This simple heuristic counts valid next moves to estimate density.\n        \"\"\"\n        next_positions = self._get_grid().get_next_positions(q_near.position)\n        free_count = sum(self._get_grid().is_agent_valid_pos(pos) for pos in next_positions)\n        # If many directions free, allow longer step, else reduce\n        factor = free_count / max(len(next_positions), 1)\n        adaptive_step = self._max_dist_base * (0.5 + 0.5 * factor)  # range 0.5*max_dist_base to max_dist_base\n        return adaptive_step\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with probability goal_sample_rate sample at goal\n        import time, random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                sample = Point(*[\n                    torch.randint(0, self._get_grid().size[i], (1,)).item()\n                    for i in range(self._get_grid().size.n_dim)\n                ])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # search over tree rooted at start only\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> 'List[Vertex]':\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dir_norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _shortcut_path(self, raw_path: 'List[Vertex]') -> 'List[Vertex]':\n        \"\"\"\n        Smooth the path by taking shortcuts between non-adjacent vertices if line is valid.\n        \"\"\"\n        optimized_path = []\n        i = 0\n        n = len(raw_path)\n        while i < n:\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(raw_path[i].position, raw_path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            optimized_path.append(raw_path[i])\n            i = j\n        if optimized_path[-1] != raw_path[-1]:\n            optimized_path.append(raw_path[-1])\n        return optimized_path\n\n    def _extract_path(self, q_goal_parent: Vertex) -> None:\n        # Reconstruct path from root to goal parent, then add exact goal vertex with its cost from q_goal_parent\n        goal_v = Vertex(self._get_grid().goal.position)\n        cost_to_goal = q_goal_parent.cost + self._get_grid().get_distance(q_goal_parent.position, goal_v.position)\n        goal_v.cost = cost_to_goal\n        self._graph.add_edge(q_goal_parent, goal_v)\n\n        path = [goal_v]\n        current = goal_v\n        while current.parents:\n            # only one parent because Forest tree structure\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Perform shortcut smoothing for path quality\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            # If ros extension enabled, send waypoint\n            try:\n                from algorithms.configuration.maps.ros_map import RosMap\n                if isinstance(grid, RosMap):\n                    grid.publish_wp(grid.agent.position)\n            except ImportError:\n                pass\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        start_time = time.perf_counter()\n        max_iterations = 8000\n\n        for iteration in range(max_iterations):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self._timeout_sec:\n                # Timeout: no path found within time limit\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_step_size(q_nearest)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Validate edge collision free\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors for rewiring within adaptive radius proportional to sqrt(log(n)/n)\n            card_v = float(self._graph.size + 1)\n            dimension = self._get_grid().size.n_dim\n            gamma_rrt_star = 30.0\n            radius = min(\n                self._max_radius,\n                gamma_rrt_star * ((math.log(card_v) / card_v) ** (1.0 / dimension))\n            )\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent vertex with minimum cost + dist\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n            for q_near in Q_near:\n                line_seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_check):\n                    cost_candidate = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                    if cost_candidate < c_min:\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better via q_new\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    # Remove existing parent edge\n                    old_parent = next(iter(q_near.parents))\n                    self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None  # reset cost before update\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved probabilistic path planner inspired by RRT* with goal biasing,\n    adaptive step sizing, and local rewiring to optimize path quality.\n    It generates random samples biased towards the goal to speed convergence, uses an adaptive max_dist \n    based on current exploration to allow larger steps early and finer steps near obstacles/goal, \n    and rewires the graph locally to reduce costs of existing vertices improving path smoothness.\n    Additionally, a shortcut smoothing step attempts to remove unnecessary intermediate vertices after a \n    path is found. The planner also respects a 10-second time limit to ensure timely termination.\n    The approach balances exploration and exploitation to improve planning efficiency, robustness, and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_initial: float\n    _max_dist_min: float\n    _goal_bias: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # Enable rewiring/removal for optimization\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._goal_bias = 0.2  # 20% samples bias towards goal\n        self._rewire_radius = 12.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling: with probability goal_bias sample the goal position else random valid\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vector)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vector / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _choose_parent(self, q_near_vertices: list, q_new: Vertex) -> Vertex:\n        # Select parent with lowest cost + movement cost to new vertex satisfying valid connection\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in q_near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        # Improve neighbors by trying to connect through q_new if it lowers their cost\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove old parent edge(s) for neighbor and add new\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Trace back path from goal to start based on parents with lowest cost\n        path_vertices = []\n        current = goal_vertex\n        while current.parents:\n            path_vertices.append(current)\n            # Choose parent with minimum cost\n            current = min(current.parents, key=lambda p: p.cost)\n        path_vertices.append(current)  # Append start vertex\n        path_vertices.reverse()\n\n        # Apply shortcut smoothing to path\n        smoothed_path = self._shortcut_smooth(path_vertices)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: list) -> list:\n        # Attempt to shortcut the path by removing intermediate vertices if direct connection is valid\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, move one ahead\n                smoothed.append(path[i+1])\n                i += 1\n        return smoothed\n\n    def _update_max_dist(self, iteration: int, max_iterations: int) -> float:\n        # Linearly decrease max_dist from initial to min step size over iterations\n        max_dist = self._max_dist_initial - (self._max_dist_initial - self._max_dist_min) * (iteration / max_iterations)\n        return max(self._max_dist_min, max_dist)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        max_time_seconds = 10.0\n        max_iterations = 6000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if (time.time() - start_time) > max_time_seconds:\n                # Timeout reached, stop planning\n                break\n\n            max_dist = self._update_max_dist(iteration, max_iterations)\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n            # Choose the best parent from neighbors\n            parent = self._choose_parent(neighbors, q_new)\n            if parent is None:\n                # Fallback: connect to nearest if none valid\n                parent = q_nearest\n            q_new.cost = parent.cost + self._get_grid().get_distance(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors if cheaper to connect via q_new\n            self._rewire(q_new, neighbors)\n\n            # Add the q_new to root vertices so it can be neighbor for future vertices\n            self._graph.root_vertices.append(q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal if possible\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    goal_cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                    if goal_vertex.cost == 0.0 or goal_cost < goal_vertex.cost:\n                        # Remove old edges to goal if any (for rewiring)\n                        for parent in list(goal_vertex.parents):\n                            self._graph.remove_edge(parent, goal_vertex)\n                        goal_vertex.cost = goal_cost\n                        self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved bidirectional informed RRT* variant with adaptive sampling and dynamic step size.\n    Key features:\n    - Bidirectional trees grow from both start and goal, increasing success rate and efficiency.\n    - Informed sampling bias towards an ellipse defined by current best path cost to focus search.\n    - Adaptive max_dist changes based on local obstacle density for better exploration/exploitation.\n    - Heuristic cost-guided rewiring with radius based on environment and graph size.\n    - Early stopping upon connecting start and goal with a valid path.\n    - Post-processing shortcut smoothing of the final path for improved quality.\n    - Time limit of 10 seconds to prevent infinite search.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        \n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        goal_vertex.cost = float('inf')\n        \n        # Use cyclic graph to allow rewiring and cyclic edges for enhanced connectivity\n        from algorithms.classic.sample_based.core.graph import CyclicGraph\n        self._graph = CyclicGraph(self._services, start_vertex, goal_vertex, [])\n        \n        # To store best current path cost\n        self._best_cost = float('inf')\n        # To store best connecting vertices between trees\n        self._best_connection = None\n\n        self._init_displays()\n\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _heuristic(self, p: Point) -> float:\n        return self._distance(p, self._get_grid().goal.position)\n\n    def _get_random_sample_in_ellipse(self, c_max: float, x_center: Point, c_min: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Sample inside an ellipse defined by start, goal and current best solution cost c_max;\n        fallback to uniform random sampling if no current solution.\n        \"\"\"\n        import math\n        import random\n\n        if c_max == float('inf'):\n            # No current solution, uniform sample in free space\n            return self._get_random_sample()\n\n        # Compute ellipse parameters\n        # major axis length = c_max\n        # minor axis length = sqrt(c_max^2 - c_min^2)\n        d = self._distance(start, goal)\n        c_best = c_max\n        c_min_val = c_min\n\n        if c_best < d:\n            # numerical stability check, no ellipse possible\n            return self._get_random_sample()\n\n        a1 = (goal.to_tensor() - start.to_tensor()) / d  # unit vector from start to goal\n        center = (start.to_tensor() + goal.to_tensor()) / 2.0\n\n        L = torch.diag(torch.tensor([c_best/2.0, math.sqrt(c_best**2 - c_min_val**2)/2.0]))\n        # Sample unit disk point in 2D\n        while True:\n            # Sample uniformly in unit circle 2D\n            theta = random.uniform(0, 2*math.pi)\n            r = random.uniform(0, 1)\n            x_ball = torch.tensor([r * math.cos(theta), r * math.sin(theta)])\n\n            # Transform to ellipse\n            rand_point = torch.mv(L, x_ball)\n\n            # Rotate ellipse to align with start-goal line in 2D\n            # Rotation matrix with a1 as x-axis vector in 2D\n            rot = torch.stack([a1, torch.tensor([-a1[1], a1[0]])], 1)\n            sample_point = torch.mv(rot, rand_point) + center\n\n            candidate = Point.from_tensor(sample_point)\n\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n    def _adaptive_max_dist(self, pos: Point, base_max_dist: float = 10.0) -> float:\n        \"\"\"\n        Adjust max dist step-size based on local obstacle density.\n        Less free space => smaller steps, more careful exploration.\n        \"\"\"\n        grid = self._get_grid()\n        scan_radius = int(base_max_dist / 2)\n        free_count = 0\n        total_count = 0\n\n        for dx in range(-scan_radius, scan_radius + 1):\n            for dy in range(-scan_radius, scan_radius + 1):\n                check_point = Point(pos.x + dx, pos.y + dy)\n                if grid.is_agent_valid_pos(check_point):\n                    free_count += 1\n                total_count += 1\n        \n        free_ratio = free_count / total_count if total_count > 0 else 1\n\n        # Scale max_dist between base_max_dist * 0.5 and base_max_dist based on free_ratio\n        adaptive_dist = base_max_dist * (0.5 + 0.5 * free_ratio)\n        return max(1.0, adaptive_dist)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n\n        if dir_norm == 0:\n            return Vertex(q_sample)\n\n        if dir_norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir / dir_norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extract path from start to goal along the best connecting vertices.\n        Also performs shortcut smoothing on the path.\n        \"\"\"\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        vertex_start = start_v\n        vertex_goal = goal_v\n\n        # Reconstruct path from start to best connection vertex\n        path_start = []\n        current = vertex_start\n        visited = set()\n        while current is not None and current not in visited:\n            visited.add(current)\n            path_start.append(current)\n            if current == self._best_connection[0]:\n                break\n            # walk children to next vertex towards connection if any else break\n            if current.children:\n                # choose child with min heuristic dist to connection to go forward\n                current = min(current.children, key=lambda c: self._distance(c.position, self._best_connection[0].position))\n            else:\n                break\n        \n        # Reconstruct path from goal to best connection vertex\n        path_goal = []\n        current = vertex_goal\n        visited = set()\n        while current is not None and current not in visited:\n            visited.add(current)\n            path_goal.append(current)\n            if current == self._best_connection[1]:\n                break\n            # walk children to next vertex towards connection if any else break\n            if current.children:\n                current = min(current.children, key=lambda c: self._distance(c.position, self._best_connection[1].position))\n            else:\n                break\n        \n        path_goal.reverse()\n        raw_path = path_start + path_goal\n\n        # Shortcut smoothing to remove unnecessary vertices in path\n        smoothed_path = [raw_path[0]]\n        for v in raw_path[1:]:\n            last = smoothed_path[-1]\n            line_seq = self._get_grid().get_line_sequence(last.position, v.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Can shortcut: replace last path vertex\n                smoothed_path[-1] = v\n            else:\n                smoothed_path.append(v)\n\n        # Final path traversal: move agent through waypoints\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        iterations = 10000\n        base_max_dist = 10.0\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        dimension = 2\n        lambda_rrt_star = 40.0\n        max_radius = 50.0\n\n        # Two sets of roots: start tree grew and goal tree grew\n        trees = [(True, [start_vertex]), (False, [goal_vertex])]\n\n        # Current best cost\n        c_best = float('inf')\n        c_min = self._distance(start_vertex.position, goal_vertex.position)\n\n        for i in range(iterations):\n            if time.time() - start_time > 10:\n                # Exceeded time limit, stop search with failure\n                return\n            \n            # Alternate between trees for bidirectional growth\n            tree_idx = i % 2\n            growing_from_start, root_vertices = trees[tree_idx]\n\n            # Informed sample biased inside ellipse if solution found, else uniform random sample\n            q_sample = self._get_random_sample_in_ellipse(c_best, start_vertex.position, c_min, start_vertex.position, goal_vertex.position)\n\n            q_nearest = self._graph.get_nearest_vertex(root_vertices, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size depending on environment around q_nearest\n            adaptive_max_dist = self._adaptive_max_dist(q_nearest.position, base_max_dist)\n            q_new = self._get_new_vertex(q_nearest, q_sample, adaptive_max_dist)\n\n            # Validate path free from obstacles\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate radius for rewiring\n            card_v = float(self._graph.size)\n            if card_v < 2:\n                radius = max_radius\n            else:\n                radius = min(lambda_rrt_star * ((torch.log(torch.tensor(card_v)) / card_v)**(1/dimension)), max_radius)\n\n            # Find neighbors for rewiring on this tree\n            Q_near = self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n            # Choose parent with minimum cost + cost to q_new\n            q_min = q_nearest\n            c_min_vertex = q_nearest.cost + self._distance(q_nearest.position, q_new.position)\n            for q_near in Q_near:\n                # Check if path between q_near and q_new is collision free\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    potential_cost = q_near.cost + self._distance(q_near.position, q_new.position)\n                    if potential_cost < c_min_vertex:\n                        q_min = q_near\n                        c_min_vertex = potential_cost\n\n            q_new.cost = c_min_vertex\n            # Add new vertex with edge to chosen parent\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring neighbors for possibly better path through q_new\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                    cost_through_qnew = q_new.cost + self._distance(q_new.position, q_near.position)\n                    if cost_through_qnew < q_near.cost:\n                        # Remove old parent edge (assuming one parent due to tree)\n                        old_parents = list(q_near.parents)\n                        for op in old_parents:\n                            self._graph.remove_edge(op, q_near)\n                        q_near.cost = cost_through_qnew\n                        self._graph.add_edge(q_new, q_near)\n\n            # Add q_new to the proper root list for next iteration\n            root_vertices.append(q_new)\n\n            # Attempt to connect q_new to the other tree's vertices\n            other_root_vertices = trees[1 - tree_idx][1]\n            connection_candidates = self._graph.get_vertices_within_radius(other_root_vertices, q_new.position, radius)\n            for q_other in connection_candidates:\n                # Check if edge between q_new and q_other can connect start and goal trees\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_other.position)):\n                    # Compute new potential cost\n                    new_cost = q_new.cost + self._distance(q_new.position, q_other.position) + q_other.cost\n                    if new_cost < c_best:\n                        c_best = new_cost\n                        self._best_cost = c_best\n                        self._best_connection = (q_new, q_other)\n\n            # Check if solution found and stop early\n            if self._best_connection is not None:\n                # Connect the two trees at best connection vertices\n                (conn_start, conn_goal) = self._best_connection\n                # Add edge between trees to create a connecting path\n                self._graph.add_edge(conn_start, conn_goal)\n                self._graph.add_edge(conn_goal, conn_start)  # bidirectional for robustness\n                # Extract the path and stop\n                self._extract_path()\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm improves path planning by integrating a goal-biased, heuristic-guided RRT* with adaptive step sizing and shortcut smoothing.\n    Key features:\n    - Adaptive step size based on distance to goal to improve exploration close to target.\n    - Goal-biased sampling with probability to guide growth quickly towards goal.\n    - Heuristic cost (Euclidean + path cost) used to choose best parent vertex and rewire.\n    - Post-processing path smoothing using shortcut attempts on extracted path.\n    - Early stopping with 10 seconds timeout to avoid long hangs.\n    These aspects aim to boost efficiency, path quality, robustness, and success rate relative to baseline RRT*.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._goal_bias_prob = 0.2  # Probability to sample the goal position to bias growth\n        self._max_step_dist = 15.0  # Maximum extension distance (adaptive per iteration)\n        self._start_time = None\n\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, from_point: Point, to_point: Point) -> float:\n        dist = self._get_grid().get_distance(from_point, to_point)\n        # Dynamic step size bounded between 5 and 15 increasing with distance\n        return min(max(dist / 3, 5.0), self._max_step_dist)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased random sampling: with some probability sample goal, else random valid point\n        if torch.rand(1).item() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n        while True:\n            rand_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir_vec)\n        if dir_norm == 0:\n            return None\n        if dir_norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dir_norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        # Validate that q_new_pos is a valid position for the agent before vertex creation\n        if not self._get_grid().is_agent_valid_pos(q_new_pos):\n            return None\n        return Vertex(q_new_pos)\n\n    def _choose_best_parent(self, q_new: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n        # Among neighbors, choose parent minimizing (cost(parent) + dist(parent,q_new) + heuristic)\n        # Heuristic is distance from q_new to goal (Euclidean)\n        min_cost = float('inf')\n        best_parent = None\n        goal_pos = self._get_grid().goal.position\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_to_new = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            heuristic = self._get_grid().get_distance(q_new.position, goal_pos)\n            total_cost = cost_to_new + heuristic\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for q_near in neighbors:\n            if q_near is q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                # Remove old parent edge(s)\n                old_parents = list(q_near.parents)\n                for p in old_parents:\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge from q_new to q_near\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _path_smoothing(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shorten path by shortcutting intermediate vertices if line is collision free\n        if len(path) <= 2:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            # Find furthest reachable vertex from smoothed[-1]\n            far_idx = len(path) - 1\n            while far_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(smoothed[-1].position, path[far_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                far_idx -= 1\n            smoothed.append(path[far_idx])\n            idx = far_idx\n        return smoothed\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_pos = self._get_grid().goal.position\n        goal_v = Vertex(goal_pos)\n        goal_v.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_pos)\n        self._graph.add_edge(q_new, goal_v)\n\n        # Trace back path from goal to start\n        path: List[Vertex] = [goal_v]\n        current = goal_v\n        while current.parents:\n            # Choose parent with lowest cost (should be single parent in tree)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        # path now contains goal to start, reverse\n        path.reverse()\n\n        # Path smoothing\n        smooth_path = self._path_smoothing(path)\n\n        for p in smooth_path:\n            self.move_agent(p.position)\n            # For ROS map extensions\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        max_iterations = 5000\n        dimension = self._get_grid().size.n_dim\n        lambda_rrt_star = 50.0\n        max_search_time = 10.0  # seconds timeout\n\n        self._start_time = time.time()\n\n        for iter in range(max_iterations):\n\n            # Timeout check for robustness\n            elapsed = time.time() - self._start_time\n            if elapsed > max_search_time:\n                # Route not found within time limit\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist_dynamic = self._get_adaptive_max_dist(q_nearest.position, q_sample)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist_dynamic)\n            if q_new is None:\n                continue\n\n            # Check path validity using Bresenham line sequence\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius for neighbors chosen as per RRT* formula with lambda_rrt_star factor\n            card_v = float(self._graph.size)\n            if card_v < 2:\n                radius = max_dist_dynamic * 2\n            else:\n                radius = min(lambda_rrt_star * ((torch.log(torch.tensor(card_v)) / card_v) ** (1/dimension)), 2*max_dist_dynamic)\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            best_parent = self._choose_best_parent(q_new, neighbors)\n            if best_parent is None:\n                continue\n\n            # Set cost & add edge from best parent\n            edge_dist = self._get_grid().get_distance(best_parent.position, q_new.position)\n            q_new.cost = best_parent.cost + edge_dist\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if cheaper path through q_new\n            self._rewire(q_new, neighbors)\n\n            # Check if close enough to goal to finish\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is a hybrid of informed sampling and heuristic-guided search inspired by RRT* and A*.\n    Key improvements:\n    - Adaptive sampling: 70% goal-biased samples, 30% random within informed ellipse (heuristic ellipse around start-goal),\n      focusing sampling in promising areas to reduce iterations and increase success rate.\n    - Adaptive step size: Step size changes based on distance to goal for more refined final approach.\n    - Heuristic cost estimate (A*-like) used to choose best parent and rewiring.\n    - Rewiring step performed for local optimality and path smoothing.\n    - Early stopping with 10 seconds timeout.\n    - Shortcut smoothing applied after path is found.\n    The result is a faster, more robust planner producing shorter and smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_iterations: int\n    _max_time_seconds: float\n    _step_size_min: float\n    _step_size_max: float\n    _goal_sample_rate: float\n    _informed_sampling_ratio: float\n    _dimension: int\n    \n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 5000\n        self._max_time_seconds = 10.0\n        self._step_size_min = 3.0\n        self._step_size_max = 15.0\n        self._goal_sample_rate = 0.7  # 70% samples bias toward goal\n        self._informed_sampling_ratio = 0.3 # 30% samples inside informed ellipse\n        self._dimension = len(self._get_grid().size)\n\n        self._init_displays()\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Euclidean distance heuristic\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_adaptive_step_size(self, position: Point) -> float:\n        # closer to goal -> smaller step size for refinement\n        dist_to_goal = self._heuristic_cost(position, self._get_grid().goal.position)\n        max_dist = self._step_size_max\n        min_dist = self._step_size_min\n        max_possible_dist = self._heuristic_cost(self._get_grid().agent.position, self._get_grid().goal.position)\n        if max_possible_dist < 1e-4:\n            return min_dist\n        ratio = dist_to_goal / max_possible_dist\n        step_size = min_dist + (max_dist - min_dist) * ratio\n        if step_size < min_dist:\n            step_size = min_dist\n        elif step_size > max_dist:\n            step_size = max_dist\n        return step_size\n\n    def _sample_in_ellipse(self) -> Point:\n        # Informed sampling in ellipse defined by start, goal, and best path length so far (simplified)\n        start = self._get_grid().agent.position.to_tensor()\n        goal = self._get_grid().goal.position.to_tensor()\n        c_best = self._heuristic_cost(self._get_grid().agent.position, self._get_grid().goal.position) * 1.5\n        c_min = self._heuristic_cost(self._get_grid().agent.position, self._get_grid().goal.position)\n        if c_min == 0:\n            return self._get_grid().goal.position\n        \n        # Ellipse parameters\n        center = (start + goal) / 2\n        a1 = (goal - start) / torch.norm(goal - start)  # unit vector from start->goal\n        # Orthogonal basis (2D assumption)\n        if self._dimension == 2:\n            a2 = torch.tensor([-a1[1], a1[0]])\n        else:\n            # In higher dims, pick random orthogonal vectors (simplified to unit cube here)\n            a2 = torch.zeros_like(a1)\n            a2[1] = 1.0\n\n        r1 = c_best / 2\n        r2 = torch.sqrt(c_best**2 - c_min**2) / 2\n\n        for _ in range(100):  # limit retries to find valid sample\n            sample_unit = torch.randn(self._dimension)\n            sample_unit = sample_unit / torch.norm(sample_unit)\n            # scale sample by ellipse radii (simplified 2D ellipse, for nD approximated by this approach)\n            sample_scaled = sample_unit * torch.tensor([r1 if i==0 else r2 for i in range(self._dimension)], dtype=torch.float)\n            # rotate and translate to ellipse center\n            pos_tensor = center + a1 * sample_scaled[0]\n            if self._dimension > 1:\n                pos_tensor = pos_tensor + a2 * sample_scaled[1]\n            sample_point = Point.from_tensor(pos_tensor)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        # Adaptive sampling: goal bias + informed region\n        import random\n        p = random.random()\n        if p < self._goal_sample_rate:\n            # direct goal bias\n            return self._get_grid().goal.position\n        elif p < self._goal_sample_rate + self._informed_sampling_ratio:\n            # informed ellipse sampling near start-goal\n            return self._sample_in_ellipse()\n        else:\n            # uniform random in free space\n            while True:\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dir_norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _extract_path(self, q_new: Vertex):\n        goal_v = Vertex(self._get_grid().goal.position)\n        goal_v.cost = q_new.cost + self._heuristic_cost(q_new.position, goal_v.position)\n        self._graph.add_edge(q_new, goal_v)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.pop()  # remove the start's parent (None)\n\n        path.reverse()\n\n        # Shortcut smoothing: attempt to shortcut path for fewer points\n        def shortcut_path(points: list) -> list:\n            if len(points) < 3:\n                return points\n            smoothed = [points[0]]\n            i = 0\n            while i < len(points)-1:\n                j = len(points)-1\n                while j > i+1:\n                    line_seq = self._get_grid().get_line_sequence(points[i].position, points[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        smoothed.append(points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # no shortcut found, move one step\n                    smoothed.append(points[i+1])\n                    i += 1\n            return smoothed\n\n        path_smoothed = shortcut_path(path)\n\n        for vertex in path_smoothed:\n            self.move_agent(vertex.position)\n            # ROS extension waypoint publish if applicable\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_dist_default = self._step_size_max\n        max_iterations = self._max_iterations\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > self._max_time_seconds:\n                # timeout, path not found\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            adaptive_step_size = self._get_adaptive_step_size(q_nearest.position)\n            q_new = self._get_new_vertex(q_nearest, q_sample, adaptive_step_size)\n\n            # Validate the path segment\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors for rewiring\n            card_v = float(self._graph.size) + 1  # avoid log(0)\n            log_card_v = torch.log(torch.tensor(card_v))\n            radius = min(50.0, 2.0 * ((log_card_v / card_v) ** (1 / self._dimension))) * adaptive_step_size\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent based on cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._heuristic_cost(q_nearest.position, q_new.position)\n\n            for neighbor in neighbors:\n                line_seq_candidate = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    continue\n\n                cost_candidate = neighbor.cost + self._heuristic_cost(neighbor.position, q_new.position)\n                if cost_candidate < c_min:\n                    c_min = cost_candidate\n                    q_min = neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new if better cost\n            for neighbor in neighbors:\n                line_seq_rewire = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    continue\n\n                cost_via_new = q_new.cost + self._heuristic_cost(q_new.position, neighbor.position)\n                if cost_via_new < neighbor.cost:\n                    # Remove old edge\n                    old_parent = None\n                    for p in neighbor.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, neighbor)\n                    # Add new edge\n                    neighbor.cost = cost_via_new\n                    self._graph.add_edge(q_new, neighbor)\n\n            # Check if goal reached within radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an Adaptive Heuristic RRT with Goal Bias and Dynamic Rewiring.\n    It incorporates:\n      - Adaptive max step distance based on distance to goal (larger steps far away, smaller close).\n      - Goal-biased sampling to increase chance of guiding towards goal.\n      - Heuristic-guided nearest vertex selection based on cost + heuristic (cost-to-come + Euclidean to goal).\n      - Rewiring of nearby vertices for path quality improvement similar to RRT*.\n      - Path shortcutting post path discovery for smoother path.\n      - Early stopping criteria (max 10 seconds runtime).\n    This aims to improve efficiency by faster convergence, improved success with goal-bias, \n    and produces smoother, shorter paths due to rewiring and shortcutting.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    _graph: Forest\n    _max_dist_base: float\n    _iterations: int\n    _start_time: float\n    \n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n        \n        self._max_dist_base = 15.0  # Base step distance; adaptive in _get_adaptive_max_dist\n        self._iterations = 8000\n    \n    def _get_heuristic_cost(self, from_v: Vertex) -> float:\n        # Euclidean distance from vertex to goal for heuristic\n        return self._get_grid().get_distance(from_v.position, self._graph.root_vertex_goal.position)\n    \n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        dist_to_goal = self._get_grid().get_distance(pos, self._graph.root_vertex_goal.position)\n        # Larger steps when far from goal, smaller steps when close\n        if dist_to_goal > 100:\n            return self._max_dist_base * 1.5\n        elif dist_to_goal < 10:\n            return max(3.0, self._max_dist_base * 0.3)\n        else:\n            return self._max_dist_base\n    \n    def _get_goal_biased_sample(self, goal_bias_prob: float = 0.2) -> Point:\n        # 20% chance sample is goal, else uniform random sample\n        import random\n        if random.random() < goal_bias_prob:\n            return self._graph.root_vertex_goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n    \n    def _get_nearest_vertex_heuristic(self, q_sample: Point) -> Vertex:\n        # Instead of pure Euclidean nearest, consider cost + heuristic for nearest vertex\n        candidates = self._graph.root_vertices\n        min_score = float('inf')\n        nearest_vertex = None\n        for root_vertex in candidates:\n            # Collect vertices efficiently around sample; fallback full vertex search if none found close\n            nearby_vertices = self._graph.get_vertices_within_radius([root_vertex], q_sample, radius=30.0)\n            search_vertices = nearby_vertices if nearby_vertices else [root_vertex]\n            for v in search_vertices:\n                # Cost-to-come + heuristic distance to goal + distance from sample -- together a prioritization heuristic\n                cost_to_come = v.cost if v.cost is not None else float('inf')\n                heuristic = self._get_grid().get_distance(v.position, self._graph.root_vertex_goal.position)\n                dist_sample_to_v = self._get_grid().get_distance(v.position, q_sample)\n                score = cost_to_come + heuristic + dist_sample_to_v\n                if score < min_score:\n                    min_score = score\n                    nearest_vertex = v\n        if nearest_vertex is None:\n            nearest_vertex = self._graph.root_vertex_start\n        return nearest_vertex\n    \n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n        return Vertex(q_new_point)\n    \n    def _get_vertices_within_rewire_radius(self, q_new: Vertex) -> list:\n        # Radius scales with sqrt(log(n)/n) similar to RRT*, capped to max radius for rewiring neighbors\n        card_v = torch.tensor(float(self._graph.size)) if self._graph.size > 0 else torch.tensor(1.0)\n        dimension = 2\n        gamma = 40  # parameter for radius calculation, tuned empirically\n        radius = min(gamma * ((torch.log(card_v) / card_v) ** (1 / dimension)), 30.0)\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius.item())\n    \n    def _rewire(self, q_new: Vertex, neighbor_vertices: list):\n        for q_near in neighbor_vertices:\n            if q_near == q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                cost_via_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                if cost_via_new < q_near.cost:\n                    # Rewire parent edge\n                    old_parents = list(q_near.parents)\n                    for p in old_parents:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_via_new\n                    self._graph.add_edge(q_new, q_near)\n    \n    def _extract_path(self, q_goal: Vertex) -> list:\n        path = [q_goal]\n        while path[-1].parents:\n            # Select cheapest parent if multiple\n            min_cost = float('inf')\n            min_parent = None\n            for p in path[-1].parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            path.append(min_parent)\n        path.reverse()\n        return path\n    \n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        \n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n    \n    def _move_along_path(self, path: list) -> None:\n        grid = self._get_grid()\n        is_ros_map = grid.__class__.__name__ == \"RosMap\"\n        for v in path:\n            self.move_agent(v.position)\n            if is_ros_map:\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n    \n    def _find_path_internal(self) -> None:\n        import time\n        \n        start_time = time.time()\n        max_duration_secs = 10.0  # Stop after 10 seconds to avoid endless search\n        \n        for iteration in range(self._iterations):\n            if time.time() - start_time > max_duration_secs:\n                break  # Timeout\n            \n            q_sample = self._get_goal_biased_sample(goal_bias_prob=0.25)\n            max_dist = self._get_adaptive_max_dist(self._graph.root_vertex_start.position)\n            \n            q_nearest = self._get_nearest_vertex_heuristic(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            \n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            \n            q_new.cost = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n            self._graph.add_edge(q_nearest, q_new)\n            \n            neighbors = self._get_vertices_within_rewire_radius(q_new)\n            # Choose parent with minimal cost (including q_new itself)\n            q_min = q_nearest\n            c_min = q_new.cost\n            for q_near in neighbors:\n                if q_near == q_new:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    cost_via_near = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                    if cost_via_near < c_min:\n                        q_min = q_near\n                        c_min = cost_via_near\n            if q_min != q_nearest:\n                # Rewire q_new to better parent\n                old_parents = list(q_new.parents)\n                for p in old_parents:\n                    self._graph.remove_edge(p, q_new)\n                q_new.cost = None\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n            \n            # Rewire neighbors to use q_new as parent if it improves cost\n            self._rewire(q_new, neighbors)\n            \n            # Check for goal reach within radius (agent radius)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex to q_new minimizing cost\n                goal_v = self._graph.root_vertex_goal\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_v.position)):\n                    goal_v.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_v.position)\n                    self._graph.add_edge(q_new, goal_v)\n                    path = self._extract_path(goal_v)\n                    # Shortcut path for smoother trajectory\n                    path = self._shortcut_path(path)\n                    self._move_along_path(path)\n                    return\n            \n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an informed RRT*-inspired planner with goal biasing,\n    adaptive step size, rewiring for optimality, and post-path shortcut smoothing.\n    Key improvements:\n    - Goal biasing: biased random sampling towards the goal with a probability.\n    - Adaptive max_dist: dynamically reduced max step length as the tree grows for finer paths.\n    - Use of RRT* style rewiring of the graph within a neighbor radius to minimize costs.\n    - Early stopping when a path to goal is found with a lower cost threshold.\n    - Post-extraction shortcutting to smooth and shorten the final path.\n    - A global timeout of 10 seconds to ensure responsiveness.\n    The method balances search efficiency, robustness, and path quality better than basic RRT or RRT-Connect.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position, True), Vertex(self._get_grid().goal.position, True), [])\n        self._graph.edges_removable = True  # enable rewiring edges\n        self._init_displays()\n\n        # Parameters\n        self._max_iterations = 5000\n        self._initial_max_dist = 15.0\n        self._final_max_dist = 3.0\n        self._goal_sample_rate = 0.15  # 15% samples directly toward goal for goal biasing\n        self._neighbor_radius = 20.0  # radius for rewiring neighbors\n        self._cost_threshold = float(\"inf\")  # track best path cost found\n\n    def _get_random_sample(self) -> Point:\n        if np.random.rand() < self._goal_sample_rate:\n            # Sample exact goal point for goal bias\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_adaptive_max_dist(self, iteration: int) -> float:\n        # Linear decay from initial max_dist to final max_dist over iterations\n        frac = min(iteration / self._max_iterations, 1.0)\n        return self._initial_max_dist + frac * (self._final_max_dist - self._initial_max_dist)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist == 0:\n            return None\n\n        if dist <= max_dist:\n            q_new_pos = q_sample\n        else:\n            direction_normalized = direction / dist\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex, q_near: Vertex) -> Vertex:\n        # Choose the neighbor with the lowest cost to new vertex via valid edge\n        q_min = q_near\n        c_min = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n\n        for neighbor in neighbors:\n            if neighbor.position == q_near.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            c_new = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n            if c_new < c_min:\n                q_min = neighbor\n                c_min = c_new\n\n        q_new.cost = c_min\n        return q_min\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        # For each neighbor, check if the path through q_new improves cost, and edge is valid\n        for neighbor in neighbors:\n            if neighbor.position == q_new.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n            if cost_through_new < neighbor.cost:\n                # Remove existing parents - as edges_removable=True, so remap parent\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                # Add new better edge\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = cost_through_new\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Trace path back to start\n        path: List[Vertex] = [q_goal]\n        while path[-1].parents:\n            # Greedy backtracking to parent with min cost to ensure optimal path\n            parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Perform shortcut smoothing to improve path quality\n        path = self._shortcut_path(path)\n\n        # Move the agent following the smoothed path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut between non-adjacent vertices to smooth path\n        if len(path) <= 2:\n            return path\n\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # Look ahead for furthest vertex that can be connected directly\n            furthest = i + 1\n            for j in range(len(path) - 1, i, -1):\n                line = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    furthest = j\n                    break\n            shortened_path.append(path[furthest])\n            i = furthest\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(self._max_iterations):\n            # Time limit check (max 10 seconds)\n            if time.time() - start_time > 10.0:\n                break\n\n            # Adaptive max_dist shrinking over iterations\n            max_dist = self._get_adaptive_max_dist(iteration)\n\n            q_rand: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_rand)\n\n            q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_rand, max_dist)\n            if q_new is None:\n                self.key_frame()\n                continue\n\n            # Find neighbors within radius for rewiring\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._neighbor_radius)\n\n            # Choose best parent to minimize cost\n            q_parent = self._choose_parent(neighbors, q_new, q_near)\n            self._graph.add_edge(q_parent, q_new)\n\n            # Rewire neighbors to optimize paths\n            self._rewire(neighbors, q_new)\n\n            # Check if new vertex is within goal radius and cost improves threshold\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._get_grid().goal.position)\n                if cost_to_goal < self._cost_threshold:\n                    # Create temporary goal vertex connected from q_new to extract path\n                    q_goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n                    q_goal_vertex.cost = cost_to_goal\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal_vertex.position)):\n                        self._graph.add_edge(q_new, q_goal_vertex)\n                        self._cost_threshold = cost_to_goal\n                        self._extract_path(q_goal_vertex)\n                        break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a goal-biased and heuristic-guided path planner that combines elements\n    of RRT*-style rewiring with an adaptive step size, heuristic cost guidance (combining Euclidean and\n    approximate obstacle clearance), and shortcut smoothing after path extraction. It uses adaptive\n    max_dist that decreases near obstacles and near goal to improve local refinement and ensures\n    smoother, shorter paths. Early stopping based on time (10 seconds) is enforced. The algorithm samples\n    points with a probability bias towards the goal, uses cost-to-come plus heuristic cost-to-go as metric,\n    rewires descendants within a radius to optimize the graph incrementally, and post-processes the path with\n    shortcutting to reduce unnecessary waypoints. The approach aims for better efficiency, robustness,\n    success rate, and path quality through these combined strategies.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_min: float\n    _max_dist_max: float\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist_max = 15.0\n        self._max_dist_min = 3.0\n        self._goal_sample_rate = 0.2  # 20% samples to goal bias\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Adaptive max_dist based on distance to goal and nearest obstacle bound distance.\n        Reduces max_dist near goal and near obstacles for finer control.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n\n        # Compute approximate min dist to obstacles around pos (simple grid check)\n        min_obs_dist = self._max_dist_max\n        for obs in grid.obstacles:\n            obs_bound = grid.get_obstacle_bound(obs.position)\n            for bound_pt in obs_bound:\n                d = Map.get_distance(pos, bound_pt)\n                if d < min_obs_dist:\n                    min_obs_dist = d\n                    if min_obs_dist < self._max_dist_min:\n                        break\n            if min_obs_dist < self._max_dist_min:\n                break\n\n        # Combine factors, clamp between min and max\n        adaptive_dist = min(dist_to_goal / 5.0, min_obs_dist, self._max_dist_max)\n        adaptive_dist = max(adaptive_dist, self._max_dist_min)\n        return adaptive_dist\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        \"\"\"\n        Heuristic cost combining distance and estimated clearance cost.\n        Clearance cost is inversely proportional to min dist to obstacles on line.\n        \"\"\"\n        grid = self._get_grid()\n        eu_dist = Map.get_distance(frm, to)\n        line_seq = grid.get_line_sequence(frm, to)\n        clearance = float('inf')\n        for pt in line_seq:\n            min_dist_to_obs = float('inf')\n            for obs in grid.obstacles:\n                # Approximate distance to obstacle boundary points\n                obs_bound = grid.get_obstacle_bound(obs.position)\n                for bpt in obs_bound:\n                    d = Map.get_distance(pt, bpt)\n                    if d < min_dist_to_obs:\n                        min_dist_to_obs = d\n            if min_dist_to_obs < clearance:\n                clearance = min_dist_to_obs\n        clearance_cost = 0 if clearance == 0 else 1 / clearance\n        return eu_dist + clearance_cost\n\n    def _get_best_parent(self, Q_near: list, q_new_pos: Point) -> (Vertex, float):\n        \"\"\"\n        Among Q_near vertices, find best parent for q_new that yields minimal cost and collision free.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        for q_near in Q_near:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new_pos)):\n                continue\n            cost = q_near.cost + self._heuristic_cost(q_near.position, q_new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return best_parent, min_cost\n\n    def _rewire(self, q_new: Vertex, Q_near: list) -> None:\n        \"\"\"\n        Rewire the vertices in Q_near using q_new if it improves their cost.\n        \"\"\"\n        grid = self._get_grid()\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                continue\n            possible_cost = q_new.cost + self._heuristic_cost(q_new.position, q_near.position)\n            if possible_cost < q_near.cost:\n                # Remove old parent edge\n                old_parent = None\n                for p in q_near.parents:\n                    old_parent = p\n                    break\n                if old_parent is not None:\n                    self._graph.remove_edge(old_parent, q_near)\n\n                # Add new edge from q_new to q_near\n                q_near.cost = possible_cost\n                self._graph.add_edge(q_new, q_near)\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Attempt shortcutting by removing unnecessary intermediate points.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n        grid = self._get_grid()\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove intermediate vertices between i and j exclusive\n                    path = path[:i+1] + path[j:]\n                    j = i + 1  # Restart inner loop after modification\n                j -= 1\n            i += 1\n        return path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal by walking parent edges, then perform smoothing shortcuts.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        # Connect q_new to goal with cost update\n        dist_to_goal = Map.get_distance(q_new.position, goal_v.position)\n        goal_v.cost = q_new.cost + dist_to_goal\n        self._graph.add_edge(q_new, goal_v)\n\n        path = [goal_v]\n        # Walk back parents to start\n        current_vertex = goal_v\n        while len(current_vertex.parents) > 0:\n            parent = next(iter(current_vertex.parents))\n            path.append(parent)\n            current_vertex = parent\n        path.reverse()\n\n        # Shortcut path to smooth\n        path = self._shortcut_path(path)\n\n        # Animate movement\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            # If RosMap, publish waypoint\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 10000\n        dimension = 2\n        lambda_rrt_star = 50\n        max_radius = 50\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0\n\n        for iteration in range(max_iterations):\n\n            # Early stop if exceeded 10 sec\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10:\n                # No path found within time limit\n                break\n\n            # Goal biased sampling (goal_sample_rate)\n            if np.random.random() < self._goal_sample_rate:\n                q_sample = grid.goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            # Nearest vertex in tree to sample\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size based on q_nearest position\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n\n            # Generate new vertex point q_new by moving towards q_sample with max_dist limit\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = float(torch.norm(dir_vec))\n            if dir_norm == 0:\n                continue  # coincident points\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dir_norm\n                new_pos_tensor = q_nearest.position.to_tensor() + max_dist * dir_normalized\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            # Skip if invalid line from q_nearest to q_new_pos\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Nearby vertices within radius for rewiring and parent selection\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, radius)\n\n            # Select best parent among Q_near with minimal cost+heuristic\n            best_parent, min_cost = self._get_best_parent(Q_near, q_new_pos)\n            if best_parent is None:\n                # No valid parent found (likely confined by obstacles), ignore sample\n                continue\n\n            # Create new vertex with updated cost\n            q_new = Vertex(q_new_pos)\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices to q_new if it improves cost\n            self._rewire(q_new, Q_near)\n\n            # Check if q_new is inside goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
