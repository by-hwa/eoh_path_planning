{
     "algorithm": "This algorithm implements an improved RRT*-inspired path planner with adaptive step size, \n    goal biasing, and rewiring optimization to improve path quality and success rate.\n    \n    Features: \n    - Goal-biased sampling with adjustable probability to improve convergence to goal.\n    - Adaptive max step size that shrinks near obstacles or when path is close to goal.\n    - Rewiring nearby vertices to optimize and shorten the path (RRT* style).\n    - Early stopping if goal is reached or if search time exceeds 10 seconds.\n    - Path smoothing by shortcutting line segments before extracting final path.\n    - Maintains a Forest graph structure, enabling incremental and flexible graph updates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_init: float\n    _goal_sample_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._max_dist_init = 12.0               # Initial max extension distance\n        self._goal_sample_rate = 0.15            # Probability to sample goal point (goal bias)\n        self._rewire_radius = 15.0                # Radius for considering rewiring\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self) -> Point:\n        p = np.random.rand()\n        if p < self._goal_sample_rate:\n            # Goal-biased sampling\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        \"\"\"\n        Adapt max step size based on distance to nearest obstacle boundary and goal\n        to enable finer adjustments near obstacles and near goal for quality paths.\n        \"\"\"\n        base = self._max_dist_init\n        dist_to_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n        # Shrink step size near goal for finer exploration\n        max_dist = base if dist_to_goal > 30 else base * (dist_to_goal / 30)\n        # Optionally, shrink near obstacles (estimate obstacle proximity)\n        # Since no direct method for obstacle distance, try simple heuristic:\n        # get neighbors: if fewer valid moves near q_near, shrink max_dist:\n        next_positions = self._get_grid().get_next_positions(q_near.position)\n        free_ratio = len(next_positions) / (3 ** self._get_grid().size.n_dim)  # max neighbors in grid approx\n        max_dist = min(max_dist, base * free_ratio)\n        max_dist = max(3.0, max_dist)  # enforce min step size of 3\n        return max_dist\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _find_near_vertices(self, point: Point) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], point, self._rewire_radius)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"\n        Among near vertices, choose one to be parent that provides minimum cost path to q_new.\n        \"\"\"\n        min_cost = float('inf')\n        min_parent = None\n        for q_near in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._cost(q_near, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                min_parent = q_near\n        if min_parent is not None:\n            q_new.cost = min_cost\n        return min_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewire nearby vertices if passing through q_new provides shorter path\n        \"\"\"\n        for q_near in near_vertices:\n            if q_near == q_new or q_near in q_new.parents:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Remove old edges from parents of q_near\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_final: Vertex) -> None:\n        \"\"\"\n        Extract path by traversing parent links backward, try shortcutting to smooth path\n        \"\"\"\n        path: List[Vertex] = [q_final]\n        while len(path[-1].parents) != 0:\n            # Since could have multiple parents, take the first for extraction\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        path.reverse()\n\n        # Attempt path smoothing via shortcutting\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 5000\n        start_time = time()\n        start_v = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n\n        # Initialize the start node cost to 0\n        start_v.cost = 0.0\n\n        found_goal = False\n        q_goal_vertex: Optional[Vertex] = None\n\n        for iteration in range(max_iterations):\n\n            # Check for maximum allowed time to prevent long runs\n            elapsed = time() - start_time\n            if elapsed > 10.0:\n                # fail early if over 10 seconds\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_v], q_sample)\n\n            # If sample == nearest position, continue\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate edge collision\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find near nodes for parent choosing and rewiring (RRT* style)\n            near_vertices = self._find_near_vertices(q_new.position)\n\n            # Choose best parent from near vertices + q_near candidate (if not in near_vertices already)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            parent = self._choose_parent(q_new, near_vertices)\n            if parent is None:\n                continue\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors if better paths found via q_new\n            self._rewire(q_new, near_vertices)\n\n            # Check if goal reached within radius (using position only)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                found_goal = True\n                q_goal_vertex = q_new\n                break\n\n            self.key_frame()\n\n        if found_goal and q_goal_vertex is not None:\n            # Connect q_goal_vertex to actual goal vertex with an edge if possible\n            goal_vertex = Vertex(goal_pos)\n            line_seq_goal = self._get_grid().get_line_sequence(q_goal_vertex.position, goal_pos)\n            if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                self._graph.add_edge(q_goal_vertex, goal_vertex)\n                q_goal_vertex = goal_vertex\n            q_goal_vertex.cost = q_goal_vertex.cost if hasattr(q_goal_vertex, 'cost') else 0.0\n            self._extract_path(q_goal_vertex)\n\n        else:\n            # Fail silently (no path) or handle if you want\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm, named PathPlanning, is a hybrid heuristic-guided, adaptive-sampling tree-based planner.\n    It combines goal-biased and obstacle-aware adaptive sampling to efficiently explore the environment.\n    It uses an informed metric combining Euclidean distance and cost-to-go heuristic (like A*) to guide expansions.\n    The step size adapts dynamically based on local obstacle density estimated via sampling.\n    It employs a rewiring mechanism to optimize path quality similar to RRT*, but selectively rewires only when\n    it improves overall path cost significantly to reduce computation.\n    The path extraction performs shortcut smoothing on the found path for smoother trajectories.\n    Early stopping occurs after timeout (10 seconds) or upon reaching the goal radius.\n    Overall, it aims for faster convergence, better path quality, and higher success rate with robustness in cluttered environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _goal_bias: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist = 15.0  # maximum extension length per step\n        self._max_radius = 30.0  # max radius for rewiring neighborhood\n        self._goal_bias = 0.2  # probability of sampling the goal directly\n        self._timeout_seconds = 10.0  # seconds maximum allowed for planning\n        self._init_displays()\n\n    # Helper: Adaptive step size based on local obstacle density\n    def _adaptive_max_dist(self, near_vertex: Vertex) -> float:\n        # Sample 8 random directions around near_vertex to estimate free space\n        free_count = 0\n        total_samples = 8\n        base_dist = self._max_dist\n        for _ in range(total_samples):\n            direction = torch.randn(len(near_vertex.position))  # random n-dimensional vector\n            direction_norm = torch.norm(direction)\n            if direction_norm == 0:\n                continue\n            dir_normalized = direction / direction_norm\n            test_point = Point.from_tensor(near_vertex.position.to_tensor() + base_dist * dir_normalized)\n            if self._get_grid().is_agent_valid_pos(test_point):\n                free_count += 1\n        ratio_free = free_count / total_samples\n        # More free space => bigger step, less free space => smaller step (min 5, max base_dist)\n        step_size = max(5.0, base_dist * ratio_free)\n        return step_size\n\n    # Helper: Heuristic cost combining cost-to-come + heuristic-to-goal (A* style)\n    def _heuristic_cost(self, from_pos: Point, to_pos: Point, cost_to_here: float) -> float:\n        heuristic = self._get_grid().get_distance(from_pos, to_pos)\n        return cost_to_here + heuristic\n\n    # Helper: Select parent with minimal cost to new vertex among neighbors\n    def _select_best_parent(self, q_new: Vertex, neighbors: list) -> Vertex:\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = neighbor\n        if best_parent is not None:\n            q_new.cost = best_cost\n        return best_parent\n\n    # Helper: Rewire neighbors if new path is better\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n            if cost_through_new < neighbor.cost:\n                # Remove old parent edge\n                old_parent = None\n                for p in neighbor.parents:\n                    old_parent = p\n                    break\n                if old_parent:\n                    self._graph.remove_edge(old_parent, neighbor)\n                neighbor.cost = cost_through_new\n                self._graph.add_edge(q_new, neighbor)\n\n    # Helper: Shortcut smoothing for extracted path\n    def _smooth_path(self, path_points: list) -> list:\n        if len(path_points) <= 2:\n            return path_points\n        smoothed = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_points[i], path_points[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path_points[j])\n            i = j\n        return smoothed\n\n    # Helper: Extract and move agent along smoothed path\n    def _extract_and_move(self, q_goal_parent: Vertex) -> None:\n        path = [q_goal_parent.position]\n        current = q_goal_parent\n        while current.parents:\n            for p in current.parents:\n                current = p\n                path.append(current.position)\n                break\n        path.reverse()\n        # Smooth path to reduce unnecessary waypoints/joints\n        path = self._smooth_path(path)\n        for p in path:\n            self.move_agent(p)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Helper: Goal-biased adaptive random sampling\n    def _goal_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    # Overridden Implementation #\n    # --------------------------#\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        iterations = 5000\n        dimension = len(self._get_grid().size)\n        lambda_rrt_star = 50\n\n        for i in range(iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_seconds:\n                # Timeout exceeded: Stop planning with no path found\n                break\n\n            q_sample: Point = self._goal_biased_sample()\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adapt step size according to local free space\n            adaptive_step = self._adaptive_max_dist(q_nearest)\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, adaptive_step)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Determine neighborhood radius for rewiring (informed by theory)\n            card_v = max(float(self._graph.size), 1.0)\n            log_card_v = max(1.0, torch.log(torch.tensor(card_v)).item())\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), self._max_radius)\n\n            neighbors: list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            if not neighbors:\n                # If no neighbors nearby, connect to nearest if valid\n                line_seq_nearest = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_nearest):\n                    q_new.cost = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n                    self._graph.add_edge(q_nearest, q_new)\n                else:\n                    # Cannot connect, discard q_new\n                    continue\n            else:\n                # Choose best parent among neighbors based on cost + heuristic\n                best_parent = self._select_best_parent(q_new, neighbors)\n                if best_parent is None:\n                    # Fallback to nearest\n                    best_parent = q_nearest\n                    q_new.cost = best_parent.cost + self._get_grid().get_distance(best_parent.position, q_new.position)\n                else:\n                    # cost set in _select_best_parent\n                    pass\n                self._graph.add_edge(best_parent, q_new)\n\n                # Rewire neighbors if beneficial; limit rewiring to best candidates to reduce overhead\n                limited_neighbors = neighbors[:min(10, len(neighbors))]  # limit to first 10 for efficiency\n                self._rewire(q_new, limited_neighbors)\n\n            # Add q_new vertex to graph's root_vertices explicitly for searching neighbors next round\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new reached near goal radius (goal region)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex\n                goal_v = self._graph.root_vertex_goal\n                line_seq = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    cost_to_goal = q_new.cost + self._get_grid().get_distance(q_new.position, goal_v.position)\n                    if goal_v.cost is None or cost_to_goal < goal_v.cost:\n                        goal_v.cost = cost_to_goal\n                        # Remove old parents if any\n                        for p in list(goal_v.parents):\n                            self._graph.remove_edge(p, goal_v)\n                        self._graph.add_edge(q_new, goal_v)\n                    self._extract_and_move(q_new)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an enhanced RRT* inspired approach with adaptive step size and goal biasing \n    combined with a rewiring technique for path optimization and early stopping based on time.\n    Key features:\n    - Adaptive sampling radius (max_dist) shrinks as tree grows to finely explore near goal.\n    - Goal-biased sampling with increasing bias probability over time.\n    - Rewiring nearby vertices to improve path quality (like RRT*).\n    - Path shortcutting after connection to smooth the path by removing redundant vertices.\n    - Early stopping if the path is found or total planning time exceeds 10 seconds.\n    - Uses heuristic (distance to goal) as a guiding cost to prefer vertices closer to goal.\n    This approach balances efficiency, path quality, robustness, and success rate improvements.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_iterations = 5000\n        self._initial_max_dist = 15  # initial max extension step size\n        self._min_max_dist = 3       # minimal max extension step size\n        self._rewire_radius = 20     # initial radius for rewiring neighbors\n        self._goal_bias_start = 0.1  # initial probability of sampling the goal\n        self._goal_bias_end = 0.5    # max goal bias probability near the end\n        self._goal_bias = self._goal_bias_start\n        self._time_limit_sec = 10.0\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        grid = self._get_grid()\n        # Increase goal bias linearly with iterations\n        goal_bias = min(\n            self._goal_bias_end,\n            self._goal_bias_start + (self._goal_bias_end - self._goal_bias_start) * (iteration / self._max_iterations)\n        )\n        if np.random.random() < goal_bias:\n            return grid.goal.position\n        # Uniform random sample within valid positions\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_adaptive_max_dist(self, iteration: int) -> float:\n        # Linearly decrease max_dist with iteration to focus closer dispersion near goal progressively\n        fraction = iteration / self._max_iterations\n        dist = self._initial_max_dist * (1 - fraction)\n        if dist < self._min_max_dist:\n            dist = self._min_max_dist\n        return dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir)\n        if norm == 0:  # Sample exactly at q_near\n            return None\n\n        if norm <= max_dist:\n            q_new = Vertex(q_sample)\n        else:\n            dir_normalized = dir / norm\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            q_new = Vertex(new_pos)\n        return q_new\n\n    def _cost(self, vertex: Vertex) -> float:\n        # Cost stored directly in vertex (length from start)\n        return vertex.cost if hasattr(vertex, 'cost') else float('inf')\n\n    def _heuristic_cost(self, vertex: Vertex) -> float:\n        # Heuristic cost: distance from vertex to goal\n        return Map.get_distance(vertex.position, self._get_grid().goal.position)\n\n    def _total_cost(self, parent: Vertex, child_pos: Point) -> float:\n        # Path cost from start to child passing through parent\n        cost_to_parent = self._cost(parent)\n        incremental_cost = self._get_grid().get_movement_cost(frm=parent.position, to=child_pos)\n        return cost_to_parent + incremental_cost\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new_pos: Point) -> Optional[Vertex]:\n        # Among near vertices, pick the one that leads to minimal cost to q_new_pos through it\n        min_cost = float('inf')\n        best_parent = None\n        for vertex in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new_pos)):\n                continue\n            cost = self._total_cost(vertex, q_new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # After adding q_new, try to improve neighbors by rewiring through q_new if it's cheaper\n        for vertex in near_vertices:\n            if vertex == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                continue\n            new_cost = self._total_cost(q_new, vertex.position)\n            if new_cost < self._cost(vertex):\n                # Remove old parent edges\n                for parent in list(vertex.parents):\n                    self._graph.remove_edge(parent, vertex)\n                # Add new edge through q_new\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> List[Vertex]:\n        # Trace back path from end_vertex to root start vertex\n        path = [end_vertex]\n        while len(path[-1].parents) != 0:\n            # Pick parent with least cost to ensure shortest path\n            best_parent = None\n            best_cost = float('inf')\n            for p in path[-1].parents:\n                if self._cost(p) < best_cost:\n                    best_cost = self._cost(p)\n                    best_parent = p\n            if best_parent is None:\n                break\n            path.append(best_parent)\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut path by connecting non-adjacent vertices if line between them is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _update_vertex_cost(self, vertex: Vertex) -> None:\n        # Update the vertex cost as shortest known cost from start (parents)\n        if len(vertex.parents) == 0:\n            vertex.cost = 0.0\n        else:\n            vertex.cost = min(\n                (self._cost(p) + self._get_grid().get_movement_cost(frm=p.position, to=vertex.position))\n                for p in vertex.parents\n            )\n\n    def _initialize_vertex_costs(self) -> None:\n        # Set cost of root start vertex to 0 and all others to infinity initially\n        for v in self._graph.root_vertices:\n            if v == self._graph.root_vertex_start:\n                v.cost = 0.0\n            else:\n                v.cost = float('inf')\n        for vertex in self._graph.root_vertices:\n            # propagate with DFS to set costs if any children exists (unlikely initially)\n            self._update_vertex_cost(vertex)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_time = time.time()\n\n        self._initialize_vertex_costs()\n\n        for it in range(self._max_iterations):\n            # Time early stop condition\n            if time.time() - start_time > self._time_limit_sec:\n                # Fail to find path within time\n                break\n\n            max_dist = self._get_adaptive_max_dist(it)\n            q_sample: Point = self._get_random_sample(it)\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Check collision-free path from q_near to q_new\n            line_sequence = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_sequence):\n                continue\n\n            # Near vertices for rewiring\n            near_vertices = self._near_vertices(q_new, self._rewire_radius)\n\n            # Choose best parent for q_new\n            best_parent = self._choose_parent(near_vertices, q_new.position)\n            if best_parent is None:\n                best_parent = q_near  # fallback\n\n            # Add q_new with best parent\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = self._total_cost(best_parent, q_new.position)\n\n            # Rewire nearby vertices to potentially improve their cost through q_new\n            self._rewire(q_new, near_vertices)\n\n            # Early check if q_new inside goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex directly if possible and extract path\n                goal_vertex = self._graph.root_vertex_goal\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = self._total_cost(q_new, goal_vertex.position)\n\n                    # Extract path from start to goal\n                    path = self._extract_path(goal_vertex)\n                    # Smooth path by shortcutting\n                    path = self._shortcut_path(path)\n\n                    for vertex in path:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is a hybrid sample-based planner combining features of RRT* and heuristic-guided search with goal bias,\n    adaptive step size, and iterative shortcut smoothing for path optimization. \n    It uses informed sampling biased towards the goal by combining uniform random sampling and goal-directed samples.\n    The maximum extension distance adapts dynamically based on local free space, improving exploration speed.\n    A rewiring step inspired by RRT* reduces path costs iteratively.\n    Once a path is found, an iterative shortcut shortcutting optimization is performed to smooth and shorten the path.\n    Additionally, the search is time-bounded (10 seconds) for practical efficiency.\n    This approach aims to improve planning efficiency, path quality, robustness, and success rate over basic RRT* or SPRM.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _goal_bias_rate: float\n    _V_size: int\n    _max_step_base: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        # Parameters\n        self._goal_bias_rate = 0.1  # 10% of samples are biased directly towards goal\n        self._V_size = 0  # Not used directly here but reserved\n        self._max_step_base = 15.0  # Base maximum extension distance\n        self._max_radius = 50.0  # Connection radius for rewiring\n        self._lambda_rrt_star = 50.0  # Parameter tuning rewire radius in RRT*\n        self._dimension = len(self._get_grid().size)  # dimension count (usually 2)\n\n        self._init_displays()\n\n    def _get_random_sample_biased(self) -> Point:\n        import random\n        grid = self._get_grid()\n        if random.random() < self._goal_bias_rate:\n            # Goal-biased: sample near goal with small gaussian noise\n            goal_pos = grid.goal.get_position()\n            import torch\n            noise = torch.randn(self._dimension) * (grid.size.min() * 0.05)  # 5% noise relative to grid min side\n            biased_point_tensor = goal_pos.to_tensor() + noise\n            biased_point_clamped = torch.min(torch.max(biased_point_tensor, torch.zeros(self._dimension)), torch.tensor(grid.size) - 1)\n            biased_point = Point.from_tensor(biased_point_clamped)\n            if grid.is_agent_valid_pos(biased_point):\n                return biased_point\n            # fallback to uniform if invalid\n        # Uniform sample\n        while True:\n            sample = Point(*[\n                torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)\n            ])\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_step(self, pos: Point) -> float:\n        # Adaptive max step based on clearance to obstacles, capped by base max\n        grid = self._get_grid()\n        clearance_search_radius = 5  # search radius for clearance in grid units\n        safe_dist = clearance_search_radius\n        for r in range(1, clearance_search_radius+1):\n            candidate_points = self._get_points_in_radius(pos, r)\n            for pt in candidate_points:\n                if not grid.is_agent_valid_pos(pt):\n                    safe_dist = r - 1\n                    return max(1.0, min(safe_dist * 2, self._max_step_base))\n        return self._max_step_base\n\n    def _get_points_in_radius(self, center: Point, radius: int) -> List[Point]:\n        # Returns all integer grid points within Euclidean integer radius from center\n        points = []\n        c_arr = center.to_tensor()\n        radius_sq = radius*radius\n        start_idx = [max(0, int(c_arr[i]-radius)) for i in range(self._dimension)]\n        end_idx = [min(self._get_grid().size[i]-1, int(c_arr[i]+radius)) for i in range(self._dimension)]\n\n        # Rectangular search: for 2D usually it's nested loops\n        if self._dimension == 2:\n            for x in range(start_idx[0], end_idx[0]+1):\n                for y in range(start_idx[1], end_idx[1]+1):\n                    p = Point(x,y)\n                    d_sq = (x - c_arr[0])**2 + (y - c_arr[1])**2\n                    if d_sq <= radius_sq:\n                        points.append(p)\n        else:\n            # Generic n-dim: recursively generate points, some overhead, but enough for supporting dimension n\n            from itertools import product\n            ranges = [range(start_idx[i], end_idx[i]+1) for i in range(self._dimension)]\n            for coords in product(*ranges):\n                d_sq = sum((coords[i] - c_arr[i])**2 for i in range(self._dimension))\n                if d_sq <= radius_sq:\n                    points.append(Point(*coords))\n        return points\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + dir_normalized * max_dist)\n        return Vertex(q_new_point)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        # Extract path from start to goal (goal_vertex) by following parents\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Assume single parent for tree structure\n            current = next(iter(current.parents))\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex], max_iterations: int = 50) -> List[Vertex]:\n        # Iterative shortcut smoothing on the path to remove unnecessary vertices\n        grid = self._get_grid()\n        if len(path) < 3:\n            return path  # Nothing to smooth\n\n        import random\n        path_positions = [v.position for v in path]\n        for _ in range(max_iterations):\n            if len(path_positions) < 3:\n                break\n            i = random.randint(0, len(path_positions) - 3)  # start index\n            j = random.randint(i+2, len(path_positions) - 1)  # end index, at least skip one vertex in between\n            seq = grid.get_line_sequence(path_positions[i], path_positions[j])\n            if grid.is_valid_line_sequence(seq):\n                # Remove intermediate vertices between i and j\n                del path_positions[i+1:j]\n        # Rebuild vertices from smoothed path positions:\n        smoothed_vertices = [Vertex(pos) for pos in path_positions]\n        # Setup parents edges:\n        for k in range(1, len(smoothed_vertices)):\n            smoothed_vertices[k].add_parent(smoothed_vertices[k - 1])\n            smoothed_vertices[k - 1].add_child(smoothed_vertices[k])\n            # Update cost as cumulative distance\n            segment_dist = torch.norm(smoothed_vertices[k].position.to_tensor() - smoothed_vertices[k - 1].position.to_tensor())\n            smoothed_vertices[k].cost = smoothed_vertices[k-1].cost + segment_dist if smoothed_vertices[k-1].cost is not None else segment_dist\n        if smoothed_vertices:\n            smoothed_vertices[0].cost = 0\n        return smoothed_vertices\n\n    def _move_agent_along_path(self, path: List[Vertex]) -> None:\n        # Animate and move agent along the path vertices positions\n        for v in path:\n            self.move_agent(v.position)\n            # For ROS compatibility if applicable\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp') and callable(getattr(grid, 'publish_wp')):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        max_time_sec = 10.0\n        start_time = time.time()\n\n        max_iterations = 8000\n        dimension = self._dimension\n\n        for i in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > max_time_sec:\n                # End search due to timeout without path found\n                return\n\n            # Sample point biased towards the goal (goal bias + uniform)\n            q_sample = self._get_random_sample_biased()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max extension based on local clearance\n            max_dist = self._adaptive_max_step(q_nearest.position)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Compute neighborhood radius for rewiring per RRT* formula\n            card_V = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            radius = min(self._lambda_rrt_star * ((torch.log(card_V) / card_V) ** (1/dimension)), self._max_radius)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose minimum cost parent in neighborhood for q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                line_quality = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost_through_near = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if line_quality and cost_through_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices if connecting through q_new shortens path\n            for q_near in Q_near:\n                line_quality = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if line_quality and cost_new_to_near < q_near.cost:\n                    # Remove old parent edge and add new\n                    old_parent = next(iter(q_near.parents))\n                    self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None  # Reset temporarily\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reached goal radius, then extract and smooth path\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_v = Vertex(grid.goal.get_position())\n                goal_v.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n                self._graph.add_edge(q_new, goal_v)\n\n                raw_path = self._extract_path(goal_v)\n                optimized_path = self._smooth_path(raw_path, max_iterations=70)\n                self._move_agent_along_path(optimized_path)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT*-inspired sample-based planner with goal biasing, adaptive step size,\n    rewiring for path cost optimization, heuristic-guided sampling, and path shortcutting.\n    It aims to improve planning efficiency by dynamically adjusting step length based on proximity to goal,\n    improving path quality through rewiring of nearby vertices to optimize cost, and robustness by biasing sampling\n    towards the goal with a progressive probability that increases during the run.\n    It also implements early stopping if a path is found and time exceeds 10 seconds to avoid infinite search.\n    The extracted path is shortcut for smoothness by attempting direct connections between non-adjacent waypoints.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable rewiring/removal of edges\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Adaptive step size: scale max_dist based on distance to goal and obstacle proximity\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        direction_normalized = dir_vec / dist\n        q_new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        q_new_pos = Point.from_tensor(q_new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias_prob: float) -> Point:\n        # Goal biased sampling: sample goal point with probability goal_bias_prob,\n        # otherwise sample random valid position in grid.\n        grid = self._get_grid()\n        if np.random.rand() < goal_bias_prob:\n            # sample goal position exactly\n            goal_pos = grid.goal.get_position()\n            if grid.is_agent_valid_pos(goal_pos):\n                return goal_pos\n        # else random valid sample\n        while True:\n            rand_pos_arr = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos_arr)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        # Compute cost from from_vertex to to_vertex with grid movement cost\n        grid = self._get_grid()\n        return grid.get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _total_cost(self, vertex: Vertex) -> float:\n        # Recursive cost to root (start)\n        if vertex == self._graph.root_vertex_start:\n            return 0.0\n        if len(vertex.parents) == 0:\n            return float('inf')  # not connected\n        # Choose minimal parent cost + edge cost\n        costs = []\n        for p in vertex.parents:\n            costs.append(self._total_cost(p) + self._cost(p, vertex))\n        return min(costs) if costs else float('inf')\n\n    def _rewire(self, q_new: Vertex, near_vertices: list, radius: float) -> None:\n        # Try to rewire each near vertex through q_new if path cost improves and line is clear\n        grid = self._get_grid()\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            potential_cost = self._total_cost(q_new) + self._cost(q_new, q_near)\n            current_cost = self._total_cost(q_near)\n            if potential_cost < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove old edges from parents to q_near\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    # Add new edge q_new -> q_near\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path back to start from goal vertex by parent links picking minimal-cost parent at each step\n        path_vertices = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break  # no connection\n            # Choose parent with minimum total cost from root\n            min_p = None\n            min_cost = float('inf')\n            for p in current.parents:\n                c = self._total_cost(p)\n                if c < min_cost:\n                    min_cost = c\n                    min_p = p\n            if min_p is None:\n                break\n            path_vertices.append(min_p)\n            current = min_p\n\n        path_vertices.reverse()  # start to goal order\n\n        path_points = [v.position for v in path_vertices]\n\n        # Shortcut path by attempting direct connections skipping intermediate points where possible\n        path_points = self._shortcut_path(path_points)\n\n        # Animate agent moving along path\n        for pos in path_points:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path_points: list) -> list:\n        # Attempt to shortcut path by skipping intermediate points if direct line between far points is valid\n        grid = self._get_grid()\n        if len(path_points) < 3:\n            return path_points\n\n        shortened_path = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            # Find farthest j > i where line is valid\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path_points[i], path_points[j])\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path_points[j])\n            i = j\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_dist_start = 10    # max distance when far from goal\n        max_dist_goal = 3      # max distance when close to goal (to fine tune\uff09\n        rewire_radius = 15.0   # radius for rewiring\n        max_iterations = 10000\n\n        grid = self._get_grid()\n        start_v = self._graph.root_vertex_start\n        goal_pos = grid.goal.get_position()\n        goal_reached_vertex = None\n\n        # Progressive goal bias probability starts low and increases linearly to 0.3\n        goal_bias_start = 0.05\n        goal_bias_end = 0.3\n\n        for iteration in range(1, max_iterations + 1):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:\n                # Timeout, fail pathfinding\n                break\n\n            # Linearly increase goal bias probability over iterations\n            goal_bias_prob = goal_bias_start + (goal_bias_end - goal_bias_start) * iteration / max_iterations\n\n            # Sample a point with goal bias\n            q_sample = self._get_random_sample(goal_bias_prob)\n\n            q_near = self._graph.get_nearest_vertex([start_v], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_goal = Map.get_distance(q_near.position, goal_pos)\n            max_dist = max_dist_goal if dist_to_goal < 20.0 else max_dist_start\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check collision for line from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Add edge q_near -> q_new\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire nearby vertices for cost optimization\n            near_vertices = self._get_near_vertices(q_new, rewire_radius)\n            self._rewire(q_new, near_vertices, rewire_radius)\n\n            # Check if goal can be connected directly from q_new\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_reached_vertex = goal_vertex\n                    break\n\n            # Check if q_new is within goal radius\n            if grid.is_agent_in_goal_radius(q_new.position):\n                goal_reached_vertex = q_new\n                break\n\n            self.key_frame()\n\n        if goal_reached_vertex is not None:\n            self._extract_path(goal_reached_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning Algorithm:\n    This algorithm improves upon basic RRT by integrating:\n    - Goal-biased sampling (with adaptive probability to sample the goal directly)\n    - Adaptive max step size, shrinking as it approaches the goal for precision\n    - Heuristic cost (distance-to-goal) to guide vertex rewiring for path optimization (similar to RRT*)\n    - Rewiring nearby vertices within a radius to shorten paths and smooth connectivity\n    - Early stopping if a valid path is found or 10 seconds have elapsed\n    - Path shortcutting on extraction to produce smoother, shorter final path\n    \n    The algorithm maintains a Forest graph structure and incrementally grows a tree from the start vertex.\n    At each iteration, a random sample is chosen with a bias towards the goal.\n    The nearest vertex is extended adaptively towards the sample, and new vertices may rewire neighbor vertices if it improves cost.\n    When the goal region is reached, path extraction attempts shortcuts to improve path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Allow edge rewiring\n        self._init_displays()\n\n    # Helper: Adaptive max step size based on distance to goal (smaller near goal for precision)\n    def _adaptive_max_dist(self, dist_to_goal: float) -> float:\n        max_step = 15.0\n        min_step = 3.0\n        threshold = 50.0\n        if dist_to_goal > threshold:\n            return max_step\n        else:\n            # Linearly shrink step size from max_step -> min_step as goal is approached\n            factor = dist_to_goal / threshold\n            return max(min_step, max_step * factor)\n\n    # Helper: Heuristic cost (distance to goal)\n    def _heuristic(self, pos: Point) -> float:\n        return self._get_grid().get_distance(pos, self._get_grid().goal.position)\n\n    # Helper: Find neighbors within a dynamic radius for rewiring (depends on vertices count)\n    def _get_neighbor_radius(self) -> float:\n        factor = 50.0  # Parameter to control neighbor radius\n        n = max(1, self._graph.size)\n        r = factor * (np.log(n) / n) ** 0.5\n        return min(r, 30.0)\n\n    # Helper: Construct path vertices starting from goal vertex back to start vertex\n    def _extract_and_shortcut_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        # Trace backwards from goal to root\n        while len(path[-1].parents) != 0:\n            # Since each vertex may have multiple parents, pick the one with minimum cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut path by attempting to connect non-adjacent nodes directly if possible\n        def can_connect_directly(p1: Point, p2: Point) -> bool:\n            line_seq = self._get_grid().get_line_sequence(p1, p2)\n            return self._get_grid().is_valid_line_sequence(line_seq)\n\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if can_connect_directly(path[i].position, path[j].position):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, just append next vertex\n                i += 1\n                shortcut_path.append(path[i])\n\n        # Animate the path\n        for vertex in shortcut_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Helper: Try rewiring neighbors to reduce cost by connecting through q_new\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                # Remove current parents edges connecting to q_neighbor\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                # Add new edge and update cost\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    # Modified helper: Get new vertex extended towards q_sample subject to max_dist, costs updated\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        q_new = Vertex(q_new_pos)\n        q_new.cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n        return q_new\n\n    def _get_random_sample(self) -> Point:\n        # With goal bias to sample goal directly with increasing probability over time\n        bias_prob = min(0.2 + 0.8 * (self._graph.size / 1000), 0.95)  # Increase bias as graph grows\n        if np.random.rand() < bias_prob:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    # Core path planning algorithm\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.perf_counter()\n\n        iterations_max = 10000\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(iterations_max):\n\n            # Enforce 10 seconds time limit\n            elapsed_time = time.perf_counter() - start_time\n            if elapsed_time > 10.0:\n                # Fail safe: no path found in allowed time\n                break\n\n            q_sample: Point = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_goal = self._heuristic(q_near.position)\n            max_dist = self._adaptive_max_dist(dist_to_goal)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within radius for rewiring, radius is dynamic based on graph size\n            neighbor_radius = self._get_neighbor_radius()\n            neighbors: list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, neighbor_radius)\n\n            # Choose best parent (lowest cost) from q_near and neighbors based on cost + distance\n            best_parent = q_near\n            best_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            for q_neighbor in neighbors:\n                if q_neighbor == q_near:\n                    continue\n                line_seq_to_neighbor = self._get_grid().get_line_sequence(q_neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_to_neighbor):\n                    continue\n                cost_through_neighbor = q_neighbor.cost + self._get_grid().get_distance(q_neighbor.position, q_new.position)\n                if cost_through_neighbor < best_cost:\n                    best_cost = cost_through_neighbor\n                    best_parent = q_neighbor\n\n            # Set cost and add edge from best parent\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if connecting through q_new improves cost\n            neighbors_except_new = [v for v in neighbors if v != q_new]\n            self._rewire_neighbors(q_new, neighbors_except_new)\n\n            # Check goal reaching\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex and connect\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                self._graph.add_edge(q_new, goal_vertex)\n\n                # Extract and shortcut path\n                self._extract_and_shortcut_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning algorithm improves over vanilla RRT by integrating the following innovations:\n    - Goal-biased sampling with adaptive probability to direct exploration progressively toward the goal.\n    - Dynamic step size (max_dist) that shrinks as the tree grows closer to the goal for finer path resolution.\n    - Incorporates a rewiring step inspired by RRT* to optimize the tree locally by reconnecting vertices within a radius to reduce cost.\n    - Heuristic cost-aware nearest neighbor search: considers both Euclidean distance and cost-to-come to select q_near.\n    - Early stopping if a path is found and no better solution is found after a timeout, capped overall by 10 seconds.\n    - Path smoothing after extraction using shortcutting by validating direct connections on path.\n    - Uses a cyclic graph to allow rewiring edges and supports multiple parents for better path quality.\n    This approach balances exploration and exploitation efficiently to improve success rate and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: CyclicGraph\n    _max_dist_initial: float\n    _timeout_sec: float\n    _rewire_radius: float\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._max_dist_initial = 15.0\n        self._timeout_sec = 10.0\n        self._rewire_radius = 20.0\n        self._goal_sample_rate = 0.2  # probability of sampling goal directly\n\n        # Use CyclicGraph to allow rewiring\n        from algorithms.classic.sample_based.core.graph import gen_forest, CyclicGraph\n        start_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = CyclicGraph(start_v, goal_v, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_sample_rate:\n            # Goal-bias sampling: sample goal position more often\n            return self._get_grid().goal.position\n        size = self._get_grid().size\n        while True:\n            rand_pos = np.random.randint(0, size, size.n_dim)\n            p = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Euclidean distance heuristic for guiding rewiring and nearest vertex costs\n        return self._get_grid().get_distance(frm, to)\n\n    def _nearest_vertex_cost_aware(self, vertices: list, p: Point) -> Vertex:\n        # Select vertex minimizing cost + heuristic distance to p, favors cheaper paths + proximity\n        min_score = float('inf')\n        best_vertex = None\n        for v in vertices:\n            cost_to_v = v.cost if v.cost is not None else 0.0\n            h = self._heuristic_cost(v.position, p)\n            score = cost_to_v + h\n            if score < min_score:\n                min_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_norm = dir_vec / norm\n        q_new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_norm)\n        return Vertex(q_new_pt, store_connectivity=True)\n\n    def _vertices_within_radius(self, center: Point, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, center, radius)\n\n    def _cost_to_vertex(self, vertex: Vertex) -> float:\n        return vertex.cost if vertex.cost is not None else 0.0\n\n    def _update_cost_and_parents(self, vertex: Vertex, new_parent: Vertex, new_cost: float) -> None:\n        # Remove old parents edges\n        for par in list(vertex.parents):\n            self._graph.remove_edge(par, vertex)\n        # Add new parent edge\n        self._graph.add_edge(new_parent, vertex)\n        vertex.cost = new_cost\n\n    def _try_rewire(self, q_new: Vertex, neighbors: list) -> None:\n        # Try rewiring neighbors to q_new if cost improves\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            # Cost if q_near connected through q_new\n            dist = self._get_grid().get_distance(q_new.position, q_near.position)\n            new_cost = q_new.cost + dist\n            if new_cost + 1e-6 < self._cost_to_vertex(q_near):  # Small epsilon tolerance\n                line = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    self._update_cost_and_parents(q_near, q_new, new_cost)\n\n    def _extract_path(self, q_goal_connected: Vertex):\n        # Backtrack from goal vertex following parent with min cost until start\n        path = [q_goal_connected]\n        current = q_goal_connected\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            # Among multiple parents pick one with minimal cost\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n        # Path smoothing by shortcutting\n        smoothed_path = [path[0]]\n        for i in range(1, len(path)):\n            for j in range(len(path)-1, i-1, -1):\n                line = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n            else:\n                smoothed_path.append(path[i])\n        # Animate the final path\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iter = 8000\n        max_dist = self._max_dist_initial\n        reached_goal_vertex = None\n\n        # Initialize cost for start vertex\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iter):\n            # Early timeout check\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_sec:\n                # fail early, no path found within time limit\n                break\n\n            # Adaptive max_dist reduces as tree approaches goal (heuristic)\n            dist_to_goal = self._get_grid().get_distance(self._graph.root_vertex_start.position, self._get_grid().goal.position)\n            max_dist = max(5.0, self._max_dist_initial * (dist_to_goal / self._get_grid().size.n_dim))\n\n            # Sample point with goal bias\n            q_sample = self._get_random_sample()\n\n            # Select nearest vertex by cost-aware heuristic\n            q_near = self._nearest_vertex_cost_aware(self._graph.root_vertices, q_sample)\n\n            # Skip if same point\n            if q_near.position == q_sample:\n                continue\n\n            # Generate new vertex\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate path from q_near to q_new\n            line_segment = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_segment):\n                continue\n\n            # Calculate cost to q_new\n            cost_to_new = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            q_new.cost = cost_to_new\n\n            # Add q_new to graph with edge from q_near\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire nearby vertices within radius to optimize paths\n            neighbors = self._vertices_within_radius(q_new.position, self._rewire_radius)\n            # Discard neighbors too far or invalid connections\n            neighbors = [v for v in neighbors if v != q_new]\n\n            # Try selecting a better parent among nearby vertices to connect q_new\n            better_parent = q_near\n            better_cost = cost_to_new\n            for v in neighbors:\n                dist = self._get_grid().get_distance(v.position, q_new.position)\n                tentative_cost = v.cost + dist\n                if tentative_cost + 1e-6 < better_cost:\n                    line_to_qnew = self._get_grid().get_line_sequence(v.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(line_to_qnew):\n                        better_parent = v\n                        better_cost = tentative_cost\n\n            if better_parent != q_near:\n                # Reconnect q_new's parent edge for better cost\n                self._graph.remove_edge(q_near, q_new)\n                self._graph.add_edge(better_parent, q_new)\n                q_new.cost = better_cost\n\n            # Rewire others through q_new if beneficial\n            self._try_rewire(q_new, neighbors)\n\n            # Check if goal is reached within radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex and connect from q_new if possible\n                goal_vertex = self._graph.root_vertex_goal\n\n                # Check path validity q_new->goal\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    cost_to_goal = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                    # Connect and update cost if better\n                    if goal_vertex.cost is None or cost_to_goal < goal_vertex.cost:\n                        # Remove old parents connecting goal vertex\n                        for p in list(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        self._graph.add_edge(q_new, goal_vertex)\n                        goal_vertex.cost = cost_to_goal\n\n                    reached_goal_vertex = goal_vertex\n                    # Early stopping criteria: if no improvement for ~1 sec or found goal, break\n                    if time.time() - start_time > 1.0:\n                        break\n\n            self.key_frame()\n\n        # If successful, extract and smooth path\n        if reached_goal_vertex is not None and reached_goal_vertex.cost is not None:\n            self._extract_path(reached_goal_vertex)",
     "objective": null,
     "other_inf": null
}
