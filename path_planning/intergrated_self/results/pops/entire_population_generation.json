{
     "algorithm": "This algorithm implements an improved RRT*-inspired path planner with adaptive step size, \n    goal biasing, and rewiring optimization to improve path quality and success rate.\n    \n    Features: \n    - Goal-biased sampling with adjustable probability to improve convergence to goal.\n    - Adaptive max step size that shrinks near obstacles or when path is close to goal.\n    - Rewiring nearby vertices to optimize and shorten the path (RRT* style).\n    - Early stopping if goal is reached or if search time exceeds 10 seconds.\n    - Path smoothing by shortcutting line segments before extracting final path.\n    - Maintains a Forest graph structure, enabling incremental and flexible graph updates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_init: float\n    _goal_sample_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._max_dist_init = 12.0               # Initial max extension distance\n        self._goal_sample_rate = 0.15            # Probability to sample goal point (goal bias)\n        self._rewire_radius = 15.0                # Radius for considering rewiring\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self) -> Point:\n        p = np.random.rand()\n        if p < self._goal_sample_rate:\n            # Goal-biased sampling\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        \"\"\"\n        Adapt max step size based on distance to nearest obstacle boundary and goal\n        to enable finer adjustments near obstacles and near goal for quality paths.\n        \"\"\"\n        base = self._max_dist_init\n        dist_to_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n        # Shrink step size near goal for finer exploration\n        max_dist = base if dist_to_goal > 30 else base * (dist_to_goal / 30)\n        # Optionally, shrink near obstacles (estimate obstacle proximity)\n        # Since no direct method for obstacle distance, try simple heuristic:\n        # get neighbors: if fewer valid moves near q_near, shrink max_dist:\n        next_positions = self._get_grid().get_next_positions(q_near.position)\n        free_ratio = len(next_positions) / (3 ** self._get_grid().size.n_dim)  # max neighbors in grid approx\n        max_dist = min(max_dist, base * free_ratio)\n        max_dist = max(3.0, max_dist)  # enforce min step size of 3\n        return max_dist\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _find_near_vertices(self, point: Point) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], point, self._rewire_radius)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"\n        Among near vertices, choose one to be parent that provides minimum cost path to q_new.\n        \"\"\"\n        min_cost = float('inf')\n        min_parent = None\n        for q_near in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._cost(q_near, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                min_parent = q_near\n        if min_parent is not None:\n            q_new.cost = min_cost\n        return min_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewire nearby vertices if passing through q_new provides shorter path\n        \"\"\"\n        for q_near in near_vertices:\n            if q_near == q_new or q_near in q_new.parents:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Remove old edges from parents of q_near\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_final: Vertex) -> None:\n        \"\"\"\n        Extract path by traversing parent links backward, try shortcutting to smooth path\n        \"\"\"\n        path: List[Vertex] = [q_final]\n        while len(path[-1].parents) != 0:\n            # Since could have multiple parents, take the first for extraction\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        path.reverse()\n\n        # Attempt path smoothing via shortcutting\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 5000\n        start_time = time()\n        start_v = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n\n        # Initialize the start node cost to 0\n        start_v.cost = 0.0\n\n        found_goal = False\n        q_goal_vertex: Optional[Vertex] = None\n\n        for iteration in range(max_iterations):\n\n            # Check for maximum allowed time to prevent long runs\n            elapsed = time() - start_time\n            if elapsed > 10.0:\n                # fail early if over 10 seconds\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_v], q_sample)\n\n            # If sample == nearest position, continue\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate edge collision\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find near nodes for parent choosing and rewiring (RRT* style)\n            near_vertices = self._find_near_vertices(q_new.position)\n\n            # Choose best parent from near vertices + q_near candidate (if not in near_vertices already)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            parent = self._choose_parent(q_new, near_vertices)\n            if parent is None:\n                continue\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors if better paths found via q_new\n            self._rewire(q_new, near_vertices)\n\n            # Check if goal reached within radius (using position only)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                found_goal = True\n                q_goal_vertex = q_new\n                break\n\n            self.key_frame()\n\n        if found_goal and q_goal_vertex is not None:\n            # Connect q_goal_vertex to actual goal vertex with an edge if possible\n            goal_vertex = Vertex(goal_pos)\n            line_seq_goal = self._get_grid().get_line_sequence(q_goal_vertex.position, goal_pos)\n            if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                self._graph.add_edge(q_goal_vertex, goal_vertex)\n                q_goal_vertex = goal_vertex\n            q_goal_vertex.cost = q_goal_vertex.cost if hasattr(q_goal_vertex, 'cost') else 0.0\n            self._extract_path(q_goal_vertex)\n\n        else:\n            # Fail silently (no path) or handle if you want\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm, named PathPlanning, is a hybrid heuristic-guided, adaptive-sampling tree-based planner.\n    It combines goal-biased and obstacle-aware adaptive sampling to efficiently explore the environment.\n    It uses an informed metric combining Euclidean distance and cost-to-go heuristic (like A*) to guide expansions.\n    The step size adapts dynamically based on local obstacle density estimated via sampling.\n    It employs a rewiring mechanism to optimize path quality similar to RRT*, but selectively rewires only when\n    it improves overall path cost significantly to reduce computation.\n    The path extraction performs shortcut smoothing on the found path for smoother trajectories.\n    Early stopping occurs after timeout (10 seconds) or upon reaching the goal radius.\n    Overall, it aims for faster convergence, better path quality, and higher success rate with robustness in cluttered environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _goal_bias: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist = 15.0  # maximum extension length per step\n        self._max_radius = 30.0  # max radius for rewiring neighborhood\n        self._goal_bias = 0.2  # probability of sampling the goal directly\n        self._timeout_seconds = 10.0  # seconds maximum allowed for planning\n        self._init_displays()\n\n    # Helper: Adaptive step size based on local obstacle density\n    def _adaptive_max_dist(self, near_vertex: Vertex) -> float:\n        # Sample 8 random directions around near_vertex to estimate free space\n        free_count = 0\n        total_samples = 8\n        base_dist = self._max_dist\n        for _ in range(total_samples):\n            direction = torch.randn(len(near_vertex.position))  # random n-dimensional vector\n            direction_norm = torch.norm(direction)\n            if direction_norm == 0:\n                continue\n            dir_normalized = direction / direction_norm\n            test_point = Point.from_tensor(near_vertex.position.to_tensor() + base_dist * dir_normalized)\n            if self._get_grid().is_agent_valid_pos(test_point):\n                free_count += 1\n        ratio_free = free_count / total_samples\n        # More free space => bigger step, less free space => smaller step (min 5, max base_dist)\n        step_size = max(5.0, base_dist * ratio_free)\n        return step_size\n\n    # Helper: Heuristic cost combining cost-to-come + heuristic-to-goal (A* style)\n    def _heuristic_cost(self, from_pos: Point, to_pos: Point, cost_to_here: float) -> float:\n        heuristic = self._get_grid().get_distance(from_pos, to_pos)\n        return cost_to_here + heuristic\n\n    # Helper: Select parent with minimal cost to new vertex among neighbors\n    def _select_best_parent(self, q_new: Vertex, neighbors: list) -> Vertex:\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = neighbor\n        if best_parent is not None:\n            q_new.cost = best_cost\n        return best_parent\n\n    # Helper: Rewire neighbors if new path is better\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n            if cost_through_new < neighbor.cost:\n                # Remove old parent edge\n                old_parent = None\n                for p in neighbor.parents:\n                    old_parent = p\n                    break\n                if old_parent:\n                    self._graph.remove_edge(old_parent, neighbor)\n                neighbor.cost = cost_through_new\n                self._graph.add_edge(q_new, neighbor)\n\n    # Helper: Shortcut smoothing for extracted path\n    def _smooth_path(self, path_points: list) -> list:\n        if len(path_points) <= 2:\n            return path_points\n        smoothed = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_points[i], path_points[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path_points[j])\n            i = j\n        return smoothed\n\n    # Helper: Extract and move agent along smoothed path\n    def _extract_and_move(self, q_goal_parent: Vertex) -> None:\n        path = [q_goal_parent.position]\n        current = q_goal_parent\n        while current.parents:\n            for p in current.parents:\n                current = p\n                path.append(current.position)\n                break\n        path.reverse()\n        # Smooth path to reduce unnecessary waypoints/joints\n        path = self._smooth_path(path)\n        for p in path:\n            self.move_agent(p)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Helper: Goal-biased adaptive random sampling\n    def _goal_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    # Overridden Implementation #\n    # --------------------------#\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        iterations = 5000\n        dimension = len(self._get_grid().size)\n        lambda_rrt_star = 50\n\n        for i in range(iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_seconds:\n                # Timeout exceeded: Stop planning with no path found\n                break\n\n            q_sample: Point = self._goal_biased_sample()\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adapt step size according to local free space\n            adaptive_step = self._adaptive_max_dist(q_nearest)\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, adaptive_step)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Determine neighborhood radius for rewiring (informed by theory)\n            card_v = max(float(self._graph.size), 1.0)\n            log_card_v = max(1.0, torch.log(torch.tensor(card_v)).item())\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), self._max_radius)\n\n            neighbors: list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            if not neighbors:\n                # If no neighbors nearby, connect to nearest if valid\n                line_seq_nearest = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_nearest):\n                    q_new.cost = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n                    self._graph.add_edge(q_nearest, q_new)\n                else:\n                    # Cannot connect, discard q_new\n                    continue\n            else:\n                # Choose best parent among neighbors based on cost + heuristic\n                best_parent = self._select_best_parent(q_new, neighbors)\n                if best_parent is None:\n                    # Fallback to nearest\n                    best_parent = q_nearest\n                    q_new.cost = best_parent.cost + self._get_grid().get_distance(best_parent.position, q_new.position)\n                else:\n                    # cost set in _select_best_parent\n                    pass\n                self._graph.add_edge(best_parent, q_new)\n\n                # Rewire neighbors if beneficial; limit rewiring to best candidates to reduce overhead\n                limited_neighbors = neighbors[:min(10, len(neighbors))]  # limit to first 10 for efficiency\n                self._rewire(q_new, limited_neighbors)\n\n            # Add q_new vertex to graph's root_vertices explicitly for searching neighbors next round\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new reached near goal radius (goal region)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex\n                goal_v = self._graph.root_vertex_goal\n                line_seq = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    cost_to_goal = q_new.cost + self._get_grid().get_distance(q_new.position, goal_v.position)\n                    if goal_v.cost is None or cost_to_goal < goal_v.cost:\n                        goal_v.cost = cost_to_goal\n                        # Remove old parents if any\n                        for p in list(goal_v.parents):\n                            self._graph.remove_edge(p, goal_v)\n                        self._graph.add_edge(q_new, goal_v)\n                    self._extract_and_move(q_new)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an enhanced RRT* inspired approach with adaptive step size and goal biasing \n    combined with a rewiring technique for path optimization and early stopping based on time.\n    Key features:\n    - Adaptive sampling radius (max_dist) shrinks as tree grows to finely explore near goal.\n    - Goal-biased sampling with increasing bias probability over time.\n    - Rewiring nearby vertices to improve path quality (like RRT*).\n    - Path shortcutting after connection to smooth the path by removing redundant vertices.\n    - Early stopping if the path is found or total planning time exceeds 10 seconds.\n    - Uses heuristic (distance to goal) as a guiding cost to prefer vertices closer to goal.\n    This approach balances efficiency, path quality, robustness, and success rate improvements.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_iterations = 5000\n        self._initial_max_dist = 15  # initial max extension step size\n        self._min_max_dist = 3       # minimal max extension step size\n        self._rewire_radius = 20     # initial radius for rewiring neighbors\n        self._goal_bias_start = 0.1  # initial probability of sampling the goal\n        self._goal_bias_end = 0.5    # max goal bias probability near the end\n        self._goal_bias = self._goal_bias_start\n        self._time_limit_sec = 10.0\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        grid = self._get_grid()\n        # Increase goal bias linearly with iterations\n        goal_bias = min(\n            self._goal_bias_end,\n            self._goal_bias_start + (self._goal_bias_end - self._goal_bias_start) * (iteration / self._max_iterations)\n        )\n        if np.random.random() < goal_bias:\n            return grid.goal.position\n        # Uniform random sample within valid positions\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_adaptive_max_dist(self, iteration: int) -> float:\n        # Linearly decrease max_dist with iteration to focus closer dispersion near goal progressively\n        fraction = iteration / self._max_iterations\n        dist = self._initial_max_dist * (1 - fraction)\n        if dist < self._min_max_dist:\n            dist = self._min_max_dist\n        return dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir)\n        if norm == 0:  # Sample exactly at q_near\n            return None\n\n        if norm <= max_dist:\n            q_new = Vertex(q_sample)\n        else:\n            dir_normalized = dir / norm\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            q_new = Vertex(new_pos)\n        return q_new\n\n    def _cost(self, vertex: Vertex) -> float:\n        # Cost stored directly in vertex (length from start)\n        return vertex.cost if hasattr(vertex, 'cost') else float('inf')\n\n    def _heuristic_cost(self, vertex: Vertex) -> float:\n        # Heuristic cost: distance from vertex to goal\n        return Map.get_distance(vertex.position, self._get_grid().goal.position)\n\n    def _total_cost(self, parent: Vertex, child_pos: Point) -> float:\n        # Path cost from start to child passing through parent\n        cost_to_parent = self._cost(parent)\n        incremental_cost = self._get_grid().get_movement_cost(frm=parent.position, to=child_pos)\n        return cost_to_parent + incremental_cost\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new_pos: Point) -> Optional[Vertex]:\n        # Among near vertices, pick the one that leads to minimal cost to q_new_pos through it\n        min_cost = float('inf')\n        best_parent = None\n        for vertex in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new_pos)):\n                continue\n            cost = self._total_cost(vertex, q_new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # After adding q_new, try to improve neighbors by rewiring through q_new if it's cheaper\n        for vertex in near_vertices:\n            if vertex == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                continue\n            new_cost = self._total_cost(q_new, vertex.position)\n            if new_cost < self._cost(vertex):\n                # Remove old parent edges\n                for parent in list(vertex.parents):\n                    self._graph.remove_edge(parent, vertex)\n                # Add new edge through q_new\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> List[Vertex]:\n        # Trace back path from end_vertex to root start vertex\n        path = [end_vertex]\n        while len(path[-1].parents) != 0:\n            # Pick parent with least cost to ensure shortest path\n            best_parent = None\n            best_cost = float('inf')\n            for p in path[-1].parents:\n                if self._cost(p) < best_cost:\n                    best_cost = self._cost(p)\n                    best_parent = p\n            if best_parent is None:\n                break\n            path.append(best_parent)\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut path by connecting non-adjacent vertices if line between them is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _update_vertex_cost(self, vertex: Vertex) -> None:\n        # Update the vertex cost as shortest known cost from start (parents)\n        if len(vertex.parents) == 0:\n            vertex.cost = 0.0\n        else:\n            vertex.cost = min(\n                (self._cost(p) + self._get_grid().get_movement_cost(frm=p.position, to=vertex.position))\n                for p in vertex.parents\n            )\n\n    def _initialize_vertex_costs(self) -> None:\n        # Set cost of root start vertex to 0 and all others to infinity initially\n        for v in self._graph.root_vertices:\n            if v == self._graph.root_vertex_start:\n                v.cost = 0.0\n            else:\n                v.cost = float('inf')\n        for vertex in self._graph.root_vertices:\n            # propagate with DFS to set costs if any children exists (unlikely initially)\n            self._update_vertex_cost(vertex)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_time = time.time()\n\n        self._initialize_vertex_costs()\n\n        for it in range(self._max_iterations):\n            # Time early stop condition\n            if time.time() - start_time > self._time_limit_sec:\n                # Fail to find path within time\n                break\n\n            max_dist = self._get_adaptive_max_dist(it)\n            q_sample: Point = self._get_random_sample(it)\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Check collision-free path from q_near to q_new\n            line_sequence = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_sequence):\n                continue\n\n            # Near vertices for rewiring\n            near_vertices = self._near_vertices(q_new, self._rewire_radius)\n\n            # Choose best parent for q_new\n            best_parent = self._choose_parent(near_vertices, q_new.position)\n            if best_parent is None:\n                best_parent = q_near  # fallback\n\n            # Add q_new with best parent\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = self._total_cost(best_parent, q_new.position)\n\n            # Rewire nearby vertices to potentially improve their cost through q_new\n            self._rewire(q_new, near_vertices)\n\n            # Early check if q_new inside goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex directly if possible and extract path\n                goal_vertex = self._graph.root_vertex_goal\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = self._total_cost(q_new, goal_vertex.position)\n\n                    # Extract path from start to goal\n                    path = self._extract_path(goal_vertex)\n                    # Smooth path by shortcutting\n                    path = self._shortcut_path(path)\n\n                    for vertex in path:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is a hybrid sample-based planner combining features of RRT* and heuristic-guided search with goal bias,\n    adaptive step size, and iterative shortcut smoothing for path optimization. \n    It uses informed sampling biased towards the goal by combining uniform random sampling and goal-directed samples.\n    The maximum extension distance adapts dynamically based on local free space, improving exploration speed.\n    A rewiring step inspired by RRT* reduces path costs iteratively.\n    Once a path is found, an iterative shortcut shortcutting optimization is performed to smooth and shorten the path.\n    Additionally, the search is time-bounded (10 seconds) for practical efficiency.\n    This approach aims to improve planning efficiency, path quality, robustness, and success rate over basic RRT* or SPRM.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _goal_bias_rate: float\n    _V_size: int\n    _max_step_base: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        # Parameters\n        self._goal_bias_rate = 0.1  # 10% of samples are biased directly towards goal\n        self._V_size = 0  # Not used directly here but reserved\n        self._max_step_base = 15.0  # Base maximum extension distance\n        self._max_radius = 50.0  # Connection radius for rewiring\n        self._lambda_rrt_star = 50.0  # Parameter tuning rewire radius in RRT*\n        self._dimension = len(self._get_grid().size)  # dimension count (usually 2)\n\n        self._init_displays()\n\n    def _get_random_sample_biased(self) -> Point:\n        import random\n        grid = self._get_grid()\n        if random.random() < self._goal_bias_rate:\n            # Goal-biased: sample near goal with small gaussian noise\n            goal_pos = grid.goal.get_position()\n            import torch\n            noise = torch.randn(self._dimension) * (grid.size.min() * 0.05)  # 5% noise relative to grid min side\n            biased_point_tensor = goal_pos.to_tensor() + noise\n            biased_point_clamped = torch.min(torch.max(biased_point_tensor, torch.zeros(self._dimension)), torch.tensor(grid.size) - 1)\n            biased_point = Point.from_tensor(biased_point_clamped)\n            if grid.is_agent_valid_pos(biased_point):\n                return biased_point\n            # fallback to uniform if invalid\n        # Uniform sample\n        while True:\n            sample = Point(*[\n                torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)\n            ])\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_step(self, pos: Point) -> float:\n        # Adaptive max step based on clearance to obstacles, capped by base max\n        grid = self._get_grid()\n        clearance_search_radius = 5  # search radius for clearance in grid units\n        safe_dist = clearance_search_radius\n        for r in range(1, clearance_search_radius+1):\n            candidate_points = self._get_points_in_radius(pos, r)\n            for pt in candidate_points:\n                if not grid.is_agent_valid_pos(pt):\n                    safe_dist = r - 1\n                    return max(1.0, min(safe_dist * 2, self._max_step_base))\n        return self._max_step_base\n\n    def _get_points_in_radius(self, center: Point, radius: int) -> List[Point]:\n        # Returns all integer grid points within Euclidean integer radius from center\n        points = []\n        c_arr = center.to_tensor()\n        radius_sq = radius*radius\n        start_idx = [max(0, int(c_arr[i]-radius)) for i in range(self._dimension)]\n        end_idx = [min(self._get_grid().size[i]-1, int(c_arr[i]+radius)) for i in range(self._dimension)]\n\n        # Rectangular search: for 2D usually it's nested loops\n        if self._dimension == 2:\n            for x in range(start_idx[0], end_idx[0]+1):\n                for y in range(start_idx[1], end_idx[1]+1):\n                    p = Point(x,y)\n                    d_sq = (x - c_arr[0])**2 + (y - c_arr[1])**2\n                    if d_sq <= radius_sq:\n                        points.append(p)\n        else:\n            # Generic n-dim: recursively generate points, some overhead, but enough for supporting dimension n\n            from itertools import product\n            ranges = [range(start_idx[i], end_idx[i]+1) for i in range(self._dimension)]\n            for coords in product(*ranges):\n                d_sq = sum((coords[i] - c_arr[i])**2 for i in range(self._dimension))\n                if d_sq <= radius_sq:\n                    points.append(Point(*coords))\n        return points\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + dir_normalized * max_dist)\n        return Vertex(q_new_point)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        # Extract path from start to goal (goal_vertex) by following parents\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Assume single parent for tree structure\n            current = next(iter(current.parents))\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex], max_iterations: int = 50) -> List[Vertex]:\n        # Iterative shortcut smoothing on the path to remove unnecessary vertices\n        grid = self._get_grid()\n        if len(path) < 3:\n            return path  # Nothing to smooth\n\n        import random\n        path_positions = [v.position for v in path]\n        for _ in range(max_iterations):\n            if len(path_positions) < 3:\n                break\n            i = random.randint(0, len(path_positions) - 3)  # start index\n            j = random.randint(i+2, len(path_positions) - 1)  # end index, at least skip one vertex in between\n            seq = grid.get_line_sequence(path_positions[i], path_positions[j])\n            if grid.is_valid_line_sequence(seq):\n                # Remove intermediate vertices between i and j\n                del path_positions[i+1:j]\n        # Rebuild vertices from smoothed path positions:\n        smoothed_vertices = [Vertex(pos) for pos in path_positions]\n        # Setup parents edges:\n        for k in range(1, len(smoothed_vertices)):\n            smoothed_vertices[k].add_parent(smoothed_vertices[k - 1])\n            smoothed_vertices[k - 1].add_child(smoothed_vertices[k])\n            # Update cost as cumulative distance\n            segment_dist = torch.norm(smoothed_vertices[k].position.to_tensor() - smoothed_vertices[k - 1].position.to_tensor())\n            smoothed_vertices[k].cost = smoothed_vertices[k-1].cost + segment_dist if smoothed_vertices[k-1].cost is not None else segment_dist\n        if smoothed_vertices:\n            smoothed_vertices[0].cost = 0\n        return smoothed_vertices\n\n    def _move_agent_along_path(self, path: List[Vertex]) -> None:\n        # Animate and move agent along the path vertices positions\n        for v in path:\n            self.move_agent(v.position)\n            # For ROS compatibility if applicable\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp') and callable(getattr(grid, 'publish_wp')):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        max_time_sec = 10.0\n        start_time = time.time()\n\n        max_iterations = 8000\n        dimension = self._dimension\n\n        for i in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > max_time_sec:\n                # End search due to timeout without path found\n                return\n\n            # Sample point biased towards the goal (goal bias + uniform)\n            q_sample = self._get_random_sample_biased()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max extension based on local clearance\n            max_dist = self._adaptive_max_step(q_nearest.position)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Compute neighborhood radius for rewiring per RRT* formula\n            card_V = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            radius = min(self._lambda_rrt_star * ((torch.log(card_V) / card_V) ** (1/dimension)), self._max_radius)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose minimum cost parent in neighborhood for q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                line_quality = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost_through_near = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if line_quality and cost_through_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices if connecting through q_new shortens path\n            for q_near in Q_near:\n                line_quality = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if line_quality and cost_new_to_near < q_near.cost:\n                    # Remove old parent edge and add new\n                    old_parent = next(iter(q_near.parents))\n                    self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None  # Reset temporarily\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reached goal radius, then extract and smooth path\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_v = Vertex(grid.goal.get_position())\n                goal_v.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n                self._graph.add_edge(q_new, goal_v)\n\n                raw_path = self._extract_path(goal_v)\n                optimized_path = self._smooth_path(raw_path, max_iterations=70)\n                self._move_agent_along_path(optimized_path)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT*-inspired sample-based planner with goal biasing, adaptive step size,\n    rewiring for path cost optimization, heuristic-guided sampling, and path shortcutting.\n    It aims to improve planning efficiency by dynamically adjusting step length based on proximity to goal,\n    improving path quality through rewiring of nearby vertices to optimize cost, and robustness by biasing sampling\n    towards the goal with a progressive probability that increases during the run.\n    It also implements early stopping if a path is found and time exceeds 10 seconds to avoid infinite search.\n    The extracted path is shortcut for smoothness by attempting direct connections between non-adjacent waypoints.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable rewiring/removal of edges\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Adaptive step size: scale max_dist based on distance to goal and obstacle proximity\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        direction_normalized = dir_vec / dist\n        q_new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        q_new_pos = Point.from_tensor(q_new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias_prob: float) -> Point:\n        # Goal biased sampling: sample goal point with probability goal_bias_prob,\n        # otherwise sample random valid position in grid.\n        grid = self._get_grid()\n        if np.random.rand() < goal_bias_prob:\n            # sample goal position exactly\n            goal_pos = grid.goal.get_position()\n            if grid.is_agent_valid_pos(goal_pos):\n                return goal_pos\n        # else random valid sample\n        while True:\n            rand_pos_arr = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos_arr)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        # Compute cost from from_vertex to to_vertex with grid movement cost\n        grid = self._get_grid()\n        return grid.get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _total_cost(self, vertex: Vertex) -> float:\n        # Recursive cost to root (start)\n        if vertex == self._graph.root_vertex_start:\n            return 0.0\n        if len(vertex.parents) == 0:\n            return float('inf')  # not connected\n        # Choose minimal parent cost + edge cost\n        costs = []\n        for p in vertex.parents:\n            costs.append(self._total_cost(p) + self._cost(p, vertex))\n        return min(costs) if costs else float('inf')\n\n    def _rewire(self, q_new: Vertex, near_vertices: list, radius: float) -> None:\n        # Try to rewire each near vertex through q_new if path cost improves and line is clear\n        grid = self._get_grid()\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            potential_cost = self._total_cost(q_new) + self._cost(q_new, q_near)\n            current_cost = self._total_cost(q_near)\n            if potential_cost < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove old edges from parents to q_near\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    # Add new edge q_new -> q_near\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path back to start from goal vertex by parent links picking minimal-cost parent at each step\n        path_vertices = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break  # no connection\n            # Choose parent with minimum total cost from root\n            min_p = None\n            min_cost = float('inf')\n            for p in current.parents:\n                c = self._total_cost(p)\n                if c < min_cost:\n                    min_cost = c\n                    min_p = p\n            if min_p is None:\n                break\n            path_vertices.append(min_p)\n            current = min_p\n\n        path_vertices.reverse()  # start to goal order\n\n        path_points = [v.position for v in path_vertices]\n\n        # Shortcut path by attempting direct connections skipping intermediate points where possible\n        path_points = self._shortcut_path(path_points)\n\n        # Animate agent moving along path\n        for pos in path_points:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path_points: list) -> list:\n        # Attempt to shortcut path by skipping intermediate points if direct line between far points is valid\n        grid = self._get_grid()\n        if len(path_points) < 3:\n            return path_points\n\n        shortened_path = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            # Find farthest j > i where line is valid\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path_points[i], path_points[j])\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path_points[j])\n            i = j\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_dist_start = 10    # max distance when far from goal\n        max_dist_goal = 3      # max distance when close to goal (to fine tune\uff09\n        rewire_radius = 15.0   # radius for rewiring\n        max_iterations = 10000\n\n        grid = self._get_grid()\n        start_v = self._graph.root_vertex_start\n        goal_pos = grid.goal.get_position()\n        goal_reached_vertex = None\n\n        # Progressive goal bias probability starts low and increases linearly to 0.3\n        goal_bias_start = 0.05\n        goal_bias_end = 0.3\n\n        for iteration in range(1, max_iterations + 1):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:\n                # Timeout, fail pathfinding\n                break\n\n            # Linearly increase goal bias probability over iterations\n            goal_bias_prob = goal_bias_start + (goal_bias_end - goal_bias_start) * iteration / max_iterations\n\n            # Sample a point with goal bias\n            q_sample = self._get_random_sample(goal_bias_prob)\n\n            q_near = self._graph.get_nearest_vertex([start_v], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_goal = Map.get_distance(q_near.position, goal_pos)\n            max_dist = max_dist_goal if dist_to_goal < 20.0 else max_dist_start\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check collision for line from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Add edge q_near -> q_new\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire nearby vertices for cost optimization\n            near_vertices = self._get_near_vertices(q_new, rewire_radius)\n            self._rewire(q_new, near_vertices, rewire_radius)\n\n            # Check if goal can be connected directly from q_new\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_reached_vertex = goal_vertex\n                    break\n\n            # Check if q_new is within goal radius\n            if grid.is_agent_in_goal_radius(q_new.position):\n                goal_reached_vertex = q_new\n                break\n\n            self.key_frame()\n\n        if goal_reached_vertex is not None:\n            self._extract_path(goal_reached_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning Algorithm:\n    This algorithm improves upon basic RRT by integrating:\n    - Goal-biased sampling (with adaptive probability to sample the goal directly)\n    - Adaptive max step size, shrinking as it approaches the goal for precision\n    - Heuristic cost (distance-to-goal) to guide vertex rewiring for path optimization (similar to RRT*)\n    - Rewiring nearby vertices within a radius to shorten paths and smooth connectivity\n    - Early stopping if a valid path is found or 10 seconds have elapsed\n    - Path shortcutting on extraction to produce smoother, shorter final path\n    \n    The algorithm maintains a Forest graph structure and incrementally grows a tree from the start vertex.\n    At each iteration, a random sample is chosen with a bias towards the goal.\n    The nearest vertex is extended adaptively towards the sample, and new vertices may rewire neighbor vertices if it improves cost.\n    When the goal region is reached, path extraction attempts shortcuts to improve path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Allow edge rewiring\n        self._init_displays()\n\n    # Helper: Adaptive max step size based on distance to goal (smaller near goal for precision)\n    def _adaptive_max_dist(self, dist_to_goal: float) -> float:\n        max_step = 15.0\n        min_step = 3.0\n        threshold = 50.0\n        if dist_to_goal > threshold:\n            return max_step\n        else:\n            # Linearly shrink step size from max_step -> min_step as goal is approached\n            factor = dist_to_goal / threshold\n            return max(min_step, max_step * factor)\n\n    # Helper: Heuristic cost (distance to goal)\n    def _heuristic(self, pos: Point) -> float:\n        return self._get_grid().get_distance(pos, self._get_grid().goal.position)\n\n    # Helper: Find neighbors within a dynamic radius for rewiring (depends on vertices count)\n    def _get_neighbor_radius(self) -> float:\n        factor = 50.0  # Parameter to control neighbor radius\n        n = max(1, self._graph.size)\n        r = factor * (np.log(n) / n) ** 0.5\n        return min(r, 30.0)\n\n    # Helper: Construct path vertices starting from goal vertex back to start vertex\n    def _extract_and_shortcut_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        # Trace backwards from goal to root\n        while len(path[-1].parents) != 0:\n            # Since each vertex may have multiple parents, pick the one with minimum cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut path by attempting to connect non-adjacent nodes directly if possible\n        def can_connect_directly(p1: Point, p2: Point) -> bool:\n            line_seq = self._get_grid().get_line_sequence(p1, p2)\n            return self._get_grid().is_valid_line_sequence(line_seq)\n\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if can_connect_directly(path[i].position, path[j].position):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, just append next vertex\n                i += 1\n                shortcut_path.append(path[i])\n\n        # Animate the path\n        for vertex in shortcut_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Helper: Try rewiring neighbors to reduce cost by connecting through q_new\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                # Remove current parents edges connecting to q_neighbor\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                # Add new edge and update cost\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    # Modified helper: Get new vertex extended towards q_sample subject to max_dist, costs updated\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        q_new = Vertex(q_new_pos)\n        q_new.cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n        return q_new\n\n    def _get_random_sample(self) -> Point:\n        # With goal bias to sample goal directly with increasing probability over time\n        bias_prob = min(0.2 + 0.8 * (self._graph.size / 1000), 0.95)  # Increase bias as graph grows\n        if np.random.rand() < bias_prob:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    # Core path planning algorithm\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.perf_counter()\n\n        iterations_max = 10000\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(iterations_max):\n\n            # Enforce 10 seconds time limit\n            elapsed_time = time.perf_counter() - start_time\n            if elapsed_time > 10.0:\n                # Fail safe: no path found in allowed time\n                break\n\n            q_sample: Point = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_goal = self._heuristic(q_near.position)\n            max_dist = self._adaptive_max_dist(dist_to_goal)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within radius for rewiring, radius is dynamic based on graph size\n            neighbor_radius = self._get_neighbor_radius()\n            neighbors: list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, neighbor_radius)\n\n            # Choose best parent (lowest cost) from q_near and neighbors based on cost + distance\n            best_parent = q_near\n            best_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            for q_neighbor in neighbors:\n                if q_neighbor == q_near:\n                    continue\n                line_seq_to_neighbor = self._get_grid().get_line_sequence(q_neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_to_neighbor):\n                    continue\n                cost_through_neighbor = q_neighbor.cost + self._get_grid().get_distance(q_neighbor.position, q_new.position)\n                if cost_through_neighbor < best_cost:\n                    best_cost = cost_through_neighbor\n                    best_parent = q_neighbor\n\n            # Set cost and add edge from best parent\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if connecting through q_new improves cost\n            neighbors_except_new = [v for v in neighbors if v != q_new]\n            self._rewire_neighbors(q_new, neighbors_except_new)\n\n            # Check goal reaching\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex and connect\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                self._graph.add_edge(q_new, goal_vertex)\n\n                # Extract and shortcut path\n                self._extract_and_shortcut_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning algorithm improves over vanilla RRT by integrating the following innovations:\n    - Goal-biased sampling with adaptive probability to direct exploration progressively toward the goal.\n    - Dynamic step size (max_dist) that shrinks as the tree grows closer to the goal for finer path resolution.\n    - Incorporates a rewiring step inspired by RRT* to optimize the tree locally by reconnecting vertices within a radius to reduce cost.\n    - Heuristic cost-aware nearest neighbor search: considers both Euclidean distance and cost-to-come to select q_near.\n    - Early stopping if a path is found and no better solution is found after a timeout, capped overall by 10 seconds.\n    - Path smoothing after extraction using shortcutting by validating direct connections on path.\n    - Uses a cyclic graph to allow rewiring edges and supports multiple parents for better path quality.\n    This approach balances exploration and exploitation efficiently to improve success rate and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: CyclicGraph\n    _max_dist_initial: float\n    _timeout_sec: float\n    _rewire_radius: float\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._max_dist_initial = 15.0\n        self._timeout_sec = 10.0\n        self._rewire_radius = 20.0\n        self._goal_sample_rate = 0.2  # probability of sampling goal directly\n\n        # Use CyclicGraph to allow rewiring\n        from algorithms.classic.sample_based.core.graph import gen_forest, CyclicGraph\n        start_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = CyclicGraph(start_v, goal_v, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_sample_rate:\n            # Goal-bias sampling: sample goal position more often\n            return self._get_grid().goal.position\n        size = self._get_grid().size\n        while True:\n            rand_pos = np.random.randint(0, size, size.n_dim)\n            p = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Euclidean distance heuristic for guiding rewiring and nearest vertex costs\n        return self._get_grid().get_distance(frm, to)\n\n    def _nearest_vertex_cost_aware(self, vertices: list, p: Point) -> Vertex:\n        # Select vertex minimizing cost + heuristic distance to p, favors cheaper paths + proximity\n        min_score = float('inf')\n        best_vertex = None\n        for v in vertices:\n            cost_to_v = v.cost if v.cost is not None else 0.0\n            h = self._heuristic_cost(v.position, p)\n            score = cost_to_v + h\n            if score < min_score:\n                min_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_norm = dir_vec / norm\n        q_new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_norm)\n        return Vertex(q_new_pt, store_connectivity=True)\n\n    def _vertices_within_radius(self, center: Point, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, center, radius)\n\n    def _cost_to_vertex(self, vertex: Vertex) -> float:\n        return vertex.cost if vertex.cost is not None else 0.0\n\n    def _update_cost_and_parents(self, vertex: Vertex, new_parent: Vertex, new_cost: float) -> None:\n        # Remove old parents edges\n        for par in list(vertex.parents):\n            self._graph.remove_edge(par, vertex)\n        # Add new parent edge\n        self._graph.add_edge(new_parent, vertex)\n        vertex.cost = new_cost\n\n    def _try_rewire(self, q_new: Vertex, neighbors: list) -> None:\n        # Try rewiring neighbors to q_new if cost improves\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            # Cost if q_near connected through q_new\n            dist = self._get_grid().get_distance(q_new.position, q_near.position)\n            new_cost = q_new.cost + dist\n            if new_cost + 1e-6 < self._cost_to_vertex(q_near):  # Small epsilon tolerance\n                line = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    self._update_cost_and_parents(q_near, q_new, new_cost)\n\n    def _extract_path(self, q_goal_connected: Vertex):\n        # Backtrack from goal vertex following parent with min cost until start\n        path = [q_goal_connected]\n        current = q_goal_connected\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            # Among multiple parents pick one with minimal cost\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n        # Path smoothing by shortcutting\n        smoothed_path = [path[0]]\n        for i in range(1, len(path)):\n            for j in range(len(path)-1, i-1, -1):\n                line = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n            else:\n                smoothed_path.append(path[i])\n        # Animate the final path\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iter = 8000\n        max_dist = self._max_dist_initial\n        reached_goal_vertex = None\n\n        # Initialize cost for start vertex\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iter):\n            # Early timeout check\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_sec:\n                # fail early, no path found within time limit\n                break\n\n            # Adaptive max_dist reduces as tree approaches goal (heuristic)\n            dist_to_goal = self._get_grid().get_distance(self._graph.root_vertex_start.position, self._get_grid().goal.position)\n            max_dist = max(5.0, self._max_dist_initial * (dist_to_goal / self._get_grid().size.n_dim))\n\n            # Sample point with goal bias\n            q_sample = self._get_random_sample()\n\n            # Select nearest vertex by cost-aware heuristic\n            q_near = self._nearest_vertex_cost_aware(self._graph.root_vertices, q_sample)\n\n            # Skip if same point\n            if q_near.position == q_sample:\n                continue\n\n            # Generate new vertex\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate path from q_near to q_new\n            line_segment = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_segment):\n                continue\n\n            # Calculate cost to q_new\n            cost_to_new = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            q_new.cost = cost_to_new\n\n            # Add q_new to graph with edge from q_near\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire nearby vertices within radius to optimize paths\n            neighbors = self._vertices_within_radius(q_new.position, self._rewire_radius)\n            # Discard neighbors too far or invalid connections\n            neighbors = [v for v in neighbors if v != q_new]\n\n            # Try selecting a better parent among nearby vertices to connect q_new\n            better_parent = q_near\n            better_cost = cost_to_new\n            for v in neighbors:\n                dist = self._get_grid().get_distance(v.position, q_new.position)\n                tentative_cost = v.cost + dist\n                if tentative_cost + 1e-6 < better_cost:\n                    line_to_qnew = self._get_grid().get_line_sequence(v.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(line_to_qnew):\n                        better_parent = v\n                        better_cost = tentative_cost\n\n            if better_parent != q_near:\n                # Reconnect q_new's parent edge for better cost\n                self._graph.remove_edge(q_near, q_new)\n                self._graph.add_edge(better_parent, q_new)\n                q_new.cost = better_cost\n\n            # Rewire others through q_new if beneficial\n            self._try_rewire(q_new, neighbors)\n\n            # Check if goal is reached within radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex and connect from q_new if possible\n                goal_vertex = self._graph.root_vertex_goal\n\n                # Check path validity q_new->goal\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    cost_to_goal = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                    # Connect and update cost if better\n                    if goal_vertex.cost is None or cost_to_goal < goal_vertex.cost:\n                        # Remove old parents connecting goal vertex\n                        for p in list(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        self._graph.add_edge(q_new, goal_vertex)\n                        goal_vertex.cost = cost_to_goal\n\n                    reached_goal_vertex = goal_vertex\n                    # Early stopping criteria: if no improvement for ~1 sec or found goal, break\n                    if time.time() - start_time > 1.0:\n                        break\n\n            self.key_frame()\n\n        # If successful, extract and smooth path\n        if reached_goal_vertex is not None and reached_goal_vertex.cost is not None:\n            self._extract_path(reached_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm is inspired by RRT* with goal biasing and adaptive rewiring to enhance efficiency,\n    path quality, and robustness. It incorporates the following improvements over standard RRT:\n    - Goal-biased sampling to increase chances of quickly finding a path to goal\n    - Adaptive max distance based on distance to the goal to allow large steps far away and finer steps near goal\n    - Rewiring of nearby vertices to improve path quality (shorter cost paths)\n    - Early stopping if goal is reached\n    - Path smoothing via shortcutting after path extraction to ensure fewer redundant nodes and smoother paths\n    - Timeout to stop search if exceeded 10 seconds (treat as failure)",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Reuse graph initialization as in RRT\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Allow edge rewiring for RRT*\n        self._init_displays()\n\n    # Helper function: Goal biased sampling: with p_goal prob return goal position to bias towards goal\n    def _get_goal_biased_sample(self, p_goal: float = 0.2) -> Point:\n        import random\n        if random.random() < p_goal:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    # Helper function: Adaptive max step distance based on distance to goal, between min_step and max_step\n    def _adaptive_max_dist(self, from_point: Point, min_step: float = 3.0, max_step: float = 12.0) -> float:\n        dist_to_goal = self._get_grid().get_distance(from_point, self._get_grid().goal.position)\n        # Linearly decay step size closer to goal\n        step = min_step + (max_step - min_step) * (dist_to_goal / max(dist_to_goal, max_step))\n        if step > max_step:\n            step = max_step\n        if step < min_step:\n            step = min_step\n        return step\n\n    # Helper function: Rewire nearby vertices within radius around q_new to improve paths (RRT* style)\n    def _rewire(self, q_new: Vertex, radius: float):\n        nearby_vertices: List[Vertex] = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        for q_nearby in nearby_vertices:\n            if q_nearby == q_new:\n                continue\n            # Check if path from q_new to q_nearby is valid and if rewiring reduces cost\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_nearby.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_nearby.position)\n            if new_cost < q_nearby.cost:\n                # Remove old parent edge(s) for simplicity and rewire to q_new\n                for p in list(q_nearby.parents):\n                    self._graph.remove_edge(p, q_nearby)\n                self._graph.add_edge(q_new, q_nearby)\n                q_nearby.cost = new_cost\n\n    # Helper function: Smooth path by shortcutting where possible\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) <= 2:\n            return path\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, just add next point\n                smoothed_path.append(path[i+1])\n                i += 1\n        return smoothed_path\n\n    # Overridden Implementation #\n    # --------------------------#\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 5000  # reduce iterations with goal bias and rewiring\n        timeout_seconds: float = 10.0\n        start_time = time.time()\n\n        # Initialize root start cost and goal cost\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n\n        for iteration in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > timeout_seconds:\n                # Timeout reached, stop search\n                break\n\n            # Goal biased sample\n            q_sample: Point = self._get_goal_biased_sample(p_goal=0.2)\n\n            # Find nearest vertex in graph to sample\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            # If sample coincides with nearest vertex, skip\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size depending on distance to goal\n            max_dist: float = self._adaptive_max_dist(q_near.position)\n\n            # Compute new vertex in direction of q_sample from q_near with step max_dist\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check valid path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue  # invalid edge, skip\n\n            # Compute cost of traveling from q_near to q_new\n            travel_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            new_cost = q_near.cost + travel_cost\n\n            # If q_new already exists near with better cost, skip adding duplicate - but here we add anyway (no duplicates typically since sampling is dense)\n            # Add new vertex to graph\n            q_new.cost = new_cost\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewiring nearby vertices to optimize cost paths\n            rewire_radius = max_dist * 2.5\n            self._rewire(q_new, rewire_radius)\n\n            # Check if goal reached by proximity to q_new\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex to q_new with edge if line is valid\n                goal_v = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    cost_to_goal = self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n                    goal_cost = q_new.cost + cost_to_goal\n                    # If this new path is better, update\n                    if goal_cost < goal_v.cost:\n                        # Remove old incoming edges to goal to force new parent connection\n                        for p in list(goal_v.parents):\n                            self._graph.remove_edge(p, goal_v)\n                        goal_v.cost = goal_cost\n                        self._graph.add_edge(q_new, goal_v)\n\n                # Extract Path from start to goal by parents traversal\n                path: List[Vertex] = [goal_v]\n                while len(path[-1].parents) != 0:\n                    parent = next(iter(path[-1].parents))\n                    path.append(parent)\n                path.reverse()  # start->goal order\n\n                # Smooth path by shortcutting\n                smoothed_path = self._smooth_path(path)\n\n                # Animate and move agent along smoothed path\n                for vertex in smoothed_path:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n\n                # Finish early on success\n                break\n\n            # Update animation key frame every iteration\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired path planning approach with:\n    - Goal-biased sampling to increase chances to quickly expand towards the goal.\n    - Adaptive max_dist that shrinks when close to goal for finer adjustments.\n    - Rewiring step for local path cost optimization (like RRT*) to improve path quality.\n    - Early stopping on success or timeout (10 seconds).\n    - Shortcut smoothing in path extraction to provide shorter, smoother paths.\n    - Uses cost heuristics to pick better parents during vertex addition.\n    \n    These enhancements collectively improve efficiency (fewer iterations), \n    path quality (shorter/smoother), robustness (higher success rate), and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring with edge removal\n        self._init_displays()\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Get vertices near q_new within radius for rewiring.\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose parent vertex that minimizes cost to q_new and valid edge\n        min_cost = float('inf')\n        min_vertex = None\n        for q_near in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                min_vertex = q_near\n        return min_vertex\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire near vertices to minimize their cost by connecting to q_new if cheaper\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Remove old parent edges and add edge from q_new\n                old_parents = list(q_near.parents)\n                for p in old_parents:\n                    self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut path smoothing by removing unnecessary vertices along direct valid lines\n        if len(path) <= 2:\n            return path\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while len(current.parents) > 0:\n            # Select parent with the minimum cost\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost < min_cost:\n                    min_parent = p\n                    min_cost = p.cost\n            if not min_parent:\n                break\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n        path = self._shortcut_path(path)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self, goal_bias_rate: float = 0.1) -> Point:\n        # Goal biased random sampling\n        if np.random.rand() < goal_bias_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _find_path_internal(self) -> None:\n        max_iter = 10000\n        base_max_dist = 10.0\n        search_start_time = time.time()\n\n        start_v: Vertex = self._graph.root_vertex_start\n        start_v.cost = 0.0\n        goal_pos = self._get_grid().goal.position\n\n        for i in range(max_iter):\n            # Stop if > 10 seconds\n            if time.time() - search_start_time > 10:\n                # Fail gracefully if timeout\n                break\n\n            # Adaptive max_dist: reduce if close to goal for finer steps\n            dist_to_goal = Map.get_distance(start_v.position, goal_pos)\n            max_dist = base_max_dist\n            if dist_to_goal < 3 * base_max_dist:\n                max_dist = max(base_max_dist * 0.2, dist_to_goal * 0.5)\n\n            q_sample: Point = self._get_random_sample(goal_bias_rate=0.15)  # 15% bias toward goal\n\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Generate new vertex in direction of q_sample from q_near\n            dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n            dir_norm = torch.norm(dir_tensor)\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n            if not self._get_grid().is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq_to_new = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq_to_new):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            q_new.cost = float('inf')  # Temporarily set high cost\n\n            # Choose best parent from nearby vertices within radius for RRT* behavior\n            radius = max_dist * 1.5\n            near_vertices = self._get_near_vertices(q_new, radius)\n            parent_vertex = self._choose_parent(near_vertices, q_new)\n            if parent_vertex is None:\n                # Fallback: connect to q_near if no better parent found\n                parent_vertex = q_near\n                # Check connectivity again to be safe\n                line_seq = self._get_grid().get_line_sequence(parent_vertex.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n            q_new.cost = parent_vertex.cost + self._get_grid().get_distance(parent_vertex.position, q_new.position)\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire nearby vertices if we found a lower cost path through q_new\n            self._rewire(near_vertices, q_new)\n\n            # Check if goal reached or within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex if path valid\n                goal_v = self._graph.root_vertex_goal\n                line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                    goal_v.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_v.position)\n                    self._graph.add_edge(q_new, goal_v)\n                    self._extract_path(goal_v)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an enhanced RRT* inspired path planner with several improvements:\n    - Goal-biased sampling: With a small probability, samples directly the goal position to speed convergence.\n    - Adaptive max step distance: Dynamically adjusted based on progress and environment to balance exploration and precision.\n    - Rewiring: Connects new vertices to existing vertices within radius to find lower-cost paths and improve path quality.\n    - Early stopping with time limit: Stops planning if it exceeds 10 seconds to avoid excessive computation time.\n    - Shortcut smoothing of final path: Removes unnecessary intermediate vertices in extracted path.\n    - Use of cost heuristics to select parent vertices during rewiring.\n    The combination of these techniques leads to shorter, smoother paths, reduced iterations, and higher success rates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_min: float\n    _max_dist_max: float\n    _goal_sample_rate: float  # probability to sample goal directly\n    _rewire_radius: float\n    _time_limit_sec: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow rewiring (removal & adding edges)\n        self._init_displays()\n\n        self._max_dist_min = 5.0\n        self._max_dist_max = 15.0\n        self._goal_sample_rate = 0.1\n        self._rewire_radius = 20.0\n        self._time_limit_sec = 10.0\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Goal-biased random sampling.\"\"\"\n        grid = self._get_grid()\n        if random.random() < self._goal_sample_rate:\n            return grid.goal.position\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_parent(self, vertex_candidates: List[Vertex], q_new_pos: Point, q_near: Vertex) -> Vertex:\n        \"\"\"\n        Choose parent among vertex_candidates that yields minimum cost path to q_new.\n        Fall back to q_near if no better cost found.\n        \"\"\"\n        grid = self._get_grid()\n        min_cost = q_near.cost + grid.get_movement_cost(q_near.position, q_new_pos)\n        parent = q_near\n        for vc in vertex_candidates:\n            line_seq = grid.get_line_sequence(vc.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_vc = vc.cost + grid.get_movement_cost(vc.position, q_new_pos)\n            if cost_through_vc < min_cost:\n                min_cost = cost_through_vc\n                parent = vc\n        return parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"Try to connect near vertices to q_new for lower cost paths.\"\"\"\n        grid = self._get_grid()\n        for near_v in near_vertices:\n            if near_v == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, near_v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + grid.get_movement_cost(q_new.position, near_v.position)\n            if cost_through_qnew < near_v.cost:\n                # Rewire: change parent of near_v to q_new\n                # Remove old edges (parents to near_v)\n                for p in list(near_v.parents):\n                    self._graph.remove_edge(p, near_v)\n                self._graph.add_edge(q_new, near_v)\n                near_v.cost = cost_through_qnew\n\n    def _shorten_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Shortcut smoothing by removing unnecessary intermediate vertices.\"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n        shortened = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Try to jump over intermediate vertices from current idx to next_idx\n            while next_idx > idx + 1:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(path[idx].position, path[next_idx].position)):\n                    break\n                next_idx -= 1\n            shortened.append(path[next_idx])\n            idx = next_idx\n        return shortened\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"Extract the path from start to goal with optional shortcut smoothing.\"\"\"\n        grid = self._get_grid()\n        path: List[Vertex] = []\n\n        # Trace back parents from q_new to root_vertex_start\n        current_v = q_new\n        while True:\n            path.append(current_v)\n            if len(current_v.parents) == 0:\n                break\n            # Since parents may have multiple, pick lowest cost parent\n            current_v = min(current_v.parents, key=lambda v: v.cost)\n\n        path.reverse()\n\n        # Shortcut smoothing of the extracted path\n        path = self._shorten_path(path)\n\n        # Animate the agent movement along path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_max_dist(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"\n        Adaptive step size: starts larger and reduces as iterations progress,\n        allowing initial rapid exploration then finer refinement closer to goal.\n        \"\"\"\n        progress = iteration / max_iterations\n        return self._max_dist_max - (self._max_dist_max - self._max_dist_min) * progress\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_time = time.time()\n\n        max_iterations = 5000\n\n        # Initialize start vertex cost to zero\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')  # No cost assigned yet\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > self._time_limit_sec:\n                # Timeout: stop search without path\n                break\n\n            max_dist = self._adaptive_max_dist(iteration, max_iterations)\n\n            q_sample: Point = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find vertices within rewiring radius around q_new for parent selection and rewiring\n            near_vertices: List[Vertex] = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, self._rewire_radius\n            )\n\n            if len(near_vertices) == 0:\n                near_vertices = [q_near]\n\n            parent: Vertex = self._choose_parent(near_vertices, q_new.position, q_near)\n            # Set cost for q_new\n            parent_to_new_cost = parent.cost + grid.get_movement_cost(parent.position, q_new.position)\n            q_new.cost = parent_to_new_cost\n\n            self._graph.add_edge(parent, q_new)\n\n            # Attempt rewiring to improve path cost of nearby vertices\n            self._rewire(q_new, near_vertices)\n\n            # Check if goal is reached by q_new vertex (in goal radius)\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex\n                goal_v = self._graph.root_vertex_goal\n                # Check line valid from q_new to goal before adding\n                line_seq_goal = grid.get_line_sequence(q_new.position, goal_v.position)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    goal_cost_candidate = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n                    # Only add edge and update goal cost if better path found\n                    if goal_cost_candidate < goal_v.cost:\n                        if goal_v.parents:\n                            # Remove old edges to goal_v (rewiring)\n                            for p in list(goal_v.parents):\n                                self._graph.remove_edge(p, goal_v)\n                        self._graph.add_edge(q_new, goal_v)\n                        goal_v.cost = goal_cost_candidate\n\n                    # Extract and animate path\n                    self._extract_path(goal_v)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* inspired path planner designed to efficiently find high-quality paths\n    on a grid environment. It introduces:\n    - Goal-biased sampling to steer growth towards the goal, increasing success likelihood;\n    - Adaptive step size to allow finer exploration near obstacles and larger steps in free spaces;\n    - RRT* style rewiring for path optimality by locally checking and updating parent connections of nearby vertices;\n    - Early stopping if goal is reached or if planning time exceeds 10 seconds;\n    - Shortcut smoothing before final path trace to reduce unnecessary waypoints;\n    - Uses existing helper functions for sampling, edge validation, and grid queries;\n    The approach balances exploration and exploitation, improving planning efficiency, success rate,\n    and resulting path optimality compared to baseline RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Enable edge removals for rewiring\n        self._init_displays()\n\n        # Added parameters for adaptive step size and goal bias\n        self.goal_bias = 0.2          # Probability to sample goal directly\n        self.max_dist_min = 3         # Minimum extension step size\n        self.max_dist_max = 10        # Maximum extension step size\n        self.rewire_radius = 15       # Neighbor radius for rewiring\n\n    # Reuse existing helper, override get_random_sample to include goal bias sampling\n    def _get_random_sample(self) -> Point:\n        if np.random.random() < self.goal_bias:\n            # Sample goal position directly to bias exploration\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_adaptive_max_dist(self, vertex: Vertex) -> float:\n        # Rough heuristic: smaller step near obstacles, larger step in free areas using grid check around position\n        # Check neighbors within radius 3 if many obstacles nearby -> reduce step size\n        neighbors = self._get_grid().get_next_positions(vertex.position)\n        obstacle_count = 0\n        for n in neighbors:\n            if not self._get_grid().is_agent_valid_pos(n):\n                obstacle_count += 1\n        # Map obstacle count to step size between min and max dist:\n        ratio = obstacle_count / len(neighbors) if neighbors else 0\n        max_dist = self.max_dist_max - (self.max_dist_max - self.max_dist_min) * ratio\n        return max_dist\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        # Extract path back from q_last to start by following parents\n        path: List[Vertex] = [q_last]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        path.reverse()\n\n        # Shortcut smoothing: attempt to skip intermediate waypoints by validating direct line segments\n        smoothed_path: List[Vertex] = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        # Animate trace along smoothed path\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iter: int = 10000\n        start_time = time()\n\n        for i in range(max_iter):\n            if time() - start_time > 10.0:\n                # Abort search after 10 seconds\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._get_adaptive_max_dist(q_near)\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_vec)\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dist\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new_pos)):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Initialize cost for cost-based rewiring: cost from start to q_new\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new_pos)\n            q_new.cost = q_near.cost + move_cost\n\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire nearby vertices for better path quality\n            neighbors = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new_pos, self.rewire_radius\n            )\n            for q_near_rewire in neighbors:\n                if q_near_rewire == q_near or q_near_rewire == q_new:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new_pos, q_near_rewire.position)):\n                    continue\n                new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new_pos, q_near_rewire.position)\n                if new_cost < q_near_rewire.cost:\n                    # Rewire to new lower cost connection\n                    # Remove old edges from current parents\n                    for parent in list(q_near_rewire.parents):\n                        self._graph.remove_edge(parent, q_near_rewire)\n                    self._graph.add_edge(q_new, q_near_rewire)\n                    q_near_rewire.cost = new_cost\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new_pos):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Sample-Based Path Planning Algorithm inspired by RRT*:\n    - Uses goal-biased sampling to accelerate convergence towards the goal.\n    - Implements adaptive step size based on distance to sampled point.\n    - Incorporates rewiring (RRT* style) to optimize path costs on the fly.\n    - Uses heuristic cost (path cost + distance to goal) to select parent vertex.\n    - Performs path shortcutting after path extraction for smoother final path.\n    - Includes early stopping criterion after 10 seconds to avoid infinite search.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # Need removable edges for rewiring\n        self._init_displays()\n        self._max_dist_base = 10.0\n        self._goal_sample_rate = 0.2  # 20% goal bias sampling\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n    \n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Goal-biased random sample:\n        With probability goal_sample_rate sample exactly the goal,\n        otherwise sample uniformly random valid point.\n        \"\"\"\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"\n        Chooses the best parent among neighbors for q_new minimizing cost + distance to q_new,\n        ensuring path lines are valid.\n        \"\"\"\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            line_seq = grid.get_line_sequence(neighbor.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to update cost and parents of neighbor vertices via q_new if it improves their cost.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove old edges from parents of neighbor to neighbor\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal vertex by following parents.\n        After extraction, perform path shortcutting for smoothness.\n        \"\"\"\n        path: List[Vertex] = []\n        v = q_goal\n        while True:\n            path.append(v)\n            if len(v.parents) == 0:\n                break\n            # Prefer parent with lowest cost (usually 1 parent in tree)\n            v = min(v.parents, key=lambda p: p.cost)\n        path.reverse()\n\n        # Path shortcutting: try to connect non-adjacent vertices directly where possible\n        grid = self._get_grid()\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(shortcut_path[-1].position, path[j].position)):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n\n        # Animate movement along shortcut path\n        for vertex in shortcut_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_total_time_sec = 10.0\n        start_time = time.time()\n        max_iterations = 10000\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        # Initialize cost for start vertex\n        start_vertex.cost = 0.0\n\n        for iter_count in range(max_iterations):\n            if time.time() - start_time > max_total_time_sec:\n                # Timeout: path not found within time limit\n                break\n\n            q_sample = self._get_random_sample()       # Goal-biased sampling\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adapt step size based on distance to sample (clamp between 1 and max_dist_base)\n            dist_to_sample = grid.get_distance(q_near.position, q_sample)\n            max_dist = min(max(1.0, dist_to_sample), self._max_dist_base)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check if path from nearest vertex to q_new is valid\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within radius for rewiring\n            radius = max_dist * 2.0\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n            if not neighbors:\n                neighbors = [q_near]\n\n            # Choose best parent among neighbors\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                continue\n\n            # Add q_new with chosen parent and update cost\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = best_parent.cost + grid.get_distance(best_parent.position, q_new.position)\n\n            # Rewire around q_new to improve paths of neighbors\n            self._rewire(q_new, neighbors)\n\n            # Add q_new vertex to root vertices so next gets nearest from expanded graph\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new reached goal region\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex explicitly\n                goal_vertex = self._graph.root_vertex_goal\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_vertex.position)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm combining RRT* strategies with goal-biased sampling and adaptive step size.\n    This algorithm enhances planning efficiency and path quality by:\n    - Using goal bias (sampling towards goal with a probability) to improve convergence speed.\n    - Applying RRT*-style rewiring to optimize paths and reduce overall cost.\n    - Dynamically adapting the step size (max_dist) based on progress.\n    - Shortcutting and smoothing the extracted path for path quality.\n    - Early stopping if path found or if search exceeds 10 seconds.\n    - Robust nearest neighbor search that considers cost-to-come for rewiring.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_init: float\n    _goal_sample_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable removable edges for rewiring\n        self._max_dist_init = 10.0\n        self._goal_sample_rate = 0.1  # 10% of samples biased towards goal\n        self._rewire_radius = 15.0  # Radius for rewiring\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        rnd = np.random.random()\n        if rnd < self._goal_sample_rate:\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n        while True:\n            rand_pos_np = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos_np)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"Calculate cost ensuring validity of path.\"\"\"\n        line_seq = self._get_grid().get_line_sequence(frm.position, to.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return float(\"inf\")\n        return frm.cost + self._get_grid().get_distance(frm.position, to.position)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"Choose best parent with lowest cost for q_new among q_near_list.\"\"\"\n        min_cost = float(\"inf\")\n        best_parent = None\n        for q_near in q_near_list:\n            c = self._cost(q_near, q_new)\n            if c < min_cost:\n                min_cost = c\n                best_parent = q_near\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: List[Vertex]) -> None:\n        \"\"\"Try to rewire neighbors to q_new to lower their cost.\"\"\"\n        for q_near in q_near_list:\n            if q_near == q_new.parents or not q_new or not q_near:\n                continue\n            new_cost = self._cost(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Check path validity before rewiring\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edges from all parents of q_near to itself\n                    for p in set(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex):\n        \"\"\"Extract a smoothed path from start to goal and move the agent.\"\"\"\n\n        # Backtrack from goal to start\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # Pick parent with min cost (there should be only one parent typically)\n            current = min(current.parents, key=lambda p: p.cost)\n            path.append(current)\n        path.reverse()\n\n        # Shortcut smoothing\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        # Animate path tracing\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_time_seconds = 10.0\n        max_dist = self._max_dist_init\n        iterations = 10000\n\n        start_time = time()\n\n        # Initialize root vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n            if time() - start_time > max_time_seconds:\n                # Time exceeded, no path found\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate edge from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find nearby vertices for rewiring\n            q_near_list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._rewire_radius)\n            if q_near not in q_near_list:\n                q_near_list.append(q_near)\n\n            # Choose the best parent among neighbors\n            best_parent = self._choose_parent(q_near_list, q_new)\n            if best_parent is None:\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through the new vertex for path improvement\n            self._rewire(q_new, q_near_list)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect the goal vertex properly to current tree\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_cost = self._cost(q_new, goal_vertex)\n                    if goal_cost < goal_vertex.cost or goal_vertex.cost == 0:\n                        # Remove old edges to goal if any\n                        for p in set(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        goal_vertex.cost = goal_cost\n                        self._graph.add_edge(q_new, goal_vertex)\n\n                    self._extract_path(goal_vertex)\n                    break\n\n            # Adaptively decrease max_dist to refine search near solution\n            if i % 100 == 0 and i > 0:\n                max_dist = max(self._max_dist_init * (1 - (i / iterations)), 2.0)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired Path Planning algorithm with:\n      - Goal biased sampling (20% samples directly towards goal).\n      - Adaptive max_dist that decreases as iterations increase for fine tuning.\n      - Rewiring step to improve path quality by reconnecting vertices within radius.\n      - Early stopping criteria based on time limit (10 seconds) for robustness.\n      - Path smoothing shortcut attempt after path extraction.\n      \n    This leads to faster convergence, shorter and smoother paths, and better success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable rewiring/removal of edges\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist < 1e-6:\n            return None\n        if dist <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        # Check if resulting position is valid\n        if not self._get_grid().is_agent_valid_pos(q_new_pos):\n            return None\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias: float = 0.2) -> Point:\n        # Sample towards goal with probability goal_bias\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_parent(self, q_new: Vertex, neighborhood: List[Vertex]) -> Vertex:\n        # Choose parent with minimal cost + distance to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for vertex in neighborhood:\n            line_seq = self._get_grid().get_line_sequence(vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = vertex.cost + self._get_grid().get_distance(vertex.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        if best_parent is None:\n            # If no valid parent found, fallback to nearest vertex\n            best_parent = neighborhood[0] if neighborhood else None\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighborhood: List[Vertex]) -> None:\n        for vertex in neighborhood:\n            if vertex == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, vertex.position)\n            if new_cost < vertex.cost:\n                # Rewire\n                # Remove old parents edges (assuming forest, so single parent)\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> List[Vertex]:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while len(current.parents) != 0:\n            for p in current.parents:\n                path.append(p)\n                current = p\n                break\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_iterations = 10000\n        base_max_dist = 15.0\n        radius_factor = 30.0  # radius for neighborhood search in rewiring\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Stop search if it takes more than 10 seconds\n                break\n\n            # Adaptive max_dist shrinks as iterations increase\n            max_dist = max(3.0, base_max_dist * (1.0 - iteration / max_iterations))\n\n            q_sample = self._get_random_sample(goal_bias=0.2)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Get neighbors within radius for RRT* rewiring and parent selection\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius_factor)\n            if len(neighbors) == 0:\n                # Fallback to just q_near if no neighbors\n                neighbors = [q_near]\n\n            # Choose best parent from neighbors\n            best_parent = self._choose_parent(q_new, neighbors)\n            if best_parent is None:\n                continue\n\n            # Assign cost for q_new and add edge from best_parent\n            q_new.cost = best_parent.cost + self._get_grid().get_distance(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices attempting to reduce path cost\n            self._rewire(q_new, neighbors)\n\n            # Check if goal reached or within radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                q_goal = Vertex(self._get_grid().goal.position)\n                q_goal.cost = float('inf')  # will be updated\n                # Connect goal with the closest vertex\n                dist_to_q_new = self._get_grid().get_distance(q_new.position, q_goal.position)\n                line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                    q_goal.cost = q_new.cost + dist_to_q_new\n                    self._graph.add_edge(q_new, q_goal)\n\n                    # Extract the path from start to goal\n                    path = self._extract_path(q_goal)\n                    smoothed_path = self._shortcut_path(path)\n\n                    # Animate moving agent along the smoothed path\n                    for vertex in smoothed_path:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is an improved RRT* inspired algorithm for grid-based path planning.\n      It uses goal-biased sampling to guide exploration towards the goal,\n      rewiring to optimize path length and smoothness, adaptive max step distance,\n      and shortcut-based path smoothing. Early stopping is enforced via a 10-second timeout\n      to enhance efficiency. The rewiring step attempts to improve the tree connectivity and cost,\n      while the shortcutting step attempts to simplify the found path by removing unnecessary vertices.\n      These measures enable improved path quality, planning efficiency, robustness, and success rate\n      compared to classical RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self) -> float:\n        # Use map diagonal / 10 as max step length, but limit minimally and maximally\n        grid_size = self._get_grid().size\n        diag = (sum(d**2 for d in grid_size)) ** 0.5\n        max_dist = diag / 15  # slightly smaller than diag/10 for finer steps\n        max_dist = max(3.0, min(max_dist, 15.0))\n        return max_dist\n\n    def _get_goal_biased_sample(self, goal_bias: float = 0.15) -> Point:\n        # With probability goal_bias, return the goal position\n        if np.random.rand() < goal_bias:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _get_parent_with_min_cost(self, near_vertices: List[Vertex], new_vertex_pos: Point) -> Optional[Vertex]:\n        # Select the parent in near_vertices that yields the minimal cost path to new vertex\n        best_parent = None\n        best_cost = float('inf')\n        for vertex in near_vertices:\n            line = self._get_grid().get_line_sequence(vertex.position, new_vertex_pos)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            cost = vertex.cost + self._get_grid().get_movement_cost(vertex.position, new_vertex_pos)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire_near_vertices(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # Try to rewire near vertices through q_new for better cost\n        for vertex in near_vertices:\n            if vertex == q_new.parents or vertex == q_new:\n                continue\n            line = self._get_grid().get_line_sequence(q_new.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, vertex.position)\n            if new_cost < vertex.cost:\n                # Remove old edges from parents to vertex\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n                # Add edge from q_new to vertex\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by removing unnecessary intermediate vertices if direct connection valid\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, just add next vertex\n                shortcut_path.append(path[i + 1])\n                i += 1\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract path via parents up to start, then shortcut and move agent with animations\n        path: List[Vertex] = [q_new]\n        current = q_new\n        while len(current.parents) != 0:\n            # pick the parent with minimal cost (usually only one in tree)\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut path for smoothness\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = self._get_adaptive_max_dist()\n        iterations = 10000\n        radius = max_dist * 2.5  # Radius for near vertices rewiring\n        start_time = time()\n\n        for i in range(iterations):\n            # Early stop if >10 seconds elapsed\n            if time() - start_time > 10:\n                break\n\n            q_sample = self._get_goal_biased_sample(goal_bias=0.15)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices within radius of q_new.position for rewiring and picking parent\n            near_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Find the best parent with minimal cost path to q_new.position\n            parent_vertex = self._get_parent_with_min_cost(near_vertices, q_new.position)\n            if parent_vertex is None:\n                continue  # No valid parent found, skip\n\n            # Set cost and add edge\n            q_new.cost = parent_vertex.cost + self._get_grid().get_movement_cost(parent_vertex.position, q_new.position)\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire near vertices if better path through q_new found\n            self._rewire_near_vertices(q_new, near_vertices)\n\n            # Check if goal reached or in radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect explicitly to goal vertex\n                goal_vertex = self._graph.root_vertex_goal\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = cost_to_goal\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm inspired by RRT*, implementing goal-biased sampling,\n    adaptive step size, rewiring for path optimality, and path shortcut smoothing.\n    The algorithm biases sampling towards the goal to improve convergence speed,\n    adapts step size based on distance to sample points to balance exploration and\n    refinement, and rewires the local neighborhood to improve path quality for shorter\n    and smoother paths. It also includes a post-processing shortcut step to smooth the final path.\n    Early stopping is activated after 10 seconds or once goal is reached to improve efficiency and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        \n        self._max_dist_base = 10.0\n        self._goal_sample_rate = 0.1   # 10% samples biased towards goal\n        self._rewire_radius = 15.0\n        \n        self._graph = gen_forest(\n            self._services, \n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True  # Allow edge rewiring/removal\n        \n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling: with probability self._goal_sample_rate, sample goal position\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        # Radius for rewire depends on number of vertices (as in RRT*), simplified here with fixed radius\n        near_verts = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n        return near_verts\n\n    def _get_cost(self, q_from: Vertex, q_to: Vertex) -> float:\n        # Cost from one vertex to another based on movement cost plus parent's cost\n        move_cost = self._get_grid().get_movement_cost(q_from.position, q_to.position)\n        return q_from.cost + move_cost\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose the best parent from near vertices to minimize cost with valid edges\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = self._get_cost(q_near, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        if best_parent is None:\n            # Fallback: connect to nearest vertex ignoring rewiring if no near vertex is valid\n            return None\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # For each near vertex, try to connect via q_new if it improves cost\n        for q_near in near_vertices:\n            if q_near == q_new.parents or q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = self._get_cost(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Remove old edge(s) to q_near's parents\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge from q_new to q_near\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_goal_parent: Vertex) -> None:\n        path: List[Vertex] = []\n        v = Vertex(self._get_grid().goal.position)  # Goal vertex\n        v.cost = 0\n        path.append(v)\n        current = q_goal_parent\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose parent with minimal cost (in case of multiple)\n            min_parent = None\n            min_cost = float('inf')\n            for parent in current.parents:\n                if parent.cost < min_cost:\n                    min_parent = parent\n                    min_cost = parent.cost\n            current = min_parent\n        path.reverse()\n\n        # Smooth path shortcutting: try to replace segments with direct paths if valid\n        smooth_path = [path[0]]\n        for i in range(1, len(path)):\n            prev = smooth_path[-1]\n            # Try to connect directly to path[i]\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(prev.position, path[i].position)):\n                # Skip intermediate points\n                pass\n            else:\n                smooth_path.append(path[i-1])\n        if smooth_path[-1] != path[-1]:\n            smooth_path.append(path[-1])\n\n        # Move agent along the smoothed path and key frame animation\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_iterations = 10000\n        \n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iter in range(max_iterations):\n            elapsed_time = time() - start_time\n            if elapsed_time > 10.0:  # Timeout after 10 seconds\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            # Adaptive max_dist: smaller step when near goal to refine path, larger otherwise\n            max_step = min(self._max_dist_base, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            near_vertices = self._get_near_vertices(q_new)\n\n            # Choose best parent among near vertices including q_near itself\n            all_near_vertices = near_vertices + [q_near]\n            best_parent = self._choose_parent(all_near_vertices, q_new)\n            if best_parent is None:\n                # If no valid parent from near vertices, add q_near as parent if valid line sequence\n                q_new.cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n                best_parent = q_near\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire the tree around q_new\n            self._rewire(q_new, near_vertices)\n\n            # Check if q_new within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()\n\n        # If search fails or timeout, no path found - no explicit handling required here\n        # Agent stays at start position implicitly\n        return",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning implements an improved RRT*-inspired algorithm combining goal-biased sampling, adaptive step size, \n    and rewiring for path quality optimization. Key features: \n    - Goal bias in sampling increases connection attempts toward goal, improving efficiency and success rate. \n    - Adaptive max_dist reduces with iterations to refine path locally and smoothness.\n    - RRT* style rewiring connects new vertex to minimal cost parent and rewires nearby vertices to reduce cost, \n      improving path quality and smoothness.\n    - Shortcut smoothing is applied in path extraction to remove unnecessary waypoints.\n    - Search halts if path is found or total planning time exceeds 10 seconds.\n    This approach improves planning efficiency, path quality, robustness, and success rate compared to basic RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring (removable edges for RRT*)\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias: float) -> Point:\n        # Goal biased random sampling with probability goal_bias to sample the goal position.\n        if np.random.rand() < goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                random_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*random_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _choose_parent(self, q_near: Vertex, q_new: Vertex, radius: float) -> Vertex:\n        # Find parent with minimum cost + edge cost within radius for rewiring (RRT*)\n        neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        min_cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n        best_parent = q_near\n        for neighbor in neighbors:\n            if neighbor == q_near:\n                continue\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_neighbor = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n            if cost_through_neighbor < min_cost:\n                min_cost = cost_through_neighbor\n                best_parent = neighbor\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, radius: float) -> None:\n        # Rewire nearby vertices to pass through q_new if reduces cost\n        neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        for neighbor in neighbors:\n            if neighbor == q_new or neighbor == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove old edge(s) from parents of neighbor and add new edge from q_new to neighbor\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut path by trying to connect non-adjacent vertices directly if line is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            # Try to find the farthest vertex we can connect directly\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        # Walk parents back to start\n        current_vertex = q_goal\n        while current_vertex != self._graph.root_vertex_start and current_vertex.parents:\n            # Among multiple parents (if any), take one with lowest cost\n            min_parent = None\n            min_cost = float('inf')\n            for parent in current_vertex.parents:\n                if parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:  # no parent found (should not happen if connected)\n                break\n            path.append(min_parent)\n            current_vertex = min_parent\n\n        path.reverse()\n\n        # Apply shortcut smoothing to reduce unnecessary waypoints\n        smoothed_path = self._shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 10000\n        base_max_dist = 12.0\n        min_max_dist = 2.0\n        goal_sample_rate = 0.2  # 20% chance to sample goal directly (goal bias)\n        search_radius_factor = 20.0  # radius factor for rewiring\n        \n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:  # Timeout at 10 seconds\n                break\n\n            # Adapt max_dist: shrink as iterations grow for finer local exploration\n            max_dist = max(min_max_dist, base_max_dist * (1.0 - iteration / max_iterations))\n\n            # Sample point with goal bias\n            q_sample: Point = self._get_random_sample(goal_sample_rate)\n            \n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Choose best parent for q_new from neighbors within radius (RRT* parent selection)\n            rewire_radius = search_radius_factor * (max_dist ** 0.5)\n            best_parent = self._choose_parent(q_near, q_new, rewire_radius)\n\n            self._graph.add_edge(best_parent, q_new)\n            # Cost is assigned inside _choose_parent\n            # Rewire neighbors passing through q_new\n            self._rewire(q_new, rewire_radius)\n\n            # Check if goal radius reached with q_new\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new directly to goal vertex for path extraction\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* (Rapidly-exploring Random Tree Star) variant\n    for path planning on a discrete grid environment. It incorporates:\n    - Goal-biased sampling to increase efficiency.\n    - Adaptive max step size scaling based on distance to goal for finer exploration near goal.\n    - Rewiring of nearby vertices after insertion to optimize path cost and smoothness.\n    - Path shortcutting for post-processing smoothing.\n    - Early termination if a path is found or after 10 seconds of planning to improve runtime robustness.\n    - Uses cost heuristic from map movement costs to guide rewiring.\n    \n    The approach balances exploration with optimization to achieve shorter, smoother and more reliable paths\n    than basic RRT, improving success rate and quality on grid environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges in RRT*\n        self._init_displays()\n\n    # Override or add helper function to compute rewiring radius based on iteration count\n    def _get_rewire_radius(self, iteration: int) -> float:\n        # Typical RRT* radius scaling: gamma * (log(n)/n)^(1/d)\n        # Using constant gamma and dimensionality d=2 here for grid (could be 2D or general)\n        n = max(iteration, 1)\n        gamma = 30.0  # Tunable parameter for neighborhood radius factor\n        dim = self._get_grid().size.n_dim\n        return gamma * ((np.log(n) / n) ** (1 / dim))\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewire the nearby vertices around q_new if the path cost improves by going through q_new.\n        \"\"\"\n        for q_near in near_vertices:\n            old_cost = q_near.cost\n            # Cost from q_new to q_near (assuming straight line)\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if cost_through_new < old_cost:\n                # Remove old edge(s) connecting q_near to parents (assuming single parent tree structure)\n                # Then add new edge from q_new to q_near\n                # Remove all parents edges (if edges_removable is enabled)\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_new\n\n    def _calculate_cost(self, parent: Vertex, child_pos: Point) -> float:\n        \"\"\"Calculate cost to reach child via parent.\"\"\"\n        return parent.cost + self._get_grid().get_movement_cost(parent.position, child_pos)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new_pos: Point) -> Vertex:\n        \"\"\"\n        Choose the best parent vertex from q_near_list for the new vertex position q_new_pos based on minimum cost.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = self._calculate_cost(q_near, q_new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return best_parent, min_cost\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Shortcut smoothing by trying to connect non-adjacent vertices directly if path valid.\n        \"\"\"\n        if len(path) < 3:\n            return path  # No smoothing possible\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path by backtracking parents from goal vertex,\n        then smooth the path with shortcutting and animate.\n        \"\"\"\n        path: List[Vertex] = [q_goal]\n        while path[-1].parents:\n            # Choose one parent (lowest cost)\n            parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(parent)\n\n        path.reverse()\n\n        # Smooth the path to remove unnecessary intermediate vertices\n        path = self._smooth_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Same as base, but store cost of parent plus incremental cost\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        return Vertex(q_new_pos)\n\n    def _find_path_internal(self) -> None:\n        max_dist_base: float = 15\n        iterations: int = 10000\n        start_time = time()\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0  # Cost to reach start is 0\n\n        found_path = False\n\n        for i in range(iterations):\n            # Check timeout (over 10 seconds)\n            if time() - start_time > 10.0:\n                break\n\n            # Goal-biased sampling: 10% samples are goal position to speed convergence\n            if np.random.rand() < 0.1:\n                q_sample = goal_pos\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist scaled by distance to goal: smaller near goal for finer steps\n            dist_to_goal = Map.get_distance(q_near.position, goal_pos)\n            max_dist = max_dist_base * (dist_to_goal / self._get_grid().size.max_dim)\n            max_dist = max(max_dist, 3.0)  # Minimum step size\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Near vertices within rewire radius for parent selection and rewiring\n            rewire_radius = self._get_rewire_radius(i + 1)\n            near_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, rewire_radius)\n\n            # Choose best parent among near vertices (including q_near)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n            best_parent, min_cost = self._choose_parent(near_vertices, q_new.position)\n            if best_parent is None:\n                # No valid parent found (should be rare), skip this iteration\n                continue\n\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices through q_new if cheaper\n            self._rewire(q_new, near_vertices)\n\n            # Check if goal reached from q_new position\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal to q_new and extract path\n                goal_vertex = Vertex(goal_pos)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    found_path = True\n                    break\n\n            self.key_frame()\n\n        # If no path found within iteration/time limit, do nothing or handle as needed\n        if not found_path:\n            # Keyframe to indicate failure or end state (optional)\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Path Planning Algorithm leveraging RRT* concepts:\n    - Adaptive max_dist clamping based on proximity to goal (smaller steps near goal)\n    - Goal-biased sampling with adjustable probability to improve success and efficiency\n    - Rewiring for path quality: after adding a vertex, attempts to connect nearby vertices to reduce path cost\n    - Early stopping if goal reached or if elapsed search time > 10 seconds\n    - Path extraction with shortcut smoothing by attempting direct line from start to goal\n    - Uses existing helper functions and graph structure (Forest)",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services, \n            Vertex(self._get_grid().agent.position), \n            Vertex(self._get_grid().goal.position), \n            [])\n        self._graph.edges_removable = True  # Enable edge modifications for rewiring\n        self._goal_bias = 0.2  # Probability to sample goal directly\n        self._max_dist_base = 10.0\n        self._rewire_radius = 15.0\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, near_pos: Point, goal_pos: Point) -> float:\n        dist = Map.get_distance(near_pos, goal_pos)\n        # Reduce max_dist near goal for finer expansions\n        if dist < 3 * self._max_dist_base:\n            return max(2.5, dist / 2)\n        return self._max_dist_base\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Goal-biased sampling:\n        With probability self._goal_bias, return goal position directly;\n        else random valid sample.\n        \"\"\"\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            # fallback: sample random valid position on grid\n            while True:\n                rand_pos = [random.randint(0, self._get_grid().size[i] - 1) for i in range(self._get_grid().size.n_dim)]\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _choose_parent(self, neighbors: List[Vertex], nearest_vertex: Vertex, q_new: Vertex) -> Vertex:\n        \"\"\"\n        Choose the best parent from neighbors to minimize cost from root to q_new\n        \"\"\"\n        min_cost = nearest_vertex.cost + self._get_grid().get_distance(nearest_vertex.position, q_new.position)\n        best_parent = nearest_vertex\n        for v in neighbors:\n            cost_through_v = v.cost + self._get_grid().get_distance(v.position, q_new.position)\n            if cost_through_v < min_cost:\n                # Check line validity\n                line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    min_cost = cost_through_v\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        For each neighbor vertex, try to improve path cost by rewiring through q_new\n        \"\"\"\n        for v in neighbors:\n            if v == q_new:\n                continue\n            cost_through_qnew = q_new.cost + self._get_grid().get_distance(q_new.position, v.position)\n            if cost_through_qnew < v.cost:\n                # Check line validity before rewiring\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edges from parents to v\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    # Add new edge from q_new to v\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_qnew\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path: List[Vertex] = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            # Pick parent with minimum cost to trace path back\n            parents_list = list(path[-1].parents)\n            parent_min_cost = min(parents_list, key=lambda p: p.cost)\n            path.append(parent_min_cost)\n        # remove the initial start vertex duplicate at end\n        if path[-1].position == self._get_grid().agent.position:\n            path.pop()\n        path.reverse()\n\n        # Attempt shortcut smoothing on path by connecting non-adjacent vertices where possible\n        smoothed_path: List[Vertex] = []\n        idx = 0\n        while idx < len(path):\n            smoothed_path.append(path[idx])\n            next_idx = len(path) - 1  # try farthest reachable\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[test_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = test_idx\n                    break\n            idx = next_idx\n\n        # Animate and move agent along smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_iterations = 8000  # Reduced iterations due to improved guidance\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            # Terminate if search takes longer than 10 seconds\n            if time() - start_time > 10.0:\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            adaptive_max_dist = self._get_adaptive_max_dist(q_near.position, goal_pos)\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find neighbors within rewire radius\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n\n            # Choose best parent with minimal cost\n            best_parent = self._choose_parent(neighbors, q_near, q_new)\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = best_parent.cost + self._get_grid().get_distance(best_parent.position, q_new.position)\n\n            # Rewire neighbors to improve paths via q_new\n            self._rewire(neighbors, q_new)\n\n            # Check if within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect final point to goal vertex\n                goal_vertex = Vertex(goal_pos)\n                self._graph.add_edge(q_new, goal_vertex)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_pos)\n                self._extract_path(goal_vertex)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* Algorithm with Goal-Biased Sampling and Adaptive Step Size",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Improved RRT* Algorithm with Goal-Biased Sampling and Adaptive Step Size}\n    \n    This algorithm extends the classic RRT with RRT* inspired rewiring to improve path quality and smoothness.\n    Key improvements:\n    - Goal-biased sampling to speed convergence.\n    - Adaptive max_dist step size reducing gradually for finer exploration near goal.\n    - Rewiring neighbors within a radius to reduce path cost (RRT* style).\n    - Early stopping if goal is connected and path cost improvements stabilize.\n    - Shortcut smoothing is applied after path extraction.\n    - Timeout of 10 seconds to ensure timely termination.\n    \"\"\"\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # Allow rewiring/removing edges\n        self._max_initial_dist = 15.0\n        self._max_final_dist = 3.0\n        self._rewire_radius = 20.0\n        self._goal_sample_rate = 0.2  # 20% of samples biased towards goal\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, iteration: int, max_iterations: int) -> float:\n        # Linearly reduce max_dist from initial to final over iterations\n        return self._max_final_dist + (self._max_initial_dist - self._max_final_dist) * max(0, (max_iterations - iteration) / max_iterations)\n\n    def _get_random_sample_goal_biased(self) -> Point:\n        # With goal_sample_rate probability sample the goal point directly for goal bias\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _choose_parent(self, q_near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose best parent with minimum cost + distance to q_new, if path valid\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float('inf')\n\n        for q_near in q_near_vertices:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            if new_cost < best_cost:\n                best_cost = new_cost\n                best_parent = q_near\n\n        if best_parent is not None:\n            q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        grid = self._get_grid()\n        for q_near in near_vertices:\n            if q_near == q_new.parents:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Cost if we go from q_new to q_near\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Rewire: change parent of q_near to q_new\n                # Removes old edges and adds new edge q_new -> q_near\n                # Remove all parents edges to q_near\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempts to shortcut path by connecting non-consecutive vertices directly if path valid\n        grid = self._get_grid()\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            furthest = idx + 1\n            for j in range(len(path)-1, idx, -1):\n                line_seq = grid.get_line_sequence(path[idx].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    furthest = j\n                    break\n            shortened_path.append(path[furthest])\n            idx = furthest\n        return shortened_path\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        # Extract path from q_last to start (root_vertex_start) by following parents, then shortcut it\n        path: List[Vertex] = [q_last]\n        while path[-1] != self._graph.root_vertex_start:\n            parents = list(path[-1].parents)\n            if not parents:\n                break\n            path.append(parents[0])  # picking one parent, RRT* always connects one parent\n        path.reverse()\n\n        # Shortcut and smoothing\n        path = self._shortcut_path(path)\n\n        # Animate path tracing\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        timeout_seconds: int = 10\n        grid: Map = self._get_grid()\n\n        start_time = time()\n\n        # Initialize cost and root vertex\n        self._graph.root_vertex_start.cost = 0.0\n\n        goal_connected = False\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n\n        for i in range(max_iterations):\n            # Timeout check\n            if time() - start_time > timeout_seconds:\n                break\n\n            max_dist = self._get_adaptive_max_dist(i, max_iterations)\n\n            # Sample point with goal bias\n            q_sample = self._get_random_sample_goal_biased()\n\n            # Nearest vertex to sample\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # New vertex evading max_dist\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq_to_new = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq_to_new):\n                continue\n\n            # Find nearby vertices for rewiring and parent selection\n            near_vertices = self._get_near_vertices(q_new, self._rewire_radius)\n\n            # Choose best parent among near vertices (including q_near)\n            best_parent = self._choose_parent(near_vertices + [q_near], q_new)\n            if best_parent is None:\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to improve path costs\n            self._rewire(q_new, near_vertices)\n\n            # Check if new vertex is within goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < best_goal_cost:\n                    best_goal_cost = q_new.cost\n                    best_goal_vertex = q_new\n                    goal_connected = True\n\n                    # Early stop criteria: if cost improvement is small or after enough iterations\n                    if i > max_iterations // 4:\n                        break\n\n            self.key_frame()\n\n        # If connected to goal, extract path\n        if goal_connected and best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)\n        else:\n            # No path found within time/iterations\n            pass  # could add fallback or message; here we quietly finish",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved sample-based path planning algorithm inspired by RRT* with goal-biased sampling,\n    dynamic step size adaptation, and rewiring to optimize path quality. The algorithm introduces:\n    - Goal bias to sample the goal with a fixed probability for faster convergence.\n    - Dynamic max_dist that adapts based on distance to closest vertex to balance exploration and exploitation.\n    - Rewiring nearby vertices within a radius to reduce overall cost and smooth paths (RRT* style).\n    - Early stopping if the path has not improved for several iterations.\n    - Path shortcutting after the path is found to smooth and shorten the route.\n    - A maximum time limit of 10 seconds to abort search and declare failure.\n    This improves planning efficiency, path quality, robustness, and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        max_iter = 10000\n        time_limit = 10.0  # seconds\n        goal_sample_rate = 0.1  # 10% samples are biased towards goal\n        rewire_radius_factor = 15.0  # factor to multiply sqrt(log(n)/n) or fixed radius\n        max_step = 15.0  # max extension step size\n        min_step = 3.0   # min extension step size to avoid overly small steps\n\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        # Initialize graph with start and goal vertices\n        self._graph = gen_forest(self._services, Vertex(start_pos), Vertex(goal_pos), [])\n        self._graph.edges_removable = True\n\n        start_time = time.time()\n\n        def get_dynamic_step(q_near_pos: Point, q_sample: Point) -> float:\n            dist = Map.get_distance(q_near_pos, q_sample)\n            # Step size adapts with distance but clamps between min_step and max_step\n            step = max(min_step, min(max_step, dist * 0.5))\n            return step\n\n        def get_nearby_vertices(q_new_pos: Point, radius: float) -> List[Vertex]:\n            return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new_pos, radius)\n\n        def cost_between(frm: Point, to: Point) -> float:\n            return grid.get_movement_cost(frm, to)\n\n        def path_cost(v: Vertex) -> float:\n            # Cost is stored in vertex; if none, we compute recursively\n            return v.cost if v.cost is not None else float('inf')\n\n        def update_vertex_cost(v: Vertex):\n            # Update cost from parents + edge cost (choose min)\n            best_cost = float('inf')\n            best_parent = None\n            for p in v.parents:\n                c = p.cost + cost_between(p.position, v.position)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = p\n            if best_parent is not None:\n                # Remove all old parents, set best parent only\n                for old_p in list(v.parents):\n                    if old_p != best_parent:\n                        self._graph.remove_edge(old_p, v)\n                # Update cost and connectivity to best parent if not yet set\n                if best_parent not in v.parents:\n                    self._graph.add_edge(best_parent, v)\n                v.cost = best_cost\n\n        def rewire(q_new: Vertex):\n            # Rewire nearby vertices to improve path if possible\n            n = self._graph.size + 1\n            radius = rewire_radius_factor * (np.log(n) / n) ** 0.5\n            radius = max(radius, max_step)  # enforce at least max_step radius\n            neighbors = get_nearby_vertices(q_new.position, radius)\n            for neighbor in neighbors:\n                # Check if connecting through q_new improves cost and path is collision free\n                if neighbor == q_new:\n                    continue\n                new_cost = q_new.cost + cost_between(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                    if not grid.is_valid_line_sequence(line_seq):\n                        continue\n                    # Rewire: Remove old parents and add new parent q_new\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n        def reconstruct_path(q_goal: Vertex) -> List[Vertex]:\n            # Reconstruct path from q_goal back to start\n            path = []\n            current = q_goal\n            while True:\n                path.append(current)\n                if current == self._graph.root_vertex_start or not current.parents:\n                    break\n                # Choose parent with minimal cost\n                current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.reverse()\n            return path\n\n        def shortcut_path(path: List[Vertex]) -> List[Vertex]:\n            # Attempt to shortcut path by checking direct line feasibility between vertices\n            if len(path) < 3:\n                return path\n            new_path = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                # Try to connect from current idx directly to next_idx backward until line valid\n                while next_idx > idx + 1:\n                    line_seq = grid.get_line_sequence(path[idx].position, path[next_idx].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        break\n                    next_idx -= 1\n                new_path.append(path[next_idx])\n                idx = next_idx\n            return new_path\n\n        # Set start vertex cost zero\n        self._graph.root_vertex_start.cost = 0.0\n\n        last_best_cost = float('inf')\n        no_improve_iters = 0\n        max_no_improve_iters = 400  # early stopping if no improvement over these many iterations\n\n        best_goal_vertex = None\n\n        for iteration in range(max_iter):\n            if (time.time() - start_time) > time_limit:\n                # Time exceeded: fail early\n                break\n\n            # Goal-biased sampling\n            sample_goal = np.random.rand() < goal_sample_rate\n            if sample_goal:\n                q_sample = grid.goal.position\n            else:\n                # Uniform random sample in valid area\n                q_sample = None\n                for _ in range(20):  # max trials to sample valid point\n                    candidate = self._get_random_sample()\n                    if candidate is not None:\n                        q_sample = candidate\n                        break\n                if q_sample is None:\n                    continue  # no valid sample found, continue next iteration\n\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue  # ignore duplicate\n\n            # Adaptive step size\n            step_size = get_dynamic_step(q_near.position, q_sample)\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist_dir = torch.norm(dir_vec)\n            direction = dir_vec / dist_dir if dist_dir > 0 else dir_vec\n            q_new_pos_tensor = q_near.position.to_tensor() + direction * step_size\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n            q_new = Vertex(q_new_pos)\n\n            # Validity check: no obstacle in path segment from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost and update\n            cost_to_new = q_near.cost + cost_between(q_near.position, q_new.position)\n            q_new.cost = cost_to_new\n\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire nearby vertices for better paths\n            rewire(q_new)\n\n            # Check for reaching goal radius\n            if grid.is_agent_in_goal_radius(q_new.position):\n                # Connect directly to goal vertex if possible\n                line_to_goal = grid.get_line_sequence(q_new.position, grid.goal.position)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = self._graph.root_vertex_goal\n                    cost_to_goal = q_new.cost + cost_between(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Check if new path improves best\n                    if cost_to_goal < last_best_cost:\n                        last_best_cost = cost_to_goal\n                        best_goal_vertex = goal_vertex\n                        no_improve_iters = 0\n                    else:\n                        no_improve_iters += 1\n\n                    # Early stopping if no improvement for many iterations and path found\n                    if no_improve_iters >= max_no_improve_iters:\n                        break\n                else:\n                    no_improve_iters += 1\n            else:\n                no_improve_iters += 1\n\n            self.key_frame()\n\n        # If we found a goal connection, extract and shortcut path\n        if best_goal_vertex is not None and best_goal_vertex.cost is not None and best_goal_vertex.cost < float('inf'):\n            path_vertices = reconstruct_path(best_goal_vertex)\n            path_vertices = shortcut_path(path_vertices)\n\n            # Animate final path\n            for vertex in path_vertices:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No path found, optional: could implement fallback or cleanup here\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planning algorithm with goal-biasing, rewiring, adaptive step size,\n    and path smoothing. It biases sampling towards the goal to increase convergence speed,\n    uses rewiring to optimize path cost locally improving the solution quality,\n    adapts max step size based on environment distances for efficiency,\n    and applies shortcut smoothing on the found path.\n    It also terminates search if it exceeds 10 seconds to prevent excessive computation.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring/removing edges\n        self._init_displays()\n        self._max_dist_min = 3.0\n        self._max_dist_max = 12.0\n        self._goal_sample_rate = 0.2  # 20% goal-biased sampling\n        self._rewire_radius = 15.0\n\n    # Adaptive step size based on distance to nearest vertex (helps efficiency)\n    def _adaptive_max_dist(self, distance_to_nearest: float) -> float:\n        max_dist = np.clip(distance_to_nearest * 0.8, self._max_dist_min, self._max_dist_max)\n        return max_dist\n\n    # Goal-biased sampling: sample goal position with certain probability\n    def _get_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    # Attempt rewiring neighbors to reduce cost to the new vertex\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        for q_near in nearby_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Remove old parent edge(s)\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Connect q_new as new parent\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    # Smooth the extracted path by shortcutting\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) <= 2:\n            return path\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Find farthest vertex reachable with clear line\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[test_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = test_idx\n                    break\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    # Overridden method implementing improved RRT* logic\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        max_iterations = 10000\n        for i in range(max_iterations):\n            # Check timeout limit for planning (10 seconds)\n            if time() - start_time > 10.0:\n                # Stop search if timeout exceeded (fail to find path)\n                break\n\n            q_sample = self._get_biased_sample()  # sample point with goal bias\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            distance_to_near = self._get_grid().get_distance(q_near.position, q_sample)\n            max_dist = self._adaptive_max_dist(distance_to_near)\n\n            # Generate new vertex toward sampled point limited by max_dist\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if q_new.position == q_near.position:\n                continue  # no progress\n\n            # Check path feasibility\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Determine cost for q_new vertex\n            q_new.cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n            # Find nearby vertices for rewiring in radius\n            nearby_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Choose best parent among nearby vertices for q_new (minimal cost)\n            min_cost = q_new.cost\n            best_parent = q_near\n            for q_nearby in nearby_vertices:\n                line_seq_potential = self._get_grid().get_line_sequence(q_nearby.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_potential):\n                    cost_potential = q_nearby.cost + self._get_grid().get_distance(q_nearby.position, q_new.position)\n                    if cost_potential < min_cost:\n                        min_cost = cost_potential\n                        best_parent = q_nearby\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices to q_new if it improves costs\n            self._rewire(q_new, nearby_vertices)\n\n            # Check if goal reached with radius condition\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex ensuring line is clear\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Extract path from goal to start\n                    path: List[Vertex] = [goal_vertex]\n                    current = goal_vertex\n                    while len(current.parents) != 0:\n                        for parent in current.parents:\n                            current = parent\n                            path.append(current)\n                            break\n                    path.reverse()\n\n                    # Smooth the extracted path for shortcutting\n                    smoothed_path = self._smooth_path(path)\n\n                    # Animate moving the agent along smoothed path\n                    for vertex in smoothed_path:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    break  # path found, stop iteration\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired algorithm with goal biasing, adaptive step size, and rewiring for better path quality and efficiency.\n    - Incorporates goal-biased sampling to direct exploration toward the goal more frequently.\n    - Uses an adaptive max distance that decays if no progress is made, to enable finer expansion near obstacles.\n    - Implements rewiring to optimize paths by connecting new vertices to nearby vertices for shorter paths.\n    - Includes early stopping when goal reached or 10 seconds timeout for robust runtime control.\n    - Performs shortcut smoothing in path extraction to reduce path length and produce smoother trajectories.\n    - Maintains forest structure and reuses existing utilities for consistent integration with framework.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow rewiring edge removals\n        self._init_displays()\n        # Additional parameters for adaptive step and goal bias\n        self._base_max_dist = 15.0\n        self._min_max_dist = 3.0\n        self._goal_sample_rate = 0.15  # 15% samples directly from goal\n        self._rewire_radius = 20.0\n        self._timeout = 10.0  # seconds timeout for planning\n\n    def _get_adaptive_max_dist(self, iteration: int) -> float:\n        # Gradually reduce max_dist with iterations to focus more locally over time\n        decay = max(self._min_max_dist, self._base_max_dist * (0.99 ** iteration))\n        return decay\n\n    def _get_goal_biased_sample(self) -> Point:\n        # With probability _goal_sample_rate return goal position, else random valid pos\n        from random import random\n        if random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _near_vertices(self, point: Point, radius: float) -> List[Vertex]:\n        # Returns vertices within radius for rewiring\n        vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], point, radius)\n        return vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose the best parent for q_new minimizing cost\n        best_parent = None\n        best_cost = float('inf')\n        for near_v in near_vertices:\n            line = self._get_grid().get_line_sequence(near_v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            edge_cost = self._get_grid().get_movement_cost(near_v.position, q_new.position)\n            cost = near_v.cost + edge_cost\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = near_v\n        if best_parent is not None:\n            q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire near vertices with q_new\n        for near_v in near_vertices:\n            line = self._get_grid().get_line_sequence(q_new.position, near_v.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            edge_cost = self._get_grid().get_movement_cost(q_new.position, near_v.position)\n            new_cost = q_new.cost + edge_cost\n            if new_cost < near_v.cost:\n                # Rewire: remove old parents and add q_new as new parent\n                for p in list(near_v.parents):\n                    self._graph.remove_edge(p, near_v)\n                self._graph.add_edge(q_new, near_v)\n                near_v.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut path by removing unnecessary intermediate nodes if direct connection is valid\n        if len(path) < 3:\n            return path\n        shortcut_path: List[Vertex] = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            farthest = idx + 1\n            for j in range(len(path)-1, idx, -1):\n                line = self._get_grid().get_line_sequence(path[idx].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    farthest = j\n                    break\n            shortcut_path.append(path[farthest])\n            idx = farthest\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract path using parents, then smooth it by shortcutting\n        path: List[Vertex] = [q_new]\n        while len(path[-1].parents) != 0:\n            # Choose parent with minimal cost path for path recovery\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in path[-1].parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n\n        path.reverse()\n\n        # Shortcut path to reduce unnecessary points\n        path = self._shortcut_path(path)\n\n        # Animate movement along the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_iterations = 8000  # reasonably limited iterations\n        for iteration in range(max_iterations):\n            now = time()\n            if now - start_time > self._timeout:\n                # Timeout exceeded, treat as not found\n                break\n\n            max_dist: float = self._get_adaptive_max_dist(iteration)\n            q_sample: Point = self._get_goal_biased_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices for rewiring (including q_near)\n            near_vertices: List[Vertex] = self._near_vertices(q_new.position, self._rewire_radius)\n            # Choose best parent for q_new (could be q_near or other near vertices)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # No valid parent with line of sight, fallback to q_near if valid\n                best_parent = q_near\n                q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire near vertices that can be reached cheaper through q_new\n            self._rewire(near_vertices, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal vertex (create goal vertex anew)\n                goal_v = Vertex(self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_v.position)):\n                    goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n                    self._graph.add_edge(q_new, goal_v)\n                    self._extract_path(goal_v)\n                else:\n                    # If direct line to goal invalid, extract using current q_new\n                    self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planner with goal bias, adaptive step size, and rewiring \n    for path quality improvement. Uses heuristic-guided rewiring within a neighborhood to \n    reduce path cost and smoothness. Employs goal-biased sampling (20% samples aimed at \n    goal) to improve success rate and convergence speed. Adaptive max_dist scales with \n    current best path cost estimate, promoting efficient exploration. Adds early stopping \n    if a path is found or after 10 seconds timeout, balancing planning efficiency. \n    Final path is shortcut-smoothed by attempting direct connections between non-adjacent \n    vertices in the path.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._max_dist_min = 5.0\n        self._max_dist_max = 15.0\n        self._goal_bias_prob = 0.2\n        self._rewire_radius = 15.0\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = dir_vec / dist\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with probability self._goal_bias_prob sample goal directly\n        if np.random.rand() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _nearest_and_cost(self, root_verts: List[Vertex], q_sample: Point):\n        # Returns (nearest_vertex, cost_to_sample_along_line)\n        q_near = self._graph.get_nearest_vertex(root_verts, q_sample)\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_sample)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None, float('inf')\n        cost_line = self._get_grid().get_movement_cost(q_near.position, q_sample)\n        cost_sum = q_near.cost + cost_line\n        return q_near, cost_sum\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new_pos: Point, q_near: Vertex) -> Vertex:\n        # Select parent with minimal cost to q_new, default q_near if none better\n        best_parent = q_near\n        best_cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new_pos)\n        for neighbor in neighbors:\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new_pos)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n            if cost_through_new < neighbor.cost:\n                # Rewire: remove edge from old parent(s)\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                # Add edge from q_new to neighbor\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = cost_through_new\n\n    def _extract_path(self, q_goal: Vertex) -> List[Vertex]:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            # Pick the parent with minimal cost (usually only one in tree)\n            current = min(current.parents, key=lambda p: p.cost)\n            path.append(current)\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut path by connecting direct waypoint skips where valid\n        if len(path) <= 2:\n            return path\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # Find the furthest vertex that can be connected directly without obstacle\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        root_start = self._graph.root_vertex_start\n        root_goal_pos = self._get_grid().goal.position\n\n        # Init costs\n        root_start.cost = 0.0\n\n        max_iterations = 10000\n\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            # Check timeout\n            if (time.time() - start_time) > 10.0:\n                # Timeout: treat as failure to find route\n                break\n\n            # Adaptive max_dist based on current best cost found:\n            if best_goal_vertex is not None:\n                max_dist = max(self._max_dist_min, min(self._max_dist_max, best_goal_cost * 0.1))\n            else:\n                max_dist = self._max_dist_max\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([root_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within radius for rewiring and better parent selection\n            neighbors = self._graph.get_vertices_within_radius([root_start], q_new.position, self._rewire_radius)\n\n            # Choose parent with minimal cost from neighbors, fallback q_near\n            parent = self._choose_parent(neighbors, q_new.position, q_near)\n\n            # Set cost and add edge\n            q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire nearby neighbors if cheaper through q_new\n            self._rewire(q_new, neighbors)\n\n            # Check if new vertex reaches goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Create a vertex for the actual goal position (fixed)\n                goal_vertex = Vertex(root_goal_pos)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, root_goal_pos)\n                if goal_vertex.cost < best_goal_cost:\n                    # Connect to graph\n                    self._graph.add_edge(q_new, goal_vertex)\n                    best_goal_vertex = goal_vertex\n                    best_goal_cost = goal_vertex.cost\n\n                    # Early exit on first successful connection (can be relaxed)\n                    break\n\n            self.key_frame()\n\n        if best_goal_vertex is None:\n            # Fail: no path found within time or iterations\n            return\n\n        # Extract path from start to goal\n        raw_path = self._extract_path(best_goal_vertex)\n\n        # Shortcut smoothing to improve path quality\n        smoothed_path = self._shortcut_path(raw_path)\n\n        # Animate movement along smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved sample-based planner inspired by RRT* and goal-biased RRT.\n    It incorporates:\n    - Goal biasing in sampling to increase chances of quickly connecting to the goal.\n    - Adaptive step size (\"max_dist\") that dynamically reduces as the tree gets closer to the goal for finer expansions.\n    - Rewiring to optimize the tree structure locally, reducing path cost and improving path quality.\n    - Early stopping if the goal is connected and path cost stabilizes.\n    - Post-processing shortcut smoothing in the extracted path to produce smoother and shorter paths.\n    - Timeout of 10 seconds to avoid unbounded planning time.\n    This leads to improved efficiency, robustness, success rate, and path quality compared to vanilla RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Allow rewiring/removal\n        self._init_displays()\n        self._goal_bias_rate = 0.15   # Probability of sampling goal to bias towards it.\n        self._initial_max_dist = 15.0\n        self._min_max_dist = 3.0\n        self._rewire_radius = 20.0\n        self._max_iterations = 5000\n\n    def _get_random_sample(self) -> Point:\n        # With probability, return goal position sample to bias growth towards goal\n        if np.random.rand() < self._goal_bias_rate:\n            return self._get_grid().goal.position\n        # Otherwise sample random valid position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost between two vertices based on grid cost and distance\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, point)\n\n    def _get_vertices_within_radius(self, point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], point, radius)\n\n    def _is_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for q_near in neighbors:\n            if q_near == q_new or q_near == self._graph.root_vertex_start:\n                continue\n            # Cost through q_new to q_near\n            new_cost = q_new.cost + self._cost(q_new, q_near)\n            if new_cost < q_near.cost and self._is_collision_free(q_new.position, q_near.position):\n                # Rewire q_near's parents: remove old edge, add new edge from q_new\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _choose_parent(self, q_new: Vertex, neighbors: List[Vertex]) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in neighbors:\n            if not self._is_collision_free(q_near.position, q_new.position):\n                continue\n            cost_through = q_near.cost + self._cost(q_near, q_new)\n            if cost_through < min_cost:\n                min_cost = cost_through\n                best_parent = q_near\n        if best_parent is None:\n            best_parent = self._graph.root_vertex_start\n            min_cost = self._cost(best_parent, q_new)\n        q_new.cost = min_cost\n        return best_parent\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Trace back parent chain to root (start)\n        path: List[Vertex] = [q_new]\n        curr = q_new\n        while len(curr.parents) > 0:\n            # Pick one parent (RRT* parents only one)\n            parent = next(iter(curr.parents))\n            path.append(parent)\n            curr = parent\n        path.reverse()\n\n        # Shortcut smoothing for path\n        smoothed_path = [path[0]]\n        for i in range(1, len(path)):\n            # Attempt to connect last added smoothed path vertex directly to path[i]\n            if self._is_collision_free(smoothed_path[-1].position, path[i].position):\n                # Shortcut is feasible, skip intermediate points\n                continue\n            else:\n                smoothed_path.append(path[i - 1])\n        smoothed_path.append(path[-1])\n\n        # Animate agent movement along smooth path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _dynamic_max_dist(self, curr_pos: Point, goal_pos: Point) -> float:\n        # Linearly interpolate max_dist from initial value to min based on distance to goal\n        dist_to_goal = Map.get_distance(curr_pos, goal_pos)\n        total_dist = Map.get_distance(self._graph.root_vertex_start.position, goal_pos)\n        frac = dist_to_goal / (total_dist + 1e-6)\n        return max(self._min_max_dist, self._initial_max_dist * frac)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        goal_pos = self._get_grid().goal.position\n\n        # Initialize root cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(self._max_iterations):\n            if (time() - start_time) > 10.0:\n                # Timeout reached, stop search\n                break\n\n            # Sample a point with goal biasing\n            q_sample = self._get_random_sample()\n            q_near = self._get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adapt step size based on distance to goal for finer expansions near goal\n            max_dist = self._dynamic_max_dist(q_near.position, goal_pos)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = self._get_vertices_within_radius(q_new.position, self._rewire_radius)\n\n            # Choose best parent among neighbors based on cost\n            chosen_parent = self._choose_parent(q_new, neighbors)\n            self._graph.add_edge(chosen_parent, q_new)\n\n            # Rewire neighbors to q_new if it improves cost\n            self._rewire(q_new, neighbors)\n\n            # If q_new reaches goal radius, finalize by connecting goal and extracting path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = Vertex(goal_pos)\n                # Connect goal to q_new if collision free\n                if self._is_collision_free(q_new.position, goal_pos):\n                    # Cost and add edge for goal vertex\n                    goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm that integrates goal-biased sampling, heuristic-guided expansion (A*-style cost),\n    adaptive step size shrinking near obstacles and goal, and rewiring steps similar to RRT* for path optimization.\n    It enhances planning efficiency by focusing exploration toward the goal and rewires the graph to improve path quality.\n    The algorithm aborts if planning time exceeds 10 seconds to ensure responsiveness.\n    Path extraction uses path smoothing by shortcutting path segments over obstacle-free line-of-sight.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable edge removals for rewiring\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Generate a new vertex towards sample with max_dist limitation.\n        Shrinks max_dist adaptively near obstacles or goal for finer control.\n        \"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist == 0:\n            return Vertex(q_sample)  # identical points edge case\n\n        # Adaptive step: smaller max_dist if near obstacle or approaching goal\n        adaptive_max_dist = max_dist\n\n        grid = self._get_grid()\n\n        # Check distance to nearest obstacle (rough approx): sample some neighbors near q_near\n        neighbors = grid.get_next_positions(q_near.position)\n        min_obstacle_dist = float('inf')\n        for n in neighbors:\n            if not grid.is_agent_valid_pos(n):\n                d = Map.get_distance(q_near.position, n)\n                if d < min_obstacle_dist:\n                    min_obstacle_dist = d\n\n        if min_obstacle_dist < max_dist * 2:\n            adaptive_max_dist = min(adaptive_max_dist, min_obstacle_dist * 0.5)\n\n        # Shrink step size when close to goal\n        dist_to_goal = Map.get_distance(q_near.position, grid.goal.position)\n        if dist_to_goal < max_dist * 3:\n            adaptive_max_dist = min(adaptive_max_dist, dist_to_goal * 0.5)\n\n        if dist <= adaptive_max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        new_point = Point.from_tensor(q_near.position.to_tensor() + adaptive_max_dist * dir_normalized)\n        return Vertex(new_point)\n\n    def _get_random_sample(self, goal_bias: float = 0.2) -> Point:\n        \"\"\"\n        Get random sample with goal bias: with probability goal_bias, sample near goal within small radius.\n        Otherwise, uniform random sample.\n        \"\"\"\n        grid = self._get_grid()\n        if np.random.rand() < goal_bias:\n            # Sample near goal, within radius 5 grid units (limited to grid bounds)\n            goal_pos = grid.goal.position\n            radius = 5\n            for _ in range(100):\n                rand_offset = np.random.randint(-radius, radius + 1, size=grid.size.n_dim)\n                sample_coords = goal_pos.to_list()\n                for i in range(len(sample_coords)):\n                    sample_coords[i] = max(0, min(grid.size[i]-1, sample_coords[i] + rand_offset[i]))\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        \n        # Uniform random sample\n        for _ in range(1000):\n            rand_pos = np.random.randint(0, grid.size, size=grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n        # As fallback, return goal position if no valid random found (should rarely happen)\n        return grid.goal.position\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        \"\"\"\n        Compute cost from from_v to to_v, considering movement cost and heuristic to goal to guide rewiring.\n        \"\"\"\n        grid = self._get_grid()\n        move_cost = grid.get_movement_cost(from_v.position, to_v.position)\n        # Heuristic: Euclidean distance to goal\n        heuristic = Map.get_distance(to_v.position, grid.goal.position)\n        return from_v.cost + move_cost + heuristic * 0.1  # Weighted heuristic to bias cost\n\n    def _rewire(self, q_new: Vertex, radius: float) -> None:\n        \"\"\"\n        Rewire vertices in radius around q_new to improve their costs if connecting via q_new is better.\n        \"\"\"\n        grid = self._get_grid()\n        neighbours = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n        for q_near in neighbours:\n            if q_near == q_new:\n                continue\n            # Check if path q_new -> q_near is valid and improves cost\n            line = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line):\n                continue\n            cost_through_q_new = q_new.cost + grid.get_movement_cost(q_new.position, q_near.position)\n            if cost_through_q_new < q_near.cost:\n                # Remove old parents to keep tree property and add q_new as parent\n                # Remove all parents edges first\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_q_new\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extract path from root_vertex_start to goal via q_new,\n        then perform path smoothing by shortcutting to improve path quality.\n        Animate the agent moving along the smooth path.\n        \"\"\"\n        grid = self._get_grid()\n\n        # Add goal vertex linked to q_new\n        goal_v = Vertex(grid.goal.position)\n        self._graph.add_edge(q_new, goal_v)\n\n        # Backtrack path parents from goal\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            p = next(iter(path[-1].parents))\n            path.append(p)\n        # Remove the root virtual vertex (agent start) if present on end\n        path.reverse()\n\n        # Path smoothing: shortcut by checking line-of-sight between non-consecutive vertices\n        smoothed_path: List[Vertex] = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1  # try furthest possible\n            while next_idx > idx + 1:\n                line = grid.get_line_sequence(path[idx].position, path[next_idx].position)\n                if grid.is_valid_line_sequence(line):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n\n        # Animate agent motion along smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n\n        max_dist = 15.0\n        iterations = 5000\n        rewire_radius = 20.0\n        goal_threshold = max_dist * 1.5  # Distance to goal to consider close enough\n\n        # Initialize start vertex cost 0\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n            if time.time() - start_time > 10.0:\n                # Exceeded time limit, treat as failure to find path\n                break\n\n            # Goal biased sampling\n            q_sample = self._get_random_sample(goal_bias=0.25)\n\n            # Find nearest vertex in current tree to sample\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Generate new vertex with adaptive step\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check validity of path segment q_near -> q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate cost to reach q_new via q_near\n            cost = q_near.cost + grid.get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost\n\n            # Add edge q_near -> q_new\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors around q_new to improve cost\n            self._rewire(q_new, rewire_radius)\n\n            dist_to_goal = Map.get_distance(q_new.position, grid.goal.position)\n            if dist_to_goal <= goal_threshold and grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, grid.goal.position)):\n                # Goal reachable from q_new\n                q_new.cost += dist_to_goal  # add direct cost estimate\n\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved path planner combining:\n    - Goal-biased sampling to enhance focus toward the goal.\n    - Adaptive step size based on distance to goal for efficient expansion.\n    - An RRT* style rewiring step to improve path quality and robustness.\n    - Early stopping criteria both by goal reach and max elapsed time (10 seconds).\n    - Shortcut smoothing after the initial path extraction to reduce unnecessary detours.\n    It uses cost and heuristic estimates to guide rewiring, improving convergence speed and final path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # Enable edge removals for rewiring\n        self._init_displays()\n        self._max_time = 10.0  # maximum allowed planning time in seconds\n        self._goal_bias = 0.2  # probability of sampling the goal point for biasing\n        self._max_dist_base = 15.0  # base maximum extension distance\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: sample goal point with probability self._goal_bias\n        if np.random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _cost(self, u: Vertex, v: Vertex) -> float:\n        # Cost metric using grid movement cost\n        return self._get_grid().get_movement_cost(u.position, v.position)\n\n    def _total_cost(self, v: Vertex) -> float:\n        # Cost-to-come stored in vertex.cost\n        return v.cost\n\n    def _heuristic(self, pos: Point) -> float:\n        # Euclidean distance heuristic to goal\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _rewire(self, q_new: Vertex, near_vertices: list):\n        # Attempt to improve tree cost by rewiring nearby vertices through q_new\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_q_new = q_new.cost + self._cost(q_new, q_near)\n            if cost_through_q_new < q_near.cost:\n                # Remove old parent edges\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add edge from q_new instead\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_q_new\n\n    def _extract_path(self, q_goal: Vertex) -> list:\n        path: list = [q_goal]\n        while len(path[-1].parents) != 0:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: list) -> list:\n        # Shortcut path smoothing by attempting to connect non-adjacent points directly\n        if len(path) < 3:\n            return path\n        new_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            new_path.append(path[next_idx])\n            idx = next_idx\n        return new_path\n\n    def _set_cost_parent(self, q_new: Vertex, q_min: Vertex):\n        q_new.cost = q_min.cost + self._cost(q_min, q_new)\n        self._graph.add_edge(q_min, q_new)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n\n        start_v = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n\n        start_v.cost = 0.0\n        max_iterations = 5000  # Reduced iteration count due to improvements\n\n        for iteration in range(max_iterations):\n            elapsed_time = time() - start_time\n            if elapsed_time > self._max_time:\n                # Timeout, stop planning\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            # Adaptive step size: larger when far from goal, smaller close to goal\n            dist_to_goal = self._heuristic(q_near.position)\n            max_dist = max(5.0, min(self._max_dist_base, dist_to_goal / 2.0))\n\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Initialize q_new.cost as infinity for optimization\n            q_new.cost = float('inf')\n\n            near_radius = max_dist * 2.5\n            near_vertices = self._get_near_vertices(q_new, near_radius)\n\n            # Choose parent with minimum cost path\n            q_min = None\n            min_cost = float('inf')\n            for q_near_candidate in near_vertices:\n                line_seq = self._get_grid().get_line_sequence(q_near_candidate.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_candidate = q_near_candidate.cost + self._cost(q_near_candidate, q_new)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    q_min = q_near_candidate\n\n            if q_min is None:\n                # No valid parent found, try the nearest vertex as fallback if valid\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_min = q_near\n                    min_cost = q_near.cost + self._cost(q_near, q_new)\n                else:\n                    continue\n\n            self._set_cost_parent(q_new, q_min)\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire the tree locally to improve path quality\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Goal reached, add goal vertex connected to q_new, then extract and smooth path\n                q_goal = Vertex(goal_pos)\n                path_goal_line = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(path_goal_line):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n\n                    path = self._extract_path(q_goal)\n                    path = self._shortcut_path(path)\n\n                    for v in path:\n                        self.move_agent(v.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Path Planning Algorithm inspired by RRT* and heuristic-guided search:\n    - Employs goal-biased and adaptive sampling to efficiently explore towards goal.\n    - Uses rewiring (like RRT*) to optimize path costs, improving path quality.\n    - Adaptive max_dist based on environment size for better step scaling.\n    - Heuristic (Euclidean distance) guides rewiring to reduce cost.\n    - Performs path shortcutting to smooth final path.\n    - Stops search either on reaching the goal or if elapsed time exceeds 10 seconds.\n    - Uses a Forest graph to maintain connectivity and cost propagation.\n    - Includes early stopping for efficiency and improved success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring/removal for optimization\n        self._init_displays()\n        self._goal_sample_rate = 0.2  # 20% goal biasing\n        self._radius_rewire = 15.0  # Radius for rewiring neighbors\n        self._max_dist_base = max(self._get_grid().size) / 10.0  # Base max_dist adaptive to grid size\n\n    def _get_adaptive_max_dist(self) -> float:\n        # Adaptive max_dist based on environment size and progress towards goal\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        dist = Map.get_distance(agent_pos, goal_pos)\n        max_dist = min(self._max_dist_base, dist / 5.0)\n        if max_dist < 1.5:\n            max_dist = 1.5\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pt)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with fallback to random valid position\n        if np.random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _calc_cost(self, parent: Vertex, child_pos: Point) -> float:\n        # Cost from parent to child plus parent's cost\n        movement_cost = self._get_grid().get_movement_cost(parent.position, child_pos)\n        return parent.cost + movement_cost\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        # For each neighbor, try to improve cost through q_new\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = self._calc_cost(q_new, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove all parents and set q_new as parent, update cost, and propagate cost down tree\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                self._update_costs_from_vertex(neighbor)\n\n    def _update_costs_from_vertex(self, vertex: Vertex) -> None:\n        # Propagate cost updates downward from vertex\n        from collections import deque\n        queue = deque([vertex])\n        while queue:\n            v = queue.popleft()\n            # Update cost to min over parents\n            min_cost = float('inf')\n            chosen_parent = None\n            for p in v.parents:\n                cost_candidate = p.cost + self._get_grid().get_movement_cost(p.position, v.position)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    chosen_parent = p\n            if min_cost < v.cost:\n                v.cost = min_cost\n            # Enqueue children to update\n            for c in v.children:\n                queue.append(c)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path by following parents and perform shortcutting for smoothing\n        path = [goal_vertex]\n        current = goal_vertex\n        while current.parents:\n            # Always pick parent with lowest cost to ensure optimal path\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            current = min_parent\n            path.append(current)\n        path.reverse()\n\n        # Shortcut path smoothing: attempt to directly connect non-adjacent points\n        def can_connect_directly(p1: Point, p2: Point) -> bool:\n            line_seq = self._get_grid().get_line_sequence(p1, p2)\n            return self._get_grid().is_valid_line_sequence(line_seq)\n\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if can_connect_directly(path[i].position, path[j].position):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, move one forward\n                smoothed_path.append(path[i + 1])\n                i += 1\n\n        # Animate movement following the smoothed path\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        self._graph.root_vertices.clear()\n        self._graph.root_vertices.append(start_vertex)\n        max_iterations = 5000\n\n        for it in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:\n                # Stop search after 10 seconds and treat as failure\n                break\n\n            max_dist = self._get_adaptive_max_dist()\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check line validity\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate cost for q_new\n            new_cost = self._calc_cost(q_near, q_new.position)\n            q_new.cost = new_cost\n\n            # Try to find better parent within radius (rewiring step)\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._radius_rewire)\n            best_parent = q_near\n            best_cost = new_cost\n\n            for neighbor in neighbors:\n                line_seq_n = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_n):\n                    continue\n                cost_through_neighbor = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n                if cost_through_neighbor < best_cost:\n                    best_cost = cost_through_neighbor\n                    best_parent = neighbor\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if better cost found through q_new\n            self._rewire(q_new, neighbors)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex and connect\n                goal_vertex = Vertex(grid.goal.position)\n                # Check direct line validity from q_new to goal\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT*-inspired planner with goal-biased sampling,\n    adaptive step size control, rewiring for path cost optimization, and path shortcut smoothing.\n    It integrates heuristic cost guidance (Euclidean + movement cost) for selecting optimal parent,\n    dynamically adjusts max extension distance based on progress, and terminates early if the goal is\n    reached or the search takes longer than 10 seconds. This aims to improve efficiency, path quality,\n    and success rate compared to classical RRT, while maintaining robustness in complex grid environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph: Forest = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring edges for path improvement\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Generate a new vertex in direction of q_sample but limited by max_dist\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir_vec)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / norm_dir\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self, goal_bias: float = 0.15) -> Point:\n        \"\"\"\n        Sampling with goal bias: with probability goal_bias, return goal position,\n        otherwise random valid sample.\n        \"\"\"\n        if np.random.rand() < goal_bias:\n            return self._get_grid().goal.position\n\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"\n        Given a set of vertices near q_new, choose best parent that minimizes total cost.\n        \"\"\"\n        best_parent = None\n        best_cost = float(\"inf\")\n        for q_near in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            tentative_cost = q_near.cost + move_cost\n            if tentative_cost < best_cost:\n                best_cost = tentative_cost\n                best_parent = q_near\n\n        if best_parent is not None:\n            q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: list) -> None:\n        \"\"\"\n        Try to improve path cost by rewiring neighbors through q_new if beneficial.\n        \"\"\"\n        for q_near in near_vertices:\n            if q_near == q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            move_cost = self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            tentative_cost = q_new.cost + move_cost\n            if tentative_cost < q_near.cost:\n                # Rewire: remove old parent edge(s), add edge from q_new to q_near\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = tentative_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract the path by traversing parents from goal vertex back to start.\n        Then smooth the path by shortcutting while verifying valid lines.\n        \"\"\"\n        path_vertices = [q_goal]\n        current = q_goal\n        while current.parents:\n            # Choose the cheapest parent (there might be multiple parents)\n            current = min(current.parents, key=lambda v: v.cost)\n            path_vertices.append(current)\n        path_vertices.reverse()\n\n        # Shortcut smoothing of path to reduce unnecessary waypoints\n        smoothed_path = [path_vertices[0]]\n        i = 0\n        while i < len(path_vertices) - 1:\n            j = len(path_vertices) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(smoothed_path[-1].position, path_vertices[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path_vertices[j])\n            i = j\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist: float = 15.0\n        base_max_dist: float = max_dist\n        iterations_limit: int = 10000\n        goal_radius: float = self._get_grid().goal.radius\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        found_goal: bool = False\n        q_goal_vertex = None\n\n        for iteration in range(iterations_limit):\n            # Early stop by time limit\n            if time.time() - start_time > 10.0:\n                break\n\n            q_sample = self._get_random_sample(goal_bias=0.2)\n\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on distance to goal and iteration count\n            dist_to_goal = Map.get_distance(q_nearest.position, self._get_grid().goal.position)\n            adap_max_dist = min(base_max_dist, max(5.0, dist_to_goal * 0.5))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, adap_max_dist)\n\n            line_seq_new = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq_new):\n                continue\n\n            # Find neighbors within radius for rewiring and parent choosing\n            neighbor_radius = adap_max_dist * 2.0\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, neighbor_radius)\n            if not neighbors:\n                neighbors = [q_nearest]\n\n            # Choose best parent for q_new from neighbors to minimize cost\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if possible to shorten paths\n            self._rewire(q_new, neighbors)\n\n            # Check if the q_new has reached the goal vicinity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex to finalize path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    q_goal_vertex = goal_vertex\n                    break\n\n            self.key_frame()\n\n        if found_goal and q_goal_vertex is not None:\n            self._extract_path(q_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved sample-based path planning inspired by RRT* with goal biasing,\n    adaptive step size, rewiring for path quality improvement, and timeout-based early stopping.\n    It samples points biased towards the goal to speed connection and adaptively reduces max step size \n    near obstacles or dense regions. Newly added vertices are rewired to nearby vertices if it reduces cost,\n    promoting smoother and shorter paths. The search terminates early upon timeout or successful goal reach.\n    Path extraction includes smoothing shortcuts after finding a connection to the goal.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = dir_vec.norm()\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / length\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_bias: float = 0.2) -> Point:\n        # With goal_bias probability, sample exactly the goal point to bias growth\n        if np.random.rand() < goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(\n            [self._graph.root_vertex_start], q_new.position, radius\n        )\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        return frm.cost + self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _choose_parent(self, near_vertices: list, q_near: Vertex, q_new: Vertex) -> Vertex:\n        best_parent = q_near\n        best_cost = self._cost(q_near, q_new)\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            c = self._cost(v, q_new)\n            if c < best_cost:\n                best_cost = c\n                best_parent = v\n        q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: list) -> None:\n        for v in near_vertices:\n            if v == q_new.parents or v.position == q_new.position:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = self._cost(q_new, v)\n            if new_cost < v.cost:\n                # Remove old parent edges to v\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _smooth_path(self, path: list) -> list:\n        # Attempt to shortcut between non-consecutive vertices on the path to smooth it\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # shortcut possible: remove intermediate vertices between i and j\n                    path = path[:i + 1] + path[j:]\n                    break\n                j -= 1\n            i += 1\n        return path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: list = [goal_v]\n        cur = goal_v\n        while cur.position != self._graph.root_vertex_start.position:\n            parents = list(cur.parents)\n            if not parents:\n                break\n            cur = min(parents, key=lambda p: p.cost)\n            path.append(cur)\n        path.reverse()\n        path = self._smooth_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        base_max_dist = 15.0\n        goal_reach_radius = 3.0\n        iteration_limit = 10000\n\n        # Initialize cost for root start vertex\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(iteration_limit):\n            if time.time() - start_time > 10.0:\n                # Timeout timeout - fail to find path in allowed time\n                break\n\n            q_sample = self._get_random_sample(goal_bias=0.3)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size: shorten max_dist if closer to obstacles (risk area)\n            # For simplicity, we reduce max_dist near obstacles by checking buffer around q_near\n            max_dist = base_max_dist\n            nearby_points = self._get_grid().get_vertices_within_radius if hasattr(self._graph, \"get_vertices_within_radius\") else None\n            # Since there is no direct obstacle proximity method, approximate adaptive max_dist with fixed base_max_dist\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Neighbor radius proportional to step size, heuristic based on dimension size\n            radius = max_dist * 2.0\n            near_vertices = self._get_near_vertices(q_new, radius)\n\n            # Choose best parent from neighbors (rewiring parent selection)\n            q_new.cost = float('inf')\n            parent_vertex = self._choose_parent(near_vertices, q_near, q_new)\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire neighbors to improve path quality\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            # Optional: dynamically decrease iterations or increase goal bias after some iterations (not mandatory here)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved sample-based path planning algorithm inspired by RRT and RRT*.\n    This algorithm uses:\n    - Goal-biased sampling with adaptive probability to speed convergence to goal.\n    - Dynamic max_dist step size based on current iteration progress to improve exploration and refinement.\n    - Heuristic-driven nearest vertex selection (cost-to-go + cost-from-start).\n    - RRT* style rewiring to improve path quality online.\n    - Post extraction shortcut smoothing of the path for smoother, shorter paths.\n    - Early stopping if solution found or after 10 seconds timeout.\n    - Uses DFS walk to rewire neighbors efficiently.\n    Goals:\n    - Efficient planning with fewer iterations by focusing sampling towards goal adaptively.\n    - Better path quality due to rewiring and smoothing.\n    - Robustness via rewiring and heuristic guidance.\n    - Higher success rate using goal bias and timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring edges for RRT* improvements\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _get_cost(self, parent: Vertex, child: Vertex) -> float:\n        # Movement cost plus parent's cost for total path cost estimate\n        move_cost = self._get_grid().get_movement_cost(parent.position, child.position)\n        return parent.cost + move_cost\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> Vertex:\n        # RRT* style parent choosing with minimum cost via neighbors connecting\n        best_parent = None\n        best_cost = float(\"inf\")\n        for neighbor in neighbors:\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = self._get_cost(neighbor, q_new)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = neighbor\n        return best_parent if best_parent is not None else neighbors[0]\n\n    def _rewire(self, q_new: Vertex, neighbors: list[Vertex]):\n        # Try to rewire neighbors through q_new if it improves their cost\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = self._get_cost(q_new, neighbor)\n            if new_cost < neighbor.cost:\n                # Remove old parent edge(s) and connect through q_new\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> list[Vertex]:\n        # Extract path by backtracking from goal vertex to start\n        path = []\n        current = q_goal\n        while current.parents:\n            path.append(current)\n            # Choose parent with lowest cost for path\n            parent = min(current.parents, key=lambda p: p.cost)\n            current = parent\n        path.append(current)  # add start vertex\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        # Try shortcutting the path for smoother trajectory\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _get_random_sample(self, goal_bias_prob: float) -> Point:\n        # Goal bias sampling: sample goal with goal_bias_prob chance or random valid position\n        if np.random.rand() < goal_bias_prob:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_iterations = 5000\n        max_dist_min = 4.0\n        max_dist_max = 15.0\n        goal_bias_start = 0.1\n        goal_bias_end = 0.6\n        rewire_radius = 15.0\n\n        start_time = time.time()\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        root_start = self._graph.root_vertex_start\n        root_start.cost = 0.0\n        root_goal = self._graph.root_vertex_goal\n\n        found_solution = False\n        best_goal_vertex = None\n\n        for i in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:  # timeout after 10 seconds\n                break\n\n            # Adaptive goal bias and step size (max_dist)\n            goal_bias_prob = goal_bias_start + (goal_bias_end - goal_bias_start) * (i / max_iterations)\n            max_dist = max_dist_max - (max_dist_max - max_dist_min) * (i / max_iterations)\n\n            q_sample = self._get_random_sample(goal_bias_prob)\n            q_near = self._graph.get_nearest_vertex([root_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find neighbors within rewire radius for RRT*\n            neighbors = self._graph.get_vertices_within_radius([root_start], q_new.position, rewire_radius)\n            if len(neighbors) == 0:\n                neighbors = [q_near]\n\n            q_new_parent = self._choose_parent(neighbors, q_new)\n            q_new.cost = self._get_cost(q_new_parent, q_new)\n            self._graph.add_edge(q_new_parent, q_new)\n\n            # Rewire neighbors around q_new for cost improvement\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is in goal radius; if yes update solution if better\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex as edge if valid\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_pos)):\n                    q_goal_candidate = Vertex(goal_pos, store_connectivity=True)\n                    q_goal_candidate.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_pos)\n                    self._graph.add_edge(q_new, q_goal_candidate)\n                    if (not found_solution) or (q_goal_candidate.cost < (best_goal_vertex.cost if best_goal_vertex else float(\"inf\"))):\n                        found_solution = True\n                        best_goal_vertex = q_goal_candidate\n\n            self.key_frame()\n\n            if found_solution:\n                # Early stop on first found improved path\n                break\n\n        if found_solution and best_goal_vertex:\n            path = self._extract_path(best_goal_vertex)\n            path = self._shortcut_path(path)\n            for vertex in path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Sample-Based Path Planning Algorithm with RRT*-style rewiring,\n    goal biasing, adaptive max distance, and shortcut smoothing for enhanced\n    path quality and efficiency.\n\n    Algorithm Highlights:\n    - Adaptive max_dist based on distance to goal, allowing larger exploratory steps far \n      from goal and finer control near goal.\n    - Goal-biased sampling (20% probability samples goal directly) for quicker convergence.\n    - Cost-aware rewiring of nearby vertices within radius to improve path quality like RRT*.\n    - Early stopping if route found or time exceeds 10 seconds.\n    - Shortcut smoothing after path extraction for smoother, shorter paths.\n    - Uses existing helpers: _get_random_sample, _get_new_vertex, _extract_path (modified).\n    - Stores vertices in a Forest graph with proper cost updates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_min: float = 3.0\n    _max_dist_max: float = 15.0\n    _goal_sample_rate: float = 0.2\n    _near_radius_factor: float = 20.0  # Radius for rewiring\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                 Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                 [])\n        self._graph.edges_removable = True  # Enable rewiring/removal of edges\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, current_pos: Point, goal_pos: Point) -> float:\n        dist = self._get_grid().get_distance(current_pos, goal_pos)\n        # Linearly interpolate between max_dist_min and max_dist_max based on distance to goal\n        dist_clamped = min(dist, self._max_dist_max)\n        max_dist = self._max_dist_min + (self._max_dist_max - self._max_dist_min) * (dist_clamped / self._max_dist_max)\n        return max_dist\n\n    def _get_random_sample_with_goal_bias(self) -> Point:\n        # 20% goal biased sampling for faster convergence\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _line_cost(self, frm: Point, to: Point) -> float:\n        # Cost function based on movement cost and distance\n        return self._get_grid().get_movement_cost(frm, to)\n\n    def _rewire_near_vertices(self, q_new: Vertex, near_vertices: list) -> None:\n        # Try rewiring nearby vertices to connect via q_new if this reduces cost\n        for q_near in near_vertices:\n            if q_new == q_near:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_cost = q_new.cost + self._line_cost(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    # Remove old parent edges and add new one\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n                    # Propagate cost improvement down the subtree of q_near\n                    self._propagate_cost_downstream(q_near)\n\n    def _propagate_cost_downstream(self, vertex: Vertex) -> None:\n        # Propagate lowered costs down all children recursively\n        for child in vertex.children:\n            old_cost = child.cost\n            new_cost = vertex.cost + self._line_cost(vertex.position, child.position)\n            if new_cost < old_cost:\n                child.cost = new_cost\n                # Recurse\n                self._propagate_cost_downstream(child)\n\n    def _extract_and_smooth_path(self, q_goal: Vertex) -> None:\n        path_vertices = [q_goal]\n        while len(path_vertices[-1].parents) != 0:\n            parent = next(iter(path_vertices[-1].parents))\n            path_vertices.append(parent)\n        path_vertices.reverse()\n\n        # Shortcut smoothing on path vertices positions\n        smoothed_positions = self._shortcut_path_smoothing([v.position for v in path_vertices])\n\n        # Animate moving agent along smoothed path\n        for pos in smoothed_positions:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path_smoothing(self, path: list) -> list:\n        # Attempt to shortcut path segments while maintaining collision-free paths\n        if len(path) <= 2:\n            return path\n\n        smooth_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            found = False\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i], path[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smooth_path.append(path[j])\n                    i = j\n                    found = True\n                    break\n                j -= 1\n            if not found:\n                smooth_path.append(path[i+1])\n                i += 1\n        return smooth_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_iterations = 7000  # Slightly smaller than original for faster attempts\n\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n\n        # Initialize costs\n        root_start.cost = 0.0\n        for v in self._graph.root_vertices:\n            v.cost = float('inf')\n        root_start.cost = 0.0\n\n        found_path = False\n\n        for i in range(max_iterations):\n\n            # Check for timeout > 10 seconds\n            if time() - start_time > 10:\n                break\n\n            q_sample = self._get_random_sample_with_goal_bias()\n\n            q_near = self._graph.get_nearest_vertex([root_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position, root_goal.position)\n            q_new_vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            q_new = Vertex(q_new_vertex.position, store_connectivity=True)\n\n            # Check line validity\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost to reach q_new via q_near\n            cost_q_new = q_near.cost + self._line_cost(q_near.position, q_new.position)\n            q_new.cost = cost_q_new\n\n            # Connect q_new with lowest cost parent within radius (choose optimal parent)\n            radius = self._near_radius_factor * max_dist / self._get_grid().size.n_dim\n            near_vertices = self._graph.get_vertices_within_radius([root_start], q_new.position, radius)\n            lowest_cost = cost_q_new\n            best_parent = q_near\n\n            for q_near_r in near_vertices:\n                if q_near_r == q_near:\n                    continue\n                line_seq_candidate = self._get_grid().get_line_sequence(q_near_r.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    cost_candidate = q_near_r.cost + self._line_cost(q_near_r.position, q_new.position)\n                    if cost_candidate < lowest_cost:\n                        lowest_cost = cost_candidate\n                        best_parent = q_near_r\n\n            # Add best edge and update cost\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = lowest_cost\n\n            # Rewire neighbors to q_new if beneficial\n            if len(near_vertices) > 0:\n                self._rewire_near_vertices(q_new, near_vertices)\n\n            # Check goal reached\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal with an edge if possible (validate line)\n                line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, root_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                    cost_to_goal = q_new.cost + self._line_cost(q_new.position, root_goal.position)\n                    if root_goal.cost > cost_to_goal:\n                        # Remove old parents of goal and add new edge\n                        for p in list(root_goal.parents):\n                            self._graph.remove_edge(p, root_goal)\n                        self._graph.add_edge(q_new, root_goal)\n                        root_goal.cost = cost_to_goal\n\n                    self._extract_and_smooth_path(root_goal)\n                    found_path = True\n                    break\n\n            self.key_frame()\n\n        # If no path found within time or iterations, treat as failure (no movement)\n        if not found_path:\n            # Optionally implement graceful failure or keep agent stationary\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved sample-based planner inspired by RRT* with goal-biasing and adaptive step size.\n    It integrates heuristic cost-to-go to guide samples and rewires the graph to optimize paths dynamically.\n    Additionally, it employs:\n    - Goal biasing to increase samples near the goal for faster convergence.\n    - Adaptive max step distance based on obstacles density near sample points.\n    - Path rewiring to improve previously found paths (RRT* style).\n    - Early stopping once a path reaches the goal with shortcut-based path smoothing.\n    - Time limit cutoff (10s) for planning process to control computational resources.\n    The cost function is Euclidean distance plus actual movement cost on the grid.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # needed for rewiring\n        self._init_displays()\n        self._max_dist_default = 10\n        self._goal_sample_rate = 0.2  # 20% bias towards goal sampling\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling with 20% probability sample goal directly\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n\n        while True:\n            rand_pos_np = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos_np)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _heuristic_cost(self, p_from: Point, p_to: Point) -> float:\n        # Euclidean + movement cost heuristic\n        euc_dist = Map.get_distance(p_from, p_to)\n        # Movement cost from p_from to p_to\n        move_cost = self._get_grid().get_movement_cost(frm=p_from, to=p_to)\n        return euc_dist + move_cost\n\n    def _get_nearest_vertex_cost(self, vertices: List[Vertex], point: Point) -> Vertex:\n        # Find the vertex in vertices with minimal cost + heuristic to point (inspired by A*-like)\n        min_total_cost = float('inf')\n        nearest = None\n        for v in vertices:\n            dist = Map.get_distance(v.position, point)\n            # cost: existing cost to v + dist from v to point (heuristic)\n            total_cost = v.cost + dist\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                nearest = v\n        return nearest\n\n    def _vertices_near(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return [v for v in vertices if Map.get_distance(v.position, point) <= radius]\n\n    def _update_vertex_cost(self, vertex: Vertex):\n        # Set vertex cost as minimum cost among parents + edge cost\n        min_cost = float('inf')\n        best_parent = None\n        for p in vertex.parents:\n            edge_cost = self._get_grid().get_movement_cost(frm=p.position, to=vertex.position)\n            new_cost = p.cost + edge_cost\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = p\n        vertex.cost = min_cost if min_cost != float('inf') else 0\n        # Ensure single parent to keep tree structure (can be multiple for cyclic graph; here we keep one)\n        if best_parent is not None and best_parent not in vertex.parents:\n            vertex.parents.clear()\n            vertex.add_parent(best_parent)\n        # For children, their costs will be updated in rewiring step\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # For each neighbor, check if going through q_new yields better cost\n        cost_q_new = q_new.cost\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            edge_cost_new_to_neighbor = self._get_grid().get_movement_cost(frm=q_new.position, to=neighbor.position)\n            new_cost = cost_q_new + edge_cost_new_to_neighbor\n            if new_cost < neighbor.cost:\n                # Check if line of sight is valid (no collision)\n                line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove previous parent edge(s)\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n                    # Propagate cost changes downward recursively\n                    self._propagate_cost_to_children(neighbor)\n\n    def _propagate_cost_to_children(self, vertex: Vertex):\n        for child in vertex.children:\n            old_cost = child.cost\n            edge_cost = self._get_grid().get_movement_cost(frm=vertex.position, to=child.position)\n            potential_new_cost = vertex.cost + edge_cost\n            if potential_new_cost < old_cost:\n                child.cost = potential_new_cost\n                self._propagate_cost_to_children(child)\n\n    def _extract_path(self, q_goal: Vertex):\n        # Trace path from goal to start (unique path because tree)\n        path = []\n        current = q_goal\n        # Could be multiple parents, but in this algorithm we keep a tree with 1 parent per vertex\n        while current is not None:\n            path.append(current)\n            if not current.parents:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        # Path shortcutting to smooth path\n        path = self._shortcut_path(path)\n\n        # Visualize path agent movement\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by skipping intermediate vertices if direct path is valid\n        if len(path) <= 2:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortened_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, just append next vertex\n                shortened_path.append(path[i + 1])\n                i += 1\n        return shortened_path\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        # Reduces max_dist if many obstacles near q_near, else uses default\n        obs_detect_radius = 5.0\n        obstacles = self._get_grid().obstacles\n        q_pos = q_near.position\n        nearby_obs_count = 0\n        for obs in obstacles:\n            dist_obs_agent = Map.get_distance(q_pos, obs.position)\n            if dist_obs_agent < obs_detect_radius + obs.radius:\n                nearby_obs_count += 1\n        # Heuristic: more obstacles -> smaller max_dist\n        max_dist = self._max_dist_default * (1.0 / (1 + nearby_obs_count))\n        # Clamp to min 2.0 and max default\n        max_dist = min(max_dist, self._max_dist_default)\n        max_dist = max(max_dist, 2.0)\n        return max_dist\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        iterations = 10000\n        radius_rewire = 15.0  # neighborhood radius for rewiring\n\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n        root_start.cost = 0\n\n        found_path_vertex = None\n\n        for i in range(iterations):\n\n            # Time cutoff\n            if time.time() - start_time > 10:\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Get nearest vertex based on cost + heuristic\n            q_near = self._get_nearest_vertex_cost([root_start] + list(self._graph.root_vertices), q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            # Initialize costs for new vertex\n            q_new.cost = float('inf')\n\n            # Find vertices near q_new within radius for rewiring (and selecting best parent)\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius_rewire)\n\n            # Choose best parent for q_new based on cost + edge cost\n            min_cost = float('inf')\n            best_parent = None\n            for near_v in near_vertices:\n                line_n = self._get_grid().get_line_sequence(near_v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_n):\n                    edge_cost = self._get_grid().get_movement_cost(frm=near_v.position, to=q_new.position)\n                    total_cost = near_v.cost + edge_cost\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_parent = near_v\n\n            # If no valid parent found, check q_near\n            if best_parent is None:\n                # Check q_near edge\n                edge_ok = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                if edge_ok:\n                    best_parent = q_near\n                    min_cost = q_near.cost + self._get_grid().get_movement_cost(frm=q_near.position, to=q_new.position)\n\n            if best_parent is None:\n                continue\n\n            # Add vertex and edge with best parent\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = min_cost\n\n            # Rewire other neighbors via q_new if better cost\n            self._rewire(q_new, near_vertices)\n\n            # Add q_new to root vertices for expansion (important for nearest/rewiring functions)\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal reached with q_new\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                found_path_vertex = q_new\n                break\n\n            self.key_frame()\n\n        if found_path_vertex:\n            self._extract_path(found_path_vertex)\n        else:\n            # No path found within time, optional: could visualize failure or reset\n            pass",
     "objective": null,
     "other_inf": null
}
