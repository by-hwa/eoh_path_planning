{
     "algorithm": "This algorithm, named PathPlanning, implements a heuristic-guided, goal-biased adaptive sampling RRT*\n    variant combined with path smoothing and adaptive max step distance.\n\n    Features:\n    - Goal bias sampling with configurable probability to accelerate reaching goal region.\n    - Use of A*-like cost heuristic (sum of exact cost so far + Euclidean distance to goal) for vertex expansion and rewiring.\n    - Adaptive max_dist that shrinks as the tree grows denser to improve path quality and smoother connections.\n    - Iteration early stopping if goal reached or if total time > 10 seconds.\n    - Post-processing path shortcutting/smoothing to improve path quality.\n    - Dynamic rewiring radius dependent on tree size to better exploit local connectivity.\n\n    This algorithm balances exploration and exploitation with adaptive parameters,\n    aims to minimize total cost while ensuring robustness and efficiency.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_initial_dist = 15.0  # Initial maximum extension distance\n        self._max_iterations = 5000\n        self._goal_sampling_rate = 0.2  # 20% samples biased toward goal\n        self._rewiring_lambda = 40.0    # Parameter for radius calculation in rewiring\n        self._dimension = len(self._get_grid().size)\n        self._init_displays()\n\n    # Helper: Goal biased random sample\n    def _get_biased_sample(self) -> Point:\n        if torch.rand(1).item() < self._goal_sampling_rate:\n            # Sample exactly at goal to bias growth toward goal\n            return self._get_grid().goal.position\n        else:\n            # Uniform random valid sample in map\n            while True:\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item()\n                                 for i in range(self._get_grid().size.n_dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    # Heuristic cost: cost_so_far + Euclidean to goal\n    def _heuristic_cost(self, vertex: Vertex) -> float:\n        dist_to_goal = self._get_grid().get_distance(vertex.position, self._get_grid().goal.position)\n        return vertex.cost + dist_to_goal\n\n    # Adaptive max step depending on current graph size to improve precision as tree grows\n    def _adaptive_max_dist(self) -> float:\n        size = max(1, self._graph.size)\n        max_dist = max(3.0, min(self._max_initial_dist, 30.0 * (1.0 / (size ** 0.3))))\n        return max_dist\n\n    # Rewiring radius based on tree size\n    def _rewiring_radius(self) -> float:\n        size = max(1, self._graph.size)\n        radius = min(50.0, self._rewiring_lambda * ((torch.log(torch.tensor(size).float()) / torch.tensor(size).float()) ** (1.0 / self._dimension)))\n        return radius.item()\n\n    # Extract and smooth path using simple shortcutting approach\n    def _extract_and_smooth_path(self, goal_parent: Vertex) -> None:\n        path = [self._graph.root_vertex_goal]\n        v = goal_parent\n        # Walk back to start\n        while v is not None and v.parents:\n            path.append(v)\n            v = next(iter(v.parents))\n        path.append(self._graph.root_vertex_start)\n        path.reverse()\n\n        # Shortcut smoothing: try to jump and skip intermediate nodes if line is collision free\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # Key frame forced to ensure animation frame updated\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_dist = self._max_initial_dist\n\n        for iteration in range(self._max_iterations):\n            # Timeout check - stop if over 10 seconds\n            if (time.time() - start_time) > 10.0:\n                # Consider path not found, return without moving agent\n                return\n\n            q_sample: Point = self._get_biased_sample()\n\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max dist shrinks with tree growth\n            max_dist = self._adaptive_max_dist()\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_vec)\n\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dir_norm\n                q_new_tensor = q_nearest.position.to_tensor() + max_dist * dir_normalized\n                q_new_pos = Point.from_tensor(q_new_tensor)\n\n            # Check collision along line from q_nearest to q_new_pos\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Initialize cost with infinity temporarily\n            q_new.cost = float('inf')\n\n            # Radius for rewiring\n            radius = self._rewiring_radius()\n\n            neighbors: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose parent minimizing cost + distance to q_new\n            q_min = q_nearest\n            cost_min = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n            for neighbor in neighbors:\n                line_check = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position))\n                cost_candidate = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if line_check and cost_candidate < cost_min:\n                    q_min = neighbor\n                    cost_min = cost_candidate\n\n            q_new.cost = cost_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for better paths\n            for neighbor in neighbors:\n                if neighbor == q_min:\n                    continue\n                line_check = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position))\n                cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if line_check and cost_through_new < neighbor.cost:\n                    # Patch parent edge\n                    old_parents = list(neighbor.parents)\n                    for p in old_parents:\n                        self._graph.remove_edge(p, neighbor)\n                    neighbor.cost = None\n                    neighbor.cost = cost_through_new\n                    self._graph.add_edge(q_new, neighbor)\n\n            # Goal check with goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal with q_new\n                goal_vertex = self._graph.root_vertex_goal\n                dist_to_goal = self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n\n                self._extract_and_smooth_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an Adaptive Heuristic-Informed RRT* with goal biasing and rewiring.\n    It improves over classic RRT and RRT-Connect by incorporating:\n    - Goal-biased sampling (with increasing probability towards the goal as iterations progress).\n    - Adaptive step size that shrinks near obstacles or when close to goal for finer exploration.\n    - Heuristic cost estimation using Euclidean distance to goal to guide vertex rewiring and new vertex choices.\n    - Rewiring steps to improve path cost and smoothness by considering neighbor vertices.\n    - A priority queue-based search embedded in vertex expansions for cost-effective growth.\n    - Early stopping if path found or after 10 seconds elapsed.\n    - Final path smoothing via shortcutting to improve path quality before output.\n    The algorithm operates within a Forest graph data structure and uses vertices with costs for optimal planning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring edges\n        self._init_displays()\n\n        self._max_dist_max = 15.0\n        self._max_dist_min = 2.5\n        self._iterations_max = 8000\n        self._goal_sample_rate_start = 0.2  # Initial goal bias probability\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        # If close to goal, shrink max dist for finer steps\n        dist_goal = self._distance(pos, self._get_grid().goal.position)\n        if dist_goal < 10:\n            return max(self._max_dist_min, self._max_dist_max * (dist_goal / 10))\n        return self._max_dist_max\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        # Gradually increase goal bias probability during iterations\n        goal_bias_prob = min(0.8, self._goal_sample_rate_start + iteration * 0.0001)\n        if np.random.rand() < goal_bias_prob:\n            return self._get_grid().goal.position\n        else:\n            # Biased sampling: sample around the line start->goal plus random noise\n            start_pos = self._get_grid().agent.position\n            goal_pos = self._get_grid().goal.position\n            direction = (goal_pos.to_tensor() - start_pos.to_tensor()).numpy()\n            baseline = start_pos.to_tensor().numpy() + np.random.rand() * direction\n            \n            # Add Gaussian noise proportional to environment size\n            env_size = np.array(self._get_grid().size)\n            noise = np.random.normal(scale=env_size / 7.0)  # spread noise\n            sample_coords = baseline + noise\n            sample_coords = np.clip(sample_coords, 0, env_size - 1).astype(int)\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                # fallback to uniform random sample\n                while True:\n                    rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    sample = Point(*rand_pos)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / norm_dir\n        q_new_coord = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point.from_tensor(q_new_coord))\n        return q_new\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> list:\n        # Return vertices within radius for rewiring\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _line_valid(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Edge cost plus heuristic cost (cost-to-come + estimated cost-to-goal)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return frm.cost + move_cost\n\n    def _heuristic(self, point: Point) -> float:\n        # Euclidean distance to goal used as heuristic estimate\n        return self._distance(point, self._get_grid().goal.position)\n\n    def _rewire(self, q_new: Vertex, near_vertices: list):\n        # Try to improve path cost by connecting q_new as parent for neighbors if better cost\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            # Check if line valid and cost can improve\n            if self._line_valid(q_new.position, q_near.position):\n                new_cost = self._cost(q_new, q_near)\n                if new_cost < q_near.cost:\n                    # Rewire: remove old parent edge(s), add new edge\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        # Extract path by traversing parents up to root start\n        path = []\n        current = last_vertex\n        while current:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose parent with lowest cost (should be only one in tree)\n            parent = min(current.parents, key=lambda v: v.cost)\n            current = parent\n        path.reverse()\n\n        # Shortcut path smoothing by trying to shortcut between non-adjacent points\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_valid(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        # Move agent along smoothed path with key frames\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        root_start = self._graph.root_vertex_start\n        root_start.cost = 0.0\n        # Initialize root goal with infinite cost\n        root_goal = self._graph.root_vertex_goal\n        root_goal.cost = float('inf')\n\n        # Add root start vertex initially\n        open_set = [root_start]\n\n        for iteration in range(self._iterations_max):\n\n            if time.time() - start_time > 10:\n                # Timeout - no path found\n                break\n\n            q_sample = self._get_random_sample(iteration)\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Avoid duplicates\n            if q_new.position == q_near.position:\n                continue\n\n            if not self._line_valid(q_near.position, q_new.position):\n                continue\n\n            new_cost = self._cost(q_near, q_new)\n            q_new.cost = new_cost\n\n            # Insert q_new into graph\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire nearby vertices if better cost can be achieved through q_new\n            neighbor_radius = min(max_dist * 2.5, 15.0)\n            near_vertices = self._get_near_vertices(q_new, neighbor_radius)\n            self._rewire(q_new, near_vertices)\n\n            # Early stop if goal is within radius and connect if possible\n            if self._distance(q_new.position, self._get_grid().goal.position) <= max_dist * 1.5:\n                # Try connecting directly to goal position vertex if valid\n                if self._line_valid(q_new.position, root_goal.position):\n                    # Update goal cost and parent edge\n                    if self._cost(q_new, root_goal) < root_goal.cost:\n                        for p in list(root_goal.parents):\n                            self._graph.remove_edge(p, root_goal)\n                        self._graph.add_edge(q_new, root_goal)\n                        root_goal.cost = self._cost(q_new, root_goal)\n\n                    # Check if goal reached with improved cost => extract path & done\n                    if root_goal.cost < float('inf'):\n                        self._extract_path(root_goal)\n                        break\n\n            # Visualization frame update\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm combines heuristic-guided sampling, goal biasing, and adaptive radius rewiring with\n    dynamic max step size to improve convergence, efficiency, and path quality on grid maps.\n    It builds a forest structure similar to RRT*, but applies A*-inspired cost + heuristic for vertex selection,\n    aggressively rewires neighbors to optimize costs, and performs path shortcutting after path extraction.\n    To improve efficiency, it uses a sampling bias towards goal and open space around current best path,\n    and it stops early if a feasible path is found or if it runs beyond 10 seconds.\n    This approach aims for balanced planning time, smoothness, connectivity, and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _goal_bias_prob: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Init Forest with start and goal vertices; costs initialized later\n        start_v = Vertex(self._get_grid().agent.position)\n        start_v.cost = 0.0\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_v, goal_v, [])\n\n        # Parameters for planning\n        self._max_dist_base = 12.0         # Base maximum distance to extend tree steps\n        self._max_radius = 40.0            # Max radius for rewiring neighbors\n        self._lambda_rrt_star = 40.0       # Constant for rewiring radius calculation\n        self._dimension = len(self._get_grid().size)  # Dimensionality (usually 2)\n        self._goal_bias_prob = 0.15        # Probability to sample goal directly\n\n        self._init_displays()\n\n    def _heuristic_cost(self, p: Point) -> float:\n        # Euclidean distance heuristic from p to goal for guiding sampling and cost estimation\n        return self._get_grid().get_distance(p, self._get_grid().goal.position)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased and heuristic-guided adaptive sampling:\n        # With some probability sample goal directly for goal bias.\n        # Else sample from a Gaussian around the vector from start to goal, to focus search.\n        if np.random.rand() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n\n        start = self._get_grid().agent.position\n        goal = self._get_grid().goal.position\n        mean = (start.to_tensor() + goal.to_tensor()) / 2\n        cov_scale = self._max_dist_base * 4\n        cov = torch.eye(self._dimension) * cov_scale\n        sample_np = np.random.multivariate_normal(mean.numpy(), cov.numpy())\n\n        sample_point = Point(*np.round(sample_np).astype(int))\n        # If outside bounds or invalid, fall back to random uniform sample until valid\n        for _ in range(10):\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n            sample_np = np.random.randint(0, self._get_grid().size, size=self._dimension)\n            sample_point = Point(*sample_np)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Last resort fallback: random uniform sample\n        while True:\n            sample_np = np.random.randint(0, self._get_grid().size, size=self._dimension)\n            sample_point = Point(*sample_np)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Find nearest vertex in start-tree by cost+heuristic metric\n        vertices = [self._graph.root_vertex_start] + list(self._graph.root_vertex_start.children)\n        min_score = float('inf')\n        nearest = self._graph.root_vertex_start\n        for v in self._graph.root_vertices:\n            # Search start-tree vertices only\n            pass\n        # Instead, use graph internal function to get nearest vertex by Euclidean distance\n        nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n        return nearest\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        # Returns vertices within radius from vertex.position in start-tree vertices\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_adaptive_max_dist(self, q_near: Vertex) -> float:\n        # Adapt max_dist based on heuristic distance of q_near to goal\n        h = self._heuristic_cost(q_near.position)\n        max_dist = min(self._max_dist_base, max(4.0, h / 2))\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n        q_new = Vertex(Point.from_tensor(new_pos_tensor))\n        return q_new\n\n    def _rewire(self, q_new: Vertex, neighbors: list):\n        # Try to rewire the neighbors to q_new if it offers lower cost paths\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    # Remove old edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge from q_new to q_near\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, leaf: Vertex) -> None:\n        # Extract path by walking up parents and then shortcut to smooth path\n        path = []\n        current = leaf\n        while current.parents:\n            path.append(current)\n            # Pick first parent\n            for p in current.parents:\n                current = p\n                break\n        path.append(current)  # Add root start vertex\n        path.reverse()\n\n        # Shortcut path smoothing\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = j\n                    break\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n\n        # Follow smoothed path and move agent accordingly\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # If ROS extension available, publish waypoint\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self):\n        max_iterations = 3000\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Initialize costs for root vertices explicitly\n        start_vertex.cost = 0.0\n        goal_vertex.cost = float('inf')\n\n        dimension = self._dimension\n        lambda_rrt_star = self._lambda_rrt_star\n        max_radius = self._max_radius\n\n        for iteration in range(max_iterations):\n\n            # Check time limit - stop if exceeding 10 seconds\n            if time() - start_time > 10.0:\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Nearest vertex in start-tree\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Validate path from q_nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            dist_near_new = self._get_grid().get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_near_new\n\n            # Compute radius for neighborhood rewiring based on the graph size\n            card_v = max(1, self._graph.size)\n            log_card_v = np.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose the best parent for q_new from Q_near including q_nearest\n            q_min = q_nearest\n            c_min = q_new.cost\n\n            for q_near in Q_near:\n                line_seq_near_new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_near_new):\n                    continue\n                cost_candidate = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                if cost_candidate < c_min:\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if better path found\n            self._rewire(q_new, Q_near)\n\n            # Add q_new to forest root vertices list for tracking\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal is reached or inside goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal explicitly if possible\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    dist_to_goal = self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    # Extract and smooth path\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired planner combining goal-biased adaptive sampling, \n    dynamic step sizing, and rewiring for path quality optimization. It uses an adaptive max_dist based on \n    current graph density and environment scale. Sampling is biased toward the goal at configurable rates \n    to improve success speed and path smoothness. Each new vertex is connected to the best parent within \n    a neighborhood radius to minimize cost, then rewired to maintain optimality. The search halts when \n    the goal is reached or after 10 seconds to ensure timely response. The extracted path is shortcut-optimized \n    to improve smoothness. This approach enhances efficiency, robustness, and path quality versus plain RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True  # allow rewiring/removal for RRT*\n        self._init_displays()\n\n        # Parameters for adaptive sampling and planning\n        self._goal_bias: float = 0.15        # Probability to sample goal directly (goal bias)\n        self._max_iterations: int = 5000     # Max iterations for sample expansion\n        self._min_max_dist: float = 5.0       # Minimum max step size (for finer paths)\n        self._max_max_dist: float = 20.0      # Maximum max step size (for coarse environment)\n        self._rewire_radius_factor: float = 2.5  # Radius factor for neighbor search during rewiring\n\n    # Helper Functions #\n\n    def _get_max_dist(self) -> float:\n        \"\"\"\n        Adaptively computes max_dist step size based on graph size and grid size.\n        As graph grows, max_dist decreases to allow finer exploration and rewiring.\n        \"\"\"\n        graph_size: int = self._graph.size\n        grid_size_scalar: float = float(min(self._get_grid().size))  # assuming size tuple-like\n        decay_rate: float = 0.0005  # controls decay speed\n\n        step = self._max_max_dist * np.exp(-decay_rate * graph_size)\n        step_clamped = max(self._min_max_dist, min(step, self._max_max_dist))\n        return step_clamped\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Returns a random sample point with goal bias. With goal_bias probability,\n        the sampled point is the goal position to guide the tree.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_parent(self, near_vertices: 'List[Vertex]', q_new: Vertex) -> Vertex:\n        \"\"\"\n        Chooses the best parent vertex for q_new from nearby vertices minimizing:\n        cost(parent) + movement_cost(parent->q_new)\n        If none found, returns None.\n        \"\"\"\n        best_parent: Vertex = None\n        best_cost: float = float('inf')\n\n        for vertex in near_vertices:\n            movement_cost = self._get_grid().get_movement_cost(vertex.position, q_new.position)\n            total_cost = vertex.cost + movement_cost\n            if total_cost < best_cost:\n                line_seq = self._get_grid().get_line_sequence(vertex.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    best_cost = total_cost\n                    best_parent = vertex\n\n        return best_parent\n\n    def _rewire(self, near_vertices: 'List[Vertex]', q_new: Vertex) -> None:\n        \"\"\"\n        For each vertex near q_new, try to rewire the graph if going through q_new reduces cost.\n        Rewiring happens only if line connection is valid.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex == q_new.parents:\n                continue  # already parent or self\n\n            movement_cost = self._get_grid().get_movement_cost(q_new.position, vertex.position)\n            potential_cost = q_new.cost + movement_cost\n            if potential_cost < vertex.cost:\n                # check valid path\n                line_seq = self._get_grid().get_line_sequence(q_new.position, vertex.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                # remove old parent edge(s)\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = potential_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extracts and smoothes the final path from goal to start by following parents.\n        Then shortcut improves path by skipping unnecessary intermediate vertices.\n        Finally animates agent movement along path.\n        \"\"\"\n        # Connect last q_new to goal vertex explicitly (if disconnected)\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        line_seq_connect_goal = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n        if self._get_grid().is_valid_line_sequence(line_seq_connect_goal):\n            self._graph.add_edge(q_new, goal_v)\n            goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n        else:\n            goal_v.cost = float('inf')\n\n        path_vertices: list[Vertex] = [goal_v]\n        current_vertex = goal_v\n\n        while current_vertex.position != self._graph.root_vertex_start.position:\n            if not current_vertex.parents:\n                break  # no path found fully, exit early\n            parent = min(current_vertex.parents, key=lambda p: p.cost)\n            path_vertices.append(parent)\n            current_vertex = parent\n\n        path_vertices.reverse()\n\n        # Shortcut smoothing: attempt to directly connect non-adjacent vertices if path valid\n        def shortcut_path(path: list[Vertex]) -> list[Vertex]:\n            if len(path) <= 2:\n                return path\n            smoothed_path = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                while next_idx > idx + 1:\n                    line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        break\n                    next_idx -= 1\n                smoothed_path.append(path[next_idx])\n                idx = next_idx\n            return smoothed_path\n\n        path_vertices = shortcut_path(path_vertices)\n\n        for vertex in path_vertices:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        iteration = 0\n\n        start_vertex: Vertex = self._graph.root_vertex_start\n        goal_pos: Point = self._get_grid().goal.position\n\n        # Initialize cost for start vertex\n        start_vertex.cost = 0.0\n\n        while iteration < self._max_iterations:\n            iteration += 1\n\n            if (time.time() - start_time) > 10.0:  # early exit if over 10 seconds\n                break\n\n            max_dist: float = self._get_max_dist()\n\n            q_sample: Point = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Generate new vertex in direction q_sample from q_near with max_dist limit\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_vec)\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dist\n                new_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n                q_new_pos = Point.from_tensor(new_tensor)\n\n            # Check if new position is valid\n            if not self._get_grid().is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos, store_connectivity=True)\n\n            # Find all nearby vertices within rewiring radius\n            neighbor_radius = self._rewire_radius_factor * max_dist\n            near_vertices: list[Vertex] = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, neighbor_radius)\n\n            # Choose best parent minimizing cost\n            best_parent = self._choose_parent(near_vertices, q_new)\n\n            if best_parent is None:\n                # Fall back to q_near if no better parent\n                best_parent = q_near\n                # Sanity check connectivity (line was already checked above)\n            q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new_pos)\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new for potential cost improvement\n            self._rewire(near_vertices, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm improves upon classic RRT and SPRM ideas by integrating:\n     - Heuristic-guided, goal-biased sampling (sampling towards goal with increasing likelihood)\n     - Adaptive step size scaling based on progress and environment complexity\n     - Incremental rewiring as in RRT* to optimize paths and improve path quality dynamically\n     - Early stopping criteria: stops either on success or timeout (10 seconds)\n     - Path shortcutting via line-of-sight pruning to smooth the final extracted path\n     \n     The approach uses a bidirectional Forest with start and goal roots; at each iteration,\n     samples are drawn with a bias that gradually shifts toward the goal. Candidates are\n     connected with edges while rewiring locally to improve paths. On success, it extracts\n     and shortcuts the path. This balances efficiency, quality, and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _iterations: int\n    _max_dist: float\n    _rewire_radius: float\n    _timeout_s: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position, store_connectivity=False),\n                                 Vertex(self._get_grid().goal.position, store_connectivity=False),\n                                 [])\n        self._graph.edges_removable = True\n        self._iterations = 3000\n        self._max_dist = 12.0\n        self._rewire_radius = 20.0\n        self._timeout_s = 10.0\n        self._init_displays()\n\n    #\n    # Helper functions\n    #\n\n    def _get_random_sample(self, goal_bias_ratio: float) -> Point:\n        # With probability goal_bias_ratio, return the goal position, else random sample from valid space\n        import random\n        if random.random() < goal_bias_ratio:\n            return self._get_grid().goal.get_position()\n        else:\n            while True:\n                rand_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _steer(self, q_near: Vertex, q_rand: Point, max_dist: float) -> Vertex:\n        # Generate a new vertex towards q_rand from q_near with max step max_dist\n        dir_vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_rand)\n        else:\n            dir_unit = dir_vec / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + dir_unit * max_dist)\n            # Clamp inside grid boundaries and validate otherwise fallback to q_rand\n            if self._get_grid().is_agent_valid_pos(new_pos):\n                return Vertex(new_pos)\n            else:\n                # fallback safer new vertex creation by stepping smaller until valid or stop at q_near\n                step_frac = 0.5\n                while step_frac > 1e-3:\n                    candidate = Point.from_tensor(q_near.position.to_tensor() + dir_unit * (max_dist * step_frac))\n                    if self._get_grid().is_agent_valid_pos(candidate):\n                        return Vertex(candidate)\n                    step_frac *= 0.5\n                return Vertex(q_near.position)  # fallback (no valid step)\n\n    def _cost(self, v1: Vertex, v2: Vertex) -> float:\n        # Returns movement cost from v1 to v2 using the grid's movement cost\n        return self._get_grid().get_movement_cost(v1.position, v2.position)\n\n    def _nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        # Find nearest vertex by Euclidean distance\n        closest = None\n        closest_dist = float('inf')\n        for v in vertices:\n            dist = Map.get_distance(v.position, point)\n            if dist < closest_dist:\n                closest_dist = dist\n                closest = v\n        return closest\n\n    def _vertices_within_radius(self, vertices: List[Vertex], center_point: Point, radius: float) -> List[Vertex]:\n        # Return vertices within radius of center_point\n        return [v for v in vertices if Map.get_distance(v.position, center_point) <= radius]\n\n    def _rewire(self, new_vertex: Vertex) -> None:\n        # Rewire the tree locally for shorter paths around new_vertex within rewire radius\n        near_vertices = self._vertices_within_radius(self._graph.root_vertices, new_vertex.position, self._rewire_radius)\n        for near_vertex in near_vertices:\n            if near_vertex is new_vertex:\n                continue\n            line_seq = self._get_grid().get_line_sequence(new_vertex.position, near_vertex.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_cost = new_vertex.cost + self._cost(new_vertex, near_vertex)\n                if new_cost < near_vertex.cost:\n                    # Remove old parent edges to near_vertex\n                    old_parents = list(near_vertex.parents)\n                    for p in old_parents:\n                        self._graph.remove_edge(p, near_vertex)\n                    # Add new edge from new_vertex to near_vertex\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = new_cost\n\n    def _extract_path(self) -> None:\n        # Extract path from start to goal by parent tracing, then apply shortcutting\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Find goal vertex with lowest cost connected from start root tree\n        candidates = [v for v in self._graph.root_vertices if self._get_grid().is_goal_reached(v.position)]\n        if not candidates:\n            # fallback: use goal root vertex if isolated\n            candidates = [goal_vertex]\n\n        goal_reached_vertex = min(candidates, key=lambda v: v.cost if hasattr(v, 'cost') else float('inf'))\n\n        path = [goal_reached_vertex]\n        current = goal_reached_vertex\n        while current is not start_vertex:\n            if not current.parents:\n                # No path found, abort extraction, just move agent to position anyway\n                break\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda p: p.cost if hasattr(p,'cost') else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        # Shortcut path to smooth it by trying to replace intermediate nodes with direct edges if collision free\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            # Check max reachable next vertex by line-of-sight valid path\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(shortcut_path[-1].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n\n        for vertex in shortcut_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    #\n    # Core method (main algorithm)\n    #\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Initialize roots costs\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Store vertices explicitly for fast access (initially only roots)\n        vertices = [start_vertex, goal_vertex]\n\n        # Goal bias: start small, increase over iterations (approach goal sampling more over time)\n        initial_goal_bias = 0.05\n        max_goal_bias = 0.4\n\n        for iter_num in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_s:\n                # Timeout stop condition, fail safely\n                break\n\n            # Goal bias morphing toward max_goal_bias after many iterations\n            goal_bias = initial_goal_bias + (max_goal_bias - initial_goal_bias) * (iter_num / self._iterations)\n            goal_bias = min(goal_bias, max_goal_bias)\n\n            # Sample random point with goal bias\n            q_rand_point = self._get_random_sample(goal_bias)\n\n            # -- Extend start tree --\n            q_near_start = self._nearest_vertex([start_vertex] + vertices, q_rand_point)\n            q_new_start = self._steer(q_near_start, q_rand_point, self._max_dist)\n            if q_new_start.position == q_near_start.position:\n                # No valid extension\n                continue\n\n            # Check collision-free path from q_near_start to q_new_start\n            line_seq_start = self._get_grid().get_line_sequence(q_near_start.position, q_new_start.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq_start):\n                continue\n\n            # Cost calculation and add edge\n            q_new_start.cost = q_near_start.cost + self._cost(q_near_start, q_new_start)\n            self._graph.add_edge(q_near_start, q_new_start)\n            vertices.append(q_new_start)\n\n            # Rewiring in start tree to improve paths\n            self._rewire(q_new_start)\n\n            # -- Extend goal tree towards q_new_start position --\n            q_near_goal = self._nearest_vertex([goal_vertex] + vertices, q_new_start.position)\n            q_new_goal = self._steer(q_near_goal, q_new_start.position, self._max_dist)\n            if q_new_goal.position == q_near_goal.position:\n                continue\n\n            line_seq_goal = self._get_grid().get_line_sequence(q_near_goal.position, q_new_goal.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq_goal):\n                continue\n\n            q_new_goal.cost = q_near_goal.cost + self._cost(q_near_goal, q_new_goal)\n            self._graph.add_edge(q_near_goal, q_new_goal)\n            vertices.append(q_new_goal)\n            self._rewire(q_new_goal)\n\n            # Check if trees connected\n            dist_trees = Map.get_distance(q_new_start.position, q_new_goal.position)\n            if dist_trees <= self._max_dist:\n                # Try direct connection between q_new_start and q_new_goal\n                line_seq_connect = self._get_grid().get_line_sequence(q_new_start.position, q_new_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    # Create connecting edges between q_new_start and q_new_goal (bidirectional)\n                    self._graph.add_edge(q_new_start, q_new_goal)\n                    self._graph.add_edge(q_new_goal, q_new_start)\n\n                    # Path found, extract it and end search\n                    self._extract_path()\n                    return\n\n            # Visualization\n            self.key_frame()\n\n        # Run fallback: no path found after iterations or timeout, no movement made\n        return",
     "objective": null,
     "other_inf": null
}
