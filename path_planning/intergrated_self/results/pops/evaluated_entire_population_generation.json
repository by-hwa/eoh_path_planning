Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0087,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.23
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0073,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.23
}
{
     "algorithm": "Enhanced heuristic-biased RRT* with adaptive step size and smoothing:\n    - Uses goal-biased sampling to improve success in directed exploration.\n    - Adaptive max step size: dynamically adjusts based on closest obstacles or previous progress.\n    - Heuristic cost guide combines actual path cost and Euclidean heuristic (inspired by A*).\n    - Incorporates rewiring similar to RRT* for path quality improvement.\n    - Uses shortcut smoothing on the extracted path for smoother final trajectory.\n    - Early stopping if solution found or time exceeds 10 seconds to improve efficiency.\n    - Novel adaptive radius for neighbor search based on vertex count and environment scale.\n    - Attempts direct connection to goal when close, increasing robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_iterations: int\n    _max_time_seconds: float\n    _goal_sample_rate: float\n    _max_step_base: float\n    _smooth_iterations: int\n    _lambda_rrt_star: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 5000\n        self._max_time_seconds = 10.0\n        self._goal_sample_rate = 0.2  # 20% samples directed to goal\n        self._max_step_base = 12.0\n        self._smooth_iterations = 30\n        self._lambda_rrt_star = 40.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_sample_rate:\n            # Biased sampling towards goal\n            return self._get_grid().goal.position\n        else:\n            # Uniform random sampling in free space\n            while True:\n                dims = self._get_grid().size.n_dim\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dims)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_adaptive_step_size(self, q_nearest: Vertex) -> float:\n        # Estimate adaptive max step size based on nearby obstacle density:\n        radius_check = self._max_step_base\n        neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_nearest.position, radius_check)\n        obstacles_near = 0\n        grid = self._get_grid()\n        # Count nearby obstacles within small radius\n        obstacle_radius = self._max_step_base / 2\n        for obs in grid.obstacles:\n            dist = Map.get_distance(q_nearest.position, obs.position)\n            if dist < obstacle_radius + obs.radius:\n                obstacles_near += 1\n        # Shrink step if many obstacles nearby, else keep max\n        step = self._max_step_base if obstacles_near == 0 else max(self._max_step_base / (2 * obstacles_near), 3.0)\n        return step\n\n    def _heuristic_cost(self, vertex: Vertex) -> float:\n        # Estimated cost = actual cost + heuristic distance to goal\n        h = Map.get_distance(vertex.position, self._get_grid().goal.position)\n        return vertex.cost + h\n\n    def _get_neighbors_radius(self, card_v: int, dimension: int = 2) -> float:\n        # Adaptive radius ($r_n$) for RRT* style rewiring\n        import math\n        return min(self._lambda_rrt_star * ((math.log(card_v) / card_v) ** (1/dimension)), 50)\n\n    def _get_new_vertex(self, q_nearest: Vertex, q_sample: Point, step_size: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_nearest.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= step_size:\n            return Vertex(q_sample)\n        else:\n            direction_normalized = direction / dist\n            new_pos_tensor = q_nearest.position.to_tensor() + step_size * direction_normalized\n            new_pos = Point.from_tensor(new_pos_tensor)\n            return Vertex(new_pos)\n\n    def _try_shortcut(self, path: list) -> list:\n        # Path smoothing via shortcutting: try connecting non-consecutive path vertices directly\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, just go to next vertex\n                smoothed_path.append(path[i+1])\n                i += 1\n        return smoothed_path\n\n    def _extract_path(self, q_new: Vertex):\n        # Perform path extraction from q_new back to start\n        path = [q_new]\n        current = q_new\n        while len(current.parents) != 0:\n            for parent in current.parents:\n                current = parent\n                path.append(current)\n                break\n        path.reverse()\n\n        # Smooth the extracted path using shortcutting\n        for _ in range(self._smooth_iterations):\n            path = self._try_shortcut(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            # Support ROS waypoint publishing if available\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        grid = self._get_grid()\n        start_time = time.time()\n        dimension = grid.size.n_dim\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._max_time_seconds:\n                # Exceeded max allowed planning time - abort\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            step_size = self._get_adaptive_step_size(q_nearest)\n            q_new = self._get_new_vertex(q_nearest, q_sample, step_size)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = self._graph.size if self._graph.size > 0 else 1\n            radius = self._get_neighbors_radius(card_v, dimension)\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose parent with minimal cost + heuristic\n            q_min = q_nearest\n            dist_min = q_nearest.cost + Map.get_distance(q_nearest.position, q_new.position)\n            for neighbor in neighbors:\n                n_cost = neighbor.cost + Map.get_distance(neighbor.position, q_new.position)\n                line_seq_n = grid.get_line_sequence(neighbor.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq_n) and n_cost < dist_min:\n                    q_min = neighbor\n                    dist_min = n_cost\n\n            q_new.cost = dist_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves\n            for neighbor in neighbors:\n                line_seq_n2 = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq_n2):\n                    new_cost = q_new.cost + Map.get_distance(q_new.position, neighbor.position)\n                    if new_cost < neighbor.cost:\n                        # Remove old parent edge\n                        old_parent = None\n                        for p in neighbor.parents:\n                            old_parent = p\n                            break\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, neighbor)\n                        # Add new parent q_new\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n            # Check if q_new is close enough to goal for direct connection\n            dist_to_goal = Map.get_distance(q_new.position, grid.goal.position)\n            if dist_to_goal <= step_size:\n                line_seq_goal = grid.get_line_sequence(q_new.position, grid.goal.position)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(q_new)\n                    return\n\n            self.key_frame()",
     "objective": 9691.49,
     "other_inf": null,
     "results": {
          "goal_found_perc": 11.33,
          "average_steps": 6.76,
          "average_distance": 6.74,
          "average_smoothness": 0.25,
          "average_clearance": 2.4,
          "average_time": 0.026,
          "average_distance_from_goal": 2.06,
          "average_original_distance_from_goal": 8.42,
          "average memory": 47.29,
          "goal_found_perc_improvement": -88.36,
          "average_steps_improvement": -4.48,
          "average_distance_improvement": -3.37,
          "average_smoothness_improvement": -25.0,
          "average_clearance_improvement": 1.27,
          "average_time_improvement": -519.05,
          "average_distance_from_goal_improvement": -930.0,
          "average_path_deviation": 0.22000000000000064,
          "average_memory_improvement": -27.02
     }
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0075,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.23
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0077,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.23
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0077,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.23
}
{
     "algorithm": "This algorithm is a hybrid of informed sampling and heuristic-guided search inspired by RRT* and A*.\n    Key improvements:\n    - Adaptive sampling: 70% goal-biased samples, 30% random within informed ellipse (heuristic ellipse around start-goal),\n      focusing sampling in promising areas to reduce iterations and increase success rate.\n    - Adaptive step size: Step size changes based on distance to goal for more refined final approach.\n    - Heuristic cost estimate (A*-like) used to choose best parent and rewiring.\n    - Rewiring step performed for local optimality and path smoothing.\n    - Early stopping with 10 seconds timeout.\n    - Shortcut smoothing applied after path is found.\n    The result is a faster, more robust planner producing shorter and smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_iterations: int\n    _max_time_seconds: float\n    _step_size_min: float\n    _step_size_max: float\n    _goal_sample_rate: float\n    _informed_sampling_ratio: float\n    _dimension: int\n    \n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 5000\n        self._max_time_seconds = 10.0\n        self._step_size_min = 3.0\n        self._step_size_max = 15.0\n        self._goal_sample_rate = 0.7  # 70% samples bias toward goal\n        self._informed_sampling_ratio = 0.3 # 30% samples inside informed ellipse\n        self._dimension = len(self._get_grid().size)\n\n        self._init_displays()\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Euclidean distance heuristic\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_adaptive_step_size(self, position: Point) -> float:\n        # closer to goal -> smaller step size for refinement\n        dist_to_goal = self._heuristic_cost(position, self._get_grid().goal.position)\n        max_dist = self._step_size_max\n        min_dist = self._step_size_min\n        max_possible_dist = self._heuristic_cost(self._get_grid().agent.position, self._get_grid().goal.position)\n        if max_possible_dist < 1e-4:\n            return min_dist\n        ratio = dist_to_goal / max_possible_dist\n        step_size = min_dist + (max_dist - min_dist) * ratio\n        if step_size < min_dist:\n            step_size = min_dist\n        elif step_size > max_dist:\n            step_size = max_dist\n        return step_size\n\n    def _sample_in_ellipse(self) -> Point:\n        # Informed sampling in ellipse defined by start, goal, and best path length so far (simplified)\n        start = self._get_grid().agent.position.to_tensor()\n        goal = self._get_grid().goal.position.to_tensor()\n        c_best = self._heuristic_cost(self._get_grid().agent.position, self._get_grid().goal.position) * 1.5\n        c_min = self._heuristic_cost(self._get_grid().agent.position, self._get_grid().goal.position)\n        if c_min == 0:\n            return self._get_grid().goal.position\n        \n        # Ellipse parameters\n        center = (start + goal) / 2\n        a1 = (goal - start) / torch.norm(goal - start)  # unit vector from start->goal\n        # Orthogonal basis (2D assumption)\n        if self._dimension == 2:\n            a2 = torch.tensor([-a1[1], a1[0]])\n        else:\n            # In higher dims, pick random orthogonal vectors (simplified to unit cube here)\n            a2 = torch.zeros_like(a1)\n            a2[1] = 1.0\n\n        r1 = c_best / 2\n        # Convert r1 and c_best to torch.tensor to fix type mismatch for sqrt input\n        r1_tensor = torch.tensor(r1, dtype=torch.float)\n        c_best_tensor = torch.tensor(c_best, dtype=torch.float)\n        c_min_tensor = torch.tensor(c_min, dtype=torch.float)\n\n        r2 = torch.sqrt(c_best_tensor**2 - c_min_tensor**2) / 2\n\n        for _ in range(100):  # limit retries to find valid sample\n            sample_unit = torch.randn(self._dimension)\n            sample_unit = sample_unit / torch.norm(sample_unit)\n            # scale sample by ellipse radii (simplified 2D ellipse, for nD approximated by this approach)\n            sample_scaled = sample_unit * torch.tensor([r1_tensor.item() if i==0 else r2.item() for i in range(self._dimension)], dtype=torch.float)\n            # rotate and translate to ellipse center\n            pos_tensor = center + a1 * sample_scaled[0]\n            if self._dimension > 1:\n                pos_tensor = pos_tensor + a2 * sample_scaled[1]\n            sample_point = Point.from_tensor(pos_tensor)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        # Adaptive sampling: goal bias + informed region\n        import random\n        p = random.random()\n        if p < self._goal_sample_rate:\n            # direct goal bias\n            return self._get_grid().goal.position\n        elif p < self._goal_sample_rate + self._informed_sampling_ratio:\n            # informed ellipse sampling near start-goal\n            return self._sample_in_ellipse()\n        else:\n            # uniform random in free space\n            while True:\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dir_norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _extract_path(self, q_new: Vertex):\n        goal_v = Vertex(self._get_grid().goal.position)\n        goal_v.cost = q_new.cost + self._heuristic_cost(q_new.position, goal_v.position)\n        self._graph.add_edge(q_new, goal_v)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.pop()  # remove the start's parent (None)\n\n        path.reverse()\n\n        # Shortcut smoothing: attempt to shortcut path for fewer points\n        def shortcut_path(points: list) -> list:\n            if len(points) < 3:\n                return points\n            smoothed = [points[0]]\n            i = 0\n            while i < len(points)-1:\n                j = len(points)-1\n                while j > i+1:\n                    line_seq = self._get_grid().get_line_sequence(points[i].position, points[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        smoothed.append(points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # no shortcut found, move one step\n                    smoothed.append(points[i+1])\n                    i += 1\n            return smoothed\n\n        path_smoothed = shortcut_path(path)\n\n        for vertex in path_smoothed:\n            self.move_agent(vertex.position)\n            # ROS extension waypoint publish if applicable\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_dist_default = self._step_size_max\n        max_iterations = self._max_iterations\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > self._max_time_seconds:\n                # timeout, path not found\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            adaptive_step_size = self._get_adaptive_step_size(q_nearest.position)\n            q_new = self._get_new_vertex(q_nearest, q_sample, adaptive_step_size)\n\n            # Validate the path segment\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors for rewiring\n            card_v = float(self._graph.size) + 1  # avoid log(0)\n            log_card_v = torch.log(torch.tensor(card_v))\n            radius = min(50.0, 2.0 * ((log_card_v / card_v) ** (1 / self._dimension))) * adaptive_step_size\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent based on cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._heuristic_cost(q_nearest.position, q_new.position)\n\n            for neighbor in neighbors:\n                line_seq_candidate = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    continue\n\n                cost_candidate = neighbor.cost + self._heuristic_cost(neighbor.position, q_new.position)\n                if cost_candidate < c_min:\n                    c_min = cost_candidate\n                    q_min = neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new if better cost\n            for neighbor in neighbors:\n                line_seq_rewire = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    continue\n\n                cost_via_new = q_new.cost + self._heuristic_cost(q_new.position, neighbor.position)\n                if cost_via_new < neighbor.cost:\n                    # Remove old edge\n                    old_parent = None\n                    for p in neighbor.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, neighbor)\n                    # Add new edge\n                    neighbor.cost = cost_via_new\n                    self._graph.add_edge(q_new, neighbor)\n\n            # Check if goal reached within radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": 2293.295,
     "other_inf": null,
     "results": {
          "goal_found_perc": 79.33,
          "average_steps": 10.92,
          "average_distance": 11.45,
          "average_smoothness": 0.32,
          "average_clearance": 2.32,
          "average_time": 0.0202,
          "average_distance_from_goal": 2.14,
          "average_original_distance_from_goal": 8.42,
          "average memory": 58.69,
          "goal_found_perc_improvement": -18.49,
          "average_steps_improvement": -30.78,
          "average_distance_improvement": -31.31,
          "average_smoothness_improvement": -28.0,
          "average_clearance_improvement": 7.91,
          "average_time_improvement": -206.06,
          "average_distance_from_goal_improvement": -970.0,
          "average_path_deviation": 2.7299999999999986,
          "average_memory_improvement": -57.64
     }
}
{
     "algorithm": "This algorithm implements an Adaptive Heuristic RRT with Goal Bias and Dynamic Rewiring.\n    It incorporates:\n      - Adaptive max step distance based on distance to goal (larger steps far away, smaller close).\n      - Goal-biased sampling to increase chance of guiding towards goal.\n      - Heuristic-guided nearest vertex selection based on cost + heuristic (cost-to-come + Euclidean to goal).\n      - Rewiring of nearby vertices for path quality improvement similar to RRT*.\n      - Path shortcutting post path discovery for smoother path.\n      - Early stopping criteria (max 10 seconds runtime).\n    This aims to improve efficiency by faster convergence, improved success with goal-bias, \n    and produces smoother, shorter paths due to rewiring and shortcutting.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    _graph: Forest\n    _max_dist_base: float\n    _iterations: int\n    _start_time: float\n    \n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n        \n        self._max_dist_base = 15.0  # Base step distance; adaptive in _get_adaptive_max_dist\n        self._iterations = 8000\n    \n    def _get_heuristic_cost(self, from_v: Vertex) -> float:\n        # Euclidean distance from vertex to goal for heuristic\n        return self._get_grid().get_distance(from_v.position, self._graph.root_vertex_goal.position)\n    \n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        dist_to_goal = self._get_grid().get_distance(pos, self._graph.root_vertex_goal.position)\n        # Larger steps when far from goal, smaller steps when close\n        if dist_to_goal > 100:\n            return self._max_dist_base * 1.5\n        elif dist_to_goal < 10:\n            return max(3.0, self._max_dist_base * 0.3)\n        else:\n            return self._max_dist_base\n    \n    def _get_goal_biased_sample(self, goal_bias_prob: float = 0.2) -> Point:\n        # 20% chance sample is goal, else uniform random sample\n        import random\n        if random.random() < goal_bias_prob:\n            return self._graph.root_vertex_goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n    \n    def _get_nearest_vertex_heuristic(self, q_sample: Point) -> Vertex:\n        # Instead of pure Euclidean nearest, consider cost + heuristic for nearest vertex\n        candidates = self._graph.root_vertices\n        min_score = float('inf')\n        nearest_vertex = None\n        for root_vertex in candidates:\n            # Collect vertices efficiently around sample; fallback full vertex search if none found close\n            nearby_vertices = self._graph.get_vertices_within_radius([root_vertex], q_sample, radius=30.0)\n            search_vertices = nearby_vertices if nearby_vertices else [root_vertex]\n            for v in search_vertices:\n                # Cost-to-come + heuristic distance to goal + distance from sample -- together a prioritization heuristic\n                cost_to_come = v.cost if v.cost is not None else float('inf')\n                heuristic = self._get_grid().get_distance(v.position, self._graph.root_vertex_goal.position)\n                dist_sample_to_v = self._get_grid().get_distance(v.position, q_sample)\n                score = cost_to_come + heuristic + dist_sample_to_v\n                if score < min_score:\n                    min_score = score\n                    nearest_vertex = v\n        if nearest_vertex is None:\n            nearest_vertex = self._graph.root_vertex_start\n        return nearest_vertex\n    \n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n        return Vertex(q_new_point)\n    \n    def _get_vertices_within_rewire_radius(self, q_new: Vertex) -> list:\n        # Radius scales with sqrt(log(n)/n) similar to RRT*, capped to max radius for rewiring neighbors\n        card_v = torch.tensor(float(self._graph.size)) if self._graph.size > 0 else torch.tensor(1.0)\n        dimension = 2\n        gamma = 40  # parameter for radius calculation, tuned empirically\n        radius = min(gamma * ((torch.log(card_v) / card_v) ** (1 / dimension)), 30.0)\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius.item())\n    \n    def _rewire(self, q_new: Vertex, neighbor_vertices: list):\n        for q_near in neighbor_vertices:\n            if q_near == q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                cost_via_new = (q_new.cost if q_new.cost is not None else float('inf')) + self._get_grid().get_distance(q_new.position, q_near.position)\n                if q_near.cost is None or cost_via_new < q_near.cost:\n                    # Rewire parent edge\n                    old_parents = list(q_near.parents)\n                    for p in old_parents:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_via_new\n                    self._graph.add_edge(q_new, q_near)\n    \n    def _extract_path(self, q_goal: Vertex) -> list:\n        path = [q_goal]\n        while path[-1].parents:\n            # Select cheapest parent if multiple\n            min_cost = float('inf')\n            min_parent = None\n            for p in path[-1].parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            path.append(min_parent)\n        path.reverse()\n        return path\n    \n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        \n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n    \n    def _move_along_path(self, path: list) -> None:\n        grid = self._get_grid()\n        is_ros_map = grid.__class__.__name__ == \"RosMap\"\n        for v in path:\n            self.move_agent(v.position)\n            if is_ros_map:\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n    \n    def _find_path_internal(self) -> None:\n        import time\n        \n        start_time = time.time()\n        max_duration_secs = 10.0  # Stop after 10 seconds to avoid endless search\n        \n        for iteration in range(self._iterations):\n            if time.time() - start_time > max_duration_secs:\n                break  # Timeout\n            \n            q_sample = self._get_goal_biased_sample(goal_bias_prob=0.25)\n            max_dist = self._get_adaptive_max_dist(self._graph.root_vertex_start.position)\n            \n            q_nearest = self._get_nearest_vertex_heuristic(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            \n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            \n            if q_nearest.cost is None:\n                continue  # Skip if no cost assigned\n            \n            q_new.cost = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n            self._graph.add_edge(q_nearest, q_new)\n            \n            neighbors = self._get_vertices_within_rewire_radius(q_new)\n            # Choose parent with minimal cost (including q_new itself)\n            q_min = q_nearest\n            c_min = q_new.cost\n            for q_near in neighbors:\n                if q_near == q_new:\n                    continue\n                if q_near.cost is None:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    cost_via_near = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                    if cost_via_near < c_min:\n                        q_min = q_near\n                        c_min = cost_via_near\n            if q_min != q_nearest:\n                # Rewire q_new to better parent\n                old_parents = list(q_new.parents)\n                for p in old_parents:\n                    self._graph.remove_edge(p, q_new)\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n            \n            # Rewire neighbors to use q_new as parent if it improves cost\n            self._rewire(q_new, neighbors)\n            \n            # Check for goal reach within radius (agent radius)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex to q_new minimizing cost\n                goal_v = self._graph.root_vertex_goal\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_v.position)):\n                    goal_v.cost = (q_new.cost if q_new.cost is not None else float('inf')) + self._get_grid().get_distance(q_new.position, goal_v.position)\n                    self._graph.add_edge(q_new, goal_v)\n                    path = self._extract_path(goal_v)\n                    # Shortcut path for smoother trajectory\n                    path = self._shortcut_path(path)\n                    self._move_along_path(path)\n                    return\n            \n            self.key_frame()",
     "objective": 10007.31,
     "other_inf": null,
     "results": {
          "goal_found_perc": 18.67,
          "average_steps": 5.96,
          "average_distance": 5.79,
          "average_smoothness": 0.19,
          "average_clearance": 2.15,
          "average_time": 0.023,
          "average_distance_from_goal": 7.44,
          "average_original_distance_from_goal": 8.42,
          "average memory": 257.3,
          "goal_found_perc_improvement": -80.82,
          "average_steps_improvement": -4.93,
          "average_distance_improvement": -5.08,
          "average_smoothness_improvement": -26.67,
          "average_clearance_improvement": -0.46,
          "average_time_improvement": -475.0,
          "average_distance_from_goal_improvement": -3620.0,
          "average_path_deviation": 0.28000000000000025,
          "average_memory_improvement": -591.11
     }
}
{
     "algorithm": "This algorithm implements an informed RRT*-inspired planner with goal biasing,\n    adaptive step size, rewiring for optimality, and post-path shortcut smoothing.\n    Key improvements:\n    - Goal biasing: biased random sampling towards the goal with a probability.\n    - Adaptive max_dist: dynamically reduced max step length as the tree grows for finer paths.\n    - Use of RRT* style rewiring of the graph within a neighbor radius to minimize costs.\n    - Early stopping when a path to goal is found with a lower cost threshold.\n    - Post-extraction shortcutting to smooth and shorten the final path.\n    - A global timeout of 10 seconds to ensure responsiveness.\n    The method balances search efficiency, robustness, and path quality better than basic RRT or RRT-Connect.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position, True), Vertex(self._get_grid().goal.position, True), [])\n        self._graph.edges_removable = True  # enable rewiring edges\n        self._init_displays()\n\n        # Parameters\n        self._max_iterations = 5000\n        self._initial_max_dist = 15.0\n        self._final_max_dist = 3.0\n        self._goal_sample_rate = 0.15  # 15% samples directly toward goal for goal biasing\n        self._neighbor_radius = 20.0  # radius for rewiring neighbors\n        self._cost_threshold = float(\"inf\")  # track best path cost found\n\n    def _get_random_sample(self) -> Point:\n        if np.random.rand() < self._goal_sample_rate:\n            # Sample exact goal point for goal bias\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_adaptive_max_dist(self, iteration: int) -> float:\n        # Linear decay from initial max_dist to final max_dist over iterations\n        frac = min(iteration / self._max_iterations, 1.0)\n        return self._initial_max_dist + frac * (self._final_max_dist - self._initial_max_dist)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist == 0:\n            return None\n\n        if dist <= max_dist:\n            q_new_pos = q_sample\n        else:\n            direction_normalized = direction / dist\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex, q_near: Vertex) -> Vertex:\n        # Choose the neighbor with the lowest cost to new vertex via valid edge\n        q_min = q_near\n        c_min = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n\n        for neighbor in neighbors:\n            if neighbor.position == q_near.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            c_new = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n            if c_new < c_min:\n                q_min = neighbor\n                c_min = c_new\n\n        q_new.cost = c_min\n        return q_min\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        # For each neighbor, check if the path through q_new improves cost, and edge is valid\n        for neighbor in neighbors:\n            if neighbor.position == q_new.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n            if cost_through_new < neighbor.cost:\n                # Remove existing parents - as edges_removable=True, so remap parent\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                # Add new better edge\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = cost_through_new\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Trace path back to start\n        path: List[Vertex] = [q_goal]\n        while path[-1].parents:\n            # Greedy backtracking to parent with min cost to ensure optimal path\n            parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Perform shortcut smoothing to improve path quality\n        path = self._shortcut_path(path)\n\n        # Move the agent following the smoothed path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut between non-adjacent vertices to smooth path\n        if len(path) <= 2:\n            return path\n\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # Look ahead for furthest vertex that can be connected directly\n            furthest = i + 1\n            for j in range(len(path) - 1, i, -1):\n                line = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    furthest = j\n                    break\n            shortened_path.append(path[furthest])\n            i = furthest\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(self._max_iterations):\n            # Time limit check (max 10 seconds)\n            if time.time() - start_time > 10.0:\n                break\n\n            # Adaptive max_dist shrinking over iterations\n            max_dist = self._get_adaptive_max_dist(iteration)\n\n            q_rand: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_rand)\n\n            q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_rand, max_dist)\n            if q_new is None:\n                self.key_frame()\n                continue\n\n            # Find neighbors within radius for rewiring\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._neighbor_radius)\n\n            # Choose best parent to minimize cost\n            q_parent = self._choose_parent(neighbors, q_new, q_near)\n            self._graph.add_edge(q_parent, q_new)\n\n            # Rewire neighbors to optimize paths\n            self._rewire(neighbors, q_new)\n\n            # Check if new vertex is within goal radius and cost improves threshold\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._get_grid().goal.position)\n                if cost_to_goal < self._cost_threshold:\n                    # Create temporary goal vertex connected from q_new to extract path\n                    q_goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n                    q_goal_vertex.cost = cost_to_goal\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal_vertex.position)):\n                        self._graph.add_edge(q_new, q_goal_vertex)\n                        self._cost_threshold = cost_to_goal\n                        self._extract_path(q_goal_vertex)\n                        break\n\n            self.key_frame()",
     "objective": 5222.27,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 10.68,
          "average_distance": 11.36,
          "average_smoothness": 0.36,
          "average_clearance": 2.12,
          "average_time": 0.2553,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 106.04,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -16.85,
          "average_distance_improvement": -17.6,
          "average_smoothness_improvement": -38.46,
          "average_clearance_improvement": 6.0,
          "average_time_improvement": -3215.58,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 1.6999999999999993,
          "average_memory_improvement": -184.82
     }
}
