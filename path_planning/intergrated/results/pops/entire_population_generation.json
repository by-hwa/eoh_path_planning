{
     "algorithm": "\"\"\"\n    PathPlanning algorithm combines goal-biased adaptive sampling and heuristic-guided expansion\n    for efficient and robust path planning on a grid.\n    It maintains a Forest graph like RRT* but uses a dynamic max_dist adapting to free space density,\n    and biases sampling progressively more towards the goal for faster convergence.\n    Expansion selects new edges by minimizing estimated total cost (cost-so-far + heuristic to goal),\n    promoting shorter and smoother paths.\n    Path extraction applies a shortcut smoothing via line-of-sight pruning.\n    Early stopping occurs upon reaching the goal or after 30 seconds elapsed,\n    trading planning efficiency and path quality with robustness.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _start_time: float\n    _goal_bias: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize start and goal vertices with cost\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist = 15.0  # initial adaptive step size, can change dynamically\n        self._max_radius = 30.0  # neighborhood radius for rewiring\n        self._goal_bias = 0.2  # initial goal bias for sampling (increases over time)\n        self._start_time = None\n        self._init_displays()\n\n    def _get_random_sample_goal_biased(self) -> Point:\n        \"\"\"\n        Sample randomly with a probability goal_bias to return the goal position\n        to bias exploration towards the goal.\n        \"\"\"\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = []\n                for i in range(self._get_grid().size.n_dim):\n                    rand_pos.append(torch.randint(0, self._get_grid().size[i], (1,)).item())\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_adaptive_max_dist(self) -> float:\n        \"\"\"\n        Adapt the max_dist based on neighborhood density around start vertex.\n        If neighborhood is crowded, reduce step size for finer exploration,\n        else increase it up to a max cap.\n        \"\"\"\n        start_vertex = self._graph.root_vertex_start\n        neighbors = self._graph.get_vertices_within_radius([start_vertex], start_vertex.position, self._max_radius)\n        density = len(neighbors)\n        if density > 20:\n            return max(5.0, self._max_dist * 0.7)  # shrink step size\n        elif density < 5:\n            return min(30.0, self._max_dist * 1.3)  # grow step size\n        else:\n            return self._max_dist  # keep current\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        \"\"\"Euclidean distance heuristic.\"\"\"\n        return Map.get_distance(frm, to)\n\n    def _extract_path_smoothed(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal by backtracking parents,\n        then improve the path by shortcutting (line-of-sight smoothing).\n        Moves the agent along final path with key frames.\n        \"\"\"\n        path: list = [q_new]\n        # Backtrack parents to start\n        current = q_new\n        while current != self._graph.root_vertex_start and len(current.parents) > 0:\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Shortcut path smoothing with line-of-sight pruning\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # publish waypoint if ROS map available\n            grid: Map = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        self._start_time = time.time()\n        max_iterations = 5000\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        dimension = self._get_grid().size.n_dim\n        lambda_star = 40.0\n\n        for iteration in range(max_iterations):\n\n            # Abort if time exceeds 30 seconds\n            if time.time() - self._start_time > 30.0:\n                # No success found in 30s\n                return\n\n            # Gradually increase goal bias to speed convergence\n            self._goal_bias = min(0.9, self._goal_bias + 0.00015)\n\n            # Adaptive max_dist tuning\n            self._max_dist = self._get_adaptive_max_dist()\n\n            q_sample = self._get_random_sample_goal_biased()\n\n            # Find nearest vertex on tree from start root only\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            # Compute new vertex at max_dist or less towards sample\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_vec)\n            if dir_norm == 0:\n                continue\n            if dir_norm <= self._max_dist:\n                q_new = Vertex(q_sample)\n            else:\n                dir_normalized = dir_vec / dir_norm\n                q_new_pos = Point.from_tensor(q_nearest.position.to_tensor() + self._max_dist * dir_normalized)\n                q_new = Vertex(q_new_pos)\n\n            # Check feasibility of edge\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Neighbor radius for rewiring based on RRT* formula\n            card_v = max(1.0, float(self._graph.size))\n            radius = min(lambda_star * ((torch.log(torch.tensor(card_v)) / card_v)**(1/dimension)), self._max_radius)\n\n            Q_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose parent minimizing cost + heuristic\n            min_cost = float('inf')\n            min_parent = None\n            for q_near in Q_near:\n                seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(seq_check):\n                    continue\n                cost_tmp = q_near.cost + self._heuristic_cost(q_near.position, q_new.position)\n                if cost_tmp < min_cost:\n                    min_cost = cost_tmp\n                    min_parent = q_near\n\n            if min_parent is None:\n                # No valid connection found\n                continue\n\n            # Add edge and update cost of q_new\n            dist_parent_to_new = self._heuristic_cost(min_parent.position, q_new.position)\n            q_new.cost = min_parent.cost + dist_parent_to_new\n            self._graph.add_edge(min_parent, q_new)\n\n            # Rewire within neighbors to optimize path cost\n            for q_near in Q_near:\n                if q_near == min_parent:\n                    continue\n                seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(seq_check):\n                    continue\n                cost_qnew_qnear = q_new.cost + self._heuristic_cost(q_new.position, q_near.position)\n                if cost_qnew_qnear < q_near.cost:\n                    # Rewire: remove old edge and add new one\n                    for par in q_near.parents:\n                        self._graph.remove_edge(par, q_near)\n                    q_near.cost = cost_qnew_qnear\n                    self._graph.add_edge(q_new, q_near)\n\n            # If newly added vertex close enough to goal, connect goal and extract path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex with q_new\n                dist_to_goal = self._heuristic_cost(q_new.position, goal_vertex.position)\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n\n                self._extract_path_smoothed(goal_vertex)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm combines several advanced techniques for improved path planning on a discrete grid.\n    It uses goal-biased adaptive sampling, with probability to sample near the goal to speed convergence.\n    The tree expands using vertices chosen by a heuristic combining cost-to-come (actual) and estimated cost-to-go (heuristic),\n    inspired by A*-like guidance but within an RRT* style rewiring and optimization framework.\n    The max extension step size adapts dynamically based on local obstacle density to improve connectivity and avoid collisions.\n    It performs local rewiring to optimize paths after every new vertex addition, improving path quality iteratively.\n    A shortcut smoothing step is applied at the end to trim unnecessary path detours.\n    The algorithm stops early upon reaching a solution, or after 30 seconds to comply with time constraints.\n    This approach aims to boost efficiency, robustness, and success rates, and provide smoother, higher-quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_min = 3.0\n        self._max_dist_max = 15.0\n        self._goal_sample_rate = 0.2  # 20% samples are from goal vicinity\n        self._max_iterations = 5000\n        self._rewire_radius = 15.0\n\n    def _get_cost(self, v: Vertex) -> float:\n        return v.cost if hasattr(v, 'cost') else float('inf')\n\n    def _set_cost(self, v: Vertex, cost: float) -> None:\n        v.cost = cost\n\n    def _heuristic(self, p: Point) -> float:\n        return self._get_grid().get_distance(p, self._get_grid().goal.position)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], p: Point) -> Vertex:\n        # Use Euclidean distance for nearest vertex\n        return self._graph.get_nearest_vertex(vertices, p)\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        # Adaptive max_dist based on nearby obstacle density\n        # Count obstacles in radius 5 around pos\n        radius = 5\n        obs_points = set()\n        for obs in self._get_grid().obstacles:\n            obs_bound = self._get_grid().get_obstacle_bound(obs.position)\n            obs_points.update(obs_bound)\n        nearby_obs = [pt for pt in obs_points if self._get_grid().get_distance(pt, pos) <= radius]\n        density = len(nearby_obs) / (radius * radius * 4)  # approx area 4*radius^2\n        # More obstacles -> smaller max_dist to carefully navigate\n        max_dist = self._max_dist_max - density * (self._max_dist_max - self._max_dist_min)\n        if max_dist < self._max_dist_min:\n            max_dist = self._max_dist_min\n        if max_dist > self._max_dist_max:\n            max_dist = self._max_dist_max\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _line_is_valid(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Vertex:\n        # Choose best parent for q_new based on minimal cost with valid path\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in near_vertices:\n            if self._line_is_valid(q_near.position, q_new.position):\n                cost = self._get_cost(q_near) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = q_near\n        if best_parent is not None:\n            self._set_cost(q_new, min_cost)\n            self._graph.add_edge(best_parent, q_new)\n        else:\n            # No valid parent means isolated vertex, set cost as large\n            self._set_cost(q_new, float('inf'))\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # Attempt to improve cost for neighbors by going through q_new\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            if self._line_is_valid(q_new.position, q_near.position):\n                new_cost = self._get_cost(q_new) + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n                if new_cost < self._get_cost(q_near):\n                    # Remove old parent edges and connect q_new as parent\n                    # To have remove functionality:\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    self._set_cost(q_near, new_cost)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            # pick parent with lowest cost (in case multiple)\n            lowest_cost_parent = None\n            lowest_cost = float('inf')\n            for p in path[-1].parents:\n                if self._get_cost(p) < lowest_cost:\n                    lowest_cost = self._get_cost(p)\n                    lowest_cost_parent = p\n            if lowest_cost_parent is None:\n                break\n            path.append(lowest_cost_parent)\n        path.reverse()\n\n        # Shortcut smoothing: attempt shortcut edges between non-adjacent points on path\n        def shortcut_path(path: List[Vertex]) -> List[Vertex]:\n            if len(path) <= 2:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i +1:\n                    if self._line_is_valid(path[i].position, path[j].position):\n                        smoothed.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # no shortcut found, go next\n                    if i+1 < len(path):\n                        smoothed.append(path[i+1])\n                        i +=1\n            return smoothed\n\n        smoothed_path = shortcut_path(path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_random_sample(self) -> Point:\n        grid_size = self._get_grid().size\n        # Goal-biased sampling\n        if np.random.rand() < self._goal_sample_rate:\n            goal_pos = self._get_grid().goal.position\n            # Sample near goal within radius 8\n            search_radius = 8\n            attempt = 0\n            while True:\n                attempt += 1\n                goal_offset = np.random.randint(-search_radius, search_radius + 1, grid_size.n_dim)\n                sample_coords = np.array(goal_pos.to_list()) + goal_offset\n                # clamp coordinates inside grid\n                sample_coords = np.clip(sample_coords, 0, grid_size.n - 1)\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                if attempt > 50:\n                    # fallback to uniform\n                    break\n        # Uniform random sampling\n        while True:\n            rand_pos = np.random.randint(0, grid_size.n, grid_size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        self._set_cost(start_vertex, 0.0)\n\n        for i in range(self._max_iterations):\n            if time.time() - start_time > 30.0:\n                # Timeout: treat as not found, end planning\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Select the best nearest vertex to extend from based on cost + heuristic (A* style)\n            # Candidate vertices to consider: all in forest root vertices\n            candidates = self._graph.root_vertices\n            best_score = float('inf')\n            best_vertex = None\n\n            for v in candidates:\n                dist = self._get_grid().get_distance(v.position, q_sample)\n                heuristic_dist = self._heuristic(q_sample)\n                score = self._get_cost(v) + dist + heuristic_dist\n                if score < best_score:\n                    best_score = score\n                    best_vertex = v\n\n            if best_vertex is None:\n                continue\n\n            max_dist = self._adaptive_max_dist(best_vertex.position)\n            q_new = self._get_new_vertex(best_vertex, q_sample, max_dist)\n\n            if not self._line_is_valid(best_vertex.position, q_new.position):\n                continue\n\n            near_vertices = self._get_near_vertices(q_new, self._rewire_radius)\n\n            parent = self._choose_parent(q_new, near_vertices if near_vertices else [best_vertex])\n            if parent is None:\n                # no valid parent, discard new vertex\n                continue\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Construct goal vertex and connect if needed\n                goal_v = self._graph.root_vertex_goal\n                if self._line_is_valid(q_new.position, goal_v.position):\n                    cost_to_goal = self._get_cost(q_new) + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n                    if cost_to_goal < self._get_cost(goal_v):\n                        # maybe remove old parents and add new edge\n                        for p in list(goal_v.parents):\n                            self._graph.remove_edge(p, goal_v)\n                        self._graph.add_edge(q_new, goal_v)\n                        self._set_cost(goal_v, cost_to_goal)\n\n                    self._extract_path(goal_v)\n                    break\n\n            # Add q_new to graph root vertices so it is considered in future nearest searches\n            self._graph.root_vertices.append(q_new)\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired path planner combined with heuristic goal biasing and adaptive step size.\n    Key features:\n    - Combines goal-biased sampling (20% samples directly toward the goal) and uniform random sampling elsewhere.\n    - Uses an adaptive step size based on local obstacle density and distance-to-goal to accelerate exploration or precision near obstacles.\n    - Employs RRT* style rewiring to optimize paths and improve path quality.\n    - Utilizes a heuristic cost (cost-to-come + estimated cost-to-goal) to prioritize connections and rewiring.\n    - Path extraction includes shortcut smoothing by line-of-sight validation to reduce unnecessary waypoints.\n    - Stops early when goal is reachable or after 30 seconds to improve efficiency.\n    \n    This provides improved planning efficiency, higher success rates, smoother and shorter paths,\n    and better robustness against complex obstacle configurations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias_prob: float\n    _start_time: float\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # allow rewiring\n        self._max_dist_base = 12.0\n        self._goal_bias_prob = 0.2  # 20% goal bias\n        self._timeout_sec = 30.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        from random import random\n\n        if random() < self._goal_bias_prob:\n            # Goal biased sample near goal with small random offset to favor goal direction\n            goal_pos = self._get_grid().goal.position\n            grid_size = self._get_grid().size\n            # Small random offset around goal (radius 3)\n            offset = Point(\n                int((torch.randint(-3, 4, (1,)).item())),\n                int((torch.randint(-3, 4, (1,)).item())),\n            )\n            biased_sample = Point(min(max(goal_pos.x + offset.x, 0), grid_size[0] - 1),\n                                  min(max(goal_pos.y + offset.y, 0), grid_size[1] - 1))\n            if self._get_grid().is_agent_valid_pos(biased_sample):\n                return biased_sample\n\n        # Uniform random sample\n        while True:\n            sample = Point(\n                *[\n                    torch.randint(0, self._get_grid().size[i], (1,)).item()\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n            )\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Adaptive step size: If nearby obstacles, reduce step size for precision.\n        Otherwise, larger step size allows faster exploration.\n        Also decrease step size if close to goal for fine approach.\n        \"\"\"\n        base = self._max_dist_base\n        radius_check = int(base / 2)\n\n        # Check obstacle density in neighborhood (square neighborhood)\n        obstacles_count = 0\n        total_checked = 0\n        for dx in range(-radius_check, radius_check + 1):\n            for dy in range(-radius_check, radius_check + 1):\n                check_point = Point(pos.x + dx, pos.y + dy)\n                if 0 <= check_point.x < self._get_grid().size[0] and 0 <= check_point.y < self._get_grid().size[1]:\n                    total_checked += 1\n                    # If point invalid for agent (likely due to obstacle radius)\n                    if not self._get_grid().is_agent_valid_pos(check_point):\n                        obstacles_count += 1\n\n        obstacle_density = obstacles_count / total_checked if total_checked > 0 else 0.0\n\n        # Distance to goal\n        dist_to_goal = self._get_grid().get_distance(pos, self._get_grid().goal.position)\n\n        # Step size reduces when near obstacles and near goal\n        step = base * (1.0 - 0.7 * obstacle_density)  # scaled down with obstacle density\n        if dist_to_goal < base * 3:\n            step = min(step, dist_to_goal * 0.8)  # slow down near goal\n\n        # Set a minimum step size\n        step = max(step, 3.0)\n        return step\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / norm\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _cost(self, v1: Vertex, v2: Vertex) -> float:\n        return self._get_grid().get_movement_cost(v1.position, v2.position)\n\n    def _heuristic_cost(self, v: Vertex) -> float:\n        # Estimated total cost = cost-to-come + Euclidean to goal\n        cost_to_come = v.cost\n        heuristic = self._get_grid().get_distance(v.position, self._get_grid().goal.position)\n        return cost_to_come + heuristic\n\n    def _find_best_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Vertex:\n        \"\"\"\n        Select best parent based on cost and valid connection.\n        \"\"\"\n        best_parent = None\n        best_cost = float(\"inf\")\n        for q_near in near_vertices:\n            if self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            ):\n                tentative_cost = q_near.cost + self._cost(q_near, q_new)\n                if tentative_cost < best_cost:\n                    best_cost = tentative_cost\n                    best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        RRT* style rewiring to improve paths.\n        \"\"\"\n        for q_near in near_vertices:\n            if q_near is q_new.parents:\n                continue\n            if self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            ):\n                new_cost = q_new.cost + self._cost(q_new, q_near)\n                if new_cost < q_near.cost:\n                    # Remove old parent edges\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    # Add new edge\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal and shortcut smoothing.\n        \"\"\"\n        path: List[Vertex] = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            # Pick parent with minimal cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut smoothing: try to connect non-adjacent vertices directly if collision free\n        def shortcut_path(vertices: List[Vertex]) -> List[Vertex]:\n            if len(vertices) <= 2:\n                return vertices\n            smooth_path = [vertices[0]]\n            i = 0\n            while i < len(vertices) - 1:\n                j = len(vertices) - 1\n                while j > i + 1:\n                    if self._get_grid().is_valid_line_sequence(\n                        self._get_grid().get_line_sequence(vertices[i].position, vertices[j].position)\n                    ):\n                        break\n                    j -= 1\n                smooth_path.append(vertices[j])\n                i = j\n            return smooth_path\n\n        path_smoothed = shortcut_path(path)\n\n        for vertex in path_smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        for iteration in range(max_iterations):\n            if time.time() - start_time > self._timeout_sec:\n                # Timeout reached without path found\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            ):\n                continue\n\n            # Find near vertices for rewiring (radius = adaptive radius like RRT*)\n            gamma_r = 30.0  # Radius parameter for neighborhood rewiring\n            near_vertices = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, gamma_r\n            )\n            if not near_vertices:\n                # Ensure at least the nearest is included\n                near_vertices = [q_near]\n\n            # Choose best parent from near vertices\n            best_parent = self._find_best_parent(q_new, near_vertices)\n            if best_parent is None:\n                continue\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire near vertices if beneficial\n            self._rewire(q_new, near_vertices)\n\n            # Add the new vertex to graph root vertices for subsequent expansions\n            self._graph.root_vertices.append(q_new)\n\n            # Check goal reachability\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = self._graph.root_vertex_goal\n                # Connect goal to q_new if possible and cheaper\n                if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                ):\n                    # Create virtual goal vertex with updated cost to integrate in graph for path extraction\n                    goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm is an enhanced RRT* inspired planner with the following improvements:\n    - Adaptive max step distance that shrinks as new samples get closer to the goal, leading to finer path refinement near the goal.\n    - Goal biased sampling with adjustable probability to accelerate progress towards the goal.\n    - Rewiring of existing vertices within a dynamic neighborhood radius to optimize the tree for shorter and smoother paths.\n    - Early stopping based on reaching goal radius or time limit (30 seconds) to avoid long runtime.\n    - Post path extraction shortcutting for path smoothing by removing unnecessary intermediate points.\n    This hybrid approach balances exploration speed, path quality, and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position, True), Vertex(self._get_grid().goal.position, True), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._iterations = 8000\n        self._goal_sample_rate = 0.2    # 20% probability sample goal directly\n        self._rewire_radius_factor = 30.0   # radius for rewiring scaled by sqrt(log(n)/n) dynamically later\n        self._start_time = None\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_random_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = vec.norm().item()\n        if dist <= max_dist:\n            return Vertex(to_p, True)\n        vec_normalized = vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * vec_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, True)\n\n    def _choose_parent(self, neighbors: list, new_v: Vertex) -> Vertex:\n        # Select a parent that results in least cost path to new_v\n        min_cost = float('inf')\n        best_parent = None\n        for v in neighbors:\n            seq = self._get_grid().get_line_sequence(v.position, new_v.position)\n            if not self._get_grid().is_valid_line_sequence(seq):\n                continue\n            cost = v.cost + self._get_grid().get_distance(v.position, new_v.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is None:\n            return None\n        new_v.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_v: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is new_v.parents or v is new_v:\n                continue\n            seq = self._get_grid().get_line_sequence(new_v.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(seq):\n                continue\n            new_cost = new_v.cost + self._get_grid().get_distance(new_v.position, v.position)\n            if new_cost < v.cost:\n                # Rewire: remove old parents and add new parent new_v\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(new_v, v)\n                v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path_vertices = [goal_vertex]\n        while len(path_vertices[-1].parents) != 0:\n            # always pick parent with minimum cost (guaranteed by rewiring)\n            min_parent = None\n            min_cost = float('inf')\n            for p in path_vertices[-1].parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path_vertices.append(min_parent)\n        path_vertices.reverse()\n\n        # Shortcut and smooth the path by shortcutting intermediate points if possible\n        def can_connect(p1, p2):\n            seq = self._get_grid().get_line_sequence(p1.position, p2.position)\n            return self._get_grid().is_valid_line_sequence(seq)\n\n        shortcut_path = []\n        i = 0\n        while i < len(path_vertices):\n            shortcut_path.append(path_vertices[i])\n            j = len(path_vertices) - 1\n            # find farthest vertex that can connect directly\n            while j > i + 1:\n                if can_connect(path_vertices[i], path_vertices[j]):\n                    break\n                j -= 1\n            if j <= i + 1:\n                i += 1\n            else:\n                i = j\n\n        # Animate movement along shortcut path\n        for v in shortcut_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_pos = self._get_grid().goal.position\n        n_vertices = 1\n\n        for i in range(self._iterations):\n            # Early stop if time > 30 seconds\n            if time.time() - self._start_time > 30:\n                break\n\n            q_rand = self._get_random_sample()\n\n            # Adaptive max_dist depends on distance to goal, reduces near goal for finer search\n            dist_to_goal = self._distance(q_rand, goal_pos)\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / 2.0))\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_rand)\n            if q_near.position == q_rand:\n                continue\n            q_new = self._steer(q_near, q_rand, max_dist)\n\n            seq_line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(seq_line):\n                continue\n\n            # Find neighbors within rewiring radius for RRT* style optimization\n            radius = self._rewire_radius_factor * (np.log(n_vertices + 1) / (n_vertices + 1))**0.5\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            parent = self._choose_parent(neighbors, q_new)\n            if parent is None:\n                # No good parent found, connect to nearest if possible\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._distance(q_near.position, q_new.position)\n                    parent = q_near\n                else:\n                    continue  # cannot connect q_new\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors to potentially improve paths via q_new\n            self._rewire(q_new, neighbors)\n\n            n_vertices += 1\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new directly to goal vertex and extract path\n                goal_vertex = self._graph.root_vertex_goal\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = q_new.cost + self._distance(q_new.position, goal_vertex.position)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a Hybrid Informed Anytime RRT* variant with heuristic-guided sampling and adaptive step sizing.\n    Key improvements:\n    - Goal-biased adaptive sampling: samples are drawn preferentially inside an ellipse defined by current best path cost for efficiency.\n    - Dynamic max step size adaptation based on distance to goal and obstacle proximity to enable both wide exploration and fine local refinement.\n    - Heuristic cost (Euclidean + cost-to-come) used for rewiring to optimize path quality.\n    - Anytime improvement: after first feasible path found, refines solution for limited time.\n    - Early stopping criteria with 30 seconds timeout.\n    - Smooth shortcutting applied on path extraction to improve path quality.\n    \n    This approach improves planning speed by focusing search in promising areas and refines the path for better quality and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.root_vertex_start.cost = 0.0\n        self._found_goal_vertex = None\n        self._max_iterations = 1500\n        self._best_path_cost = float(\"inf\")\n        self._improvement_time_limit = 5.0  # seconds for anytime improvement\n        self._max_step_size_base = 15.0\n        self._goal_sample_rate = 0.2  # 20% samples towards goal\n        self._init_displays()\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance heuristic from point p to goal\n        goal_pos = self._get_grid().goal.position\n        return self._get_grid().get_distance(p, goal_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost between two vertices (used for path cost)\n        return self._get_grid().get_distance(frm.position, to.position)\n\n    def _sample_in_ellipse(self, c_max: float, start: Point, goal: Point) -> Point:\n        # Sample inside ellipse defined by start, goal and current best path cost (c_max),\n        # Adapted from Informed RRT* ellipse sampling for 2D.\n        import math\n        import random\n\n        if c_max == float(\"inf\"):\n            return self._get_random_sample()\n\n        c_min = self._get_grid().get_distance(start, goal)\n        if c_min == 0:\n            return start\n\n        # Ellipse parameters\n        a = c_max / 2.0\n        b = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Sample random point inside unit circle (2D assumed)\n        theta = random.uniform(0, 2.0 * math.pi)\n        r = math.sqrt(random.uniform(0, 1))\n        x = r * math.cos(theta)\n        y = r * math.sin(theta)\n\n        # Scale to ellipse\n        x_ellipse = a * x\n        y_ellipse = b * y\n\n        # Rotate ellipse to align with start-goal vector\n        dx = goal.x - start.x\n        dy = goal.y - start.y\n        angle = math.atan2(dy, dx)\n        xr = math.cos(angle) * x_ellipse - math.sin(angle) * y_ellipse\n        yr = math.sin(angle) * x_ellipse + math.cos(angle) * y_ellipse\n\n        center_x = (start.x + goal.x) / 2.0\n        center_y = (start.y + goal.y) / 2.0\n\n        sample_x = int(round(center_x + xr))\n        sample_y = int(round(center_y + yr))\n\n        sampled_point = Point(sample_x, sample_y)\n        if self._get_grid().is_agent_valid_pos(sampled_point):\n            return sampled_point\n        else:\n            # fallback if invalid sample\n            return self._get_random_sample()\n\n    def _get_adaptive_max_step_size(self, from_pos: Point, to_pos: Point) -> float:\n        # Adapt step size according to distance to goal and local obstacle density proximity (simple proxy)\n        base = self._max_step_size_base\n        dist_to_goal = self._get_grid().get_distance(from_pos, self._get_grid().goal.position)\n        # Adaptive factor reduces step near goal\n        adaptive = max(5.0, min(base, dist_to_goal / 2))\n        return adaptive\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        if dist == 0:\n            return Vertex(q_near.position)\n\n        dir_normalized = dir / dist\n        q_new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pt)\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            if q_near is q_new:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            new_cost = q_new.cost + self._cost(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Remove old parent edge\n                for p in q_near.parents:\n                    self._graph.remove_edge(p, q_near)\n                    break\n                # Add new edge and update cost\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _shortcut_path(self, path_vertices: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut the path by removing intermediate vertices on valid direct connections\n        new_path = [path_vertices[0]]\n        n = len(path_vertices)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_vertices[i].position, path_vertices[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path_vertices[j])\n            i = j\n        return new_path\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path from start to goal vertex by traversing parents\n        path: List[Vertex] = [goal_vertex]\n\n        current = goal_vertex\n        while len(current.parents) > 0:\n            # In forest structure, single parent assumed for shortest path tree\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Apply shortcut smoothing\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            # Optional: publish waypoint if ros_map (not mandatory here)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        best_cost = float(\"inf\")\n        best_goal_vertex = None\n\n        start_time = time.time()\n        max_time_limit = 30.0  # seconds timeout\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        iteration = 0\n        while iteration < self._max_iterations:\n            iteration += 1\n\n            elapsed = time.time() - start_time\n            if elapsed > max_time_limit:\n                # Timeout - no path found within time limit\n                break\n\n            # Sample with goal bias and ellipse informed sampling if best path known\n            if best_cost < float(\"inf\") and torch.rand(1).item() > self._goal_sample_rate:\n                q_sample = self._sample_in_ellipse(best_cost, start, goal)\n            else:\n                if torch.rand(1).item() < self._goal_sample_rate:\n                    q_sample = goal\n                else:\n                    q_sample = self._get_random_sample()\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            max_step = self._get_adaptive_max_step_size(q_nearest.position, q_sample)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_step)\n\n            if q_new.position == q_nearest.position:\n                continue\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Determine radius for near vertices for rewiring (using RRT* style radius)\n            card_v = torch.tensor(float(self._graph.size))\n            dimension = grid.size.n_dim\n            if card_v <= 1:\n                radius = self._max_step_size_base\n            else:\n                gamma_rrt_star = 50.0  # tuning parameter\n                radius = min(\n                    gamma_rrt_star * ((torch.log(card_v) / card_v) ** (1 / dimension)),\n                    self._max_step_size_base * 2.0,\n                )\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent vertex with min total cost\n            c_min = float(\"inf\")\n            q_min = None\n            for q_near in Q_near:\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                c_new = q_near.cost + self._cost(q_near, q_new)\n                if c_new < c_min:\n                    c_min = c_new\n                    q_min = q_near\n\n            if q_min is None:\n                # No valid parent, try q_nearest if valid\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position)):\n                    q_min = q_nearest\n                    c_min = q_nearest.cost + self._cost(q_nearest, q_new)\n                else:\n                    continue\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors\n            self._rewire(q_new, Q_near)\n\n            # Add q_new vertex into graph if not present (forest includes edge addition)\n            # Already added via add_edge\n\n            # Check if q_new is within goal radius to update best solution\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < best_cost:\n                    best_cost = q_new.cost\n                    best_goal_vertex = q_new\n                    self._found_goal_vertex = q_new\n\n                    # Extract and temporarily show path\n                    self._extract_path(best_goal_vertex)\n\n                    # Anytime path improvement phase: limited time refinements\n                    improve_start = time.time()\n                    while time.time() - improve_start < self._improvement_time_limit:\n                        # Sample inside informed ellipse again for improvement\n                        q_sample_improve = self._sample_in_ellipse(best_cost, start, goal)\n                        q_nearest_improve = self._get_nearest_vertex(q_sample_improve)\n                        max_step_improve = self._get_adaptive_max_step_size(q_nearest_improve.position, q_sample_improve)\n                        q_new_improve = self._get_new_vertex(q_nearest_improve, q_sample_improve, max_step_improve)\n\n                        if q_new_improve.position == q_nearest_improve.position:\n                            continue\n\n                        if not grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest_improve.position, q_new_improve.position)):\n                            continue\n\n                        Q_near_improve = self._get_vertices_within_radius(q_new_improve, radius)\n                        c_min_improve = float(\"inf\")\n                        q_min_improve = None\n                        for q_near in Q_near_improve:\n                            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new_improve.position)):\n                                continue\n                            c_new = q_near.cost + self._cost(q_near, q_new_improve)\n                            if c_new < c_min_improve:\n                                c_min_improve = c_new\n                                q_min_improve = q_near\n\n                        if q_min_improve is None:\n                            if grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest_improve.position, q_new_improve.position)):\n                                q_min_improve = q_nearest_improve\n                                c_min_improve = q_nearest_improve.cost + self._cost(q_nearest_improve, q_new_improve)\n                            else:\n                                continue\n\n                        q_new_improve.cost = c_min_improve\n                        self._graph.add_edge(q_min_improve, q_new_improve)\n                        self._rewire(q_new_improve, Q_near_improve)\n\n                        if grid.is_agent_in_goal_radius(q_new_improve.position):\n                            if q_new_improve.cost < best_cost:\n                                best_cost = q_new_improve.cost\n                                best_goal_vertex = q_new_improve\n                                self._extract_path(best_goal_vertex)\n\n                        self.key_frame()\n\n                    break  # End main loop early on first found solution with improvement\n\n            self.key_frame()\n\n        # If no path found but previously extracted, show path from that best found vertex\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm incorporates a hybrid approach combining goal-biased adaptive sampling, \n    heuristic-guided expansion (using estimated total cost = cost-so-far + heuristic), and adaptive step \n    sizing based on the local environment's obstacle density. It maintains a Forest graph and performs a \n    rewiring optimization similar to RRT*, but additionally uses informed sampling in an elliptical region \n    around the start and goal to focus exploration in promising areas. The algorithm also includes an early \n    stopping criterion based on elapsed time (30 seconds) and a post-extraction shortcut smoothing for path quality.\n\n    The main improvements are:\n      - Adaptive max_dist based on density of obstacles around the sampling region to balance exploration/exploitation.\n      - Informed goal-biased sampling within an ellipse between start and goal to concentrate sample points.\n      - Heuristic cost combining path cost and Euclidean heuristic to drive better tree growth.\n      - Rewiring to continuously optimize paths.\n      - Post path extraction shortcutting smoothing to improve path quality.\n      - Early timeout to stop if no path found in 30 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._start_vertex = self._graph.root_vertex_start\n        self._goal_vertex = self._graph.root_vertex_goal\n        self._start_vertex.cost = 0\n        self._init_displays()\n\n    def _heuristic_cost(self, point_a: Point, point_b: Point) -> float:\n        return self._get_grid().get_distance(point_a, point_b)\n\n    def _adaptive_max_dist(self, pos: Point, base_max_dist: float = 15, max_radius: int = 5) -> float:\n        \"\"\"\n        Calculate adaptive max distance that shrinks near obstacles density:\n        The more obstacles near pos within max_radius, the smaller max_dist becomes.\n        \"\"\"\n        grid = self._get_grid()\n        obstacles = grid.obstacles\n        obstacle_count = 0\n        radius = max_radius\n\n        # Count how many obstacles are close to pos within radius radius.\n        for obs in obstacles:\n            obs_pos = obs.position\n            dist = grid.get_distance(pos, obs_pos)\n            if dist <= radius:\n                obstacle_count += 1\n\n        # Normalize count (max could be number of obstacles)\n        if len(obstacles) == 0:\n            density = 0\n        else:\n            density = obstacle_count / len(obstacles)\n\n        # More dense obstacles => smaller max_dist (minimum 5)\n        adaptive_dist = base_max_dist * (1 - 0.7 * density)\n        adaptive_dist = max(5, min(adaptive_dist, base_max_dist))\n        return adaptive_dist\n\n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Samples a point uniformly within an ellipse defined by start and goal positions extended by current best path cost.\n        If no best path found yet, fallback to uniform random sampling in the grid.\n        \"\"\"\n        grid = self._get_grid()\n        start = self._start_vertex.position\n        goal = self._goal_vertex.position\n\n        best_cost = None\n        # Try to estimate best current solution cost (lowest cost vertex connected to goal)\n        for v in self._graph.root_vertices:\n            if v == self._goal_vertex:\n                continue\n            for child in v.children:\n                if child == self._goal_vertex:\n                    if best_cost is None or v.cost + grid.get_distance(v.position, goal) < best_cost:\n                        best_cost = v.cost + grid.get_distance(v.position, goal)\n\n        # If no solution yet, default to map diagonal as max distance for ellipse\n        if best_cost is None:\n            best_cost = grid.get_distance(start, goal) * 1.5\n\n        # Ellipse axes lengths: a = best_cost/2, c = distance start-goal/2, b = sqrt(a^2 - c^2)\n        c = grid.get_distance(start, goal) / 2\n        a = best_cost / 2\n        if a < c:  # Numerical safety\n            a = c * 1.1\n        b_sq = max(a * a - c * c, 0.01)\n        b = b_sq ** 0.5\n\n        # Ellipse centered at midpoint between start and goal\n        center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n\n        # Random polar coordinates inside unit circle & scale to ellipse\n        attempted = 0\n        while True:\n            theta = np.random.uniform(0, 2 * np.pi)\n            r = np.sqrt(np.random.uniform(0, 1))\n\n            # Sample point in ellipse coordinates before rotation\n            x_ellipse = r * np.cos(theta) * a\n            y_ellipse = r * np.sin(theta) * b\n\n            # Rotation angle between start-goal vector and x-axis\n            dx = goal.x - start.x\n            dy = goal.y - start.y\n            angle = np.arctan2(dy, dx)\n\n            # Rotate point back to map coordinates\n            x_rot = x_ellipse * np.cos(angle) - y_ellipse * np.sin(angle)\n            y_rot = x_ellipse * np.sin(angle) + y_ellipse * np.cos(angle)\n\n            sample_point = Point(center.x + x_rot, center.y + y_rot)\n\n            # Round to int grid coords, check validity and return if valid\n            sample = Point(int(round(sample_point.x)), int(round(sample_point.y)))\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n            attempted += 1\n            # Avoid infinite loops/fallback\n            if attempted > 100:\n                # Fallback uniform random sample anywhere in grid\n                while True:\n                    rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                    fallback_sample = Point(*rand_pos)\n                    if grid.is_agent_valid_pos(fallback_sample):\n                        return fallback_sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_new):\n        \"\"\"\n        Extract path and apply shortcut smoothing to the path for quality.\n        \"\"\"\n\n        grid = self._get_grid()\n        goal_v = Vertex(grid.goal.position)\n        goal_v.cost = q_new.cost + grid.get_distance(q_new.position, goal_v.position)\n        self._graph.add_edge(q_new, goal_v)\n\n        path = [goal_v]\n        while len(path[-1].parents) > 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.pop()  # Remove last (start's parent is empty, so popped)\n\n        path.reverse()\n        # Shortcut smoothing pass - attempt a constant number of shortcuts\n        path = self._shortcut_smoothing(path, iterations=10)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            # If ROS Map, publish waypoint\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smoothing(self, path: list, iterations: int = 10) -> list:\n        \"\"\"\n        Attempts to iteratively shorten the path by connecting non-adjacent vertices directly if valid.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        import random\n\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p_i = path[i]\n            p_j = path[j]\n\n            line_seq = grid.get_line_sequence(p_i.position, p_j.position)\n            if grid.is_valid_line_sequence(line_seq):\n                # Remove intermediate vertices between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        max_base_dist = 15\n        max_iterations = 8000\n        lambda_rrt_star = 30  # smaller radius factor for faster but still good rewire radius\n\n        start_time = time.time()\n\n        for _ in range(max_iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:  # timeout after 30 seconds\n                # Consider no path found\n                break\n\n            # 30% of samples are pure uniform random to maintain exploration\n            if np.random.rand() < 0.3:\n                q_sample = None\n                while q_sample is None:\n                    rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                    candidate = Point(*rand_pos)\n                    if grid.is_agent_valid_pos(candidate):\n                        q_sample = candidate\n            else:\n                q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist_adaptive = self._adaptive_max_dist(q_nearest.position, max_base_dist)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist_adaptive)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Rewire radius adapting dynamically based on graph size & heuristic\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            log_card = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card / card_v) ** (1 / 2)), 40)\n\n            # Find near vertices for rewiring\n            Q_near = self._graph.get_vertices_within_radius([self._start_vertex], q_new.position, radius)\n\n            # Choose parent with minimum cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + grid.get_distance(q_nearest.position, q_new.position) + self._heuristic_cost(q_new.position, grid.goal.position)\n\n            for q_near in Q_near:\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                cost_near_to_new = q_near.cost + grid.get_distance(q_near.position, q_new.position) + self._heuristic_cost(q_new.position, grid.goal.position)\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            dist_qmin_qnew = grid.get_distance(q_min.position, q_new.position)\n            q_new.cost = q_min.cost + dist_qmin_qnew\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better paths possible\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_new_to_near = q_new.cost + grid.get_distance(q_new.position, q_near.position)\n                if cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for p in q_near.parents:\n                        q_parent = p\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is an adaptive sample-based algorithm combining goal-biased sampling, heuristic-driven expansion,\n    and dynamic step sizing to improve path quality and efficiency. It employs a Forest graph structure like RRT* but\n    integrates A*-like heuristic cost-guided vertex extension and rewiring with adaptive sampling radius based on local\n    vertex density. The method adapts max step size according to obstacle proximity to avoid collisions and dynamically\n    schedules exploration versus exploitation via adjustable goal bias probability. It stops early when the found path\n    reaches a predetermined cost threshold or the search time exceeds 30 seconds, ensuring practical runtime limits.\n    The final path is smoothed by shortcutting via valid direct line connections between non-consecutive waypoints,\n    improving path smoothness and shortening total travel distance.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist_base = 12.0\n        self._max_radius = 30.0\n        self._goal_bias = 0.2  # probability to sample goal directly\n        self._cost_threshold = None  # can be dynamically updated during the run\n        self._init_displays()\n\n    def _get_heuristic_cost(self, frm: Vertex, to: Vertex) -> float:\n        # Using Euclidean distance heuristic from frm to to (Goal)\n        return Map.get_distance(frm.position, to.position)\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        # Decrease max step if near obstacle boundary\n        grid = self._get_grid()\n        nearby_positions = grid.get_next_positions(q_near.position)\n        obstacle_count = 0\n        total = len(nearby_positions)\n        for pos in nearby_positions:\n            if not grid.is_agent_valid_pos(pos):\n                obstacle_count += 1\n        obstacle_density = obstacle_count / total if total > 0 else 0\n        # Reduce max_dist by up to 50% if obstacle density is high\n        max_dist = self._max_dist_base * (1 - 0.5 * obstacle_density)\n        return max(3.0, max_dist)\n\n    def _goal_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _rewire(self, q_new: Vertex, Q_near: 'List[Vertex]'):\n        # Rewire neighbors of q_new for improved path cost\n        grid = self._get_grid()\n        for q_near in Q_near:\n            if q_near is q_new:\n                continue\n            # Check collision-free connection from q_new to q_near\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_new_to_near = q_new.cost + Map.get_distance(q_new.position, q_near.position)\n            if cost_new_to_near < q_near.cost:\n                # Remove old parent edge\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                q_near.cost = cost_new_to_near\n                self._graph.add_edge(q_new, q_near)\n\n    def _smooth_path(self, path: 'List[Vertex]') -> 'List[Vertex]':\n        # Attempt shortcuts between non-adjacent vertices in the path\n        grid = self._get_grid()\n        if len(path) < 3:\n            return path  # Nothing to smooth\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(smoothed_path[-1].position, path[next_idx].position)):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    def _extract_path(self, q_goal: Vertex):\n        # Extract path from start to q_goal by backtracking parents\n        path = [q_goal]\n        while len(path[-1].parents) != 0:\n            # Pick one parent (arbitrary if multiple)\n            for p in path[-1].parents:\n                path.append(p)\n                break\n        path.reverse()\n        # Smooth path\n        path = self._smooth_path(path)\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n        grid = self._get_grid()\n        start_time = time.time()\n        max_iterations = 5000\n        dimension = grid.size.n_dim\n        lambda_rrt_star = 60\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Initialize cost threshold to a high value\n        self._cost_threshold = float('inf')\n\n        for i in range(max_iterations):\n            # Time check: stop if exceeded 30 seconds\n            if time.time() - start_time > 30.0:\n                # Stop search, treat as not found\n                break\n\n            # Sample with goal bias\n            q_sample_pos = self._goal_biased_sample()\n            nearest_vertex = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n\n            if nearest_vertex.position == q_sample_pos:\n                continue\n\n            max_dist = self._adaptive_max_dist(nearest_vertex)\n            dir_vec = q_sample_pos.to_tensor() - nearest_vertex.position.to_tensor()\n            dir_norm = torch.norm(dir_vec)\n            if dir_norm == 0.0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample_pos\n            else:\n                q_new_pos = Point.from_tensor(nearest_vertex.position.to_tensor() + max_dist * dir_vec / dir_norm)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(nearest_vertex.position, q_new_pos)):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Calculate tentative cost from start through nearest_vertex to q_new\n            tentative_cost = nearest_vertex.cost + Map.get_distance(nearest_vertex.position, q_new.position)\n            q_new.cost = tentative_cost\n\n            # Determine adaptive radius for rewiring/neighbors\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)), self._max_radius)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Find the best parent for q_new minimizing f = cost + heuristic\n            best_parent = nearest_vertex\n            best_cost = tentative_cost + self._get_heuristic_cost(q_new, goal_vertex)\n            for q_near in near_vertices:\n                if q_near == q_new:\n                    continue\n                # Verify collision-free path q_near -> q_new\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                cost_through_near = q_near.cost + Map.get_distance(q_near.position, q_new.position)\n                f_cost = cost_through_near + self._get_heuristic_cost(q_new, goal_vertex)\n                if f_cost < best_cost:\n                    best_parent = q_near\n                    best_cost = f_cost\n                    q_new.cost = cost_through_near\n\n            # Add q_new to the graph\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors around q_new\n            self._rewire(q_new, near_vertices)\n\n            # Update graph size manually (assume adding vertex)\n            self._graph.size += 1\n\n            # Attempt connecting q_new directly to goal vertex if possible\n            dist_to_goal = Map.get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= max_dist:\n                # Check direct connection feasibility\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_cost = q_new.cost + dist_to_goal\n                    if goal_cost < self._cost_threshold:\n                        self._cost_threshold = goal_cost\n                        goal_vertex.cost = goal_cost\n                        # Clear existing parents edges of goal\n                        for parent in list(goal_vertex.parents):\n                            self._graph.remove_edge(parent, goal_vertex)\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract smooth path and finish\n                        self._extract_path(goal_vertex)\n                        return\n\n            # Early stopping if found a path under threshold\n            if self._cost_threshold < float('inf') and i > 100:\n                # If we have a good path and some iterations have passed, stop to prevent overrun\n                # This improves efficiency\n                self._extract_path(goal_vertex)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* inspired method that incorporates goal-biased sampling,\n    heuristic guided vertex selection, adaptive step length, and rewiring for continuous path cost optimization.\n    It uses a Forest graph structure rooted at start with incremental vertex insertion.\n    Key improvements:\n    - Goal-bias in sampling guides exploration towards goal.\n    - Adaptive max step size based on distance to nearest vertex and goal.\n    - Heuristic (cost + distance-to-goal) to select parents for new vertex, improving path quality.\n    - Rewiring nearby vertices around new vertex to reduce path cost (like RRT*).\n    - Shortcut smoothing applied after path found for smoother routes.\n    - Early termination if path cost no longer improves or if 30s timeout reached.\n    This balances exploration, path quality, and computational efficiency for improved planning performance.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _iterations: int\n    _goal_sample_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n\n        self._max_dist_base = 12.0  # base adaptive max step length\n        self._iterations = 8000\n        self._goal_sample_rate = 0.2  # probability of sampling goal to bias towards it\n        self._rewire_radius = 20.0\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        from random import random\n        if random() < self._goal_sample_rate:\n            # With some probability sample goal directly\n            return self._graph.root_vertex_goal.position\n        else:\n            while True:\n                sample = Point(*[\n                    torch.randint(0, self._get_grid().size[i], (1,)).item()\n                    for i in range(self._get_grid().size.n_dim)\n                ])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, point)\n\n    def _get_dist(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _get_adaptive_max_dist(self, q_near: Vertex, q_rand: Point) -> float:\n        d_to_goal = self._get_dist(q_near.position, self._graph.root_vertex_goal.position)\n        d_to_rand = self._get_dist(q_near.position, q_rand)\n        max_dist = min(self._max_dist_base, max(d_to_rand * 0.75, 5.0), d_to_goal * 0.75)\n        if max_dist < 1.0:\n            max_dist = 1.0\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / norm\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _line_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose parent to minimize cost + heuristic-to-goal\n        best_parent = None\n        best_cost = float('inf')\n        for v in near_vertices:\n            if v.position == q_new.position:\n                continue\n            if self._line_valid(v.position, q_new.position):\n                cost_v = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n                heuristic = self._get_dist(q_new.position, self._graph.root_vertex_goal.position)\n                total_cost = cost_v + heuristic\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire near vertices for lower cost paths through q_new\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if self._line_valid(q_new.position, v.position):\n                cost_through_qnew = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n                if cost_through_qnew < v.cost:\n                    # Change parent edge\n                    # Remove old parent edges:\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    # Add new edge\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_qnew\n\n    def _extract_path(self) -> None:\n        path: List[Vertex] = []\n        current = self._graph.root_vertex_goal\n\n        # Trace back to start by choosing minimum cost parent\n        while current != self._graph.root_vertex_start:\n            path.append(current)\n            # Choose parent with minimal cost\n            if not current.parents:\n                # Fail-safe if no parent (break infinite)\n                break\n            current = min(current.parents, key=lambda p: p.cost + self._get_dist(p.position, current.position))\n        path.append(self._graph.root_vertex_start)\n        path.reverse()\n\n        # Shortcut smoothing - try to remove unnecessary intermediate nodes\n        path = self._smooth_path(path)\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut by skipping intermediate vertices if direct connection is collision free\n        if len(path) < 3:\n            return path\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1  # try to connect as far as possible\n            while next_idx > idx + 1:\n                if self._line_valid(path[idx].position, path[next_idx].position):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for i in range(self._iterations):\n            if time.time() - start_time > 30.0:\n                # timeout reached, stop planning without path\n                return\n\n            q_rand: Point = self._get_random_sample()\n            q_near: Vertex = self._get_nearest_vertex(self._graph.root_vertices, q_rand)\n\n            max_dist: float = self._get_adaptive_max_dist(q_near, q_rand)\n            q_new: Vertex = self._get_new_vertex(q_near, q_rand, max_dist)\n\n            if not self._line_valid(q_near.position, q_new.position):\n                continue\n\n            # Find near vertices within radius for rewiring and parent choosing\n            near_vertices: List[Vertex] = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n\n            # Choose best parent based on cost+heuristic\n            parent_vertex = self._choose_parent(near_vertices + [q_near], q_new)\n            if parent_vertex is None:\n                parent_vertex = q_near\n\n            # Set cost and add vertex and edge\n            q_new.cost = parent_vertex.cost + self._get_grid().get_movement_cost(parent_vertex.position, q_new.position)\n            self._graph.root_vertices.append(q_new)\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire neighbors to improve path cost\n            self._rewire(near_vertices, q_new)\n\n            # Early check if new vertex reached goal or close enough\n            if self._get_dist(q_new.position, self._graph.root_vertex_goal.position) < self._max_dist_base:\n                if self._line_valid(q_new.position, self._graph.root_vertex_goal.position):\n                    # Connect goal directly if possible\n                    if self._graph.root_vertex_goal.cost > q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position):\n                        # Remove old parent edges of goal\n                        for p in list(self._graph.root_vertex_goal.parents):\n                            self._graph.remove_edge(p, self._graph.root_vertex_goal)\n                        self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                        self._graph.root_vertex_goal.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n\n            # Terminate early if goal is connected and path cost is finite\n            if self._graph.root_vertex_goal.cost < float('inf'):\n                self._extract_path()\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an Adaptive Heuristic RRT* with Goal Biasing and Dynamic Step Sizing.\n    - It uses heuristic-guided sampling biased towards the goal to improve convergence speed.\n    - The max step size dynamically adapts based on distance to goal and environment conditions.\n    - Rewiring optimizes the tree continuously to enhance path quality.\n    - Early stopping occurs either on success or after 30 seconds timeout to ensure efficiency.\n    - After a path is found, shortcut smoothing attempts to reduce unnecessary waypoints for smoother paths.\n    - A* style heuristic cost (distance to goal) guides vertex rewiring and selection.\n    - Sampling occasionally explores fully random points to maintain environment coverage and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        self._max_iterations = 8000\n        self._goal_bias = 0.15          # Probability to sample goal directly\n        self._max_step_initial = 15.0\n        self._max_step_min = 5.0\n        self._rewire_radius_factor = 50  # tuning param for radius in rewiring\n        self._dimension = 2\n        self._timeout_sec = 30.0\n        self._goal_sample_every = 10    # Force goal sampling every N iterations\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        # Goal biased with occasional pure random exploration\n        if iteration % self._goal_sample_every == 0 or np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, position: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        delta: torch.Tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(delta)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = delta / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction)\n        return Vertex(q_new_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost from frm to to using grid's movement cost\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _heuristic(self, v: Vertex) -> float:\n        # Euclidean distance to goal as heuristic\n        return Map.get_distance(v.position, self._graph.root_vertex_goal.position)\n\n    def _can_connect(self, from_pos: Point, to_pos: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            if q_near is q_new:\n                continue\n            if self._can_connect(q_new.position, q_near.position):\n                cost_through_new = q_new.cost + self._cost(q_new, q_near)\n                if cost_through_new < q_near.cost:\n                    # Remove old parent edges\n                    old_parents = list(q_near.parents)\n                    for p in old_parents:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_goal: Vertex) -> List[Vertex]:\n        path: List[Vertex] = [q_goal]\n        # Trace back from goal to start via parents\n        while path[-1].parents:\n            # pick parent with minimal cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut path by connecting non-adjacent vertices if collision-free\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # find farthest vertex reachable from current without collision\n            j = len(path) - 1\n            while j > i + 1:\n                if self._can_connect(path[i].position, path[j].position):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _update_max_step(self, dist_to_goal: float) -> float:\n        # Adaptive max step size: smaller when close to goal, or large otherwise\n        step = max(self._max_step_min,\n                   min(self._max_step_initial, dist_to_goal / 2))\n        return step\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        # Pre-cache log for rewiring radius formula\n        card_v = 1.0\n\n        for iter_count in range(1, self._max_iterations + 1):\n            current_time = time.time()\n            if current_time - start_time > self._timeout_sec:\n                # Timeout: fail gracefully by breaking loop\n                break\n\n            q_sample = self._get_random_sample(iter_count)\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            dist_to_sample = Map.get_distance(q_nearest.position, q_sample)\n            if dist_to_sample == 0:\n                continue\n\n            # adapt step size based on distance to goal from q_nearest\n            dist_to_goal = Map.get_distance(q_nearest.position, goal_pos)\n            max_step = self._update_max_step(dist_to_goal)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_step)\n\n            # Check path validity\n            if not self._can_connect(q_nearest.position, q_new.position):\n                self.key_frame()\n                continue\n\n            # Prepare for rewiring radius calculation\n            card_v = float(self._graph.size + 1)\n            radius = min(self._rewire_radius_factor * ((np.log(card_v) / card_v) ** (1 / self._dimension)), 50.0)\n\n            Q_near = self._get_vertices_within_radius(q_new.position, radius)\n            # Choose parent with lowest cost + heuristic\n            costs = []\n            for q_near in Q_near:\n                if self._can_connect(q_near.position, q_new.position):\n                    cost = q_near.cost + self._cost(q_near, q_new) + self._heuristic(q_new)\n                    costs.append((cost, q_near))\n            if not costs:\n                # No valid parent - discard vertex\n                self.key_frame()\n                continue\n            costs.sort(key=lambda x: x[0])\n            min_cost, q_min = costs[0]\n\n            q_new.cost = q_min.cost + self._cost(q_min, q_new)\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if beneficial\n            self._rewire(q_new, Q_near)\n\n            # Check if goal reached within radius of goal + smoothing on connecting edge\n            if self._can_connect(q_new.position, goal_pos):\n                cost_to_goal = q_new.cost + self._cost(q_new, self._graph.root_vertex_goal)\n                if cost_to_goal < self._graph.root_vertex_goal.cost or self._graph.root_vertex_goal.cost == 0:\n                    self._graph.root_vertex_goal.cost = cost_to_goal\n                    self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                    # Extract and shortcut path\n                    path = self._extract_path(self._graph.root_vertex_goal)\n                    path = self._shortcut_path(path)\n                    for p in path:\n                        self.move_agent(p.position)\n                        # publish waypoints if applicable\n                        grid = self._get_grid()\n                        # Support ROS waypoint publishing if supported\n                        if hasattr(grid, 'publish_wp'):\n                            grid.publish_wp(grid.agent.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an informed, goal-biased RRT* inspired planner with adaptive step size and path smoothing.\n    It maintains a forest of vertices connecting start and goal roots with rewiring to improve path quality.\n    The sampling is biased increasingly toward the goal as iterations progress to speed convergence.\n    Adaptive step size adjusts expansion distance based on obstacle proximity to improve robustness.\n    When a connection between start and goal trees is found, a shortcut smoothing post-processing step is applied.\n    Early stopping occurs if no path is found within 30 seconds or path quality stabilizes.\n    This approach improves planning efficiency, success rate, and path smoothness compared to standard RRT or SPRM.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_min: float\n    _max_dist_max: float\n    _iterations: int\n    _max_smoothing_steps: int\n    _goal_sample_rate: float  # probability to sample goal-biased points\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        self._graph = gen_forest(self._services, Vertex(agent_pos), Vertex(goal_pos), [])\n\n        self._graph.edges_removable = True\n        self._max_dist_min = 3.0\n        self._max_dist_max = 15.0\n        self._iterations = 10000\n        self._max_smoothing_steps = 15\n        self._goal_sample_rate = 0.2\n        self._timeout_sec = 30.0\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Adaptive goal biasing: increase goal bias with time/iterations\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            sample = Point(*[\n                torch.randint(0, self._get_grid().size[i], (1,)).item()\n                for i in range(self._get_grid().size.n_dim)\n            ])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _adaptive_max_dist(self, from_point: Point) -> float:\n        # Reduce step size near obstacles to improve robustness\n        check_radius = 5\n        obstacles = self._get_grid().obstacles\n        dist_min = self._max_dist_max\n        for obs in obstacles:\n            # Use Euclidean distance from from_point to obstacle bounds (rough)\n            obs_bound = self._get_grid().get_obstacle_bound(obs.position)\n            for p in obs_bound:\n                d = Map.get_distance(from_point, p)\n                if d < dist_min:\n                    dist_min = d\n                    if dist_min <= self._max_dist_min:\n                        return self._max_dist_min\n        return max(self._max_dist_min, min(self._max_dist_max, dist_min))\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir_vec)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / norm_dir\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_nearby_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _cost(self, parent: Vertex, child: Vertex) -> float:\n        return parent.cost + self._get_grid().get_movement_cost(parent.position, child.position)\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        for q_near in nearby_vertices:\n            if q_near is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                new_cost = self._cost(q_new, q_near)\n                if new_cost < q_near.cost:\n                    # Rewire q_near to q_new\n                    # Remove old parents of q_near\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self) -> None:\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # Find connection vertex common to both trees or closest connection\n        connection_vertex = None\n        min_cost_sum = float('inf')\n\n        # Collect all goal subtree vertices for quick lookup\n        goal_vertices = set()\n        def collect_goal(v: Vertex) -> bool:\n            goal_vertices.add(v)\n            return True\n        self._graph.walk_dfs([goal_root], collect_goal)\n\n        def collect_start(v: Vertex) -> bool:\n            nonlocal connection_vertex, min_cost_sum\n            if v in goal_vertices:\n                cost = v.cost + v.cost  # cost is same both sides, just simplified\n                if cost < min_cost_sum:\n                    connection_vertex = v\n                    min_cost_sum = cost\n            return True\n        self._graph.walk_dfs([start_root], collect_start)\n\n        if connection_vertex is None:\n            # Try a fallback: closest vertex pairs between trees, minor performance hit\n            start_vertices = [v for v in self._graph.root_vertices if v.cost < float('inf')]\n            goal_vertices_list = list(goal_vertices)\n            for sv in start_vertices:\n                for gv in goal_vertices_list:\n                    line_seq = self._get_grid().get_line_sequence(sv.position, gv.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        cost_sum = sv.cost + self._get_grid().get_distance(sv.position, gv.position) + gv.cost\n                        if cost_sum < min_cost_sum:\n                            connection_vertex = sv\n                            min_cost_sum = cost_sum\n\n            if connection_vertex is None:\n                # As a last resort, fallback to start root vertex only path (should rarely occur)\n                connection_vertex = start_root\n\n        # Trace path from connection_vertex back to start root\n        path_from_start = []\n        current = connection_vertex\n        while True:\n            path_from_start.append(current)\n            if current is start_root or len(current.parents) == 0:\n                break\n            # Choose parent with lowest cost (heuristic)\n            current = min(current.parents, key=lambda p: p.cost)\n\n        path_from_start.reverse()\n\n        # Trace path from connection_vertex back to goal root\n        path_from_goal = []\n        current = connection_vertex\n        while True:\n            path_from_goal.append(current)\n            if current is goal_root or len(current.parents) == 0:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n\n        # Combine paths avoiding duplication of connection vertex\n        path = path_from_start + path_from_goal[1:]\n\n        # Path smoothing by shortcutting\n        path = self._smooth_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        smoothed_path = path[:]\n        n = len(smoothed_path)\n        if n <= 2:\n            return smoothed_path\n\n        steps = 0\n        while steps < self._max_smoothing_steps:\n            i = 0\n            changed = False\n            while i < len(smoothed_path) - 2:\n                for j in range(len(smoothed_path) - 1, i+1, -1):\n                    line_seq = self._get_grid().get_line_sequence(smoothed_path[i].position, smoothed_path[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        # remove intermediate vertices\n                        if j - i > 1:\n                            smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n                            changed = True\n                        break\n                i += 1\n            if not changed:\n                break\n            steps += 1\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # Initialize costs to zero for root vertices\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        for iteration in range(self._iterations):\n\n            if time.time() - start_time > self._timeout_sec:\n                # Timeout: no path found in allocated time\n                break\n\n            # Adaptive goal bias rate increasing gradually\n            self._goal_sample_rate = min(0.6, 0.2 + iteration / self._iterations * 0.4)\n\n            # Sample point biased towards goal increasingly over time\n            q_rand = self._get_random_sample()\n\n            # Alternate expansion between start and goal roots for better connection chances\n            current_root = start_root if iteration % 2 == 0 else goal_root\n            other_root = goal_root if current_root is start_root else start_root\n\n            q_near = self._get_nearest_vertex(current_root, q_rand)\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_rand, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                # invalid extension\n                self.key_frame()\n                continue\n\n            # Add q_new with cost and edge\n            q_new.cost = self._cost(q_near, q_new)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire in neighborhood to improve paths\n            radius = max_dist * 2.5\n            nearby_vertices = self._get_nearby_vertices(q_new, radius)\n            self._rewire(q_new, nearby_vertices)\n\n            # Try to connect q_new to the other tree\n            q_near_other = self._get_nearest_vertex(other_root, q_new.position)\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near_other.position)):\n                q_connect = self._get_new_vertex(q_new, q_near_other.position, self._get_grid().size.n_dim * max_dist)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_connect.position)):\n                    q_connect.cost = self._cost(q_new, q_connect)\n                    self._graph.add_edge(q_new, q_connect)\n\n                    # Rewire after connection\n                    near_connect = self._get_nearby_vertices(q_connect, radius)\n                    self._rewire(q_connect, near_connect)\n\n                    # Check if a path can be extracted by DFS over connectivity\n                    # Heuristic: if goal_root reachable from start_root or vice versa in connectivity, path found\n                    found_path = False\n\n                    visited = set()\n                    stack = [start_root]\n                    while stack:\n                        v = stack.pop()\n                        if v == goal_root:\n                            found_path = True\n                            break\n                        visited.add(v)\n                        for c in v.children:\n                            if c not in visited:\n                                stack.append(c)\n\n                    if found_path:\n                        self._extract_path()\n                        return\n\n            # Visualization keyframe\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm combines goal-biased sampling with heuristic-guided tree expansion to improve planning efficiency and path quality.\n    It builds a forest (tree) of vertices starting from the agent's position, incrementally connecting samples biased towards the goal.\n    It uses an adaptive step size that shrinks near obstacles and grows in free space, improving connectivity and path smoothness.\n    A heuristic cost combining actual traveled cost and an admissible estimate to goal (like A*) guides connection and rewiring,\n    enabling earlier discovery of high-quality paths. It performs local rewiring for local optimization.\n    The path extraction performs a smoothing shortcut step reducing unnecessary intermediate points.\n    The algorithm includes an early stopping condition based on success or 10 seconds timeout for robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n        # Initialize start and goal vertices and the forest graph\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 3000\n        self._max_step_distance = 12.0\n        self._min_step_distance = 4.0\n        self._rewire_radius = 20.0\n        self._goal_bias_prob = 0.2  # 20% samples directly biased to goal\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _heuristic_cost(self, vertex: Vertex) -> float:\n        \"\"\"Cost estimate = real cost from start + heuristic to goal.\"\"\"\n        goal_pos = self._get_grid().goal.position\n        heuristic = self._get_distance(vertex.position, goal_pos)\n        return vertex.cost + heuristic\n\n    def _adaptive_step_size(self, from_pos: Point) -> float:\n        \"\"\"\n        Compute adaptive step size depending on clearance from obstacles.\n        Smaller step size near obstacles for precision, larger in open space.\n        \"\"\"\n        # Direction we will consider: towards goal\n        goal_pos = self._get_grid().goal.position\n        dir_vec = goal_pos.to_tensor() - from_pos.to_tensor()\n        dist_to_goal = float(torch.norm(dir_vec))\n\n        # Simple clearance estimate: count valid neighbors from from_pos within a small radius\n        neighbors = self._get_grid().get_next_positions(from_pos)\n        clearance_factor = len(neighbors) / 8  # max neighbors in 2D grid could be 8\n        clearance_factor = max(0.1, min(1.0, clearance_factor))  # Clamp\n\n        step_size = self._min_step_distance + clearance_factor * (self._max_step_distance - self._min_step_distance)\n        if dist_to_goal < step_size:\n            step_size = dist_to_goal  # never overshoot goal\n        return step_size\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Goal-biased sampling: with _goal_bias_prob probability sample goal exactly.\"\"\"\n        import random\n        if random.random() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n        while True:\n            sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Search only from start root vertices for growth\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> \"List[Vertex]\":\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir_vec)\n        if dir_norm <= max_dist and dir_norm > 0:\n            return Vertex(q_sample)\n        if dir_norm == 0:  # identical points\n            return Vertex(q_near.position)\n        dir_normalized = dir_vec / dir_norm\n        new_point_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point.from_tensor(new_point_tensor))\n        return q_new\n\n    def _extract_path(self, goal_parent: Vertex) -> None:\n        \"\"\"\n        Extract path from goal to start, then smooth it by shortcutting.\n        Move agent along the smoothed path with keyframing.\n        \"\"\"\n        path: \"List[Vertex]\" = list()\n        current = Vertex(self._get_grid().goal.position)\n        current.cost = goal_parent.cost + self._get_distance(goal_parent.position, current.position)\n        self._graph.add_edge(goal_parent, current)\n\n        # Build path backward\n        while current.parents:\n            path.append(current)\n            # Select first parent (forest, so only one parent expected)\n            current = next(iter(current.parents))\n\n        path.append(current)  # add start vertex\n        path.reverse()\n\n        # Path smoothing via shortcutting\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Try to shortcut as far as possible with collision-free line\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[test_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = test_idx\n                    break\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n\n        # Move the agent along the smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # For ROS extension waypoint publishing if applicable\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\") and callable(getattr(grid, \"publish_wp\")):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _rewire(self, q_new: Vertex, neighbors: \"List[Vertex]\") -> None:\n        \"\"\"\n        Attempt to rewire neighbors to q_new if this reduces their cost \n        and is collision-free.\n        \"\"\"\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._get_distance(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                # Remove old edge from parent to q_near\n                old_parents = list(q_near.parents)\n                for old_parent in old_parents:\n                    self._graph.remove_edge(old_parent, q_near)\n                # Add edge from q_new to q_near and update cost\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        iteration = 0\n        while iteration < self._max_iterations:\n            iteration += 1\n            # Timeout check\n            if (time.time() - start_time) > 10.0:\n                # Timeout reached, no path found\n                # Could set a flag or simply break and return\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            max_step = self._adaptive_step_size(q_nearest.position)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_step)\n\n            # Check if new point is the same as nearest - ignore redundant sample\n            if q_new.position == q_nearest.position:\n                continue\n\n            # Validate by collision checking line between q_nearest and q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost and connect q_new\n            cost_to_new = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n            q_new.cost = cost_to_new\n\n            # Radius for near vertices rewiring scaled by graph size and dimension heuristic (2D here)\n            V_size = max(1, self._graph.size)\n            rewiring_radius = min(self._rewire_radius, 30 * ((torch.log(torch.tensor(float(V_size))) / float(V_size)) ** 0.5))\n\n            near_vertices = self._get_vertices_within_radius(q_new, rewiring_radius)\n            q_min = q_nearest\n            c_min = cost_to_new\n\n            # Check candidates for better connection (like RRT*)\n            for q_near in near_vertices:\n                if q_near.position == q_new.position:\n                    continue\n                line_seq_candidate = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    continue\n                tentative_cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if tentative_cost < c_min:\n                    q_min = q_near\n                    c_min = tentative_cost\n\n            # Set best parent found\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for local optimization\n            self._rewire(q_new, near_vertices)\n\n            # Early stopping if goal reached within radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            # Add vertex q_new into the forest's root vertices list to allow further expansion\n            self._graph.root_vertices.append(q_new)\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an adaptive RRT* inspired approach combined with goal-bias sampling and heuristic-guided vertex selection.\n    It improves planning efficiency and path quality by:\n    - Using an adaptive max step size to better traverse open spaces and slow down near obstacles or close to the goal.\n    - Biasing sampling towards the goal with increasing frequency.\n    - Employing a heuristic cost (distance + cost-to-come) to select extension vertices.\n    - Rewiring vertices within a neighborhood radius to continuously optimize the tree cost.\n    - Including a smoothing shortcut step at the end to prune unnecessary waypoints.\n    - Early stopping if the path is found and no improvement occurs for consecutive iterations.\n    - Failure detection based on a 10-second timeout to stop long unsuccessful runs.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                 Vertex(self._get_grid().goal.position, store_connectivity=True), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_base_dist = 15.0\n        self._min_dist = 3.0\n        self._iterations = 10000\n        self._goal_bias_start = 0.2\n        self._goal_bias_end = 0.6\n        self._rewire_radius = 20.0\n        self._no_improve_limit = 100\n        self._timeout_limit_sec = 10\n        self._start_time = None\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        # Adaptive goal bias increasing with iteration\n        goal_bias = min(self._goal_bias_start + (self._goal_bias_end - self._goal_bias_start) * (iteration / self._iterations),\n                        self._goal_bias_end)\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position  # goal bias sample\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        vec_normalized = vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * vec_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Select the parent vertex that results in the least cost path to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            step_cost = self._get_grid().get_movement_cost(v.position, q_new.position)\n            total_cost = v.cost + step_cost\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = v\n        if best_parent is None:\n            return None\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex):\n        # Try to rewire existing vertices to go through q_new for cost improvement\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            step_cost = self._get_grid().get_movement_cost(q_new.position, v.position)\n            new_cost = q_new.cost + step_cost\n            if new_cost < v.cost:\n                # Remove old parents edges and connect q_new instead\n                for parent in list(v.parents):\n                    self._graph.remove_edge(parent, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _extract_path(self, q_best: Vertex):\n        # Trace path from best vertex to start\n        path = [q_best]\n        while len(path[-1].parents) > 0:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut smoothing\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) <= 2:\n            return path\n        optimized_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                seq = self._get_grid().get_line_sequence(optimized_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(seq):\n                    break\n                j -= 1\n            optimized_path.append(path[j])\n            i = j\n        return optimized_path\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        # Adaptive step size: decreases near goal or obstacles\n        dist_to_goal = self._get_grid().get_distance(pos, self._get_grid().goal.position)\n        # get next positions for density\n        next_positions = self._get_grid().get_next_positions(pos)\n        obs_factor = max(1.0, 5.0 - len(next_positions))  # fewer free neighbors => smaller step\n        max_dist = max(self._min_dist, min(self._max_base_dist, dist_to_goal / 2.0)) / obs_factor\n        return max_dist\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n\n        start_vertex: Vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        goal_pos: Point = self._get_grid().goal.position\n\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n        no_improve_count = 0\n\n        for iteration in range(self._iterations):\n            # Timeout check\n            elapsed_time = time.time() - self._start_time\n            if elapsed_time > self._timeout_limit_sec:\n                break\n\n            q_sample: Point = self._get_random_sample(iteration)\n\n            # Select the nearest vertex with heuristic cost weighting (cost + heuristic)\n            candidate_vertices = self._graph.root_vertices\n            # Add all tree nodes to list for selection\n            all_vertices = []\n            def collect(vertex):\n                all_vertices.append(vertex)\n                return True\n            self._graph.walk_dfs(collect)\n\n            def vertex_score(v: Vertex):\n                heuristic = self._get_grid().get_distance(v.position, q_sample)\n                return v.cost + heuristic\n\n            nearest_vertex = min(all_vertices, key=vertex_score)\n\n            adaptive_dist = self._adaptive_max_dist(nearest_vertex.position)\n            q_new = self._get_new_vertex(nearest_vertex, q_sample, adaptive_dist)\n\n            # Check if valid path from nearest_vertex to q_new\n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Find neighbors within radius for rewiring and parent selection\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n            if not near_vertices:\n                near_vertices = [nearest_vertex]  # fallback if none found\n\n            # Choose best parent to minimize cost\n            parent_vertex = self._choose_parent(near_vertices, q_new)\n            if parent_vertex is None:\n                self.key_frame()\n                continue\n\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire near vertices through q_new if improves cost\n            self._rewire(near_vertices, q_new)\n\n            # Check if new vertex is inside goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < best_goal_cost:\n                    best_goal_cost = q_new.cost\n                    best_goal_vertex = q_new\n                    no_improve_count = 0  # reset no improvement\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self._no_improve_limit:\n                    break  # stop if no improvement for limit iterations\n\n            else:\n                no_improve_count += 1\n\n            self.key_frame()\n\n        # Extract path if found\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an A*-inspired heuristic-driven anytime RRT* variant with adaptive step sizing,\n    goal-bias sampling, and path smoothing to improve planning efficiency, success rate, and path quality.\n    Core features:\n    - Uses a Forest graph storing start and goal roots.\n    - Samples with a goal-biased probability for rapid goal approach.\n    - Adaptive max_dist reduces step size near obstacles or goal for finer refinements.\n    - Incorporates rewiring in vertex neighborhoods to optimize path cost (RRT* style).\n    - Uses heuristic cost (cost-to-come + estimated cost-to-go) to guide vertex expansion.\n    - Early stopping upon path quality stabilization or time limit (10 seconds).\n    - Extracts and smooths final path with shortcutting for better quality.\n    - Ensures robustness by repeated attempts and fallback on less optimal paths if necessary.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _iterations: int\n    _goal_sample_rate: float  # Probability to sample goal directly\n    _search_radius_factor: float\n    _start_time: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph as a forest with start and goal vertices\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # allow rewiring/removal\n        self._max_dist_base = 12.0\n        self._iterations = 5000\n        self._goal_sample_rate = 0.1  # 10% goal bias\n        self._search_radius_factor = 30.0  # radius for rewiring neighborhood\n        self._init_displays()\n\n    def _heuristic(self, point: Point) -> float:\n        \"\"\"Estimate cost-to-go from point to goal.\"\"\"\n        return self._get_grid().get_distance(point, self._get_grid().goal.position)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"Return movement cost between two vertices.\"\"\"\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _adaptive_max_dist(self, point: Point) -> float:\n        \"\"\"Adapt max_dist based on proximity to obstacles or goal.\"\"\"\n        dist_to_goal = self._get_grid().get_distance(point, self._get_grid().goal.position)\n        max_dist = self._max_dist_base\n        # Reduce step size near goal for precision\n        if dist_to_goal < 30.0:\n            max_dist = max_dist * (dist_to_goal / 30.0)\n        # Further reduce step size if near obstacles by checking neighbors\n        neighbors = self._get_grid().get_next_positions(point)\n        for npos in neighbors:\n            if not self._get_grid().is_agent_valid_pos(npos):\n                max_dist = min(max_dist, 3.0)  # fine step near obstacles\n                break\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if torch.rand(1).item() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        # Returns the closest Vertex in vertices to given point\n        nearest = None\n        min_dist = float('inf')\n        for v in vertices:\n            dist = self._get_grid().get_distance(v.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = v\n        return nearest\n\n    def _vertices_within_radius(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        # Returns vertices within radius of point\n        result = []\n        for v in vertices:\n            if self._get_grid().get_distance(v.position, point) <= radius:\n                result.append(v)\n        return result\n\n    def _line_clear(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, vertex_new: Vertex, neighbors: List[Vertex]) -> None:\n        # RRT* style rewiring to minimize cost\n        for v_near in neighbors:\n            if v_near == vertex_new:\n                continue\n            if not self._line_clear(vertex_new.position, v_near.position):\n                continue\n            new_cost = vertex_new.cost + self._cost(vertex_new, v_near)\n            if new_cost < v_near.cost:\n                # Remove old parent edges first\n                for parent in list(v_near.parents):\n                    self._graph.remove_edge(parent, v_near)\n                # Add new edge from vertex_new to v_near\n                self._graph.add_edge(vertex_new, v_near)\n                v_near.cost = new_cost\n\n    def _update_costs_from(self, vertex: Vertex) -> None:\n        # Propagate cost updates down the tree\n        stack = [vertex]\n        while stack:\n            current = stack.pop()\n            for child in current.children:\n                new_cost = current.cost + self._cost(current, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _extract_path(self) -> None:\n        # Extract path from start to goal by DFS cost optimal path\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Trace back from goal to start via minimum cost parents\n        path_vertices = [goal_vertex]\n        current = goal_vertex\n        while current != start_vertex:\n            if not current.parents:\n                # No path found, break out\n                break\n            # Choose parent with minimum cost + step cost (robust backward)\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                cost_candidate = p.cost + self._cost(p, current)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    min_parent = p\n            if min_parent is None:\n                break\n            current = min_parent\n            path_vertices.append(current)\n\n        path_vertices.reverse()\n\n        # Smooth extracted path by shortcutting\n        smoothed_path = [path_vertices[0]]\n        idx = 0\n        while idx < len(path_vertices) - 1:\n            next_idx = len(path_vertices) - 1\n            while next_idx > idx + 1:\n                if self._line_clear(path_vertices[idx].position, path_vertices[next_idx].position):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path_vertices[next_idx])\n            idx = next_idx\n\n        # Move agent along smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Initialize cost for start vertex\n        start_vertex.cost = 0.0\n        goal_vertex.cost = float('inf')\n\n        all_vertices = [start_vertex, goal_vertex]  # maintain vertex list\n\n        best_cost_to_goal = float('inf')\n        best_path_found = False\n\n        for iteration in range(self._iterations):\n            # Time cutoff for search\n            if time.time() - self._start_time > 10.0:\n                # Timeout fallback\n                break\n\n            q_rand = self._get_random_sample()\n\n            q_near = self._nearest_vertex(all_vertices, q_rand)\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_rand, max_dist)\n\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            if not self._line_clear(q_near.position, q_new.position):\n                continue\n\n            # Prepare new vertex cost and insert vertex into graph\n            q_new.cost = q_near.cost + self._cost(q_near, q_new)\n\n            # Neighborhood for rewiring\n            radius = self._search_radius_factor * ( (np.log(len(all_vertices)+1) / (len(all_vertices)+1)) ** (1/3) )\n            neighbors = self._vertices_within_radius(all_vertices, q_new.position, radius)\n\n            # Choose best parent for q_new to minimize cost\n            min_cost = q_new.cost\n            best_parent = q_near\n\n            for v_near in neighbors:\n                if v_near == q_near:\n                    continue\n                if not self._line_clear(v_near.position, q_new.position):\n                    continue\n                candidate_cost = v_near.cost + self._cost(v_near, q_new)\n                if candidate_cost < min_cost:\n                    min_cost = candidate_cost\n                    best_parent = v_near\n            q_new.cost = min_cost\n\n            # Add vertex and connect edge from best_parent\n            all_vertices.append(q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for potential improvements\n            self._rewire(q_new, neighbors)\n\n            # If q_new close enough to goal, try to connect goal\n            dist_to_goal = self._get_grid().get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= max_dist:\n                if self._line_clear(q_new.position, goal_vertex.position):\n                    # Try rewiring goal parent if better\n                    new_cost_goal = q_new.cost + self._cost(q_new, goal_vertex)\n                    if new_cost_goal < goal_vertex.cost:\n                        # Remove old parents of goal vertex\n                        for p in list(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        goal_vertex.cost = new_cost_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Re-update costs from goal vertex downward\n                        self._update_costs_from(goal_vertex)\n                        best_path_found = True\n                        best_cost_to_goal = goal_vertex.cost\n\n            # Early stopping if a good path has already been found and iteration limit passed enough\n            if best_path_found and iteration > 1000:\n                # Try to smooth/extract path and finish early\n                self._extract_path()\n                return\n\n            # Visualization step\n            self.key_frame()\n\n        # At end of iterations or timeout, check if path to goal found\n        if best_path_found:\n            self._extract_path()\n        else:\n            # Fail-safe: attempt to find any connection from start to goal by best effort\n            # Select vertex closest to goal (with path from start)\n            connect_vertex = None\n            min_goal_dist = float('inf')\n            for v in all_vertices:\n                if v.cost < float('inf'):\n                    dist_to_goal = self._get_grid().get_distance(v.position, goal_vertex.position)\n                    if dist_to_goal < min_goal_dist:\n                        min_goal_dist = dist_to_goal\n                        connect_vertex = v\n            if connect_vertex is not None:\n                if self._line_clear(connect_vertex.position, goal_vertex.position):\n                    # Connect goal vertex if possible\n                    self._graph.add_edge(connect_vertex, goal_vertex)\n                    goal_vertex.cost = connect_vertex.cost + self._cost(connect_vertex, goal_vertex)\n                    self._extract_path()\n                    return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved, heuristic-guided variant inspired by RRT*, incorporating:\n    - Goal-biased sampling (80% random samples, 20% goal samples) for faster convergence.\n    - Adaptive step size: dynamically reduces max_dist near obstacles for safer navigation.\n    - Rewiring for path optimization to produce shorter paths as vertices are added.\n    - A* heuristic (cost + Euclidean distance) to guide vertex selection (near vertex with best cost-to-go estimate).\n    - Path shortcutting after solution to smooth the found path.\n    - Early stopping when the goal is connected plus a timeout limit of 10 seconds.\n    \n    This approach aims for a balance between exploration and exploitation to enhance path quality and planning efficiency.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        # Goal bias sampling: 20% samples at goal, 80% random valid positions\n        if np.random.rand() < 0.2:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _cost(self, v: Vertex) -> float:\n        # Cost from start to this vertex\n        return v.cost\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance heuristic from p to goal\n        return self._get_grid().get_distance(p, self._get_grid().goal.position)\n\n    def _total_cost(self, v: Vertex) -> float:\n        # f = g + h\n        return self._cost(v) + self._heuristic(v.position)\n\n    def _choose_parent(self, Q_near: list, q_new: Vertex, max_dist: float) -> Vertex:\n        # Choose the parent vertex that minimizes cost to q_new via that vertex\n        best_parent = None\n        best_cost = float(\"inf\")\n        for q_near in Q_near:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            step_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            total_cost = q_near.cost + step_cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, Q_near: list, q_new: Vertex, max_dist: float) -> None:\n        # For vertices within radius, try to improve their cost by connecting through q_new\n        for q_near in Q_near:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            step_cost = self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            new_cost = q_new.cost + step_cost\n            if new_cost < q_near.cost:\n                # Remove old parent edges\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        # Attempt to shortcut path by directly connecting farther nodes if line is valid\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, just add next node\n                shortcut_path.append(path[i + 1])\n                i += 1\n        return shortcut_path\n\n    def _extract_path(self, q_connected: Vertex):\n        # Build path from goal to start by parents\n        path = [Vertex(self._get_grid().goal.position)]\n        # Connect q_connected to goal vertex\n        self._graph.add_edge(q_connected, path[0])\n        q_current = q_connected\n        while q_current.parents:\n            # Always pick parent with lowest cost\n            parent = min(q_current.parents, key=lambda v: v.cost)\n            path.append(parent)\n            q_current = parent\n        path.reverse()\n\n        # Shortcut/smooth path to improve quality\n        path = self._shortcut_path(path)\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        # Reduce step size if q_near close to obstacles for safer expansion\n        obstacle_radius = 5.0  # threshold distance to obstacle to reduce step\n        base_max_dist = 10.0\n        min_max_dist = 3.0\n\n        min_dist_to_obs = float(\"inf\")\n        for obs in self._get_grid().obstacles:\n            obs_center = obs.position\n            dist = self._get_grid().get_distance(q_near.position, obs_center) - obs.radius\n            if dist < min_dist_to_obs:\n                min_dist_to_obs = dist\n        if min_dist_to_obs < obstacle_radius:\n            # Interpolate linearly between min_max_dist and base_max_dist depending on distance\n            f = max(0, min_dist_to_obs / obstacle_radius)\n            return min_max_dist + f * (base_max_dist - min_max_dist)\n        else:\n            return base_max_dist\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_global_iterations = 5000\n        iteration = 0\n        start_time = time.monotonic()\n\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n\n        root_start.cost = 0.0\n        self._graph.root_vertices = [root_start]\n\n        found_goal = False\n        best_goal_vertex = None\n        best_goal_cost = float(\"inf\")\n\n        # Pre-allocate reuse data structures\n        radius_rewire = 15.0  # Radius to look for neighbors for rewiring and parent choosing\n\n        while iteration < max_global_iterations and (time.monotonic() - start_time) < 10.0:\n            iteration += 1\n\n            q_sample = self._get_random_sample()\n\n            # Select best candidate to connect to q_sample based on cost + heuristic (A* style)\n            nearby_vertices = self._graph.get_vertices_within_radius([root_start], q_sample, radius_rewire)\n            if not nearby_vertices:\n                # Fallback: nearest vertex if no nearby vertices in radius\n                q_near = self._graph.get_nearest_vertex([root_start], q_sample)\n            else:\n                # Choose vertex minimizing cost-to-come + estimated cost to goal via q_sample\n                def cost_to_q_sample(v: Vertex) -> float:\n                    line_seq = self._get_grid().get_line_sequence(v.position, q_sample)\n                    if not self._get_grid().is_valid_line_sequence(line_seq):\n                        return float(\"inf\")\n                    return v.cost + self._get_grid().get_distance(v.position, q_sample)\n\n                q_near = min(nearby_vertices, key=cost_to_q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq_new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq_new):\n                continue\n\n            # Find best parent in neighborhood for q_new\n            Q_near_for_parent = self._graph.get_vertices_within_radius([root_start], q_new.position, radius_rewire)\n            best_parent = self._choose_parent(Q_near_for_parent, q_new, max_dist)\n            if best_parent is None:\n                # Connect to q_near if no better parent found\n                best_parent = q_near\n\n            # Set the cost for q_new via best_parent\n            step_cost = self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            q_new.cost = best_parent.cost + step_cost\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to improve path quality\n            Q_near_for_rewire = self._graph.get_vertices_within_radius([root_start], q_new.position, radius_rewire)\n            self._rewire(Q_near_for_rewire, q_new, max_dist)\n\n            # Check if q_new reaches goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_cost = q_new.cost + self._get_grid().get_distance(q_new.position, self._get_grid().goal.position)\n                if goal_cost < best_goal_cost:\n                    found_goal = True\n                    best_goal_cost = goal_cost\n                    best_goal_vertex = q_new\n                    # Early stopping on improved solution found after minimum iterations\n                    if iteration > 100:\n                        break\n\n            self.key_frame()\n\n        if found_goal and best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)\n        else:\n            # No path found in given time/iterations, call key frame once for visualization\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* inspired planner designed for efficient and high-quality pathfinding on a discrete grid.\n    Key enhancements include:\n    - Goal-biased sampling that leans towards the goal 20% of the time for faster convergence.\n    - Adaptive step size (`max_dist`) that reduces as the tree grows to fine-tune exploration and resolution.\n    - RRT* style rewiring: after adding a new vertex, nearby vertices within a radius are checked for rewiring to improve path cost.\n    - Heuristic-guided cost calculation using movement cost plus a heuristic (Euclidean distance to goal).\n    - Early stopping when the path is found, or the time limit (10 seconds) is exceeded.\n    - Path extraction incorporates a shortcut smoothing by skipping unnecessary intermediate vertices where possible.\n    This approach aims for faster, smoother, and more reliable path solutions while maintaining robustness in complex environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable rewiring edge removal\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Goal-biased sampling: 20% samples near goal, 80% random valid positions.\n        \"\"\"\n        import random\n        if random.random() < 0.2:\n            # Sample near the goal with a small perturbation (within 5 units radius)\n            goal_pos: Point = self._get_grid().goal.position\n            for _ in range(100):  # try max 100 times to find a valid goal-biased sample\n                offset = np.random.randint(-5, 6, self._get_grid().size.n_dim)\n                candidate = Point(*(goal_pos.to_tuple()[i] + offset[i] for i in range(self._get_grid().size.n_dim)))\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n        # Otherwise uniform random sampling\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n\n        if dist <= max_dist:\n            new_position = q_sample\n        else:\n            direction_normalized = direction / dist\n            new_position = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n\n        return Vertex(new_position)\n\n    def _calc_cost(self, parent: Vertex, child: Vertex) -> float:\n        return parent.cost + self._get_grid().get_movement_cost(parent.position, child.position)\n\n    def _choose_parent(self, q_new: Vertex, nearby_vertices: list) -> Vertex:\n        \"\"\"\n        Among vertices in nearby_vertices, choose the parent vertex with \n        lowest cost to q_new, if a valid collision-free connection exists.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n\n        for vertex in nearby_vertices:\n            line_seq = self._get_grid().get_line_sequence(vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = self._calc_cost(vertex, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n\n        if best_parent is None:\n            return None\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: list) -> None:\n        \"\"\"\n        Attempt to rewire nearby vertices to q_new if cost improves and edge is collision-free.\n        \"\"\"\n        for vertex in nearby_vertices:\n            if vertex == q_new or vertex == self._graph.root_vertex_start:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_new.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, vertex.position)\n            if new_cost < vertex.cost:\n                # Remove old parent edges\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n                # Add new edge from q_new to vertex\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        \"\"\"\n        Extract the path from goal to start by walking parents,\n        then attempt shortcut smoothing by removing intermediate waypoints if possible.\n        \"\"\"\n        path = [q_last]\n        current = q_last\n\n        while len(current.parents) != 0:\n            # Always pick one parent (arbitrary if multiple, no cycle expected)\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n\n        path.reverse()\n\n        # Shortcut smoothing: try to skip intermediate points if direct line is collision-free\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist_init = 15.0\n        radius_rewire_init = 20.0\n        iterations = 15000\n        start_time = time.time()\n\n        # Initialize root vertex start cost 0 and goal cost large\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for i in range(iterations):\n            # Time check for early stop if > 10 seconds\n            if time.time() - start_time > 10.0:\n                # Consider path not found; stop search\n                break\n\n            # Adaptive max_dist: linearly reduce max_dist as tree grows (smaller steps for higher resolution)\n            max_dist = max(5.0, max_dist_init * (1 - self._graph.size / iterations))\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check valid connection line segment from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find nearby vertices for choosing best parent and rewiring\n            radius_rewire = max(radius_rewire_init * (1 - self._graph.size / iterations), max_dist)\n            nearby_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius_rewire)\n            if len(nearby_vertices) == 0:\n                nearby_vertices = [q_near]\n\n            # Choose best parent for q_new with minimal cost\n            best_parent = self._choose_parent(q_new, nearby_vertices)\n            if best_parent is None:\n                # No valid parent connection found\n                continue\n\n            # Add edge from best parent to q_new\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices if better cost with q_new as parent\n            self._rewire(q_new, nearby_vertices)\n\n            # If close to goal, attempt to connect directly to goal with collision check\n            goal_pos = self._get_grid().goal.position\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist * 1.2:\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = float('inf')  # initialize cost\n                    # Choose parent for goal among close vertices (including q_new)\n                    close_to_goal = self._graph.get_vertices_within_radius(self._graph.root_vertices + [q_new], goal_pos, max_dist * 1.5)\n                    best_goal_parent = self._choose_parent(goal_vertex, close_to_goal)\n                    if best_goal_parent is not None:\n                        goal_vertex.cost = self._calc_cost(best_goal_parent, goal_vertex)\n                        self._graph.add_edge(best_goal_parent, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved Hybrid Heuristic RRT with Adaptive Step and Goal Biasing.\n    It combines several enhancements:\n    - Adaptive step size (max_dist) based on local obstacle density (estimated via nearby vertices),\n      allowing finer exploration in cluttered regions and larger steps in free space.\n    - Goal-biased sampling with an adjustable probability to increase chances of direct goal connections.\n    - Heuristic guided parent choosing based on combined cost-to-come + heuristic-to-go (A*-style) to prefer vertices leading to shorter paths.\n    - Local rewiring based on radius neighborhood to optimize path cost similarly to RRT*.\n    - Post-processing smooth shortcut attempts on path extraction to improve path quality.\n    - Early termination with a global time limit (10 seconds).\n    This should provide improved planning efficiency, path quality, and robustness over baseline RRT and RRT*.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist_base = 15.0  # base max_dist, dynamically adjusted per iteration\n        self._goal_sample_rate = 0.2  # 20% chance to sample goal directly for biasing\n        self._rewire_radius_constant = 40\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, vertex: Vertex) -> float:\n        # Adaptive step length: reduce max_dist if many neighbors nearby (dense obstacles),\n        # increase max_dist if sparser area.\n        radius_check = 10.0\n        neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius_check)\n        density_ratio = max(1, len(neighbors)) / (self._graph.size + 1)\n        # Inverse relation: more neighbors => smaller step\n        max_dist = max(5.0, self._max_dist_base * (1.0 - 0.7 * density_ratio))\n        return max_dist\n\n    def _get_random_sample(self) -> Point:\n        # Goal biasing: sample the goal with goal_sample_rate probability directly to speed up connecting to goal.\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        # Else uniform sample with validity check.\n        attempts = 0\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n            if attempts > 100:  # fallback heuristic sample near goal if stuck\n                goal_pos = self._get_grid().goal.position\n                offset = np.random.randint(-10, 11, self._get_grid().size.n_dim)\n                near_goal = Point(*(goal_pos.to_list()[i] + offset[i] for i in range(self._get_grid().size.n_dim)))\n                if self._get_grid().is_agent_valid_pos(near_goal):\n                    return near_goal\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pt)\n\n    def _heuristic_cost(self, p: Point) -> float:\n        # Euclidean straight line distance from p to goal (heuristic for informed search)\n        return Map.get_distance(p, self._get_grid().goal.position)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        # Connect last vertex directly to goal\n        if not any(parent.position == goal_v.position for parent in q_new.parents):\n            self._graph.add_edge(q_new, goal_v)\n\n        # Backtrack path from goal to start by always choosing parent with lowest cost + heuristic cost\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            parents = list(path[-1].parents)\n            # Choose parent minimizing cost + heuristic\n            best_parent = min(parents, key=lambda p: p.cost + self._heuristic_cost(p.position))\n            path.append(best_parent)\n\n        path.pop()  # remove start duplicate\n        path.reverse()\n\n        # Smooth path shortcutting to improve path quality\n        path = self._smooth_path(path)\n\n        # Animate the path following\n        for p in path:\n            self.move_agent(p.position)\n            # ROS wp publishing if needed\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp') and callable(getattr(grid, 'publish_wp')):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut the path by connecting non-adjacent vertices if collision free\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # Find furthest vertex reachable from smoothed_path[-1]\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        max_iterations = 8000\n        dimension = 2\n        c_best = float('inf')\n        best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            # Check time limit for early exit (timeout if > 10s)\n            if time.time() - start_time > 10.0:\n                # Fail gracefully: stop and abort path search\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within radius for rewiring, radius shrinking with graph size\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v + 1.0)\n            max_radius = self._rewire_radius_constant\n            radius = min(max_radius, self._rewire_radius_constant * ((log_card_v / (card_v + 1)) ** (1 / dimension)))\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose best parent with minimal cost + heuristic + collision check\n            q_min = q_near\n            c_min = q_near.cost + Map.get_distance(q_near.position, q_new.position)\n            for q_near_candidate in neighbors:\n                candidate_line_seq = self._get_grid().get_line_sequence(q_near_candidate.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(candidate_line_seq):\n                    continue\n                cand_cost = q_near_candidate.cost + Map.get_distance(q_near_candidate.position, q_new.position)\n                if cand_cost < c_min:\n                    q_min = q_near_candidate\n                    c_min = cand_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring neighbors with q_new as potential parent if better and edge valid\n            for q_near_candidate in neighbors:\n                if q_near_candidate == q_min:\n                    continue\n                candidate_line_seq = self._get_grid().get_line_sequence(q_new.position, q_near_candidate.position)\n                if not self._get_grid().is_valid_line_sequence(candidate_line_seq):\n                    continue\n\n                cost_through_new = q_new.cost + Map.get_distance(q_new.position, q_near_candidate.position)\n                if cost_through_new < q_near_candidate.cost:\n                    # Remove old parent edge and add new\n                    old_parent = None\n                    for parent in q_near_candidate.parents:\n                        old_parent = parent\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near_candidate)\n                    q_near_candidate.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near_candidate)\n\n            # Track improvement to best cost path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Construct a temp goal vertex linked to q_new to get path cost\n                temp_goal = Vertex(self._get_grid().goal.position)\n                dist_to_goal = Map.get_distance(q_new.position, temp_goal.position)\n                total_cost = q_new.cost + dist_to_goal\n                if total_cost < c_best:\n                    c_best = total_cost\n                    best_goal_vertex = q_new\n\n            # If best solution found early, extract and stop\n            if best_goal_vertex is not None:\n                self._extract_path(best_goal_vertex)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
