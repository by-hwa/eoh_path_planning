{
     "algorithm": "\"\"\"\n    PathPlanning algorithm combines goal-biased adaptive sampling and heuristic-guided expansion\n    for efficient and robust path planning on a grid.\n    It maintains a Forest graph like RRT* but uses a dynamic max_dist adapting to free space density,\n    and biases sampling progressively more towards the goal for faster convergence.\n    Expansion selects new edges by minimizing estimated total cost (cost-so-far + heuristic to goal),\n    promoting shorter and smoother paths.\n    Path extraction applies a shortcut smoothing via line-of-sight pruning.\n    Early stopping occurs upon reaching the goal or after 30 seconds elapsed,\n    trading planning efficiency and path quality with robustness.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _start_time: float\n    _goal_bias: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize start and goal vertices with cost\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist = 15.0  # initial adaptive step size, can change dynamically\n        self._max_radius = 30.0  # neighborhood radius for rewiring\n        self._goal_bias = 0.2  # initial goal bias for sampling (increases over time)\n        self._start_time = None\n        self._init_displays()\n\n    def _get_random_sample_goal_biased(self) -> Point:\n        \"\"\"\n        Sample randomly with a probability goal_bias to return the goal position\n        to bias exploration towards the goal.\n        \"\"\"\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = []\n                for i in range(self._get_grid().size.n_dim):\n                    rand_pos.append(torch.randint(0, self._get_grid().size[i], (1,)).item())\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_adaptive_max_dist(self) -> float:\n        \"\"\"\n        Adapt the max_dist based on neighborhood density around start vertex.\n        If neighborhood is crowded, reduce step size for finer exploration,\n        else increase it up to a max cap.\n        \"\"\"\n        start_vertex = self._graph.root_vertex_start\n        neighbors = self._graph.get_vertices_within_radius([start_vertex], start_vertex.position, self._max_radius)\n        density = len(neighbors)\n        if density > 20:\n            return max(5.0, self._max_dist * 0.7)  # shrink step size\n        elif density < 5:\n            return min(30.0, self._max_dist * 1.3)  # grow step size\n        else:\n            return self._max_dist  # keep current\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        \"\"\"Euclidean distance heuristic.\"\"\"\n        return Map.get_distance(frm, to)\n\n    def _extract_path_smoothed(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal by backtracking parents,\n        then improve the path by shortcutting (line-of-sight smoothing).\n        Moves the agent along final path with key frames.\n        \"\"\"\n        path: list = [q_new]\n        # Backtrack parents to start\n        current = q_new\n        while current != self._graph.root_vertex_start and len(current.parents) > 0:\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Shortcut path smoothing with line-of-sight pruning\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # publish waypoint if ROS map available\n            grid: Map = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        self._start_time = time.time()\n        max_iterations = 5000\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        dimension = self._get_grid().size.n_dim\n        lambda_star = 40.0\n\n        for iteration in range(max_iterations):\n\n            # Abort if time exceeds 30 seconds\n            if time.time() - self._start_time > 30.0:\n                # No success found in 30s\n                return\n\n            # Gradually increase goal bias to speed convergence\n            self._goal_bias = min(0.9, self._goal_bias + 0.00015)\n\n            # Adaptive max_dist tuning\n            self._max_dist = self._get_adaptive_max_dist()\n\n            q_sample = self._get_random_sample_goal_biased()\n\n            # Find nearest vertex on tree from start root only\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            # Compute new vertex at max_dist or less towards sample\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_vec)\n            if dir_norm == 0:\n                continue\n            if dir_norm <= self._max_dist:\n                q_new = Vertex(q_sample)\n            else:\n                dir_normalized = dir_vec / dir_norm\n                q_new_pos = Point.from_tensor(q_nearest.position.to_tensor() + self._max_dist * dir_normalized)\n                q_new = Vertex(q_new_pos)\n\n            # Check feasibility of edge\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Neighbor radius for rewiring based on RRT* formula\n            card_v = max(1.0, float(self._graph.size))\n            radius = min(lambda_star * ((torch.log(torch.tensor(card_v)) / card_v)**(1/dimension)), self._max_radius)\n\n            Q_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose parent minimizing cost + heuristic\n            min_cost = float('inf')\n            min_parent = None\n            for q_near in Q_near:\n                seq_check = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(seq_check):\n                    continue\n                cost_tmp = q_near.cost + self._heuristic_cost(q_near.position, q_new.position)\n                if cost_tmp < min_cost:\n                    min_cost = cost_tmp\n                    min_parent = q_near\n\n            if min_parent is None:\n                # No valid connection found\n                continue\n\n            # Add edge and update cost of q_new\n            dist_parent_to_new = self._heuristic_cost(min_parent.position, q_new.position)\n            q_new.cost = min_parent.cost + dist_parent_to_new\n            self._graph.add_edge(min_parent, q_new)\n\n            # Rewire within neighbors to optimize path cost\n            for q_near in Q_near:\n                if q_near == min_parent:\n                    continue\n                seq_check = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(seq_check):\n                    continue\n                cost_qnew_qnear = q_new.cost + self._heuristic_cost(q_new.position, q_near.position)\n                if cost_qnew_qnear < q_near.cost:\n                    # Rewire: remove old edge and add new one\n                    for par in q_near.parents:\n                        self._graph.remove_edge(par, q_near)\n                    q_near.cost = cost_qnew_qnear\n                    self._graph.add_edge(q_new, q_near)\n\n            # If newly added vertex close enough to goal, connect goal and extract path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex with q_new\n                dist_to_goal = self._heuristic_cost(q_new.position, goal_vertex.position)\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n\n                self._extract_path_smoothed(goal_vertex)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm combines several advanced techniques for improved path planning on a discrete grid.\n    It uses goal-biased adaptive sampling, with probability to sample near the goal to speed convergence.\n    The tree expands using vertices chosen by a heuristic combining cost-to-come (actual) and estimated cost-to-go (heuristic),\n    inspired by A*-like guidance but within an RRT* style rewiring and optimization framework.\n    The max extension step size adapts dynamically based on local obstacle density to improve connectivity and avoid collisions.\n    It performs local rewiring to optimize paths after every new vertex addition, improving path quality iteratively.\n    A shortcut smoothing step is applied at the end to trim unnecessary path detours.\n    The algorithm stops early upon reaching a solution, or after 30 seconds to comply with time constraints.\n    This approach aims to boost efficiency, robustness, and success rates, and provide smoother, higher-quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_min = 3.0\n        self._max_dist_max = 15.0\n        self._goal_sample_rate = 0.2  # 20% samples are from goal vicinity\n        self._max_iterations = 5000\n        self._rewire_radius = 15.0\n\n    def _get_cost(self, v: Vertex) -> float:\n        return v.cost if hasattr(v, 'cost') else float('inf')\n\n    def _set_cost(self, v: Vertex, cost: float) -> None:\n        v.cost = cost\n\n    def _heuristic(self, p: Point) -> float:\n        return self._get_grid().get_distance(p, self._get_grid().goal.position)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], p: Point) -> Vertex:\n        # Use Euclidean distance for nearest vertex\n        return self._graph.get_nearest_vertex(vertices, p)\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        # Adaptive max_dist based on nearby obstacle density\n        # Count obstacles in radius 5 around pos\n        radius = 5\n        obs_points = set()\n        for obs in self._get_grid().obstacles:\n            obs_bound = self._get_grid().get_obstacle_bound(obs.position)\n            obs_points.update(obs_bound)\n        nearby_obs = [pt for pt in obs_points if self._get_grid().get_distance(pt, pos) <= radius]\n        density = len(nearby_obs) / (radius * radius * 4)  # approx area 4*radius^2\n        # More obstacles -> smaller max_dist to carefully navigate\n        max_dist = self._max_dist_max - density * (self._max_dist_max - self._max_dist_min)\n        if max_dist < self._max_dist_min:\n            max_dist = self._max_dist_min\n        if max_dist > self._max_dist_max:\n            max_dist = self._max_dist_max\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _line_is_valid(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Vertex:\n        # Choose best parent for q_new based on minimal cost with valid path\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in near_vertices:\n            if self._line_is_valid(q_near.position, q_new.position):\n                cost = self._get_cost(q_near) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = q_near\n        if best_parent is not None:\n            self._set_cost(q_new, min_cost)\n            self._graph.add_edge(best_parent, q_new)\n        else:\n            # No valid parent means isolated vertex, set cost as large\n            self._set_cost(q_new, float('inf'))\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # Attempt to improve cost for neighbors by going through q_new\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            if self._line_is_valid(q_new.position, q_near.position):\n                new_cost = self._get_cost(q_new) + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n                if new_cost < self._get_cost(q_near):\n                    # Remove old parent edges and connect q_new as parent\n                    # To have remove functionality:\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    self._set_cost(q_near, new_cost)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            # pick parent with lowest cost (in case multiple)\n            lowest_cost_parent = None\n            lowest_cost = float('inf')\n            for p in path[-1].parents:\n                if self._get_cost(p) < lowest_cost:\n                    lowest_cost = self._get_cost(p)\n                    lowest_cost_parent = p\n            if lowest_cost_parent is None:\n                break\n            path.append(lowest_cost_parent)\n        path.reverse()\n\n        # Shortcut smoothing: attempt shortcut edges between non-adjacent points on path\n        def shortcut_path(path: List[Vertex]) -> List[Vertex]:\n            if len(path) <= 2:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i +1:\n                    if self._line_is_valid(path[i].position, path[j].position):\n                        smoothed.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # no shortcut found, go next\n                    if i+1 < len(path):\n                        smoothed.append(path[i+1])\n                        i +=1\n            return smoothed\n\n        smoothed_path = shortcut_path(path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_random_sample(self) -> Point:\n        grid_size = self._get_grid().size\n        # Goal-biased sampling\n        if np.random.rand() < self._goal_sample_rate:\n            goal_pos = self._get_grid().goal.position\n            # Sample near goal within radius 8\n            search_radius = 8\n            attempt = 0\n            while True:\n                attempt += 1\n                goal_offset = np.random.randint(-search_radius, search_radius + 1, grid_size.n_dim)\n                sample_coords = np.array(goal_pos.to_list()) + goal_offset\n                # clamp coordinates inside grid\n                sample_coords = np.clip(sample_coords, 0, grid_size.n - 1)\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                if attempt > 50:\n                    # fallback to uniform\n                    break\n        # Uniform random sampling\n        while True:\n            rand_pos = np.random.randint(0, grid_size.n, grid_size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        self._set_cost(start_vertex, 0.0)\n\n        for i in range(self._max_iterations):\n            if time.time() - start_time > 30.0:\n                # Timeout: treat as not found, end planning\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Select the best nearest vertex to extend from based on cost + heuristic (A* style)\n            # Candidate vertices to consider: all in forest root vertices\n            candidates = self._graph.root_vertices\n            best_score = float('inf')\n            best_vertex = None\n\n            for v in candidates:\n                dist = self._get_grid().get_distance(v.position, q_sample)\n                heuristic_dist = self._heuristic(q_sample)\n                score = self._get_cost(v) + dist + heuristic_dist\n                if score < best_score:\n                    best_score = score\n                    best_vertex = v\n\n            if best_vertex is None:\n                continue\n\n            max_dist = self._adaptive_max_dist(best_vertex.position)\n            q_new = self._get_new_vertex(best_vertex, q_sample, max_dist)\n\n            if not self._line_is_valid(best_vertex.position, q_new.position):\n                continue\n\n            near_vertices = self._get_near_vertices(q_new, self._rewire_radius)\n\n            parent = self._choose_parent(q_new, near_vertices if near_vertices else [best_vertex])\n            if parent is None:\n                # no valid parent, discard new vertex\n                continue\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Construct goal vertex and connect if needed\n                goal_v = self._graph.root_vertex_goal\n                if self._line_is_valid(q_new.position, goal_v.position):\n                    cost_to_goal = self._get_cost(q_new) + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n                    if cost_to_goal < self._get_cost(goal_v):\n                        # maybe remove old parents and add new edge\n                        for p in list(goal_v.parents):\n                            self._graph.remove_edge(p, goal_v)\n                        self._graph.add_edge(q_new, goal_v)\n                        self._set_cost(goal_v, cost_to_goal)\n\n                    self._extract_path(goal_v)\n                    break\n\n            # Add q_new to graph root vertices so it is considered in future nearest searches\n            self._graph.root_vertices.append(q_new)\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired path planner combined with heuristic goal biasing and adaptive step size.\n    Key features:\n    - Combines goal-biased sampling (20% samples directly toward the goal) and uniform random sampling elsewhere.\n    - Uses an adaptive step size based on local obstacle density and distance-to-goal to accelerate exploration or precision near obstacles.\n    - Employs RRT* style rewiring to optimize paths and improve path quality.\n    - Utilizes a heuristic cost (cost-to-come + estimated cost-to-goal) to prioritize connections and rewiring.\n    - Path extraction includes shortcut smoothing by line-of-sight validation to reduce unnecessary waypoints.\n    - Stops early when goal is reachable or after 30 seconds to improve efficiency.\n    \n    This provides improved planning efficiency, higher success rates, smoother and shorter paths,\n    and better robustness against complex obstacle configurations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias_prob: float\n    _start_time: float\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # allow rewiring\n        self._max_dist_base = 12.0\n        self._goal_bias_prob = 0.2  # 20% goal bias\n        self._timeout_sec = 30.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        from random import random\n\n        if random() < self._goal_bias_prob:\n            # Goal biased sample near goal with small random offset to favor goal direction\n            goal_pos = self._get_grid().goal.position\n            grid_size = self._get_grid().size\n            # Small random offset around goal (radius 3)\n            offset = Point(\n                int((torch.randint(-3, 4, (1,)).item())),\n                int((torch.randint(-3, 4, (1,)).item())),\n            )\n            biased_sample = Point(min(max(goal_pos.x + offset.x, 0), grid_size[0] - 1),\n                                  min(max(goal_pos.y + offset.y, 0), grid_size[1] - 1))\n            if self._get_grid().is_agent_valid_pos(biased_sample):\n                return biased_sample\n\n        # Uniform random sample\n        while True:\n            sample = Point(\n                *[\n                    torch.randint(0, self._get_grid().size[i], (1,)).item()\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n            )\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Adaptive step size: If nearby obstacles, reduce step size for precision.\n        Otherwise, larger step size allows faster exploration.\n        Also decrease step size if close to goal for fine approach.\n        \"\"\"\n        base = self._max_dist_base\n        radius_check = int(base / 2)\n\n        # Check obstacle density in neighborhood (square neighborhood)\n        obstacles_count = 0\n        total_checked = 0\n        for dx in range(-radius_check, radius_check + 1):\n            for dy in range(-radius_check, radius_check + 1):\n                check_point = Point(pos.x + dx, pos.y + dy)\n                if 0 <= check_point.x < self._get_grid().size[0] and 0 <= check_point.y < self._get_grid().size[1]:\n                    total_checked += 1\n                    # If point invalid for agent (likely due to obstacle radius)\n                    if not self._get_grid().is_agent_valid_pos(check_point):\n                        obstacles_count += 1\n\n        obstacle_density = obstacles_count / total_checked if total_checked > 0 else 0.0\n\n        # Distance to goal\n        dist_to_goal = self._get_grid().get_distance(pos, self._get_grid().goal.position)\n\n        # Step size reduces when near obstacles and near goal\n        step = base * (1.0 - 0.7 * obstacle_density)  # scaled down with obstacle density\n        if dist_to_goal < base * 3:\n            step = min(step, dist_to_goal * 0.8)  # slow down near goal\n\n        # Set a minimum step size\n        step = max(step, 3.0)\n        return step\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / norm\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _cost(self, v1: Vertex, v2: Vertex) -> float:\n        return self._get_grid().get_movement_cost(v1.position, v2.position)\n\n    def _heuristic_cost(self, v: Vertex) -> float:\n        # Estimated total cost = cost-to-come + Euclidean to goal\n        cost_to_come = v.cost\n        heuristic = self._get_grid().get_distance(v.position, self._get_grid().goal.position)\n        return cost_to_come + heuristic\n\n    def _find_best_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Vertex:\n        \"\"\"\n        Select best parent based on cost and valid connection.\n        \"\"\"\n        best_parent = None\n        best_cost = float(\"inf\")\n        for q_near in near_vertices:\n            if self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            ):\n                tentative_cost = q_near.cost + self._cost(q_near, q_new)\n                if tentative_cost < best_cost:\n                    best_cost = tentative_cost\n                    best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        RRT* style rewiring to improve paths.\n        \"\"\"\n        for q_near in near_vertices:\n            if q_near is q_new.parents:\n                continue\n            if self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            ):\n                new_cost = q_new.cost + self._cost(q_new, q_near)\n                if new_cost < q_near.cost:\n                    # Remove old parent edges\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    # Add new edge\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal and shortcut smoothing.\n        \"\"\"\n        path: List[Vertex] = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            # Pick parent with minimal cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut smoothing: try to connect non-adjacent vertices directly if collision free\n        def shortcut_path(vertices: List[Vertex]) -> List[Vertex]:\n            if len(vertices) <= 2:\n                return vertices\n            smooth_path = [vertices[0]]\n            i = 0\n            while i < len(vertices) - 1:\n                j = len(vertices) - 1\n                while j > i + 1:\n                    if self._get_grid().is_valid_line_sequence(\n                        self._get_grid().get_line_sequence(vertices[i].position, vertices[j].position)\n                    ):\n                        break\n                    j -= 1\n                smooth_path.append(vertices[j])\n                i = j\n            return smooth_path\n\n        path_smoothed = shortcut_path(path)\n\n        for vertex in path_smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        for iteration in range(max_iterations):\n            if time.time() - start_time > self._timeout_sec:\n                # Timeout reached without path found\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            ):\n                continue\n\n            # Find near vertices for rewiring (radius = adaptive radius like RRT*)\n            gamma_r = 30.0  # Radius parameter for neighborhood rewiring\n            near_vertices = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, gamma_r\n            )\n            if not near_vertices:\n                # Ensure at least the nearest is included\n                near_vertices = [q_near]\n\n            # Choose best parent from near vertices\n            best_parent = self._find_best_parent(q_new, near_vertices)\n            if best_parent is None:\n                continue\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire near vertices if beneficial\n            self._rewire(q_new, near_vertices)\n\n            # Add the new vertex to graph root vertices for subsequent expansions\n            self._graph.root_vertices.append(q_new)\n\n            # Check goal reachability\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = self._graph.root_vertex_goal\n                # Connect goal to q_new if possible and cheaper\n                if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                ):\n                    # Create virtual goal vertex with updated cost to integrate in graph for path extraction\n                    goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm is an enhanced RRT* inspired planner with the following improvements:\n    - Adaptive max step distance that shrinks as new samples get closer to the goal, leading to finer path refinement near the goal.\n    - Goal biased sampling with adjustable probability to accelerate progress towards the goal.\n    - Rewiring of existing vertices within a dynamic neighborhood radius to optimize the tree for shorter and smoother paths.\n    - Early stopping based on reaching goal radius or time limit (30 seconds) to avoid long runtime.\n    - Post path extraction shortcutting for path smoothing by removing unnecessary intermediate points.\n    This hybrid approach balances exploration speed, path quality, and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position, True), Vertex(self._get_grid().goal.position, True), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_initial = 15.0\n        self._max_dist_min = 3.0\n        self._iterations = 8000\n        self._goal_sample_rate = 0.2    # 20% probability sample goal directly\n        self._rewire_radius_factor = 30.0   # radius for rewiring scaled by sqrt(log(n)/n) dynamically later\n        self._start_time = None\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_random_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = vec.norm().item()\n        if dist <= max_dist:\n            return Vertex(to_p, True)\n        vec_normalized = vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * vec_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, True)\n\n    def _choose_parent(self, neighbors: list, new_v: Vertex) -> Vertex:\n        # Select a parent that results in least cost path to new_v\n        min_cost = float('inf')\n        best_parent = None\n        for v in neighbors:\n            seq = self._get_grid().get_line_sequence(v.position, new_v.position)\n            if not self._get_grid().is_valid_line_sequence(seq):\n                continue\n            cost = v.cost + self._get_grid().get_distance(v.position, new_v.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is None:\n            return None\n        new_v.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_v: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is new_v.parents or v is new_v:\n                continue\n            seq = self._get_grid().get_line_sequence(new_v.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(seq):\n                continue\n            new_cost = new_v.cost + self._get_grid().get_distance(new_v.position, v.position)\n            if new_cost < v.cost:\n                # Rewire: remove old parents and add new parent new_v\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(new_v, v)\n                v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path_vertices = [goal_vertex]\n        while len(path_vertices[-1].parents) != 0:\n            # always pick parent with minimum cost (guaranteed by rewiring)\n            min_parent = None\n            min_cost = float('inf')\n            for p in path_vertices[-1].parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path_vertices.append(min_parent)\n        path_vertices.reverse()\n\n        # Shortcut and smooth the path by shortcutting intermediate points if possible\n        def can_connect(p1, p2):\n            seq = self._get_grid().get_line_sequence(p1.position, p2.position)\n            return self._get_grid().is_valid_line_sequence(seq)\n\n        shortcut_path = []\n        i = 0\n        while i < len(path_vertices):\n            shortcut_path.append(path_vertices[i])\n            j = len(path_vertices) - 1\n            # find farthest vertex that can connect directly\n            while j > i + 1:\n                if can_connect(path_vertices[i], path_vertices[j]):\n                    break\n                j -= 1\n            if j <= i + 1:\n                i += 1\n            else:\n                i = j\n\n        # Animate movement along shortcut path\n        for v in shortcut_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_pos = self._get_grid().goal.position\n        n_vertices = 1\n\n        for i in range(self._iterations):\n            # Early stop if time > 30 seconds\n            if time.time() - self._start_time > 30:\n                break\n\n            q_rand = self._get_random_sample()\n\n            # Adaptive max_dist depends on distance to goal, reduces near goal for finer search\n            dist_to_goal = self._distance(q_rand, goal_pos)\n            max_dist = max(self._max_dist_min, min(self._max_dist_initial, dist_to_goal / 2.0))\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_rand)\n            if q_near.position == q_rand:\n                continue\n            q_new = self._steer(q_near, q_rand, max_dist)\n\n            seq_line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(seq_line):\n                continue\n\n            # Find neighbors within rewiring radius for RRT* style optimization\n            radius = self._rewire_radius_factor * (np.log(n_vertices + 1) / (n_vertices + 1))**0.5\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            parent = self._choose_parent(neighbors, q_new)\n            if parent is None:\n                # No good parent found, connect to nearest if possible\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._distance(q_near.position, q_new.position)\n                    parent = q_near\n                else:\n                    continue  # cannot connect q_new\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors to potentially improve paths via q_new\n            self._rewire(q_new, neighbors)\n\n            n_vertices += 1\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new directly to goal vertex and extract path\n                goal_vertex = self._graph.root_vertex_goal\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = q_new.cost + self._distance(q_new.position, goal_vertex.position)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a Hybrid Informed Anytime RRT* variant with heuristic-guided sampling and adaptive step sizing.\n    Key improvements:\n    - Goal-biased adaptive sampling: samples are drawn preferentially inside an ellipse defined by current best path cost for efficiency.\n    - Dynamic max step size adaptation based on distance to goal and obstacle proximity to enable both wide exploration and fine local refinement.\n    - Heuristic cost (Euclidean + cost-to-come) used for rewiring to optimize path quality.\n    - Anytime improvement: after first feasible path found, refines solution for limited time.\n    - Early stopping criteria with 30 seconds timeout.\n    - Smooth shortcutting applied on path extraction to improve path quality.\n    \n    This approach improves planning speed by focusing search in promising areas and refines the path for better quality and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.root_vertex_start.cost = 0.0\n        self._found_goal_vertex = None\n        self._max_iterations = 1500\n        self._best_path_cost = float(\"inf\")\n        self._improvement_time_limit = 5.0  # seconds for anytime improvement\n        self._max_step_size_base = 15.0\n        self._goal_sample_rate = 0.2  # 20% samples towards goal\n        self._init_displays()\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance heuristic from point p to goal\n        goal_pos = self._get_grid().goal.position\n        return self._get_grid().get_distance(p, goal_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost between two vertices (used for path cost)\n        return self._get_grid().get_distance(frm.position, to.position)\n\n    def _sample_in_ellipse(self, c_max: float, start: Point, goal: Point) -> Point:\n        # Sample inside ellipse defined by start, goal and current best path cost (c_max),\n        # Adapted from Informed RRT* ellipse sampling for 2D.\n        import math\n        import random\n\n        if c_max == float(\"inf\"):\n            return self._get_random_sample()\n\n        c_min = self._get_grid().get_distance(start, goal)\n        if c_min == 0:\n            return start\n\n        # Ellipse parameters\n        a = c_max / 2.0\n        b = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Sample random point inside unit circle (2D assumed)\n        theta = random.uniform(0, 2.0 * math.pi)\n        r = math.sqrt(random.uniform(0, 1))\n        x = r * math.cos(theta)\n        y = r * math.sin(theta)\n\n        # Scale to ellipse\n        x_ellipse = a * x\n        y_ellipse = b * y\n\n        # Rotate ellipse to align with start-goal vector\n        dx = goal.x - start.x\n        dy = goal.y - start.y\n        angle = math.atan2(dy, dx)\n        xr = math.cos(angle) * x_ellipse - math.sin(angle) * y_ellipse\n        yr = math.sin(angle) * x_ellipse + math.cos(angle) * y_ellipse\n\n        center_x = (start.x + goal.x) / 2.0\n        center_y = (start.y + goal.y) / 2.0\n\n        sample_x = int(round(center_x + xr))\n        sample_y = int(round(center_y + yr))\n\n        sampled_point = Point(sample_x, sample_y)\n        if self._get_grid().is_agent_valid_pos(sampled_point):\n            return sampled_point\n        else:\n            # fallback if invalid sample\n            return self._get_random_sample()\n\n    def _get_adaptive_max_step_size(self, from_pos: Point, to_pos: Point) -> float:\n        # Adapt step size according to distance to goal and local obstacle density proximity (simple proxy)\n        base = self._max_step_size_base\n        dist_to_goal = self._get_grid().get_distance(from_pos, self._get_grid().goal.position)\n        # Adaptive factor reduces step near goal\n        adaptive = max(5.0, min(base, dist_to_goal / 2))\n        return adaptive\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        if dist == 0:\n            return Vertex(q_near.position)\n\n        dir_normalized = dir / dist\n        q_new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pt)\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            if q_near is q_new:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            new_cost = q_new.cost + self._cost(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Remove old parent edge\n                for p in q_near.parents:\n                    self._graph.remove_edge(p, q_near)\n                    break\n                # Add new edge and update cost\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _shortcut_path(self, path_vertices: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut the path by removing intermediate vertices on valid direct connections\n        new_path = [path_vertices[0]]\n        n = len(path_vertices)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_vertices[i].position, path_vertices[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path_vertices[j])\n            i = j\n        return new_path\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path from start to goal vertex by traversing parents\n        path: List[Vertex] = [goal_vertex]\n\n        current = goal_vertex\n        while len(current.parents) > 0:\n            # In forest structure, single parent assumed for shortest path tree\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Apply shortcut smoothing\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            # Optional: publish waypoint if ros_map (not mandatory here)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        best_cost = float(\"inf\")\n        best_goal_vertex = None\n\n        start_time = time.time()\n        max_time_limit = 30.0  # seconds timeout\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        iteration = 0\n        while iteration < self._max_iterations:\n            iteration += 1\n\n            elapsed = time.time() - start_time\n            if elapsed > max_time_limit:\n                # Timeout - no path found within time limit\n                break\n\n            # Sample with goal bias and ellipse informed sampling if best path known\n            if best_cost < float(\"inf\") and torch.rand(1).item() > self._goal_sample_rate:\n                q_sample = self._sample_in_ellipse(best_cost, start, goal)\n            else:\n                if torch.rand(1).item() < self._goal_sample_rate:\n                    q_sample = goal\n                else:\n                    q_sample = self._get_random_sample()\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            max_step = self._get_adaptive_max_step_size(q_nearest.position, q_sample)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_step)\n\n            if q_new.position == q_nearest.position:\n                continue\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Determine radius for near vertices for rewiring (using RRT* style radius)\n            card_v = torch.tensor(float(self._graph.size))\n            dimension = grid.size.n_dim\n            if card_v <= 1:\n                radius = self._max_step_size_base\n            else:\n                gamma_rrt_star = 50.0  # tuning parameter\n                radius = min(\n                    gamma_rrt_star * ((torch.log(card_v) / card_v) ** (1 / dimension)),\n                    self._max_step_size_base * 2.0,\n                )\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent vertex with min total cost\n            c_min = float(\"inf\")\n            q_min = None\n            for q_near in Q_near:\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                c_new = q_near.cost + self._cost(q_near, q_new)\n                if c_new < c_min:\n                    c_min = c_new\n                    q_min = q_near\n\n            if q_min is None:\n                # No valid parent, try q_nearest if valid\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position)):\n                    q_min = q_nearest\n                    c_min = q_nearest.cost + self._cost(q_nearest, q_new)\n                else:\n                    continue\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors\n            self._rewire(q_new, Q_near)\n\n            # Add q_new vertex into graph if not present (forest includes edge addition)\n            # Already added via add_edge\n\n            # Check if q_new is within goal radius to update best solution\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < best_cost:\n                    best_cost = q_new.cost\n                    best_goal_vertex = q_new\n                    self._found_goal_vertex = q_new\n\n                    # Extract and temporarily show path\n                    self._extract_path(best_goal_vertex)\n\n                    # Anytime path improvement phase: limited time refinements\n                    improve_start = time.time()\n                    while time.time() - improve_start < self._improvement_time_limit:\n                        # Sample inside informed ellipse again for improvement\n                        q_sample_improve = self._sample_in_ellipse(best_cost, start, goal)\n                        q_nearest_improve = self._get_nearest_vertex(q_sample_improve)\n                        max_step_improve = self._get_adaptive_max_step_size(q_nearest_improve.position, q_sample_improve)\n                        q_new_improve = self._get_new_vertex(q_nearest_improve, q_sample_improve, max_step_improve)\n\n                        if q_new_improve.position == q_nearest_improve.position:\n                            continue\n\n                        if not grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest_improve.position, q_new_improve.position)):\n                            continue\n\n                        Q_near_improve = self._get_vertices_within_radius(q_new_improve, radius)\n                        c_min_improve = float(\"inf\")\n                        q_min_improve = None\n                        for q_near in Q_near_improve:\n                            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new_improve.position)):\n                                continue\n                            c_new = q_near.cost + self._cost(q_near, q_new_improve)\n                            if c_new < c_min_improve:\n                                c_min_improve = c_new\n                                q_min_improve = q_near\n\n                        if q_min_improve is None:\n                            if grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest_improve.position, q_new_improve.position)):\n                                q_min_improve = q_nearest_improve\n                                c_min_improve = q_nearest_improve.cost + self._cost(q_nearest_improve, q_new_improve)\n                            else:\n                                continue\n\n                        q_new_improve.cost = c_min_improve\n                        self._graph.add_edge(q_min_improve, q_new_improve)\n                        self._rewire(q_new_improve, Q_near_improve)\n\n                        if grid.is_agent_in_goal_radius(q_new_improve.position):\n                            if q_new_improve.cost < best_cost:\n                                best_cost = q_new_improve.cost\n                                best_goal_vertex = q_new_improve\n                                self._extract_path(best_goal_vertex)\n\n                        self.key_frame()\n\n                    break  # End main loop early on first found solution with improvement\n\n            self.key_frame()\n\n        # If no path found but previously extracted, show path from that best found vertex\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm incorporates a hybrid approach combining goal-biased adaptive sampling, \n    heuristic-guided expansion (using estimated total cost = cost-so-far + heuristic), and adaptive step \n    sizing based on the local environment's obstacle density. It maintains a Forest graph and performs a \n    rewiring optimization similar to RRT*, but additionally uses informed sampling in an elliptical region \n    around the start and goal to focus exploration in promising areas. The algorithm also includes an early \n    stopping criterion based on elapsed time (30 seconds) and a post-extraction shortcut smoothing for path quality.\n\n    The main improvements are:\n      - Adaptive max_dist based on density of obstacles around the sampling region to balance exploration/exploitation.\n      - Informed goal-biased sampling within an ellipse between start and goal to concentrate sample points.\n      - Heuristic cost combining path cost and Euclidean heuristic to drive better tree growth.\n      - Rewiring to continuously optimize paths.\n      - Post path extraction shortcutting smoothing to improve path quality.\n      - Early timeout to stop if no path found in 30 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._start_vertex = self._graph.root_vertex_start\n        self._goal_vertex = self._graph.root_vertex_goal\n        self._start_vertex.cost = 0\n        self._init_displays()\n\n    def _heuristic_cost(self, point_a: Point, point_b: Point) -> float:\n        return self._get_grid().get_distance(point_a, point_b)\n\n    def _adaptive_max_dist(self, pos: Point, base_max_dist: float = 15, max_radius: int = 5) -> float:\n        \"\"\"\n        Calculate adaptive max distance that shrinks near obstacles density:\n        The more obstacles near pos within max_radius, the smaller max_dist becomes.\n        \"\"\"\n        grid = self._get_grid()\n        obstacles = grid.obstacles\n        obstacle_count = 0\n        radius = max_radius\n\n        # Count how many obstacles are close to pos within radius radius.\n        for obs in obstacles:\n            obs_pos = obs.position\n            dist = grid.get_distance(pos, obs_pos)\n            if dist <= radius:\n                obstacle_count += 1\n\n        # Normalize count (max could be number of obstacles)\n        if len(obstacles) == 0:\n            density = 0\n        else:\n            density = obstacle_count / len(obstacles)\n\n        # More dense obstacles => smaller max_dist (minimum 5)\n        adaptive_dist = base_max_dist * (1 - 0.7 * density)\n        adaptive_dist = max(5, min(adaptive_dist, base_max_dist))\n        return adaptive_dist\n\n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Samples a point uniformly within an ellipse defined by start and goal positions extended by current best path cost.\n        If no best path found yet, fallback to uniform random sampling in the grid.\n        \"\"\"\n        grid = self._get_grid()\n        start = self._start_vertex.position\n        goal = self._goal_vertex.position\n\n        best_cost = None\n        # Try to estimate best current solution cost (lowest cost vertex connected to goal)\n        for v in self._graph.root_vertices:\n            if v == self._goal_vertex:\n                continue\n            for child in v.children:\n                if child == self._goal_vertex:\n                    if best_cost is None or v.cost + grid.get_distance(v.position, goal) < best_cost:\n                        best_cost = v.cost + grid.get_distance(v.position, goal)\n\n        # If no solution yet, default to map diagonal as max distance for ellipse\n        if best_cost is None:\n            best_cost = grid.get_distance(start, goal) * 1.5\n\n        # Ellipse axes lengths: a = best_cost/2, c = distance start-goal/2, b = sqrt(a^2 - c^2)\n        c = grid.get_distance(start, goal) / 2\n        a = best_cost / 2\n        if a < c:  # Numerical safety\n            a = c * 1.1\n        b_sq = max(a * a - c * c, 0.01)\n        b = b_sq ** 0.5\n\n        # Ellipse centered at midpoint between start and goal\n        center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n\n        # Random polar coordinates inside unit circle & scale to ellipse\n        attempted = 0\n        while True:\n            theta = np.random.uniform(0, 2 * np.pi)\n            r = np.sqrt(np.random.uniform(0, 1))\n\n            # Sample point in ellipse coordinates before rotation\n            x_ellipse = r * np.cos(theta) * a\n            y_ellipse = r * np.sin(theta) * b\n\n            # Rotation angle between start-goal vector and x-axis\n            dx = goal.x - start.x\n            dy = goal.y - start.y\n            angle = np.arctan2(dy, dx)\n\n            # Rotate point back to map coordinates\n            x_rot = x_ellipse * np.cos(angle) - y_ellipse * np.sin(angle)\n            y_rot = x_ellipse * np.sin(angle) + y_ellipse * np.cos(angle)\n\n            sample_point = Point(center.x + x_rot, center.y + y_rot)\n\n            # Round to int grid coords, check validity and return if valid\n            sample = Point(int(round(sample_point.x)), int(round(sample_point.y)))\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n            attempted += 1\n            # Avoid infinite loops/fallback\n            if attempted > 100:\n                # Fallback uniform random sample anywhere in grid\n                while True:\n                    rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                    fallback_sample = Point(*rand_pos)\n                    if grid.is_agent_valid_pos(fallback_sample):\n                        return fallback_sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_new):\n        \"\"\"\n        Extract path and apply shortcut smoothing to the path for quality.\n        \"\"\"\n\n        grid = self._get_grid()\n        goal_v = Vertex(grid.goal.position)\n        goal_v.cost = q_new.cost + grid.get_distance(q_new.position, goal_v.position)\n        self._graph.add_edge(q_new, goal_v)\n\n        path = [goal_v]\n        while len(path[-1].parents) > 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.pop()  # Remove last (start's parent is empty, so popped)\n\n        path.reverse()\n        # Shortcut smoothing pass - attempt a constant number of shortcuts\n        path = self._shortcut_smoothing(path, iterations=10)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            # If ROS Map, publish waypoint\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smoothing(self, path: list, iterations: int = 10) -> list:\n        \"\"\"\n        Attempts to iteratively shorten the path by connecting non-adjacent vertices directly if valid.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        import random\n\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p_i = path[i]\n            p_j = path[j]\n\n            line_seq = grid.get_line_sequence(p_i.position, p_j.position)\n            if grid.is_valid_line_sequence(line_seq):\n                # Remove intermediate vertices between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        max_base_dist = 15\n        max_iterations = 8000\n        lambda_rrt_star = 30  # smaller radius factor for faster but still good rewire radius\n\n        start_time = time.time()\n\n        for _ in range(max_iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:  # timeout after 30 seconds\n                # Consider no path found\n                break\n\n            # 30% of samples are pure uniform random to maintain exploration\n            if np.random.rand() < 0.3:\n                q_sample = None\n                while q_sample is None:\n                    rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                    candidate = Point(*rand_pos)\n                    if grid.is_agent_valid_pos(candidate):\n                        q_sample = candidate\n            else:\n                q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._start_vertex], q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist_adaptive = self._adaptive_max_dist(q_nearest.position, max_base_dist)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist_adaptive)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Rewire radius adapting dynamically based on graph size & heuristic\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            log_card = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card / card_v) ** (1 / 2)), 40)\n\n            # Find near vertices for rewiring\n            Q_near = self._graph.get_vertices_within_radius([self._start_vertex], q_new.position, radius)\n\n            # Choose parent with minimum cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + grid.get_distance(q_nearest.position, q_new.position) + self._heuristic_cost(q_new.position, grid.goal.position)\n\n            for q_near in Q_near:\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                cost_near_to_new = q_near.cost + grid.get_distance(q_near.position, q_new.position) + self._heuristic_cost(q_new.position, grid.goal.position)\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            dist_qmin_qnew = grid.get_distance(q_min.position, q_new.position)\n            q_new.cost = q_min.cost + dist_qmin_qnew\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better paths possible\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_new_to_near = q_new.cost + grid.get_distance(q_new.position, q_near.position)\n                if cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for p in q_near.parents:\n                        q_parent = p\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is an adaptive sample-based algorithm combining goal-biased sampling, heuristic-driven expansion,\n    and dynamic step sizing to improve path quality and efficiency. It employs a Forest graph structure like RRT* but\n    integrates A*-like heuristic cost-guided vertex extension and rewiring with adaptive sampling radius based on local\n    vertex density. The method adapts max step size according to obstacle proximity to avoid collisions and dynamically\n    schedules exploration versus exploitation via adjustable goal bias probability. It stops early when the found path\n    reaches a predetermined cost threshold or the search time exceeds 30 seconds, ensuring practical runtime limits.\n    The final path is smoothed by shortcutting via valid direct line connections between non-consecutive waypoints,\n    improving path smoothness and shortening total travel distance.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist_base = 12.0\n        self._max_radius = 30.0\n        self._goal_bias = 0.2  # probability to sample goal directly\n        self._cost_threshold = None  # can be dynamically updated during the run\n        self._init_displays()\n\n    def _get_heuristic_cost(self, frm: Vertex, to: Vertex) -> float:\n        # Using Euclidean distance heuristic from frm to to (Goal)\n        return Map.get_distance(frm.position, to.position)\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        # Decrease max step if near obstacle boundary\n        grid = self._get_grid()\n        nearby_positions = grid.get_next_positions(q_near.position)\n        obstacle_count = 0\n        total = len(nearby_positions)\n        for pos in nearby_positions:\n            if not grid.is_agent_valid_pos(pos):\n                obstacle_count += 1\n        obstacle_density = obstacle_count / total if total > 0 else 0\n        # Reduce max_dist by up to 50% if obstacle density is high\n        max_dist = self._max_dist_base * (1 - 0.5 * obstacle_density)\n        return max(3.0, max_dist)\n\n    def _goal_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _rewire(self, q_new: Vertex, Q_near: 'List[Vertex]'):\n        # Rewire neighbors of q_new for improved path cost\n        grid = self._get_grid()\n        for q_near in Q_near:\n            if q_near is q_new:\n                continue\n            # Check collision-free connection from q_new to q_near\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_new_to_near = q_new.cost + Map.get_distance(q_new.position, q_near.position)\n            if cost_new_to_near < q_near.cost:\n                # Remove old parent edge\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                q_near.cost = cost_new_to_near\n                self._graph.add_edge(q_new, q_near)\n\n    def _smooth_path(self, path: 'List[Vertex]') -> 'List[Vertex]':\n        # Attempt shortcuts between non-adjacent vertices in the path\n        grid = self._get_grid()\n        if len(path) < 3:\n            return path  # Nothing to smooth\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(smoothed_path[-1].position, path[next_idx].position)):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    def _extract_path(self, q_goal: Vertex):\n        # Extract path from start to q_goal by backtracking parents\n        path = [q_goal]\n        while len(path[-1].parents) != 0:\n            # Pick one parent (arbitrary if multiple)\n            for p in path[-1].parents:\n                path.append(p)\n                break\n        path.reverse()\n        # Smooth path\n        path = self._smooth_path(path)\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n        grid = self._get_grid()\n        start_time = time.time()\n        max_iterations = 5000\n        dimension = grid.size.n_dim\n        lambda_rrt_star = 60\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Initialize cost threshold to a high value\n        self._cost_threshold = float('inf')\n\n        for i in range(max_iterations):\n            # Time check: stop if exceeded 30 seconds\n            if time.time() - start_time > 30.0:\n                # Stop search, treat as not found\n                break\n\n            # Sample with goal bias\n            q_sample_pos = self._goal_biased_sample()\n            nearest_vertex = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n\n            if nearest_vertex.position == q_sample_pos:\n                continue\n\n            max_dist = self._adaptive_max_dist(nearest_vertex)\n            dir_vec = q_sample_pos.to_tensor() - nearest_vertex.position.to_tensor()\n            dir_norm = torch.norm(dir_vec)\n            if dir_norm == 0.0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample_pos\n            else:\n                q_new_pos = Point.from_tensor(nearest_vertex.position.to_tensor() + max_dist * dir_vec / dir_norm)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(nearest_vertex.position, q_new_pos)):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Calculate tentative cost from start through nearest_vertex to q_new\n            tentative_cost = nearest_vertex.cost + Map.get_distance(nearest_vertex.position, q_new.position)\n            q_new.cost = tentative_cost\n\n            # Determine adaptive radius for rewiring/neighbors\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)), self._max_radius)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Find the best parent for q_new minimizing f = cost + heuristic\n            best_parent = nearest_vertex\n            best_cost = tentative_cost + self._get_heuristic_cost(q_new, goal_vertex)\n            for q_near in near_vertices:\n                if q_near == q_new:\n                    continue\n                # Verify collision-free path q_near -> q_new\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                cost_through_near = q_near.cost + Map.get_distance(q_near.position, q_new.position)\n                f_cost = cost_through_near + self._get_heuristic_cost(q_new, goal_vertex)\n                if f_cost < best_cost:\n                    best_parent = q_near\n                    best_cost = f_cost\n                    q_new.cost = cost_through_near\n\n            # Add q_new to the graph\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors around q_new\n            self._rewire(q_new, near_vertices)\n\n            # Update graph size manually (assume adding vertex)\n            self._graph.size += 1\n\n            # Attempt connecting q_new directly to goal vertex if possible\n            dist_to_goal = Map.get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= max_dist:\n                # Check direct connection feasibility\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_cost = q_new.cost + dist_to_goal\n                    if goal_cost < self._cost_threshold:\n                        self._cost_threshold = goal_cost\n                        goal_vertex.cost = goal_cost\n                        # Clear existing parents edges of goal\n                        for parent in list(goal_vertex.parents):\n                            self._graph.remove_edge(parent, goal_vertex)\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract smooth path and finish\n                        self._extract_path(goal_vertex)\n                        return\n\n            # Early stopping if found a path under threshold\n            if self._cost_threshold < float('inf') and i > 100:\n                # If we have a good path and some iterations have passed, stop to prevent overrun\n                # This improves efficiency\n                self._extract_path(goal_vertex)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* inspired method that incorporates goal-biased sampling,\n    heuristic guided vertex selection, adaptive step length, and rewiring for continuous path cost optimization.\n    It uses a Forest graph structure rooted at start with incremental vertex insertion.\n    Key improvements:\n    - Goal-bias in sampling guides exploration towards goal.\n    - Adaptive max step size based on distance to nearest vertex and goal.\n    - Heuristic (cost + distance-to-goal) to select parents for new vertex, improving path quality.\n    - Rewiring nearby vertices around new vertex to reduce path cost (like RRT*).\n    - Shortcut smoothing applied after path found for smoother routes.\n    - Early termination if path cost no longer improves or if 30s timeout reached.\n    This balances exploration, path quality, and computational efficiency for improved planning performance.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _iterations: int\n    _goal_sample_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n\n        self._max_dist_base = 12.0  # base adaptive max step length\n        self._iterations = 8000\n        self._goal_sample_rate = 0.2  # probability of sampling goal to bias towards it\n        self._rewire_radius = 20.0\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        from random import random\n        if random() < self._goal_sample_rate:\n            # With some probability sample goal directly\n            return self._graph.root_vertex_goal.position\n        else:\n            while True:\n                sample = Point(*[\n                    torch.randint(0, self._get_grid().size[i], (1,)).item()\n                    for i in range(self._get_grid().size.n_dim)\n                ])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, point)\n\n    def _get_dist(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _get_adaptive_max_dist(self, q_near: Vertex, q_rand: Point) -> float:\n        d_to_goal = self._get_dist(q_near.position, self._graph.root_vertex_goal.position)\n        d_to_rand = self._get_dist(q_near.position, q_rand)\n        max_dist = min(self._max_dist_base, max(d_to_rand * 0.75, 5.0), d_to_goal * 0.75)\n        if max_dist < 1.0:\n            max_dist = 1.0\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / norm\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _line_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose parent to minimize cost + heuristic-to-goal\n        best_parent = None\n        best_cost = float('inf')\n        for v in near_vertices:\n            if v.position == q_new.position:\n                continue\n            if self._line_valid(v.position, q_new.position):\n                cost_v = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n                heuristic = self._get_dist(q_new.position, self._graph.root_vertex_goal.position)\n                total_cost = cost_v + heuristic\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire near vertices for lower cost paths through q_new\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if self._line_valid(q_new.position, v.position):\n                cost_through_qnew = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n                if cost_through_qnew < v.cost:\n                    # Change parent edge\n                    # Remove old parent edges:\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    # Add new edge\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_qnew\n\n    def _extract_path(self) -> None:\n        path: List[Vertex] = []\n        current = self._graph.root_vertex_goal\n\n        # Trace back to start by choosing minimum cost parent\n        while current != self._graph.root_vertex_start:\n            path.append(current)\n            # Choose parent with minimal cost\n            if not current.parents:\n                # Fail-safe if no parent (break infinite)\n                break\n            current = min(current.parents, key=lambda p: p.cost + self._get_dist(p.position, current.position))\n        path.append(self._graph.root_vertex_start)\n        path.reverse()\n\n        # Shortcut smoothing - try to remove unnecessary intermediate nodes\n        path = self._smooth_path(path)\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut by skipping intermediate vertices if direct connection is collision free\n        if len(path) < 3:\n            return path\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1  # try to connect as far as possible\n            while next_idx > idx + 1:\n                if self._line_valid(path[idx].position, path[next_idx].position):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for i in range(self._iterations):\n            if time.time() - start_time > 30.0:\n                # timeout reached, stop planning without path\n                return\n\n            q_rand: Point = self._get_random_sample()\n            q_near: Vertex = self._get_nearest_vertex(self._graph.root_vertices, q_rand)\n\n            max_dist: float = self._get_adaptive_max_dist(q_near, q_rand)\n            q_new: Vertex = self._get_new_vertex(q_near, q_rand, max_dist)\n\n            if not self._line_valid(q_near.position, q_new.position):\n                continue\n\n            # Find near vertices within radius for rewiring and parent choosing\n            near_vertices: List[Vertex] = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n\n            # Choose best parent based on cost+heuristic\n            parent_vertex = self._choose_parent(near_vertices + [q_near], q_new)\n            if parent_vertex is None:\n                parent_vertex = q_near\n\n            # Set cost and add vertex and edge\n            q_new.cost = parent_vertex.cost + self._get_grid().get_movement_cost(parent_vertex.position, q_new.position)\n            self._graph.root_vertices.append(q_new)\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire neighbors to improve path cost\n            self._rewire(near_vertices, q_new)\n\n            # Early check if new vertex reached goal or close enough\n            if self._get_dist(q_new.position, self._graph.root_vertex_goal.position) < self._max_dist_base:\n                if self._line_valid(q_new.position, self._graph.root_vertex_goal.position):\n                    # Connect goal directly if possible\n                    if self._graph.root_vertex_goal.cost > q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position):\n                        # Remove old parent edges of goal\n                        for p in list(self._graph.root_vertex_goal.parents):\n                            self._graph.remove_edge(p, self._graph.root_vertex_goal)\n                        self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                        self._graph.root_vertex_goal.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n\n            # Terminate early if goal is connected and path cost is finite\n            if self._graph.root_vertex_goal.cost < float('inf'):\n                self._extract_path()\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an Adaptive Heuristic RRT* with Goal Biasing and Dynamic Step Sizing.\n    - It uses heuristic-guided sampling biased towards the goal to improve convergence speed.\n    - The max step size dynamically adapts based on distance to goal and environment conditions.\n    - Rewiring optimizes the tree continuously to enhance path quality.\n    - Early stopping occurs either on success or after 30 seconds timeout to ensure efficiency.\n    - After a path is found, shortcut smoothing attempts to reduce unnecessary waypoints for smoother paths.\n    - A* style heuristic cost (distance to goal) guides vertex rewiring and selection.\n    - Sampling occasionally explores fully random points to maintain environment coverage and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        self._max_iterations = 8000\n        self._goal_bias = 0.15          # Probability to sample goal directly\n        self._max_step_initial = 15.0\n        self._max_step_min = 5.0\n        self._rewire_radius_factor = 50  # tuning param for radius in rewiring\n        self._dimension = 2\n        self._timeout_sec = 30.0\n        self._goal_sample_every = 10    # Force goal sampling every N iterations\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        # Goal biased with occasional pure random exploration\n        if iteration % self._goal_sample_every == 0 or np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, position: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        delta: torch.Tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(delta)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = delta / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction)\n        return Vertex(q_new_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost from frm to to using grid's movement cost\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _heuristic(self, v: Vertex) -> float:\n        # Euclidean distance to goal as heuristic\n        return Map.get_distance(v.position, self._graph.root_vertex_goal.position)\n\n    def _can_connect(self, from_pos: Point, to_pos: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            if q_near is q_new:\n                continue\n            if self._can_connect(q_new.position, q_near.position):\n                cost_through_new = q_new.cost + self._cost(q_new, q_near)\n                if cost_through_new < q_near.cost:\n                    # Remove old parent edges\n                    old_parents = list(q_near.parents)\n                    for p in old_parents:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_goal: Vertex) -> List[Vertex]:\n        path: List[Vertex] = [q_goal]\n        # Trace back from goal to start via parents\n        while path[-1].parents:\n            # pick parent with minimal cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut path by connecting non-adjacent vertices if collision-free\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # find farthest vertex reachable from current without collision\n            j = len(path) - 1\n            while j > i + 1:\n                if self._can_connect(path[i].position, path[j].position):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _update_max_step(self, dist_to_goal: float) -> float:\n        # Adaptive max step size: smaller when close to goal, or large otherwise\n        step = max(self._max_step_min,\n                   min(self._max_step_initial, dist_to_goal / 2))\n        return step\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        # Pre-cache log for rewiring radius formula\n        card_v = 1.0\n\n        for iter_count in range(1, self._max_iterations + 1):\n            current_time = time.time()\n            if current_time - start_time > self._timeout_sec:\n                # Timeout: fail gracefully by breaking loop\n                break\n\n            q_sample = self._get_random_sample(iter_count)\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            dist_to_sample = Map.get_distance(q_nearest.position, q_sample)\n            if dist_to_sample == 0:\n                continue\n\n            # adapt step size based on distance to goal from q_nearest\n            dist_to_goal = Map.get_distance(q_nearest.position, goal_pos)\n            max_step = self._update_max_step(dist_to_goal)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_step)\n\n            # Check path validity\n            if not self._can_connect(q_nearest.position, q_new.position):\n                self.key_frame()\n                continue\n\n            # Prepare for rewiring radius calculation\n            card_v = float(self._graph.size + 1)\n            radius = min(self._rewire_radius_factor * ((np.log(card_v) / card_v) ** (1 / self._dimension)), 50.0)\n\n            Q_near = self._get_vertices_within_radius(q_new.position, radius)\n            # Choose parent with lowest cost + heuristic\n            costs = []\n            for q_near in Q_near:\n                if self._can_connect(q_near.position, q_new.position):\n                    cost = q_near.cost + self._cost(q_near, q_new) + self._heuristic(q_new)\n                    costs.append((cost, q_near))\n            if not costs:\n                # No valid parent - discard vertex\n                self.key_frame()\n                continue\n            costs.sort(key=lambda x: x[0])\n            min_cost, q_min = costs[0]\n\n            q_new.cost = q_min.cost + self._cost(q_min, q_new)\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if beneficial\n            self._rewire(q_new, Q_near)\n\n            # Check if goal reached within radius of goal + smoothing on connecting edge\n            if self._can_connect(q_new.position, goal_pos):\n                cost_to_goal = q_new.cost + self._cost(q_new, self._graph.root_vertex_goal)\n                if cost_to_goal < self._graph.root_vertex_goal.cost or self._graph.root_vertex_goal.cost == 0:\n                    self._graph.root_vertex_goal.cost = cost_to_goal\n                    self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                    # Extract and shortcut path\n                    path = self._extract_path(self._graph.root_vertex_goal)\n                    path = self._shortcut_path(path)\n                    for p in path:\n                        self.move_agent(p.position)\n                        # publish waypoints if applicable\n                        grid = self._get_grid()\n                        # Support ROS waypoint publishing if supported\n                        if hasattr(grid, 'publish_wp'):\n                            grid.publish_wp(grid.agent.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an informed, goal-biased RRT* inspired planner with adaptive step size and path smoothing.\n    It maintains a forest of vertices connecting start and goal roots with rewiring to improve path quality.\n    The sampling is biased increasingly toward the goal as iterations progress to speed convergence.\n    Adaptive step size adjusts expansion distance based on obstacle proximity to improve robustness.\n    When a connection between start and goal trees is found, a shortcut smoothing post-processing step is applied.\n    Early stopping occurs if no path is found within 30 seconds or path quality stabilizes.\n    This approach improves planning efficiency, success rate, and path smoothness compared to standard RRT or SPRM.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_min: float\n    _max_dist_max: float\n    _iterations: int\n    _max_smoothing_steps: int\n    _goal_sample_rate: float  # probability to sample goal-biased points\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        self._graph = gen_forest(self._services, Vertex(agent_pos), Vertex(goal_pos), [])\n\n        self._graph.edges_removable = True\n        self._max_dist_min = 3.0\n        self._max_dist_max = 15.0\n        self._iterations = 10000\n        self._max_smoothing_steps = 15\n        self._goal_sample_rate = 0.2\n        self._timeout_sec = 30.0\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Adaptive goal biasing: increase goal bias with time/iterations\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            sample = Point(*[\n                torch.randint(0, self._get_grid().size[i], (1,)).item()\n                for i in range(self._get_grid().size.n_dim)\n            ])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _adaptive_max_dist(self, from_point: Point) -> float:\n        # Reduce step size near obstacles to improve robustness\n        check_radius = 5\n        obstacles = self._get_grid().obstacles\n        dist_min = self._max_dist_max\n        for obs in obstacles:\n            # Use Euclidean distance from from_point to obstacle bounds (rough)\n            obs_bound = self._get_grid().get_obstacle_bound(obs.position)\n            for p in obs_bound:\n                d = Map.get_distance(from_point, p)\n                if d < dist_min:\n                    dist_min = d\n                    if dist_min <= self._max_dist_min:\n                        return self._max_dist_min\n        return max(self._max_dist_min, min(self._max_dist_max, dist_min))\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir_vec)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / norm_dir\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_nearby_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _cost(self, parent: Vertex, child: Vertex) -> float:\n        return parent.cost + self._get_grid().get_movement_cost(parent.position, child.position)\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        for q_near in nearby_vertices:\n            if q_near is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                new_cost = self._cost(q_new, q_near)\n                if new_cost < q_near.cost:\n                    # Rewire q_near to q_new\n                    # Remove old parents of q_near\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self) -> None:\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # Find connection vertex common to both trees or closest connection\n        connection_vertex = None\n        min_cost_sum = float('inf')\n\n        # Collect all goal subtree vertices for quick lookup\n        goal_vertices = set()\n        def collect_goal(v: Vertex) -> bool:\n            goal_vertices.add(v)\n            return True\n        self._graph.walk_dfs([goal_root], collect_goal)\n\n        def collect_start(v: Vertex) -> bool:\n            nonlocal connection_vertex, min_cost_sum\n            if v in goal_vertices:\n                cost = v.cost + v.cost  # cost is same both sides, just simplified\n                if cost < min_cost_sum:\n                    connection_vertex = v\n                    min_cost_sum = cost\n            return True\n        self._graph.walk_dfs([start_root], collect_start)\n\n        if connection_vertex is None:\n            # Try a fallback: closest vertex pairs between trees, minor performance hit\n            start_vertices = [v for v in self._graph.root_vertices if v.cost < float('inf')]\n            goal_vertices_list = list(goal_vertices)\n            for sv in start_vertices:\n                for gv in goal_vertices_list:\n                    line_seq = self._get_grid().get_line_sequence(sv.position, gv.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        cost_sum = sv.cost + self._get_grid().get_distance(sv.position, gv.position) + gv.cost\n                        if cost_sum < min_cost_sum:\n                            connection_vertex = sv\n                            min_cost_sum = cost_sum\n\n            if connection_vertex is None:\n                # As a last resort, fallback to start root vertex only path (should rarely occur)\n                connection_vertex = start_root\n\n        # Trace path from connection_vertex back to start root\n        path_from_start = []\n        current = connection_vertex\n        while True:\n            path_from_start.append(current)\n            if current is start_root or len(current.parents) == 0:\n                break\n            # Choose parent with lowest cost (heuristic)\n            current = min(current.parents, key=lambda p: p.cost)\n\n        path_from_start.reverse()\n\n        # Trace path from connection_vertex back to goal root\n        path_from_goal = []\n        current = connection_vertex\n        while True:\n            path_from_goal.append(current)\n            if current is goal_root or len(current.parents) == 0:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n\n        # Combine paths avoiding duplication of connection vertex\n        path = path_from_start + path_from_goal[1:]\n\n        # Path smoothing by shortcutting\n        path = self._smooth_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        smoothed_path = path[:]\n        n = len(smoothed_path)\n        if n <= 2:\n            return smoothed_path\n\n        steps = 0\n        while steps < self._max_smoothing_steps:\n            i = 0\n            changed = False\n            while i < len(smoothed_path) - 2:\n                for j in range(len(smoothed_path) - 1, i+1, -1):\n                    line_seq = self._get_grid().get_line_sequence(smoothed_path[i].position, smoothed_path[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        # remove intermediate vertices\n                        if j - i > 1:\n                            smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n                            changed = True\n                        break\n                i += 1\n            if not changed:\n                break\n            steps += 1\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # Initialize costs to zero for root vertices\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        for iteration in range(self._iterations):\n\n            if time.time() - start_time > self._timeout_sec:\n                # Timeout: no path found in allocated time\n                break\n\n            # Adaptive goal bias rate increasing gradually\n            self._goal_sample_rate = min(0.6, 0.2 + iteration / self._iterations * 0.4)\n\n            # Sample point biased towards goal increasingly over time\n            q_rand = self._get_random_sample()\n\n            # Alternate expansion between start and goal roots for better connection chances\n            current_root = start_root if iteration % 2 == 0 else goal_root\n            other_root = goal_root if current_root is start_root else start_root\n\n            q_near = self._get_nearest_vertex(current_root, q_rand)\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_rand, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                # invalid extension\n                self.key_frame()\n                continue\n\n            # Add q_new with cost and edge\n            q_new.cost = self._cost(q_near, q_new)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire in neighborhood to improve paths\n            radius = max_dist * 2.5\n            nearby_vertices = self._get_nearby_vertices(q_new, radius)\n            self._rewire(q_new, nearby_vertices)\n\n            # Try to connect q_new to the other tree\n            q_near_other = self._get_nearest_vertex(other_root, q_new.position)\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near_other.position)):\n                q_connect = self._get_new_vertex(q_new, q_near_other.position, self._get_grid().size.n_dim * max_dist)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_connect.position)):\n                    q_connect.cost = self._cost(q_new, q_connect)\n                    self._graph.add_edge(q_new, q_connect)\n\n                    # Rewire after connection\n                    near_connect = self._get_nearby_vertices(q_connect, radius)\n                    self._rewire(q_connect, near_connect)\n\n                    # Check if a path can be extracted by DFS over connectivity\n                    # Heuristic: if goal_root reachable from start_root or vice versa in connectivity, path found\n                    found_path = False\n\n                    visited = set()\n                    stack = [start_root]\n                    while stack:\n                        v = stack.pop()\n                        if v == goal_root:\n                            found_path = True\n                            break\n                        visited.add(v)\n                        for c in v.children:\n                            if c not in visited:\n                                stack.append(c)\n\n                    if found_path:\n                        self._extract_path()\n                        return\n\n            # Visualization keyframe\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
