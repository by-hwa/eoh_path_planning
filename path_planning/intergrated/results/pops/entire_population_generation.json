{
     "algorithm": "This algorithm implements an Adaptive Heuristic-RRT approach, combining goal-biased sampling with heuristic-driven vertex expansion,\n    adaptive step size adjustment based on local obstacle density, and path smoothing after initial path discovery.\n    \n    Key Features:\n    - Goal Biasing: Samples the goal position directly with a configurable probability to focus exploration.\n    - Heuristic-Guided Expansion: Chooses extensions toward samples using a combined cost heuristic (distance + estimated cost-to-goal).\n    - Adaptive Step Size: Dynamically adjusts the maximum extension length based on local obstacle density to improve exploration efficiency.\n    - Tree Rewiring: Integrates RRT* style rewiring within a dynamically computed radius to improve path quality during construction.\n    - Early Stopping: Stops path search early if a valid path has been found or if execution time exceeds 10 seconds.\n    - Path Smoothing: After finding a feasible path, attempts shortcutting by connecting non-consecutive waypoints directly with collision checks.\n    \n    This blend aims to produce shorter, smoother paths more reliably with fewer iterations and better robustness in complex grids.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist_base = 12.0       # Base max extension distance\n        self._goal_sample_rate = 0.2     # Probability of sampling goal directly (goal biasing)\n        self._lambda_rrt_star = 40       # Radius factor for rewiring\n        self._max_radius = 40             # Max radius for neighborhood searches\n        self._max_iterations = 5000\n        self._start_time = None\n        \n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        import random\n\n        if random.random() < self._goal_sample_rate:\n            # Goal-biased sampling: return goal position\n            return self._get_grid().goal.position\n        else:\n            # Uniform random sample that is valid\n            while True:\n                sample_coords = [\n                    torch.randint(0, self._get_grid().size[i], (1,)).item()\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _adaptive_max_dist(self, position: Point) -> float:\n        # Estimate local obstacle density by checking neighbors in small radius\n        neighbor_radius = 5.0\n        obstacle_count = 0\n        neighbor_points = self._get_grid().get_vertices_within_radius([Vertex(position)], position, neighbor_radius)\n        # Instead of vertices, we estimate density by counting invalid positions around the point\n        # We'll use get_next_positions for rough obstacle count\n        next_positions = self._get_grid().get_next_positions(position)\n        for nb_pos in next_positions:\n            if not self._get_grid().is_agent_valid_pos(nb_pos):\n                obstacle_count += 1\n        \n        # More obstacles nearby reduce max_dist, clamp between 4 and base max_dist\n        max_dist = max(4.0, self._max_dist_base - obstacle_count * 2.5)\n        return max_dist\n    \n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Euclidean distance heuristic\n        return self._get_grid().get_distance(frm, to)\n    \n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_goal: Vertex):\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            for p in current.parents:\n                current = p\n                path.append(current)\n                break\n        path.reverse()\n\n        # Path smoothing by shortcutting non-consecutive waypoints\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        for p in smoothed_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n\n        for i in range(self._max_iterations):\n\n            # Early stop if anything exceeds 10 seconds\n            if time.time() - self._start_time > 10.0:\n                # Failed to find path in time\n                return\n\n            q_sample: Point = self._get_random_sample()\n\n            # Find nearest vertex using custom heuristic-adjusted cost alongside distance\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist_dynamic: float = self._adaptive_max_dist(q_nearest.position)\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist_dynamic)\n\n            # Validate direct line connection from nearest to new vertex\n            line_seq_near_new = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq_near_new):\n                continue\n\n            # Calculate radius for neighborhood rewiring based on graph size and dimension = 2\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card_v = torch.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / 2)), self._max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Find minimum cost parent in Q_near using cost + movement + heuristic to goal\n            q_min = None\n            c_min = float('inf')\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost = q_near.cost + self._heuristic_cost(q_near.position, q_new.position)\n                if cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            if q_min is None:\n                # If no good parent, connect from nearest\n                q_min = q_nearest\n                c_min = q_nearest.cost + self._heuristic_cost(q_nearest.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to new vertex if cheaper\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq_new_near = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_new_near):\n                    continue\n                cost_new_to_near = q_new.cost + self._heuristic_cost(q_new.position, q_near.position)\n                if cost_new_to_near < q_near.cost:\n                    # Remove old parent edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if we reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            # Heuristic-driven expansion: if q_new is closer to goal than q_nearest, bias next samples nearer to goal\n            dist_to_goal_new = self._heuristic_cost(q_new.position, self._get_grid().goal.position)\n            dist_to_goal_nearest = self._heuristic_cost(q_nearest.position, self._get_grid().goal.position)\n            if dist_to_goal_new < dist_to_goal_nearest:\n                self._goal_sample_rate = min(0.4, self._goal_sample_rate + 0.01)  # Increase goal bias adaptively\n            else:\n                self._goal_sample_rate = max(0.1, self._goal_sample_rate - 0.005) # Decrease goal bias slowly\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an adaptive, heuristic-guided RRT* inspired planner incorporating:\n      - Goal-biased sampling with dynamic probability increasing over time to accelerate convergence.\n      - Adaptive max step size based on distance to goal for more precise final connection.\n      - Rewiring step to optimize paths by attempting to connect newly added vertices to nearby vertices with lower cost.\n      - Heuristic cost (distance-to-goal + cost-so-far) guide for vertex selection improving expansion quality.\n      - Path shortcutting after goal reach to improve path smoothness.\n      - Early stopping based on time limit (10 seconds) for planning efficiency.\n    This approach balances exploration and exploitation, improving planning efficiency, path quality, success rate, and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges for optimization\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_adaptive_max_dist(self, from_pos: Point, to_pos: Point) -> float:\n        dist = self._get_grid().get_distance(from_pos, to_pos)\n        base_step = 15.0\n        # Make step smaller as we approach goal (min 2, max base_step)\n        adapted_step = max(min(base_step, dist * 0.5), 2.0)\n        return adapted_step\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / norm\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias_prob: float) -> Point:\n        \"\"\"Sample random point with goal bias.\"\"\"\n        import random\n        if random.random() < goal_bias_prob:\n            # Goal biased sample\n            return self._get_grid().goal.position\n        grid_size = self._get_grid().size\n        while True:\n            rand_pos_coords = [np.random.randint(0, s) for s in grid_size]\n            sample = Point(*rand_pos_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _heuristic_cost(self, vertex: Vertex) -> float:\n        # Cost-so-far + estimated cost-to-goal\n        cost_so_far = vertex.cost\n        est_go = self._get_grid().get_distance(vertex.position, self._get_grid().goal.position)\n        return cost_so_far + est_go\n\n    def _rewire(self, q_new: Vertex, neighbor_radius: float) -> None:\n        \"\"\"\n        Attempt to rewire neighbors of q_new to reduce cost:\n        For each neighbor within radius, if going through q_new reduces cost and line is valid, rewire.\n        \"\"\"\n        neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, neighbor_radius)\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            # Potential new cost through q_new\n            cost_to_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if cost_to_new < q_near.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parent edge(s)\n                    for old_parent in list(q_near.parents):\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge from q_new to q_near\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = cost_to_new\n\n    def _extract_path_and_shortcut(self, q_new: Vertex) -> None:\n        \"\"\"Trace back the path from q_new to start and apply shortcut smoothing.\"\"\"\n\n        path: list[Vertex] = [q_new]\n        while len(path[-1].parents) != 0:\n            # Always choose parent with minimum cost (better path)\n            min_parent = None\n            min_cost = float('inf')\n            for p in path[-1].parents:\n                if p.cost < min_cost:\n                    min_parent = p\n                    min_cost = p.cost\n            if min_parent is None:\n                break\n            path.append(min_parent)\n\n        path.reverse()\n        # Shortcutting to smooth path: try to connect non-adjacent vertices directly if possible\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            connected = False\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    connected = True\n                    break\n                j -= 1\n            if not connected:\n                # Can't shortcut, just take next vertex\n                shortcut_path.append(path[i+1])\n                i += 1\n\n        # Animate moving agent along shortcut path\n        for vertex in shortcut_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 5000\n        goal_bias_start = 0.05\n        goal_bias_end = 0.3\n        goal_bias = goal_bias_start\n\n        neighbor_radius_base = 20.0\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0  # Cost 0 at start\n\n        for iteration in range(max_iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout fail\n                break\n\n            # Increase goal bias gradually\n            goal_bias = min(goal_bias_end, goal_bias_start + (iteration / max_iterations) * (goal_bias_end - goal_bias_start))\n\n            # Sample point with current goal bias probability\n            q_sample = self._get_random_sample(goal_bias)\n\n            # Choose q_near with minimal heuristic cost (improved from vanilla RRT)\n            candidates = self._graph.root_vertices\n            q_near_candidates = []\n            # To improve, search all vertices (could be expensive), limit by nearby or random subset\n            sample_candidates = list(self._graph.root_vertices)\n            # Collect all vertices in graph (approximate breadth-first)\n            all_vertices = []\n            def collect_all(v: Vertex):\n                all_vertices.append(v)\n                return True\n            self._graph.walk_dfs(collect_all)\n            if len(all_vertices) > 1000:\n                # Pick random subset of vertices to limit computational cost\n                import random\n                sample_candidates = random.sample(all_vertices, 1000)\n            else:\n                sample_candidates = all_vertices\n\n            best_near = None\n            best_heuristic = float('inf')\n            for v in sample_candidates:\n                dist = self._get_grid().get_distance(v.position, q_sample)\n                # Ignore candidates too far away (> 30)\n                if dist > 30:\n                    continue\n                h_cost = self._heuristic_cost(v)\n                if h_cost < best_heuristic:\n                    best_heuristic = h_cost\n                    best_near = v\n            q_near = best_near\n            if q_near is None:\n                q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position, q_sample)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check collision along straight line\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost from start to q_new\n            cost_new = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_new\n\n            # Add q_new and connect from q_near\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors to optimize cost\n            neighbor_radius = neighbor_radius_base * ((iteration + 1) / max_iterations) ** 0.5\n            self._rewire(q_new, neighbor_radius)\n\n            # Check if reached goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal vertex if possible\n                goal_vertex = self._graph.root_vertex_goal\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    # Extract and shortcut path\n                    self._extract_path_and_shortcut(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved sample-based path planner inspired by RRT* and heuristic guidance.\n    It combines goal-biased adaptive sampling with rewiring steps for path optimization.\n    Key enhancements:\n    - Adaptive max step size based on distance to nearest vertex and goal.\n    - Goal bias sampling (with 20% probability).\n    - Heuristic guided nearest vertex search using a combined cost: cost-to-come + heuristic-to-go.\n    - Rewiring to shorten paths and improve path quality.\n    - Path shortcutting for smoother final path.\n    - Early stopping if a good-quality path is found or after 10 seconds.\n    The algorithm maintains a single tree rooted at the start and incrementally builds and improves\n    the tree while aiming to connect to the goal efficiently.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                 Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                 [])\n        self._graph.edges_removable = True  # support rewiring/removal of edges for optimization\n        self._goal_vertex = self._graph.root_vertex_goal\n        self._start_vertex = self._graph.root_vertex_start\n        self._max_iterations = 5000\n        self._time_limit_seconds = 10.0\n        self._goal_bias = 0.2\n        self._rewire_radius = 15.0\n        self._max_step = 15.0\n        self._init_displays()\n        self._path_found = False\n        self._best_goal_vertex = None  # will store vertex connecting to goal with best cost\n\n    def _get_distance(self, frm: Point, to: Point) -> float:\n        # Wrapper for static distance function\n        return self._get_grid().get_distance(frm, to)\n\n    def _heuristic_cost(self, vertex: Vertex) -> float:\n        # Heuristic cost to goal: Euclidean distance from vertex to goal\n        return self._get_distance(vertex.position, self._goal_vertex.position)\n\n    def _total_cost(self, vertex: Vertex) -> float:\n        # Total estimated cost = cost to come + heuristic to goal\n        return vertex.cost + self._heuristic_cost(vertex)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir).item()\n        if dist <= max_dist:\n            # new vertex is exactly the sample\n            new_pos = q_sample\n        else:\n            dir_normalized = dir / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling: with probability goal_bias sample goal, else random valid sample\n        import numpy as np\n        if np.random.random() < self._goal_bias:\n            return self._goal_vertex.position\n        else:\n            while True:\n                rand_pos_arr = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos_arr)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: list) -> Vertex:\n        # For RRT* style rewiring, select best parent from near vertices with valid connection\n        min_cost = float('inf')\n        best_parent = None\n        for near_v in near_vertices:\n            if near_v == q_new:\n                continue\n            # Check if line from near_v to q_new is valid\n            line_seq = self._get_grid().get_line_sequence(near_v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            # cost to come through near_v\n            edge_cost = self._get_grid().get_movement_cost(near_v.position, q_new.position)\n            new_cost = near_v.cost + edge_cost\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = near_v\n        if best_parent is None:\n            # fallback to nearest neighbor (no rewiring parent)\n            best_parent = self._graph.get_nearest_vertex([self._start_vertex], q_new.position)\n            min_cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: list) -> None:\n        # Try rewiring near vertices through q_new to shorten paths\n        for near_v in near_vertices:\n            if near_v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, near_v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            edge_cost = self._get_grid().get_movement_cost(q_new.position, near_v.position)\n            new_cost = q_new.cost + edge_cost\n            if new_cost < near_v.cost:\n                # Remove old parent edge(s) that cause cost > new_cost\n                # Assume one parent for simplicity (tree), remove all parents edges and add new\n                for p in list(near_v.parents):\n                    self._graph.remove_edge(p, near_v)\n                self._graph.add_edge(q_new, near_v)\n                near_v.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._start_vertex:\n            if not current.parents:\n                break  # Safety check in case disconnected\n            # Choose the parent with lowest cost (usually one parent for tree)\n            parent = min(current.parents, key=lambda v: v.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut smoothing:\n        path = self._shortcut_path(path)\n\n        # Animate moves along the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        # Attempts to shortcut the path by skipping intermediate vertices when possible\n        if len(path) < 3:\n            return path\n        i = 0\n        while i < len(path) - 2:\n            j = i + 2\n            shortcut_found = False\n            while j < len(path):\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove intermediate vertices between i and j\n                    del path[i + 1:j]\n                    shortcut_found = True\n                    break\n                j += 1\n            if not shortcut_found:\n                i += 1\n        return path\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        self._start_vertex.cost = 0.0\n        self._best_goal_vertex = None\n        best_cost_to_goal = float('inf')\n\n        for iteration in range(self._max_iterations):\n            # Check time limit\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit_seconds:\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Find nearest vertex using heuristic cost: cost-to-come + heuristic-to-sample\n            # Custom nearest vertex search that balances cost-to-come and distance to sample\n            def combined_cost(v: Vertex) -> float:\n                c_to_come = v.cost\n                dist_to_sample = self._get_distance(v.position, q_sample)\n                return c_to_come + dist_to_sample\n\n            # We search nearest vertex among entire existing tree for better heuristic guidance\n            nearest_vertex_candidates = list(self._graph.root_vertices)\n            # Flatten all vertices by DFS to find nearest vertex by combined cost\n            all_vertices = []\n\n            def collect_all_vertices(v: Vertex) -> bool:\n                all_vertices.append(v)\n                return True  # continue DFS\n\n            self._graph.walk_dfs(collect_all_vertices)\n\n            q_near = min(all_vertices, key=combined_cost)\n\n            # Compute adaptive max step based on distance from q_near to q_sample\n            dist_to_sample = self._get_distance(q_near.position, q_sample)\n            adaptive_max_step = min(self._max_step, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_max_step)\n\n            # Check line validity from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                # Invalid edge, skip iteration\n                self.key_frame()\n                continue\n\n            # Find near vertices within rewire radius to use for choosing parent and rewiring\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n            if not near_vertices:\n                near_vertices = [q_near]  # fallback\n\n            q_new_chosen_parent = self._choose_parent(q_new, near_vertices)\n            self._graph.add_edge(q_new_chosen_parent, q_new)\n            q_new.cost = q_new_chosen_parent.cost + self._get_grid().get_movement_cost(q_new_chosen_parent.position, q_new.position)\n\n            # Rewire other near vertices through q_new to improve path quality\n            self._rewire(q_new, near_vertices)\n\n            self._graph.root_vertices.append(q_new)  # add new vertex to forest root_vertices for indexing\n\n            # Check if q_new is close enough to goal and line to goal is valid\n            dist_to_goal = self._get_distance(q_new.position, self._goal_vertex.position)\n            if dist_to_goal <= self._max_step:\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    goal_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._goal_vertex.position)\n                    if goal_cost < best_cost_to_goal:\n                        best_cost_to_goal = goal_cost\n                        # Add connection to goal vertex (re-wiring the goal vertex)\n                        # Remove old parents edges of goal vertex and add new edge from q_new for best path so far\n                        for p in list(self._goal_vertex.parents):\n                            self._graph.remove_edge(p, self._goal_vertex)\n                        self._graph.add_edge(q_new, self._goal_vertex)\n                        self._goal_vertex.cost = goal_cost\n                        self._best_goal_vertex = self._goal_vertex\n\n                        # Early stopping criteria: if path cost is sufficiently low\n                        if best_cost_to_goal < self._get_distance(self._start_vertex.position, self._goal_vertex.position) * 1.1:\n                            self._path_found = True\n                            break\n\n            # Visualization keyframe update\n            self.key_frame()\n\n        # Final path extraction if found\n        if self._best_goal_vertex is not None:\n            self._extract_path(self._best_goal_vertex)\n        else:\n            # No path found within time or iteration limit\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an Adaptive Heuristic-Guided Biased Sampling Tree (AHGBST):\n    - Combines dual-tree growth (from start and goal) within a Forest structure for robust start-goal connection.\n    - Uses goal-biased sampling (with increasing probability over iterations) for efficiency.\n    - Heuristic cost (Euclidean + movement cost) guides vertex expansion, favoring promising directions.\n    - Adaptive step size (max_dist) shrinks near obstacles or goal to enhance path quality.\n    - Rewires the tree to improve path cost whenever possible, borrowing from RRT* concepts.\n    - Early stopping on successful start-goal connection or on 10 seconds elapsed.\n    - Extracted path is shortcut-smoothed by attempting direct traversals on path segments.\n    - Designed for smooth, shorter, and reliable path with fewer iterations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph: Forest = None\n        self._max_dist_init: float = 15.0\n        self._max_radius: float = 30.0\n        self._lambda_rrt_star: float = 50.0\n        self._dimension: int = self._get_grid().size.n_dim\n        self._start_vertex: Vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._init_displays()\n\n    # Additional helper: heuristic cost (Euclidean + movement cost)\n    def _heuristic_cost(self, frm: Vertex, to: Point) -> float:\n        return self._get_grid().get_distance(frm.position, to)\n\n    # Adaptive step size: shrink max_dist if near obstacle or near goal for finer resolution\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        dist_to_goal = self._get_grid().get_distance(pos, self._goal_vertex.position)\n        base_dist = self._max_dist_init\n        # Shrink step size near goal\n        if dist_to_goal < 20:\n            base_dist = max(3.0, base_dist * (dist_to_goal / 20))\n        # Check surroundings for obstacles within 3-unit radius (using next positions)\n        next_positions = self._get_grid().get_next_positions(pos)\n        if len(next_positions) < 8:  # fewer moves suggests cluttered area\n            base_dist = max(3.0, base_dist * 0.5)\n        return base_dist\n\n    # Goal-biased sample with probability increasing over iterations (max 0.4)\n    def _goal_biased_sample(self, iteration: int, max_iters: int) -> Point:\n        goal_bias_max = 0.4\n        bias_prob = min(goal_bias_max, (iteration / max_iters) * goal_bias_max)\n        import random\n        if random.random() < bias_prob:\n            return self._goal_vertex.position\n        return self._get_random_sample()\n\n    # Shortcut smoothing on paths by trying to replace two-segment with direct segment if collision-free\n    def _shortcut_path(self, path_points: list) -> list:\n        if len(path_points) <= 2:\n            return path_points\n        shortcut_path = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_points[i], path_points[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path_points[j])\n            i = j\n        return shortcut_path\n\n    # Extract path from merged forest roots and smooth it\n    def _extract_and_smooth_path(self, connecting_vertex: Vertex):\n        path_vertices = [connecting_vertex]\n        # Traverse parents to start\n        current = connecting_vertex\n        while current and len(current.parents) > 0:\n            parent = next(iter(current.parents))\n            path_vertices.append(parent)\n            current = parent\n        path_vertices.reverse()\n\n        # Traverse children from connecting vertex to goal\n        current = connecting_vertex\n        while current and len(current.children) > 0:\n            child = next(iter(current.children))\n            path_vertices.append(child)\n            current = child\n\n        # Extract points\n        path_points = [v.position for v in path_vertices]\n\n        # Shortcut smooth the path\n        smoothed_points = self._shortcut_path(path_points)\n\n        # Move agent along path\n        for p in smoothed_points:\n            self.move_agent(p)\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    # Overridden main search function\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        max_iterations: int = 5000\n        start_time = time.time()\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout reached, path not found\n                break\n\n            # Adaptive sampling, biased towards goal progressively\n            q_sample: Point = self._goal_biased_sample(iteration, max_iterations)\n\n            # Choose tree to expand: alternate or heuristic based\n            # Here: expand from start tree if iteration even; else from goal tree to balance\n            expanding_root_vertices = [self._graph.root_vertex_start] if iteration % 2 == 0 else [self._graph.root_vertex_goal]\n\n            q_nearest: Vertex = self._graph.get_nearest_vertex(expanding_root_vertices, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max dist based on environment and proximity\n            max_dist = self._adaptive_max_dist(q_nearest.position)\n\n            # New vertex towards sample\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_vec)\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dir_norm\n                q_new_pos = Point.from_tensor(q_nearest.position.to_tensor() + max_dist * dir_normalized)\n\n            q_new = Vertex(q_new_pos)\n\n            # Reject if path invalid between nearest and new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Connect q_new with best parent in radius using rewiring like RRT*\n            card_v = float(self._graph.size) + 1\n            log_card_v = math.log(card_v)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), self._max_radius)\n\n            nearby_vertices: list = self._graph.get_vertices_within_radius(expanding_root_vertices, q_new.position, radius)\n\n            # Find minimum cost parent among nearby vertices\n            min_cost = None\n            min_vertex = None\n            for v in nearby_vertices:\n                # Check line validity from v to q_new\n                line_seq_n = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_n):\n                    continue\n                cost_to_new = v.cost + self._get_grid().get_distance(v.position, q_new.position)\n                if min_cost is None or cost_to_new < min_cost:\n                    min_cost = cost_to_new\n                    min_vertex = v\n\n            if min_vertex is None:\n                # fallback to nearest vertex if no nearby feasible vertex found\n                min_vertex = q_nearest\n                min_cost = min_vertex.cost + self._get_grid().get_distance(min_vertex.position, q_new.position)\n\n            q_new.cost = min_cost\n            self._graph.add_edge(min_vertex, q_new)\n\n            # Rewire nearby vertices if connecting from q_new is cheaper\n            for v in nearby_vertices:\n                if v == min_vertex:\n                    continue\n                line_seq_v = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_v):\n                    continue\n                cost_v_new = q_new.cost + self._get_grid().get_distance(q_new.position, v.position)\n                if cost_v_new < v.cost:\n                    # Remove old parent edge\n                    old_parent = next(iter(v.parents)) if v.parents else None\n                    if old_parent:\n                        self._graph.remove_edge(old_parent, v)\n                    # Add new edge from q_new\n                    v.cost = cost_v_new\n                    self._graph.add_edge(q_new, v)\n\n            # Attempt to connect opposite tree root vertices if q_new close enough to any vertex in opposite tree\n            opposite_root_vertices = [self._graph.root_vertex_goal] if expanding_root_vertices == [self._graph.root_vertex_start] else [self._graph.root_vertex_start]\n            connect_candidates = self._graph.get_vertices_within_radius(opposite_root_vertices, q_new.position, radius)\n            connected = False\n\n            for opp_v in connect_candidates:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, opp_v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    # Connect q_new and opp_v both ways to merge trees\n                    self._graph.add_edge(q_new, opp_v)\n                    self._graph.add_edge(opp_v, q_new)\n                    connected = True\n                    break\n\n            if connected:\n                # Extract path from merged trees through connecting vertex q_new\n                self._extract_and_smooth_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved path planner inspired by RRT* and heuristic-guided sampling.\n    It uses adaptive step size and goal-biased sampling to speed up exploration.\n    The algorithm incrementally builds a tree with rewiring to optimize path cost (like RRT*),\n    reuses a radius-based neighborhood search to improve connectivity and smoothness,\n    and employs a heuristic based on Euclidean distance to goal to guide sampling.\n    During path extraction, it attempts path shortcutting to smoothen it.\n    To ensure responsiveness, search is limited to 10 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.1       # Probability to sample goal directly\n        self._rewire_radius = 20.0  # Neighborhood radius for rewiring\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        # With probability goal_bias, sample the goal; otherwise random valid sample\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        # Return all vertices within radius of point in given list\n        near_vert = []\n        radius_sq = radius * radius\n        for v in vertices:\n            if Map.get_distance(v.position, point) <= radius:\n                near_vert.append(v)\n        return near_vert\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost equivalently distance plus movement cost from grid (might consider obstacles implicitly)\n        dist = Map.get_distance(frm.position, to.position)\n        # Movement cost from grid between positions (may differ if terrain)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose best parent vertex minimizing cost to q_new + movement cost, only if line valid\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire the tree to use q_new as intermediate for near vertices if it reduces cost\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove old parent edges, add new edge from q_new\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by skipping intermediate vertices if direct line is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Decrease j until direct connection is valid\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        # Backtrack to root start by best parent chain (assume single parent tree)\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break  # no path\n            # Choose the parent with minimal cost (should be single due to rewiring but safe check)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut smoothing\n        smoothed_path = self._shortcut_path(path)\n\n        for p in smoothed_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        max_dist = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                # Give up on path finding (not found in time)\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on distance to sample\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices for rewiring (within radius)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Choose best parent to connect q_new with\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # No suitable parent found, try q_near as fallback\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to q_new if it improves cost\n            self._rewire(near_vertices, q_new)\n\n            # Check goal reached\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Connect final goal vertex\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved, heuristic-guided sample-based planner inspired by RRT*.\n    It incorporates:\n    - Goal-biased sampling (bias towards the goal with some probability)\n    - Adaptive max step size that shrinks as new vertices approach the goal\n    - Rewiring of the graph to optimize path costs (RRT* style)\n    - Heuristic cost function combining distance from start and to goal (A*-like)\n    - Path shortcutting by trying direct connections between non-adjacent vertices after completion\n    - Early stopping criteria including time limit (10 seconds) and goal radius check\n    The algorithm aims for better planning efficiency, path quality, robustness, and success rate by optimizing graph edges and guided sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        self._graph = gen_forest(self._services, Vertex(start_pos), Vertex(goal_pos), [])\n        self._graph.edges_removable = True  # Allow rewiring edges\n        self._init_displays()\n    \n\n    def _get_cost(self, vertex_from: Vertex, vertex_to: Vertex) -> float:\n        # Real movement cost from vertex_from to vertex_to (assuming valid)\n        return self._get_grid().get_movement_cost(vertex_from.position, vertex_to.position)\n\n    def _heuristic(self, point: Point) -> float:\n        # Estimated cost from point to goal (Euclidean distance)\n        goal_pos = self._get_grid().goal.position\n        return self._get_grid().get_distance(point, goal_pos)\n\n    def _total_cost(self, vertex: Vertex, new_parent: Vertex) -> float:\n        # Cost to reach vertex via new_parent\n        cost_from_parent = new_parent.cost + self._get_cost(new_parent, vertex)\n        # Heuristic cost from vertex to goal for potential A* style\n        h_cost = self._heuristic(vertex.position)\n        return cost_from_parent + h_cost\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_point = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_point)\n\n    def _get_random_sample(self, goal_bias_ratio: float = 0.2) -> Point:\n        # With probability goal_bias_ratio, sample goal position to bias towards goal\n        if np.random.rand() < goal_bias_ratio:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _find_near_vertices(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n    \n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewire the graph for RRT* optimization:\n        For each vertex near q_new, check if path through q_new reduces cost.\n        \"\"\"\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Rewire edge\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) > 0:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut the path by attempts to connect non-adjacent vertices directly where possible\n        path = self._shortcut_path(path)\n\n        # Animate path following\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n    \n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempts to straight-line connect points in path to shortcut and smooth the path.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1  # try to connect as far as possible\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 8000\n        max_dist_initial = 15.0\n        radius_constant = 30.0  # Radius to find neighbors for rewiring\n        \n        root_start = self._graph.root_vertex_start\n        root_start.cost = 0.0\n\n        # Add root start vertex to graph explicitly if needed\n        if root_start not in self._graph.root_vertices:\n            self._graph.root_vertices.append(root_start)\n\n        for iteration in range(max_iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:  # early stop if runtime exceeds 10 seconds\n                break\n\n            # Adaptive max_dist shrinks near goal for fine refinement\n            dist_to_goal = self._get_grid().get_distance(root_start.position, self._get_grid().goal.position)\n            max_dist = max_dist_initial * min(1.0, dist_to_goal / 100.0) + 2.0\n\n            q_sample = self._get_random_sample(goal_bias_ratio=0.25)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            \n            if q_near.position == q_sample:\n                continue  # skip if sample coincides with nearest vertex\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n            \n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Initialize q_new cost as cost to reach from q_near\n            q_new.cost = q_near.cost + self._get_cost(q_near, q_new)\n\n            # Find nearby vertices for rewiring (radius scales with log of graph size)\n            if self._graph.size > 0:\n                radius = radius_constant * (np.log(self._graph.size) / self._graph.size) ** 0.5\n                radius = max(radius, max_dist * 2)\n            else:\n                radius = radius_constant\n\n            near_vertices = self._find_near_vertices(q_new, radius)\n\n            # Choose parent vertex for q_new with minimal cost + valid line\n            min_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v == q_near:\n                    continue\n                test_line_seq = self._get_grid().get_line_sequence(near_v.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(test_line_seq):\n                    continue\n                cost_through_near = near_v.cost + self._get_cost(near_v, q_new)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    best_parent = near_v\n            q_new.cost = min_cost\n\n            # Add q_new to graph and connect to best parent\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire near vertices to possibly optimize paths through q_new\n            self._rewire(q_new, near_vertices)\n\n            # Add q_new to root vertices for expanding search\n            self._graph.root_vertices.append(q_new)\n            self._graph.size += 1\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Extract path with optimization shortcuts\n                self._extract_path(q_new)\n                return\n            \n            # Mark a key frame for animation\n            self.key_frame()\n\n        # If end not reached in allocated iterations or time, treat as not found (no path extraction)\n        # Could optionally move agent back to start or do nothing\n        return",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved path planner inspired by RRT* that integrates:\n    - a goal-biased adaptive sampling technique to improve convergence speed,\n    - dynamic max step size adapting to local free-space and distance to goal,\n    - rewiring for path quality improvement (shorter, smoother paths),\n    - heuristic-guided nearest vertex selection using A*-like cost estimates,\n    - path shortcutting after reaching the goal to smooth the final path,\n    - early stopping when goal is reached or 10 seconds elapsed for robustness and efficiency.\n    \n    The approach:\n    1. Samples points with a probability bias towards the goal.\n    2. Chooses the nearest vertex using a heuristic combining distance and cost-to-come.\n    3. Creates a new vertex stepping adaptively towards sampled point.\n    4. Connects and rewires local neighborhood for better cost propagation.\n    5. Upon finding a path, extracts and shortcuts it for smoothness.\n    6. Limits total planning time to 10 seconds to avoid excessive computation.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # needed for rewiring\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias=0.2) -> Point:\n        # Goal-biased sampling with probability goal_bias\n        import random\n        if random.random() < goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _heuristic_cost(self, vertex: Vertex, goal_pos: Point) -> float:\n        # Heuristic cost (Euclidean dist from vertex to goal)\n        return Map.get_distance(vertex.position, goal_pos)\n\n    def _adapt_max_dist(self, from_pos: Point, to_pos: Point) -> float:\n        # Dynamic max_dist: smaller when near goal or obstacles, larger otherwise\n        dist_to_goal = Map.get_distance(from_pos, to_pos)\n        base_dist = 12.0\n        agent_pos = self._get_grid().agent.position\n        # Shrink max step if near obstacles (simple heuristic: check neighbors)\n        neighbors = self._get_grid().get_next_positions(from_pos)\n        obstacle_penalty = 0\n        for n in neighbors:\n            if not self._get_grid().is_agent_valid_pos(n):\n                obstacle_penalty += 1\n        penalty_factor = 1 + obstacle_penalty * 0.5\n        max_step = min(base_dist, dist_to_goal)\n        max_step = max_step / penalty_factor\n        max_step = max(max_step, 1.5)  # Avoid too small step\n        return max_step\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Similar to RRT but max_dist adaptively provided\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / norm\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_norm)\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, near_vertices: 'List[Vertex]', q_new: Vertex) -> Vertex:\n        # Choose best parent based on lowest cost + edge cost (RRT* rewiring)\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            edge_cost = self._get_grid().get_movement_cost(v.position, q_new.position)\n            total_cost = v.cost + edge_cost\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = v\n        if best_parent is None:\n            best_parent = near_vertices[0]\n            min_cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: 'List[Vertex]', q_new: Vertex) -> None:\n        # Try to improve costs of near vertices by going through q_new\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            edge_cost = self._get_grid().get_movement_cost(q_new.position, v.position)\n            new_cost = q_new.cost + edge_cost\n            if new_cost < v.cost:\n                # Remove old edges from parents to v and add new edge from q_new to v\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path from goal backwards to start\n        path = [q_goal]\n        while len(path[-1].parents) > 0:\n            # Pick parent with lowest cost if multiple\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut path for smoothing: iteratively try to connect non-adjacent vertices\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n\n        # Animate the agent movement along the shortcut path\n        for vertex in shortcut_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        from collections import deque\n\n        start_time = time.time()\n        max_time = 10.0  # seconds timeout\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n\n        max_iterations = 8000  # adaptive, could allow longer if needed\n\n        radius = 15.0  # radius for rewiring and neighborhood\n\n        for _ in range(max_iterations):\n            current_time = time.time()\n            if current_time - start_time > max_time:\n                # Timeout - no path found within time limit\n                break\n\n            q_sample = self._get_random_sample()\n            # Heuristic-nearest based on combined cost + dist to sample\n            vertices = self._graph.root_vertices\n            min_dist = float('inf')\n            q_near = None\n            for v in vertices:\n                dist = Map.get_distance(v.position, q_sample)\n                heuristic = v.cost + dist\n                if heuristic < min_dist:\n                    min_dist = heuristic\n                    q_near = v\n            if q_near is None:\n                continue\n\n            max_dist = self._adapt_max_dist(q_near.position, q_sample)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Neighborhood for rewiring\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n            if not near_vertices:\n                near_vertices = [q_near]\n\n            # Choose best parent within neighborhood for q_new\n            best_parent = self._choose_parent(near_vertices, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighborhood to improve path costs\n            self._rewire(near_vertices, q_new)\n\n            # Add q_new to root vertices to extend search\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal reached within radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex for path extraction\n                goal_vertex = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_pos)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved version inspired by RRT* with goal biasing, adaptive step size, rewiring,\n    and heuristic-guided sampling to improve planning efficiency, path quality, robustness, and success rate.\n    \n    Key features:\n    - Goal-biased sampling to increase the chance of progress towards the goal.\n    - Adaptive max_dist: decreases step size when close to obstacles or goal for finer exploration.\n    - Uses RRT*-style rewiring to optimize path cost locally.\n    - Heuristic cost combines path cost + Euclidean distance to goal.\n    - Early stopping criteria on goal reach or after 10 seconds to avoid excessive computation.\n    - Path shortcutting applied on extracted path for smoother and shorter result.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _time_limit_sec: float\n    _start_time: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._time_limit_sec = 10.0\n        import time\n        self._start_time = time.time()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_heuristic_cost(self, vertex: Vertex, goal: Point) -> float:\n        # Cost = current cost + Euclidean distance heuristic to goal\n        return vertex.cost + self._get_grid().get_distance(vertex.position, goal)\n\n    def _get_random_sample(self, goal_bias: float = 0.1) -> Point:\n        # With probability goal_bias, return the goal position to bias search towards goal\n        import random\n        if random.random() < goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _find_near_vertices(self, forest: Forest, vertex: Vertex, radius: float) -> List[Vertex]:\n        return forest.get_vertices_within_radius([forest.root_vertex_start], vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose a parent which yields the lowest cost to q_new given collision free path\n        min_cost = float(\"inf\")\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_distance(v.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex):\n        # Attempt to rewire near vertices if q_new offers a lower cost path\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, v.position)\n            if new_cost < v.cost:\n                # Remove old parents edges and add edge q_new -> v\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _extract_path(self, q_goal_parent: Vertex) -> None:\n        # Build path backwards from goal parent to start\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_goal_parent, goal_v)  # connect last sampled to goal vertex\n        goal_v.cost = q_goal_parent.cost + self._get_grid().get_distance(q_goal_parent.position, goal_v.position)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            # In this version the tree is rooted and edges directional, and each vertex has parents with costs\n            # Choose the parent with minimal cost (should be only one in RRT* tree)\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n\n        path.reverse()\n\n        # Shortcut path to smooth and shorten\n        smooth_path = self._shortcut_path(path)\n\n        # Move agent along the path with keyframes for animation\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex], max_trials: int = 50) -> List[Vertex]:\n        # Attempt to shortcut path by connecting non-neighbor vertices if path valid\n        if len(path) <= 2:\n            return path\n\n        import random\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 2)\n            j = random.randint(i + 2, len(path) - 1)\n            p1 = path[i].position\n            p2 = path[j].position\n            line_seq = self._get_grid().get_line_sequence(p1, p2)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Shortcut possible: remove intermediate nodes\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n        import time\n        max_time = self._time_limit_sec\n        self._start_time = time.time()\n\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n\n        # Initialize cost for start vertex\n        start_vertex.cost = 0.0\n\n        max_iterations = 10000\n        dimension = self._get_grid().size.n_dim\n\n        # Adaptive radius for rewiring similar to RRT*\n        gamma_rrt_star = 50.0\n        volume = np.prod(self._get_grid().size[:dimension])\n        unit_ball_vol = np.pi if dimension == 2 else 4/3*np.pi if dimension == 3 else 1.0\n        r_max = gamma_rrt_star * (np.log(max_iterations) / max_iterations) ** (1 / dimension)\n\n        for iteration in range(max_iterations):\n            if time.time() - self._start_time > max_time:\n                # Time limit exceeded, no path found\n                break\n\n            # Adaptive max_dist based on distance to goal and obstacles\n            dist_to_goal = self._get_grid().get_distance(start_vertex.position, goal_pos)\n            max_dist = max(3.0, min(15.0, dist_to_goal / 5))\n\n            # Sample with goal bias, starting from 0.2 probability decreasing gradually\n            goal_bias = max(0.05, 0.2 * (1 - iteration / max_iterations))\n            q_sample = self._get_random_sample(goal_bias=goal_bias)\n\n            # Find nearest vertex (using underlying forest method)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Get point in the direction towards q_sample with max_dist limit\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices within adaptive radius\n            near_vertices = self._find_near_vertices(self._graph, q_new, radius=r_max)\n            if not near_vertices:\n                near_vertices = [q_near]\n\n            # Choose parent with minimum cost from near vertices\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                continue\n\n            q_new.cost = best_parent.cost + self._get_grid().get_distance(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire to optimize cost of edges within radius\n            self._rewire(near_vertices, q_new)\n\n            # Check if goal reached (inside radius)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* inspired path planner with:\n    - Goal-biased sampling to increase chances of reaching goal faster.\n    - Adaptive step size to balance exploration and refinement based on proximity to goal.\n    - Rewiring of nearby vertices to optimize the tree for shorter path cost (RRT* style).\n    - Path smoothing shortcut step before final path extraction.\n    - Early stopping if the path is found or if exceeded a 10 second time limit.\n    \n    These improvements result in higher success rate, better path quality, and reduced planning time.",
     "code": "class PathPlanning(RRT):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._goal_bias_prob = 0.1         # Probability to sample directly near goal\n        self._rewire_radius = 15.0         # Radius to search neighbors for rewiring\n        self._max_dist_far = 15.0           # Max step size when far from goal\n        self._max_dist_near = 5.0           # Max step size when near goal\n        self._time_limit_seconds = 10       # Time limit for planning\n        self._start_time = None             # To track elapsed time\n\n    def _get_adaptive_max_dist(self, current_pos: Point, goal_pos: Point) -> float:\n        dist_to_goal = Map.get_distance(current_pos, goal_pos)\n        if dist_to_goal < 20:\n            return self._max_dist_near\n        else:\n            return self._max_dist_far\n\n    def _get_goal_biased_sample(self) -> Point:\n        # With probability goal_bias_prob, sample near goal, else random\n        import random\n        if random.random() < self._goal_bias_prob:\n            goal_pos: Point = self._get_grid().goal.position\n            # Sample in a small cube around goal within radius 5\n            attempts = 0\n            while attempts < 20:\n                rand_offset = np.random.randint(-5, 6, self._get_grid().size.n_dim)\n                biased_sample = Point(*(goal_pos.to_list()[i] + rand_offset[i] for i in range(self._get_grid().size.n_dim)))\n                if self._get_grid().is_agent_valid_pos(biased_sample):\n                    return biased_sample\n                attempts += 1\n            # Fallback to random sample if no valid biased sample found\n        return self._get_random_sample()\n\n    def _rewire(self, q_new: Vertex) -> None:\n        neighbors: List[Vertex] = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            # Check if path q_near to q_new is valid and if cost improves by rewiring q_near under q_new\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Remove old edge from q_near parents and add new edge from q_new\n                old_parents = list(q_near.parents)\n                for old_parent in old_parents:\n                    self._graph.remove_edge(old_parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _try_shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path: if line between non-adjacent vertices is valid, skip intermediate vertices\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path) -1\n            while j > i +1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, add next immediate vertex\n                shortcut_path.append(path[i+1])\n                i += 1\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Modified extract_path with path smoothing shortcut\n        \n        path: List[Vertex] = [q_new]\n        current_vertex = q_new\n        while len(current_vertex.parents) != 0:\n            # pick parent with lowest cost (if multiple)\n            parent = min(current_vertex.parents, key=lambda v: v.cost)\n            path.append(parent)\n            current_vertex = parent\n        path.reverse()\n\n        # shortcut smoothing\n        path = self._try_shortcut_path(path)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        self._start_time = time.time()\n        max_iterations = 10000\n        goal_pos: Point = self._get_grid().goal.position\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n\n            # Check time limit early stop\n            elapsed_time = time.time() - self._start_time\n            if elapsed_time > self._time_limit_seconds:\n                break\n\n            q_sample: Point = self._get_goal_biased_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position, goal_pos)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            new_cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = new_cost\n\n            # Choose parent within radius that improves cost (RRT* style)\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n            best_parent = q_near\n            best_cost = new_cost\n            for neighbor in neighbors:\n                line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_through_neighbor = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost_through_neighbor < best_cost:\n                    best_cost = cost_through_neighbor\n                    best_parent = neighbor\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors around q_new\n            self._rewire(q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* algorithm with goal-biased sampling, rewiring for path optimality, adaptive max step size, \n    and early stopping on success or timeout. It samples points mostly towards the goal to increase success rate,\n    adapts max extension length for tighter expansions near obstacles, rewires the tree to reduce path cost improving\n    path quality, and stops if a path is found or search exceeds 10 seconds. Path smoothing is applied as a post process.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring (removable edges)\n        self._max_dist_base = 10.0\n        self._goal_sample_rate = 0.2  # 20% goal bias\n        self._init_displays()\n    \n    \n    def _get_adaptive_max_dist(self, vertex_pos: Point) -> float:\n        \"\"\"Adaptive max step size based on proximity to obstacles.\"\"\"\n        grid = self._get_grid()\n        # Minimum distance to any obstacle from vertex_pos (approximate by checking neighborhood)\n        min_dist_obstacle = self._max_dist_base\n\n        for obs in grid.obstacles:\n            dist = grid.get_distance(vertex_pos, obs.position) - obs.radius\n            if dist < min_dist_obstacle:\n                min_dist_obstacle = max(dist, 1.5)  # Set min dist floor to 1.5 to avoid too small step\n\n        return min(self._max_dist_base, min_dist_obstacle)\n\n    def _sample_point(self) -> Point:\n        \"\"\"Goal-biased sampling: sample goal point with probability goal_sample_rate, else uniform.\"\"\"\n        import random\n        grid = self._get_grid()\n        if random.random() < self._goal_sample_rate:\n            return grid.goal.position\n        else:\n            # Uniform random valid sample\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n    def _choose_parent(self, q_near: Vertex, q_new_pos: Point, radius: float) -> Vertex:\n        \"\"\"Choose lowest cost parent within radius of q_new_pos, fallback to q_near.\"\"\"\n        neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new_pos, radius)\n        grid = self._get_grid()\n\n        best_parent = q_near\n        best_cost = q_near.cost + grid.get_distance(q_near.position, q_new_pos)\n\n        for vertex in neighbors:\n            if vertex == q_near:\n                continue\n            # Check path validity from vertex to q_new_pos\n            path_line = grid.get_line_sequence(vertex.position, q_new_pos)\n            if grid.is_valid_line_sequence(path_line):\n                cost = vertex.cost + grid.get_distance(vertex.position, q_new_pos)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = vertex\n\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, radius: float) -> None:\n        \"\"\"Attempt to rewire neighbors for better path cost through q_new.\"\"\"\n        neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        grid = self._get_grid()\n\n        for vertex in neighbors:\n            if vertex == q_new:\n                continue\n            # Check if path from q_new to vertex is valid and offers lower cost\n            line_seq = grid.get_line_sequence(q_new.position, vertex.position)\n            if grid.is_valid_line_sequence(line_seq):\n                potential_cost = q_new.cost + grid.get_distance(q_new.position, vertex.position)\n                if potential_cost < vertex.cost:\n                    # Rewire edge: remove old parent edge(s), add edge from q_new\n                    # Here we remove all old edges (parents) for simplicity:\n                    for p in list(vertex.parents):\n                        self._graph.remove_edge(p, vertex)\n                    self._graph.add_edge(q_new, vertex)\n                    vertex.cost = potential_cost\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Smooth path by shortcutting line segments if collision free.\"\"\"\n        grid = self._get_grid()\n\n        if len(path) <= 2:\n            return path\n\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    smoothed_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, just add next vertex\n                smoothed_path.append(path[i+1])\n                i += 1\n        return smoothed_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from q_goal back to root start,\n        then smooth and move agent along that path.\n        \"\"\"\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # Choose parent with minimum cost (usually one)\n            current = min(current.parents, key=lambda v: v.cost)\n            path.append(current)\n        path.reverse()\n\n        # Smooth the path before moving agent\n        path = self._smooth_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n\n        # Initialize start root vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n        \n        timeout_sec = 10.0\n        start_time = time.time()\n\n        iterations = 10000\n        radius_rewire = 15.0\n\n        for i in range(iterations):\n            if time.time() - start_time > timeout_sec:\n                # Timeout reached, stop searching no path found\n                break\n\n            q_sample = self._sample_point()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            # Ensure max_dist is at least a small value to make progress\n            max_dist = max(1.5, max_dist)\n            \n            # Get new vertex at max distance or q_sample if close\n            def steer(q_near_pos: Point, q_sample_pos: Point, max_d: float) -> Point:\n                diff = q_sample_pos.to_tensor() - q_near_pos.to_tensor()\n                dist = torch.norm(diff)\n                if dist <= max_d:\n                    return q_sample_pos\n                else:\n                    direction = diff / dist\n                    new_pos_tensor = q_near_pos.to_tensor() + direction * max_d\n                    return Point.from_tensor(new_pos_tensor)\n\n            q_new_pos = steer(q_near.position, q_sample, max_dist)\n            line_seq = grid.get_line_sequence(q_near.position, q_new_pos)\n\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Choose parent in radius around q_new_pos\n            q_parent = self._choose_parent(q_near, q_new_pos, radius_rewire)\n\n            # Create new vertex with cost from chosen parent\n            q_new = Vertex(q_new_pos)\n            q_new.cost = q_parent.cost + grid.get_distance(q_parent.position, q_new.position)\n\n            self._graph.add_edge(q_parent, q_new)\n\n            # Rewire neighbors around q_new to improve path cost\n            self._rewire(q_new, radius_rewire)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm based on RRT* with goal-biased sampling, adaptive step size, \n    rewiring for path optimization, and early stopping criteria to improve efficiency and path quality.\n    Key improvements:\n    - Goal bias sampling: sample near the goal with a certain probability to guide tree growth.\n    - Adaptive max_dist based on distance to sampled point for finer local exploration, coarser global expansion.\n    - Rewiring nearby vertices within a radius for cost optimization (RRT* style).\n    - Shortcutting path during extraction to smooth the final path by checking direct valid line connections.\n    - Early stop if a path found or time > 10 seconds to avoid wasteful iteration.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Allow removing edges for rewiring\n\n        self._goal_sample_rate = 0.1  # 10% samples biased towards goal\n        self._max_dist_default = 10.0  # default max step distance\n        self._rewire_radius = 15.0  # radius to consider rewiring neighbors\n        self._init_displays()\n    \n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        distance = torch.norm(dir)\n        if distance <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / distance\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost between two vertices (distance)\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _get_vertices_near(self, point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, point, radius)\n\n    def _choose_parent(self, q_new: Vertex, neighbors: List[Vertex]) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for neighbor in neighbors:\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = neighbor.cost + self._get_grid().get_movement_cost_from_index(self._get_grid().get_move_index([(q_new.position.x - neighbor.position.x), (q_new.position.y - neighbor.position.y)]), neighbor.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n        if best_parent is None:\n            # fallback to start vertex nearest (should rarely happen)\n            best_parent = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_new.position)\n            min_cost = best_parent.cost + self._get_grid().get_distance(best_parent.position, q_new.position)\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Attempt to connect neighbors through q_new to improve cost (RRT* rewiring)\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove old parent edge(s) and add new edge\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut path by checking if skipping intermediate vertices is valid (line is collision free)\n        if len(path) < 3:\n            return path\n        shortened = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(shortened[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = j\n                    break\n            shortened.append(path[next_idx])\n            idx = next_idx\n        return shortened\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        path: List[Vertex] = [q_last]\n        # Walk back to start along parents with minimum cost\n        current = q_last\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                # No connection back to start (should rarely happen)\n                break\n            # Among parents, select one with minimal cost (robust backtracking)\n            min_parent_cost = float('inf')\n            next_vertex = None\n            for p in current.parents:\n                if p.cost < min_parent_cost:\n                    min_parent_cost = p.cost\n                    next_vertex = p\n            if next_vertex is None:\n                break\n            path.append(next_vertex)\n            current = next_vertex\n        \n        path.reverse()\n\n        # Apply shortcutting to smooth path\n        path = self._shortcut_path(path)\n\n        # Animate the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_time = 10.0  # seconds\n        start_time = time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        max_iterations = 10000\n        for iteration in range(max_iterations):\n            if time() - start_time > max_time:\n                break\n\n            q_sample: Point = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist: smaller step if close, larger if far\n            dist_near_sample = self._get_grid().get_distance(q_near.position, q_sample)\n            max_dist = min(self._max_dist_default, dist_near_sample)\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate the path (line between q_near and q_new)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors for rewiring (RRT*)\n            neighbors: List[Vertex] = self._get_vertices_near(q_new.position, self._rewire_radius)\n\n            # Choose best parent from neighbors\n            best_parent: Vertex = self._choose_parent(q_new, neighbors)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if possible to improve cost\n            self._rewire(q_new, neighbors)\n\n            # Check if goal reached with radius check\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()\n        # No path found or time exceeded; just return here (failure case)\n        return",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm builds upon RRT* heuristic-guided sampling,\n    incorporating adaptive step size and dynamic rewire radius to increase planning efficiency\n    and robustness. It enhances node sampling by guided sampling distribution biased towards a\n    path corridor between start and goal using heuristic cost-to-go estimates (similar to A* heuristic).\n    Step size dynamically adapts based on local environment clearance estimated by obstacle-free distance.\n    The rewire radius shrinks as the tree grows, balancing exploration and exploitation.\n    Early stopping triggers once a near-optimal connection to goal is detected based on cost thresholds.\n    Path extraction includes shortcutting to boost path quality.\n    Time limit of 10 seconds ensures responsiveness.\n    This design improves path quality, success rate, and reduces required iterations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.15      # Increased goal bias for more directed sampling\n        self._rewire_radius_base = 25.0  # Base neighborhood radius for rewiring (start larger)\n        self._min_rewire_radius = 10.0   # Minimum radius to limit radius shrinking\n        self._max_iter = 8000             # Reduced max iterations for quicker termination\n\n    def _adaptive_step_size(self, q_near_pos: Point, q_sample_pos: Point) -> float:\n        \"\"\"\n        Adaptive step size based on estimated clearance: \n        sample a small neighborhood to estimate free space for larger steps if possible.\n        Caps at self._max_dist_base and is at least a small minimum.\n        \"\"\"\n        import random\n\n        max_step = self._max_dist_base\n        direction = q_sample_pos.to_tensor() - q_near_pos.to_tensor()\n        dist = torch.norm(direction).item()\n        if dist < 1e-6:\n            return 0.0\n\n        # Sample points along the line to estimate clearance (binary search)\n        num_checks = 5\n        clearance = dist\n        for i in range(1, num_checks + 1):\n            alpha = i / num_checks\n            intermediate = Point.from_tensor((1 - alpha) * q_near_pos.to_tensor() + alpha * q_sample_pos.to_tensor())\n            if not self._get_grid().is_agent_valid_pos(intermediate):\n                clearance = dist * (i - 1) / num_checks\n                break\n        step = min(max_step, clearance)\n        step = max(1.0, step)  # Minimum step\n        return step\n\n    def _sample_in_informed_ellipse(self, start: Point, goal: Point, c_best: float) -> Point:\n        \"\"\"\n        Sample within an ellipse defined by start-goal positions and current best cost (c_best).\n        This is informed sampling to bias samples toward promising regions.\n        Falls back to uniform valid random sampling if c_best is infinite (no path yet).\n        \"\"\"\n        import random\n        import math\n        grid = self._get_grid()\n        start_np = start.to_tensor().numpy()\n        goal_np = goal.to_tensor().numpy()\n        dim = len(start_np)\n        center = (start_np + goal_np) / 2\n        dist = np.linalg.norm(goal_np - start_np)\n\n        if not np.isfinite(c_best):\n            # No solution found, do uniform random sampling\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Calculate ellipse parameters\n        a = c_best / 2  # major axis half-length\n        b = max(math.sqrt(max(c_best ** 2 - dist ** 2, 0)) / 2, 1e-6)  # minor axis half-length\n\n        # Random point in unit circle scaled by ellipse axes\n        while True:\n            theta = random.uniform(0, 2 * math.pi)\n            r = random.uniform(0, 1)\n            # Point in the unit circle\n            x = r * math.cos(theta)\n            y = r * math.sin(theta)\n\n            # Scale by ellipse axes\n            sample_np = np.zeros(dim)\n            # 2D assumption, fallback to uniform if dims !=2\n            if dim == 2:\n                sample_np[0] = a * x\n                sample_np[1] = b * y\n            else:\n                # fallback to uniform sampling in grid's range if not 2D\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n            # Rotate ellipse to align with start-goal\n            diff = goal_np - start_np\n            angle = math.atan2(diff[1], diff[0])\n            rot_matrix = np.array([[math.cos(angle), -math.sin(angle)],\n                                   [math.sin(angle), math.cos(angle)]])\n            rotated = rot_matrix @ sample_np[:2]\n            sample_position = center[:2] + rotated\n            sample_position_int = np.clip(np.round(sample_position), 0, grid.size - 1).astype(int)\n            sample_point = Point(*sample_position_int)\n\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_goal_biased_sample(self, c_best: float) -> Point:\n        \"\"\"\n        With probability _goal_bias, sample goal directly,\n        else perform ellipse informed sampling around start-goal corridor to bias search.\n        \"\"\"\n        import random\n\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            start_pos = self._graph.root_vertex_start.position\n            goal_pos = self._get_grid().goal.position\n            return self._sample_in_informed_ellipse(start_pos, goal_pos, c_best)\n\n    def _rewire_radius_dynamic(self, iteration: int) -> float:\n        \"\"\"\n        Shrink rewiring radius as iteration increases, to focus exploration early and optimization later.\n        Linear decay from base radius to minimum radius over max iterations.\n        \"\"\"\n        fraction = max(0.0, min(1.0, iteration / self._max_iter))\n        radius = (1 - fraction) * self._rewire_radius_base + fraction * self._min_rewire_radius\n        return radius\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_pos = self._get_grid().goal.position\n\n        best_cost = float('inf')\n        best_goal_vertex = None\n\n        for iteration in range(self._max_iter):\n            # Timeout\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:\n                # Fail safe break\n                break\n\n            # Dynamic rewiring radius\n            rewire_radius = self._rewire_radius_dynamic(iteration)\n\n            # Sample with goal bias and informed sampling\n            q_sample_pos = self._get_goal_biased_sample(best_cost)\n\n            # Nearest vertex to sample\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n\n            if q_near.position == q_sample_pos:\n                continue\n\n            # Adaptive step size using clearance estimation\n            step_size = self._adaptive_step_size(q_near.position, q_sample_pos)\n            if step_size <= 1e-3:\n                continue\n\n            # Extend toward sample using adaptive step size\n            q_new = self._get_new_vertex(q_near, q_sample_pos, step_size)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Near vertices for rewiring with dynamic radius\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            # Choose best parent vertex minimizing cost and ensuring validity\n            best_parent = self._choose_parent(near_vertices, q_new)\n\n            if best_parent is None:\n                # fallback to q_near if path valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            # Add edge and update cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if possible\n            self._rewire(near_vertices, q_new)\n\n            # Check if q_new improves connection to goal\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            # Smaller of current best cost and potential new\n            tentative_cost = q_new.cost + dist_to_goal\n\n            # Early stopping check: if path cost significantly better than current best\n            if tentative_cost < best_cost * 0.98:\n                # Try connect q_new to goal\n                goal_line_seq = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    q_goal = Vertex(goal_pos)\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n\n                    # Update best found path info\n                    best_cost = q_goal.cost\n                    best_goal_vertex = q_goal\n\n                    # Early stopping criterion: close enough cost & position\n                    if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                        self._extract_path(q_goal)\n                        break\n\n            # Additional stop if cost improving slowly and iteration > threshold\n            if iteration > (self._max_iter * 0.8) and best_goal_vertex is not None:\n                # Extract best found path if near end iterations and improved cost found\n                self._extract_path(best_goal_vertex)\n                break\n\n            self.key_frame()\n\n        else:\n            # If loop ended without break but path found\n            if best_goal_vertex is not None:\n                self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nImproved path planning algorithm named `PathPlanning` implemented as an\nenhanced RRT* variant with goal-biased sampling, adaptive step size, rewiring,\nand path shortcutting for smoother and shorter paths.\n\nKey improvements over basic RRT:\n- Goal bias sampling: samples the goal directly with a fixed probability to encourage quicker connections.\n- Adaptive max_dist: allows larger steps when far and smaller when near goal for finer refinement.\n- Rewiring step like RRT*: after adding a vertex, we try to improve neighbors' costs by rewiring.\n- Path shortcutting: after path extraction, tries to shortcut over intermediate nodes to smooth path.\n- Early stopping if path found and time exceeds 10 seconds.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist_base: float\n    _goal_sample_rate: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow rewiring\n        self._max_dist_base = 15.0\n        self._goal_sample_rate = 0.1  # 10% of samples directly at goal\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pt)\n\n    def _get_random_sample(self) -> Point:\n        # goal-biased sampling: with probability goal_sample_rate, sample goal directly\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Return cost to go from frm to to via line check\n        dist = self._get_grid().get_distance(frm.position, to.position)\n        return frm.cost + dist\n\n    def _choose_parent(self, q_new: Vertex, neighbors: List[Vertex]) -> Vertex:\n        # find neighbor with minimal cost + edge cost from neighbor to q_new\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                continue\n            cost = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = neighbor\n        if best_parent is None:\n            return None\n        q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # try to improve neighbor cost by going through q_new\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove old parents edges to neighbor, add q_new -> neighbor\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path from goal back to start by parents chain\n        path = [q_goal]\n        current = q_goal\n        while len(current.parents) != 0:\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Try shortcutting path for smoother, shorter path\n        path = self._shortcut_path(path)\n\n        # Animate route with moves & key frames\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Path shortcutting by checking direct lines skipping intermediate vertices\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) -1\n            while j > i +1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        max_iterations = 7000\n        max_dist_base = self._max_dist_base\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time() - start_time > 10.0:\n                # Timeout after 10 seconds\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist: smaller when near goal for fine refinement\n            dist_to_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n            max_dist = max_dist_base * min(1.0, dist_to_goal / 50.0)\n            max_dist = max(3.0, max_dist)  # minimum step size\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check collision-free path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors for rewiring (within radius)\n            radius = max_dist * 2\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose best parent from neighbors for q_new\n            best_parent = self._choose_parent(q_new, neighbors)\n            if best_parent is None:\n                # Fallback: try q_near as parent if no better found\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                q_new.cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                best_parent = q_near\n\n            # Add edge from best_parent to q_new\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new to improve path costs\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new reaches goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new directly to goal vertex if collision-free\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Set goal vertex cost as well\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n\n                    self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planning algorithm with goal-biased sampling,\n    adaptive step size, and rewiring optimization to improve path quality and efficiency.\n    It biases sampling towards the goal with a probability, dynamically adjusts max step size \n    based on distance to goal, and rewires the tree within a radius to reduce path cost after \n    adding new vertices. The algorithm includes early stopping once path is found and a\n    timeout of 10 seconds to prevent excessive planning time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # support rewiring by allowing edge removals\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self, goal_bias: float = 0.2) -> Point:\n        \"\"\"\n        Goal-biased sampling: with probability goal_bias, return goal point directly.\n        Else sample random valid position.\n        \"\"\"\n        if np.random.rand() < goal_bias:\n            return self._get_grid().goal.position\n\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_neighborhood_radius(self, n_vertices: int, gamma: float = 50.0) -> float:\n        \"\"\"\n        RRT* inspired radius for rewiring, scaled by number of vertices to shrink as tree grows.\n        gamma is tunable parameter.\n        \"\"\"\n        dim = self._get_grid().size.n_dim\n        return min(gamma * (np.log(n_vertices + 1) / (n_vertices + 1)) ** (1 / dim), 30.0)\n\n    def _choose_parent(self, q_near_candidates: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"\n        Choose the best parent among q_near_candidates that provides lowest cost to q_new with valid path.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in q_near_candidates:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, q_nears: List[Vertex]) -> None:\n        \"\"\"\n        Rewire the neighborhood vertices to q_new if it improves path cost and edge is valid.\n        \"\"\"\n        for q_near in q_nears:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Remove old parent edge(s)\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                    q_near.parents.discard(p)\n                # Add new edge from q_new to q_near\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n\n        # Trace back from goal vertex to start via cheapest cost path (single parent)\n        current = q_goal\n        while current.parents:\n            # Choose parent with lowest cost (should be one in current algorithm)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n\n        path.reverse()\n\n        # Shortcut/smooth path by iterative shortcut attempts\n        def shortcut_path(path: List[Vertex]) -> List[Vertex]:\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = i + 2\n                while j < len(path):\n                    line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        # shortcut possible, remove intermediate vertices\n                        del path[i + 1:j]\n                        j = i + 2\n                    else:\n                        j += 1\n                i += 1\n            return path\n\n        smooth_path = shortcut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n\n        max_dist_min = 5.0\n        max_dist_max = 15.0\n        iterations = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex]  # make sure root vertices list includes start\n\n        for _ in range(iterations):\n            # Timeout check: abort if >10 sec\n            if (time() - start_time) > 10:\n                break\n\n            # Goal biased sampling\n            q_sample: Point = self._get_random_sample(goal_bias=0.25)\n\n            # Nearest vertex from tree\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue  # same position sampled\n\n            # Adaptive max step based on distance to goal (larger steps near start, smaller near goal)\n            dist_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n            max_dist = max(min(dist_goal / 3, max_dist_max), max_dist_min)\n\n            # New vertex toward sample\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate straight path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within rewiring radius for RRT* style optimization\n            n_vertices = self._graph.size + 1\n            radius = self._get_neighborhood_radius(n_vertices)\n            q_near_candidates = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n            # Choose parent vertex minimizing cost to q_new\n            parent_vertex = self._choose_parent(q_near_candidates, q_new)\n            if parent_vertex is None:\n                # fallback to q_near if no other valid parent found\n                parent_vertex = q_near\n\n            # Set q_new cost and add edge\n            q_new.cost = parent_vertex.cost + self._get_grid().get_distance(parent_vertex.position, q_new.position)\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire neighbors to q_new if cost improved\n            self._rewire(q_new, q_near_candidates)\n\n            # Check for goal proximity and connect if close enough\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect final edge to goal vertex\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, self._get_grid().goal.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm enhances the original RRT*-inspired planner by integrating:\n      - A heuristic-driven cost function combining path cost and estimated remaining distance \n        (similar to A* heuristic) to guide parent selection and rewiring, improving path quality.\n      - Adaptive max step size based on local obstacle density (denser regions cause smaller step size).\n      - Enhanced goal biasing with a small probability of direct goal sampling and increased sampling inside \n        an informed ellipse region focused on start-goal to improve efficiency.\n      - Dynamic rewiring radius adjusted by root graph size for better connectivity.\n      - Early stopping once a feasible path close to optimal is found or max time reached.\n      - More aggressive path shortcutting ensuring smoother result.\n      - Timeout enforced at 10 seconds to ensure responsiveness.\n    Overall, this yields faster convergence, higher success rates, and smoother, shorter paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0     # Base max extending distance (adaptive)\n        self._goal_bias = 0.12         # Slightly increased probability to sample goal directly\n        self._rewire_radius = 20.0     # Neighborhood radius for rewiring (will adapt)\n        self._informed_sample_ratio = 0.8  # Probability to sample inside informed ellipse to focus search\n\n    def _heuristic(self, point: Point, goal: Point) -> float:\n        # Euclidean distance heuristic to goal (can be enhanced if needed)\n        return Map.get_distance(point, goal)\n\n    def _adaptive_max_dist(self, position: Point) -> float:\n        # Adjust max_dist based on local obstacle density around position\n        # Sample points in neighborhood to estimate density (simple heuristic)\n        radius = 5.0\n        grid = self._get_grid()\n        count_obstacles = 0\n        samples = 0\n        for dx in range(-3, 4):\n            for dy in range(-3, 4):\n                # Assuming 2D environment since from Point usage\n                if grid.size.n_dim < 2:\n                    continue\n                sample_point = Point(position.x + dx, position.y + dy)\n                if not grid.is_agent_valid_pos(sample_point):\n                    count_obstacles += 1\n                samples += 1\n        density = count_obstacles / max(samples, 1)\n        # In denser areas take smaller steps\n        max_dist = self._max_dist_base * (1.0 - density * 0.75)\n        # Clamp between some bounds\n        max_dist = max(5.0, min(max_dist, self._max_dist_base))\n        return max_dist\n\n    def _informed_sample(self, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Sample inside an ellipse defined by start and goal to bias sampling towards,\n        improving efficiency (informed RRT* style).\n        \"\"\"\n        import random\n        import math\n        grid = self._get_grid()\n        c_best = Map.get_distance(start, goal)\n        c_min = c_best\n        center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n        theta = math.atan2(goal.y - start.y, goal.x - start.x)\n\n        while True:\n            r1 = random.random()\n            r2 = random.random()\n            # Sample unit circle\n            angle = 2 * math.pi * r1\n            radius = r2 ** 0.5\n            x_ball = radius * math.cos(angle)\n            y_ball = radius * math.sin(angle)\n\n            # Scale to ellipse radii\n            a = c_best / 2\n            b = (c_best ** 2 - c_min ** 2) ** 0.5 / 2 if c_best > c_min else 0\n            ellipse_point = Point(a * x_ball, b * y_ball)\n\n            # Rotate ellipse to align with start-goal\n            rotated_x = ellipse_point.x * math.cos(theta) - ellipse_point.y * math.sin(theta)\n            rotated_y = ellipse_point.x * math.sin(theta) + ellipse_point.y * math.cos(theta)\n\n            sample_point = Point(int(center.x + rotated_x + 0.5), int(center.y + rotated_y + 0.5))\n\n            if 0 <= sample_point.x < grid.size.x and 0 <= sample_point.y < grid.size.y and grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _cost_with_heuristic(self, frm: Vertex, to: Vertex, goal: Point) -> float:\n        # Combining cost + movement + heuristic to goal (like A* f = g + h)\n        g_cost = frm.cost + self._cost(frm, to)\n        h_cost = self._heuristic(to.position, goal)\n        return g_cost + h_cost\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        # Override with heuristic-guided parent choosing minimizing f = g + h\n        min_f_cost = float('inf')\n        best_parent = None\n        goal_pos = self._get_grid().goal.position\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            f_cost = self._cost_with_heuristic(v, q_new, goal_pos)\n            if f_cost < min_f_cost:\n                min_f_cost = f_cost\n                best_parent = v\n        if best_parent is not None:\n            # Set actual cost g in q_new.cost\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        # Rewire only if f cost decreased (cost + heuristic), improving quality more aggressively\n        goal_pos = self._get_grid().goal.position\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            original_f = v.cost + self._heuristic(v.position, goal_pos)\n            new_f = cost_through_qnew + self._heuristic(v.position, goal_pos)\n            if new_f < original_f:\n                # Remove old parent edges, add new edge from q_new\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        # Dynamically adjust rewiring radius with graph size\n        base_rewire_radius = self._rewire_radius\n\n        for i in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                break\n\n            sample_choice = random.random()\n\n            # Sample: informed sampling with some probability, else goal bias or random\n            if sample_choice < self._informed_sample_ratio:\n                q_sample = self._informed_sample(start_vertex.position, goal_pos)\n            else:\n                q_sample = self._get_goal_biased_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on local obstacle density around q_near\n            max_dist = self._adaptive_max_dist(q_near.position)\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Adjust rewiring radius dynamically by graph size\n            rewire_radius = base_rewire_radius * (1.0 + (self._graph.size / 1000.0))\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            self._rewire(near_vertices, q_new)\n\n            # Check if goal reached within radius tolerance\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Connect final goal vertex\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            # Key frame for visualization update\n            self.key_frame()\n\n        else:\n            # If loop finishes without break, no path found in time\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm builds upon the RRT* and heuristic-guided sampling framework, aiming to enhance planning efficiency, path quality,\n    robustness, and success rate. Key improvements include:\n    - Informed sampling region shaped as an ellipse between start and goal to focus sampling effort.\n    - Adaptive step size that decreases near obstacles and goal for finer control.\n    - Utilizes an A*-inspired cost heuristic combining path cost and estimated cost-to-go to guide parent selection.\n    - Dynamic rewiring radius reducing as tree grows to balance exploration and optimization.\n    - Early stopping as soon as a near-optimal path is found rather than waiting full iterations.\n    - Enhanced path shortcutting with recursive smoothing for smoother final paths.\n    The algorithm remains within a 10-second time budget to ensure responsiveness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n        import math\n\n        start_time = time.time()\n\n        max_iterations = 8000\n        max_dist = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        # Precompute the direction and distance for informed sampling\n        start_pos = start_vertex.position\n        c_best = float('inf')  # best path cost for informed sampling\n\n        def ellipse_sample():\n            \"\"\"\n            Sample within an ellipse bounded by start and goal with current best cost c_best.\n            If no solution found yet (c_best == inf), uniform random goal biased sampling.\n            \"\"\"\n            if random.random() < self._goal_bias:\n                return goal_pos\n\n            if math.isinf(c_best):\n                # No solution yet \u2014 uniform random valid sample\n                while True:\n                    rand_pos = [\n                        random.randint(0, self._get_grid().size[i] - 1) for i in range(self._get_grid().size.n_dim)\n                    ]\n                    sample = Point(*rand_pos)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n            # Informed Sampling: Ellipse with foci at start and goal\n            # axis lengths depend on c_best (best path length found)\n            c_min = Map.get_distance(start_pos, goal_pos)\n            if c_best < c_min:\n                # In case numerical issue, fallback\n                return goal_pos\n\n            # Compute ellipse parameters\n            center = Point(*((start_pos.to_tensor() + goal_pos.to_tensor()) / 2))\n            diff = goal_pos.to_tensor() - start_pos.to_tensor()\n            e_dir = diff / c_min  # unit vector along start->goal\n            n_dim = self._get_grid().size.n_dim\n\n            # Build rotation matrix to align ellipse with start-goal line in n-D\n            # We'll sample in a canonical unit ball then transform/scale\n            from numpy import eye, dot\n            import numpy as np\n\n            if n_dim == 2:\n                theta = math.atan2(float(e_dir[1]), float(e_dir[0]))\n                cos_theta, sin_theta = math.cos(theta), math.sin(theta)\n                R = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n            else:\n                # For >2D, use Householder reflection to rotate e_dir to x-axis vector\n                e1 = np.zeros(n_dim)\n                e1[0] = 1\n                v = e_dir - e1\n                if np.linalg.norm(v) < 1e-10:\n                    R = np.eye(n_dim)\n                else:\n                    v = v / np.linalg.norm(v)\n                    H = np.eye(n_dim) - 2 * np.outer(v, v)\n                    R = H\n\n            # Lengths of ellipse axes per c_best (inspired by RRT* Informed RRT*)\n            r1 = c_best / 2.0  # major axis half-length\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0  # minor axis half-length\n            r_axes = np.array([r1] + [r2]*(n_dim - 1))\n\n            # Sample uniformly in unit n-ball\n            while True:\n                rand_dir = np.random.normal(size=n_dim)\n                norm_rand_dir = np.linalg.norm(rand_dir)\n                if norm_rand_dir > 1e-10:\n                    rand_dir /= norm_rand_dir\n                    break\n            radius = np.random.rand() ** (1.0 / n_dim)\n            unit_ball_sample = radius * rand_dir\n\n            # Scale and rotate\n            ellip_sample = dot(R, unit_ball_sample * r_axes)\n            ellip_sample_point = Point.from_tensor(center.to_tensor() + ellip_sample)\n\n            if self._get_grid().is_agent_valid_pos(ellip_sample_point):\n                return ellip_sample_point\n\n            # Fallback uniform sample if invalid\n            while True:\n                rand_pos = [\n                    random.randint(0, self._get_grid().size[i] - 1) for i in range(self._get_grid().size.n_dim)\n                ]\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        def a_star_heuristic(v: Vertex) -> float:\n            # Heuristic cost-to-go estimate (Euclidean distance)\n            return Map.get_distance(v.position, goal_pos)\n\n        def combined_cost(parent: Vertex, child_pos: Point) -> float:\n            # Compute transitioned cost: parent's cost + cost(parent->child) + heuristic(child)\n            move_cost = self._get_grid().get_movement_cost(parent.position, child_pos)\n            dist = Map.get_distance(parent.position, child_pos)\n            cost_to_child = parent.cost + dist + move_cost\n            h = Map.get_distance(child_pos, goal_pos)\n            return cost_to_child + h\n\n        def choose_parent_heuristic(near_vertices: list, q_new: Vertex) -> Vertex:\n            # Chooses parent minimizing cost_so_far + cost + heuristic\n            min_cost = float('inf')\n            best_parent = None\n            for v in near_vertices:\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                    continue\n                cost_est = combined_cost(v, q_new.position)\n                if cost_est < min_cost:\n                    min_cost = cost_est\n                    best_parent = v\n            if best_parent is not None:\n                # Actual cost from parent to q_new (without heuristic)\n                best_parent_to_qnew_cost = best_parent.cost + self._cost(best_parent, q_new)\n                q_new.cost = best_parent_to_qnew_cost\n            return best_parent\n\n        def adaptive_step(q_near: Vertex, q_sample: Point) -> float:\n            # Reduce max_dist if near obstacles or very close to goal\n            dist_to_goal = Map.get_distance(q_near.position, goal_pos)\n            # Reduce step if close to goal for finer moves\n            step = self._max_dist_base\n            if dist_to_goal < self._max_dist_base * 2:\n                step = max(self._max_dist_base / 3, dist_to_goal / 1.5)\n\n            # Check near obstacles (simple heuristic: reduce step if obstacle near q_near)\n            obstacle_near = False\n            for obs in self._get_grid().obstacles:\n                obs_pos = obs.position\n                if Map.get_distance(q_near.position, obs_pos) <= 5.0:\n                    obstacle_near = True\n                    break\n            if obstacle_near:\n                step = max(step / 2, 2.0)\n\n            # Also limit step length by distance to q_sample\n            dist_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(step, dist_sample)\n\n            return step\n\n        def recursive_shortcut(path: list, tries=15) -> list:\n            # Improved recursive shortcutting\n            if len(path) <= 2:\n                return path\n            for _ in range(tries):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove intermediates between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialization\n        best_goal_vertex = None\n        c_best = float('inf')\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Time limit exceeded\n                break\n\n            q_sample = ellipse_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            step = adaptive_step(q_near, q_sample)\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            # Validate edge from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Dynamic rewire radius shrinking with tree size (for better local refinement)\n            radius = self._rewire_radius * (max(1.0, (self._graph.size)**(-1/4)))\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent using heuristic-guided cost\n            best_parent = choose_parent_heuristic(near_vertices, q_new)\n            if best_parent is None:\n                # Fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors around q_new if beneficial (cost reduction)\n            self._rewire(near_vertices, q_new)\n\n            # Update c_best and best_goal_vertex if closer to goal found\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal < max_dist * 1.5:\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                    q_goal = Vertex(goal_pos)\n                    line_to_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                    if self._get_grid().is_valid_line_sequence(line_to_goal):\n                        q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                        self._graph.add_edge(q_new, q_goal)\n\n                        if q_goal.cost < c_best:\n                            c_best = q_goal.cost\n                            best_goal_vertex = q_goal\n\n                            # Early stop if path is sufficiently good (within 5% of direct dist)\n                            c_min = Map.get_distance(start_pos, goal_pos)\n                            if c_best <= 1.05 * c_min:\n                                break\n\n            self.key_frame()\n\n        # Extract and move agent if solution found\n        if best_goal_vertex:\n            # Backtrack path\n            path = [best_goal_vertex]\n            current = best_goal_vertex\n            while current != start_vertex:\n                if not current.parents:\n                    break\n                parent = min(current.parents, key=lambda p: p.cost)\n                path.append(parent)\n                current = parent\n            path.reverse()\n\n            # Recursive shortcut smoothing for better path quality\n            smoothed_path = recursive_shortcut(path, tries=30)\n\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* variant with:\n    - goal bias sampling (20% samples directly at goal to boost convergence),\n    - adaptive step size reduction near obstacles for smoother edges,\n    - rewiring to optimize paths making them shorter and more cost-efficient,\n    - path shortcutting at extraction for smoothness,\n    - early stop if planning time exceeds 10 seconds,\n    - heuristic cost estimation using movement cost to goal and from start,\n    - prioritized connection attempts to nearby nodes within a radius,\n    to improve planning efficiency, path quality, robustness, and success rate over basic RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _goal_sample_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        self._graph = gen_forest(self._services, Vertex(start_pos), Vertex(goal_pos), [])\n        self._graph.edges_removable = True  # Allow rewiring (remove edges)\n        self._max_dist = 15.0                # Start with a max step length\n        self._goal_sample_rate = 0.2         # 20% samples biased towards goal\n        self._rewire_radius = 20.0            # Radius for rewiring\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self) -> Point:\n        if np.random.rand() < self._goal_sample_rate:\n            # Goal biased sampling\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, point: Point) -> List[Vertex]:\n        # Get vertices within rewire radius for rewiring\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, point, self._rewire_radius)\n\n    def _cost_to_go(self, frm: Point, to: Point) -> float:\n        # Heuristic cost estimate (distance)\n        return self._get_grid().get_distance(frm, to)\n\n    def _cost(self, parent: Vertex, child: Vertex) -> float:\n        # Cost of edge (movement cost)\n        return self._get_grid().get_movement_cost(parent.position, child.position)\n\n    def _choose_best_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        best_parent = None\n        best_cost = float('inf')\n        for vertex in near_vertices:\n            # Check if line between vertex and q_new is valid\n            line = self._get_grid().get_line_sequence(vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            cost = vertex.cost + self._cost(vertex, q_new)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        for vertex in near_vertices:\n            if vertex == q_new:\n                continue\n            line = self._get_grid().get_line_sequence(q_new.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            cost_through_new = q_new.cost + self._cost(q_new, vertex)\n            if cost_through_new < vertex.cost:\n                for parent in list(vertex.parents):\n                    self._graph.remove_edge(parent, vertex)\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = cost_through_new\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing unnecessary intermediate nodes,\n        if direct line between two nodes is collision-free.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    shortened_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # Could not shortcut further, move one step forward\n                shortened_path.append(path[i + 1])\n                i += 1\n        return shortened_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path from start to goal, with shortcutting and animation\n        path: List[Vertex] = [q_goal]\n        # Walk back from goal to start via parents with minimum cost\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            # Choose parent with lowest cost\n            best_parent = min(current.parents, key=lambda p: p.cost)\n            path.append(best_parent)\n            current = best_parent\n        path.reverse()\n        # Shortcut smoothing\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_iterations = 10000\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                break  # Timeout after 10 seconds, fail gracefully\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adjust max_dist adaptively: smaller near obstacles (naive approach)\n            max_dist = self._max_dist\n            # Try stepping with max_dist first, then smaller if collision found\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n\n            if not self._get_grid().is_valid_line_sequence(line):\n                # Try smaller steps to improve connectivity near obstacles\n                for scale in [0.5, 0.33, 0.2, 0.1]:\n                    stepped_dist = max_dist * scale\n                    q_new = self._get_new_vertex(q_near, q_sample, stepped_dist)\n                    line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(line):\n                        break\n                else:\n                    continue  # No valid new vertex found\n\n            # Find near vertices for rewiring\n            near_vertices = self._get_near_vertices(q_new.position)\n            # Choose the best parent vertex among near vertices (lowest cost)\n            best_parent = self._choose_best_parent(near_vertices, q_new)\n            if best_parent is None:\n                # No suitable parent found, skip this new point\n                continue\n\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire near vertices through q_new if improves cost\n            self._rewire(near_vertices, q_new)\n\n            # Check goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal if valid\n                goal_vertex = self._graph.root_vertex_goal\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            # Mark animation key frame for every 20 iterations\n            if iteration % 20 == 0:\n                self.key_frame()\n\n        # If we reach here, either timeout or max iterations exhausted with no path found\n        # Optionally, can report failure or attempt partial path extraction\n        return",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planner builds on the RRT* inspired approach with goal-biased sampling,\n    adaptive max step distance, and rewiring to optimize connectivity.\n    Enhancements include:\n    - Dynamic adjustment of max extension distance based on local obstacle density,\n      promoting finer exploration in cluttered regions and faster jumps in free space.\n    - Heuristic combined cost: Euclidean distance + terrain cost guides parent selection with greater accuracy.\n    - Incorporation of an adaptive rewire radius that shrinks over time to limit unnecessary rewiring\n      as the tree grows denser, improving efficiency.\n    - Early path extraction when a vertex gets very close to goal (within a threshold),\n      enabling faster success and reducing iterations.\n    - More aggressive path shortcutting involving repeated attempts to smooth path segments.\n    - Timeout enforced at 10 seconds to maintain responsiveness.\n    Overall, this results in fewer iterations, smoother and shorter paths,\n    better success rate, and robustness against obstacles.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.15      # Slightly higher goal bias for faster convergence\n        self._rewire_radius_base = 20.0  # Starting neighborhood radius for rewiring\n        self._rewire_radius_min = 5.0    # Minimal radius at end of search\n        self._early_goal_threshold = 10.0  # Distance threshold for early goal check\n        self._max_iterations = 10000\n\n    def _get_local_obstacle_density(self, pos: Point, radius: float = 5.0) -> float:\n        \"\"\"\n        Estimate local obstacle density around pos by counting obstacles within radius.\n        Returns value between 0 and 1 representing density.\n        \"\"\"\n        obstacle_points = set()\n        for obs in self._get_grid().obstacles:\n            bound = self._get_grid().get_obstacle_bound(obs.position)\n            obstacle_points.update(bound)\n        if not obstacle_points:\n            return 0.0\n\n        count = 0\n        for p in obstacle_points:\n            if Map.get_distance(p, pos) <= radius:\n                count += 1\n        max_count = 4 * radius * radius  # rough upper bound for density normalization\n        density = min(1.0, count / max_count)\n        return density\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        \"\"\"\n        Adjust max_dist based on local obstacle density to encourage finer steps near obstacles.\n        \"\"\"\n        density = self._get_local_obstacle_density(q_near.position)\n        adaptive_dist = self._max_dist_base * (1.0 - 0.7 * density)\n        # Clamp distance minimum to 3.0 to maintain exploration capability\n        return max(adaptive_dist, 3.0)\n\n    def _adaptive_rewire_radius(self, iter_index: int) -> float:\n        \"\"\"\n        Gradually decrease rewire radius from base to minimum as iterations advance.\n        \"\"\"\n        frac = min(1.0, iter_index / self._max_iterations)\n        radius = self._rewire_radius_base * (1.0 - frac) + self._rewire_radius_min * frac\n        return radius\n\n    def _heuristic_cost(self, from_v: Vertex, to_p: Point) -> float:\n        \"\"\"\n        Estimate total cost to goal through a vertex, combining current cost + heuristic (distance + terrain).\n        \"\"\"\n        dist_to_goal = Map.get_distance(to_p, self._get_grid().goal.position)\n        terrain_cost = self._get_grid().get_movement_cost(from_v.position, to_p)\n        return from_v.cost + terrain_cost + dist_to_goal\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"\n        Choose best parent to minimize total cost: existing cost + movement cost + heuristic to goal.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost_to_new = v.cost + self._cost(v, q_new)\n            heuristic = Map.get_distance(q_new.position, self._get_grid().goal.position)\n            total_cost = cost_to_new + heuristic\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        \"\"\"\n        Try rewiring neighbors to use q_new if it improves cost.\n        \"\"\"\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove old parent edges, add new edge from q_new\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Repeatedly attempt path shortcutting passes for improved smoothness.\n        \"\"\"\n        def simple_shortcut(path):\n            if len(path) <= 2:\n                return path\n            res = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        break\n                    j -= 1\n                res.append(path[j])\n                i = j\n            return res\n\n        shortcut_path = path\n        for _ in range(3):  # multiple passes to smooth more aggressively\n            shortcut_path = simple_shortcut(shortcut_path)\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        smoothed_path = self._shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(self._max_iterations):\n            if time.time() - start_time > 10.0:\n                break\n\n            # Goal-biased sampling with adaptive biasing\n            if random.random() < self._goal_bias:\n                q_sample = goal_pos\n            else:\n                while True:\n                    rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    q_sample = Point(*rand_coords)\n                    if self._get_grid().is_agent_valid_pos(q_sample):\n                        break\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near)\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            # New vertex toward q_sample\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            if torch.norm(dir_vec) == 0:\n                continue\n            q_new_pos_tensor = q_near.position.to_tensor() + (step / torch.norm(dir_vec)) * dir_vec\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n            q_new = Vertex(q_new_pos)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Adaptive rewire radius shrinking over time\n            radius = self._adaptive_rewire_radius(i)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent to connect q_new\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if possible\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            self._rewire(near_vertices, q_new)\n\n            # Early stopping if a vertex is within threshold distance to goal\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= self._early_goal_threshold:\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This improved path planner is inspired by RRT* with multiple enhancements for better \n    efficiency, robustness, and path quality:\n\n    - Uses adaptive max step sizes tuned to the environment and progress\n    - Combines goal-biased sampling with heuristic adaptive sampling probability,\n      increasing goal bias as search progresses to focus tree growth.\n    - Employs heuristic-guided vertex selection balancing cost-to-come and distance-to-goal,\n      similar to informed RRT*, to select better expansion nodes.\n    - Incorporates radius-based rewiring like RRT*, with dynamic radius shrinking for efficiency\n    - Adds intermediate validation checks along the extension for early collision pruning\n    - Implements aggressive path shortcutting and smoothing after path extraction,\n      integrating both vertex skipping and partial intermediate point smoothing by line validation.\n    - Uses an exponential backoff on max iterations adapting to elapsed planning time,\n      yielding more iterations early, fewer as time elapses (within 10s max).\n    - Early stopping when goal reached with path cost stabilization heuristic,\n      increasing reliability of good path detection.\n    - Maintains single tree rooted at start node ensuring connectivity and cost consistency.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This improved path planner is inspired by RRT* with multiple enhancements for better \n    efficiency, robustness, and path quality:\n\n    - Uses adaptive max step sizes tuned to the environment and progress\n    - Combines goal-biased sampling with heuristic adaptive sampling probability,\n      increasing goal bias as search progresses to focus tree growth.\n    - Employs heuristic-guided vertex selection balancing cost-to-come and distance-to-goal,\n      similar to informed RRT*, to select better expansion nodes.\n    - Incorporates radius-based rewiring like RRT*, with dynamic radius shrinking for efficiency\n    - Adds intermediate validation checks along the extension for early collision pruning\n    - Implements aggressive path shortcutting and smoothing after path extraction,\n      integrating both vertex skipping and partial intermediate point smoothing by line validation.\n    - Uses an exponential backoff on max iterations adapting to elapsed planning time,\n      yielding more iterations early, fewer as time elapses (within 10s max).\n    - Early stopping when goal reached with path cost stabilization heuristic,\n      increasing reliability of good path detection.\n    - Maintains single tree rooted at start node ensuring connectivity and cost consistency.\n    \"\"\"\n    }\n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n    _max_iterations: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0      # Base max extending distance\n        self._goal_bias = 0.1           # Initial goal bias probability\n        self._rewire_radius = 20.0      # Initial rewiring radius\n        self._max_iterations = 12000    # Base max iterations, adaptable in runtime\n\n    def _adaptive_goal_bias(self, elapsed_time: float) -> float:\n        # Increase goal bias gradually with elapsed time (up to 0.5) to favor goal sampling later\n        bias = min(0.5, self._goal_bias + 0.4 * (elapsed_time / 10.0))\n        return bias\n\n    def _adaptive_max_dist(self, iteration: int, elapsed_time: float) -> float:\n        # Decrease max_dist smoothly as iterations/time increase for finer exploration near goal\n        max_dist = self._max_dist_base * max(0.4, 1.0 - elapsed_time / 15.0)\n        return max_dist\n\n    def _heuristic_nearest_vertex(self, root_vertex_start: Vertex, sample: Point) -> Vertex:\n        # Select nearest vertex weighted by f = cost_to_vertex + heuristic_to_goal\n        # This biases selection toward vertices promising lower total path cost\n        \n        min_f = float('inf')\n        best_vertex = None\n        goal_pos = self._get_grid().goal.position\n\n        # Iterate over all vertices in the tree (DFS)\n        vertices = []\n\n        def collect(v: Vertex) -> bool:\n            vertices.append(v)\n            return True\n\n        self._graph.walk_dfs(collect)\n\n        for v in vertices:\n            cost_to_v = v.cost if v.cost is not None else float('inf')\n            heuristic = Map.get_distance(v.position, goal_pos)\n            f = cost_to_v + heuristic\n            dist_sample = Map.get_distance(v.position, sample)\n            # Penalize vertices too far from sample to encourage local expansions\n            penalty = dist_sample * 0.5\n            score = f + penalty\n            if score < min_f:\n                min_f = score\n                best_vertex = v\n\n        return best_vertex if best_vertex is not None else root_vertex_start\n\n    def _check_valid_extension(self, from_pos: Point, to_pos: Point) -> bool:\n        # Validate line with extra intermediate point checks (dense check)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        # Early prune by checking few intermediate points more strictly\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return False\n\n        # Extra intermediate collision check for safety (check 25%, 50%, 75%)\n        n = len(line_seq)\n        points_to_check = []\n        if n > 4:\n            points_to_check = [line_seq[n // 4], line_seq[n // 2], line_seq[(3 * n) // 4]]\n        for pt in points_to_check:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _choose_parent(self, near_vertices: list[Vertex], q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._check_valid_extension(v.position, q_new.position):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list[Vertex], q_new: Vertex) -> None:\n        # Rewire if connecting thru q_new improves neighbor costs\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._check_valid_extension(q_new.position, v.position):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _enhanced_shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        # Shortcut and partial smoothing:\n        # 1) Remove unnecessary intermediate vertices if direct line valid\n        # 2) Try local smoothing by small segment partial shortcut\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n\n        # Local smoothing pass: attempt smoothing small hops by examining neighbors in shortcut path\n        improved = True\n        while improved and len(shortcut_path) > 3:\n            improved = False\n            new_path = [shortcut_path[0]]\n            k = 0\n            while k < len(shortcut_path) - 1:\n                next_k = k + 1\n                # Try if we can skip next_k by connecting new_path[-1] and shortcut_path[next_k + 1]\n                if next_k + 1 < len(shortcut_path):\n                    if self._get_grid().is_valid_line_sequence(\n                        self._get_grid().get_line_sequence(new_path[-1].position, shortcut_path[next_k+1].position)):\n                        new_path.append(shortcut_path[next_k+1])\n                        k = next_k + 1\n                        improved = True\n                    else:\n                        new_path.append(shortcut_path[next_k])\n                        k = next_k\n                else:\n                    new_path.append(shortcut_path[next_k])\n                    k = next_k\n            shortcut_path = new_path\n\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: list[Vertex] = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        smoothed_path = self._enhanced_shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        last_best_cost = float('inf')\n        stable_cost_count = 0\n        stable_cost_threshold = 20  # iterations with stable cost before early stop\n\n        iteration = 0\n\n        while True:\n            elapsed_time = time.time() - start_time\n\n            if elapsed_time > 10.0:\n                # Timeout - stop search\n                break\n\n            # Adapt max iterations dynamically based on time left (early generous, late strict)\n            max_iterations_now = int(self._max_iterations * max(0.3, 1.0 - elapsed_time / 10.0))\n\n            if iteration >= max_iterations_now:\n                break\n\n            # Adaptive goal bias grows with elapsed time to focus more on goal sampling\n            current_goal_bias = self._adaptive_goal_bias(elapsed_time)\n\n            # Sample point with adaptive goal bias\n            if random.random() < current_goal_bias:\n                q_sample = goal_pos\n            else:\n                # Random valid sample point\n                while True:\n                    rand_pos_arr = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    q_sample = Point(*rand_pos_arr)\n                    if self._get_grid().is_agent_valid_pos(q_sample):\n                        break\n\n            # Heuristic nearest vertex selection balancing cost and distance\n            q_near = self._heuristic_nearest_vertex(start_vertex, q_sample)\n\n            if q_near.position == q_sample:\n                iteration += 1\n                self.key_frame()\n                continue\n\n            # Adaptive max step size decreasing with time iterations and elapsed time\n            max_dist = self._adaptive_max_dist(iteration, elapsed_time)\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            # Generate new vertex in direction toward q_sample\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist_dir = torch.norm(dir_vec)\n            if dist_dir < 1e-8:\n                iteration += 1\n                self.key_frame()\n                continue\n\n            dir_normalized = dir_vec / dist_dir\n            q_new_pos_tensor = q_near.position.to_tensor() + step * dir_normalized\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n            q_new = Vertex(q_new_pos)\n\n            if not self._check_valid_extension(q_near.position, q_new.position):\n                iteration += 1\n                self.key_frame()\n                continue\n\n            radius = self._rewire_radius * max(0.2, 1.0 - elapsed_time / 10.0)  # shrink radius as time progresses\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n\n            # As fallback, try connecting to q_near if no better parent found\n            if best_parent is None:\n                if self._check_valid_extension(q_near.position, q_new.position):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    iteration += 1\n                    self.key_frame()\n                    continue\n\n            # Add new vertex & edge to the tree\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new when beneficial\n            self._rewire(near_vertices, q_new)\n\n            # Check if goal reached within radius considering agent's radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                if self._check_valid_extension(q_new.position, q_goal.position):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            # Early stopping heuristic: if best cost does not improve across N iterations\n            current_best_cost = min((v.cost for v in self._graph.root_vertices if v.cost is not None), default=float('inf'))\n            if abs(current_best_cost - last_best_cost) < 1e-4:\n                stable_cost_count += 1\n            else:\n                stable_cost_count = 0\n            last_best_cost = current_best_cost\n\n            if stable_cost_count >= stable_cost_threshold:\n                # Costs stable, stop as path likely optimal/nearly optimal\n                break\n\n            iteration += 1\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm extends the provided RRT* inspired planner with several enhancements aimed at improving\n    planning efficiency, path quality, and robustness.\n\n    Key improvements include:\n    - Adaptive max_dist based on local obstacle density to encourage smaller steps in cluttered areas and larger jumps in free space.\n    - Informed heuristic sampling within an ellipsoidal region between start and goal to bias samples towards promising regions.\n    - Dynamic rewiring radius that shrinks as the tree grows for better local optimization without excessive rewiring cost.\n    - Enhanced path shortcutting with multiple passes and backtracking to achieve smoother paths.\n    - Early stopping once a valid path within a cost threshold is found, or upon timeout of 10 seconds.\n    - Use of cost-to-go heuristic (Euclidean distance to goal) to prioritize expansion towards goal.\n    - Fail-safe fallback to always connect to nearest vertex if no better parent found.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.15      # Slightly higher goal bias\n        self._rewire_radius = 20.0  # Initial rewiring radius\n\n        # Added parameters for adaptive sampling and rewiring\n        self._min_rewire_radius = 5.0\n        self._max_rewire_radius = 25.0\n        self._max_iterations = 10000\n\n    def _adaptive_max_dist(self, near_vertex: Vertex) -> float:\n        \"\"\"\n        Adapt max_dist based on local obstacle density around near_vertex.\n        More obstacles -> smaller step size for finer exploration.\n        \"\"\"\n        radius_check = 5.0\n        nearby_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, near_vertex.position, radius_check)\n        obstacle_count = 0\n        grid = self._get_grid()\n        # Sample points in radius to count invalid positions (approximate density)\n        sample_points = 0\n        steps = 6\n        for dx in range(-steps, steps + 1):\n            for dy in range(-steps, steps + 1):\n                sample_point = Point(near_vertex.position.x + dx, near_vertex.position.y + dy)\n                if 0 <= sample_point.x < grid.size.x and 0 <= sample_point.y < grid.size.y:\n                    sample_points += 1\n                    if not grid.is_agent_valid_pos(sample_point):\n                        obstacle_count += 1\n        if sample_points == 0:\n            return self._max_dist_base\n        obstacle_ratio = obstacle_count / sample_points\n        adaptive_dist = self._max_dist_base * (1.0 - obstacle_ratio)\n        return max(3.0, min(self._max_dist_base, adaptive_dist))\n\n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Samples points biased within an ellipse between start and goal informed by the current best path cost.\n        If no path found yet, fallback to goal-biased uniform random sampling.\n        \"\"\"\n        import random\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        best_cost = float('inf')\n        # Find current best cost to goal vertex if exists\n        for v in self._graph.root_vertices:\n            if self._get_grid().is_agent_in_goal_radius(v.position):\n                if v.cost < best_cost:\n                    best_cost = v.cost\n\n        if random.random() < self._goal_bias:\n            return goal\n\n        if best_cost == float('inf'):\n            # No solution yet, sample uniformly inside valid grid\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling within ellipse oriented from start to goal\n        c_min = Map.get_distance(start, goal)\n        c_best = best_cost if best_cost < float('inf') else float('inf')\n\n        if c_best == float('inf'):\n            # fallback uniform sampling\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Ellipse parameters\n        center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n        a1 = (goal.x - start.x)\n        a2 = (goal.y - start.y)\n        norm = (a1 * a1 + a2 * a2) ** 0.5\n        if norm == 0:\n            return start\n        # Rotation matrix components\n        cos_theta = a1 / norm\n        sin_theta = a2 / norm\n\n        # Sampling within unit circle then scale to ellipse\n        while True:\n            # Sample random point inside unit circle\n            r = random.random() ** 0.5\n            theta = random.uniform(0, 2 * 3.141592653589793)\n            x_u = r * np.cos(theta)\n            y_u = r * np.sin(theta)\n\n            # Scale ellipse axis\n            L1 = c_best / 2\n            if c_best == float('inf'):\n                L1 = grid.size.x / 2\n            L2 = (c_best * c_best - c_min * c_min) ** 0.5 / 2 if c_best > c_min else 0.0\n\n            # Point in ellipse coordinate\n            x_e = L1 * x_u\n            y_e = L2 * y_u\n\n            # Rotate back to world frame\n            x_s = cos_theta * x_e - sin_theta * y_e + center.x\n            y_s = sin_theta * x_e + cos_theta * y_e + center.y\n\n            sample_pt = Point(int(round(x_s)), int(round(y_s)))\n            if 0 <= sample_pt.x < grid.size.x and 0 <= sample_pt.y < grid.size.y:\n                if grid.is_agent_valid_pos(sample_pt):\n                    return sample_pt\n\n    def _dynamic_rewire_radius(self, vertices_count: int) -> float:\n        \"\"\"\n        Decrease rewiring radius logarithmically as tree grows.\n        \"\"\"\n        import math\n        radius = self._max_rewire_radius * (math.log(vertices_count + 1) / (vertices_count + 1)) ** 0.5\n        radius = max(self._min_rewire_radius, min(self._max_rewire_radius, radius))\n        return radius\n\n    def _multi_pass_shortcut(self, path: list) -> list:\n        \"\"\"\n        Perform multiple passes of shortcutting with backtracking until no improvement.\n        \"\"\"\n        prev_len = float('inf')\n        curr_path = path\n        for _ in range(3):\n            if len(curr_path) >= 3:\n                new_path = [curr_path[0]]\n                i = 0\n                while i < len(curr_path) - 1:\n                    j = len(curr_path) - 1\n                    while j > i + 1:\n                        line_seq = self._get_grid().get_line_sequence(curr_path[i].position, curr_path[j].position)\n                        if self._get_grid().is_valid_line_sequence(line_seq):\n                            break\n                        j -= 1\n                    new_path.append(curr_path[j])\n                    i = j\n                curr_path = new_path\n                if len(curr_path) >= prev_len:\n                    break\n                prev_len = len(curr_path)\n            else:\n                break\n        return curr_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: list = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break  # no path\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        smoothed_path = self._multi_pass_shortcut(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex_pos = grid.goal.position\n        start_vertex.cost = 0.0\n\n        goal_connected = False\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n\n        for i in range(self._max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout\n                break\n\n            q_sample = self._informed_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near)\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            # Validate edge between q_near and q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Update dynamic rewiring radius based on current tree size\n            current_tree_size = max(1, self._graph.size)\n            rewire_radius = self._dynamic_rewire_radius(current_tree_size)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            # Choose parent minimizing cost + movement cost, verify edge validity\n            best_parent = self._choose_parent(near_vertices, q_new)\n\n            if best_parent is None:\n                # Fallback to q_near if valid\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if cheaper to go through q_new\n            self._rewire(near_vertices, q_new)\n\n            # Check if goal reached within radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position, goal=grid.goal):\n                q_goal = Vertex(goal_vertex_pos)\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n\n                    # Update best known goal if better cost\n                    if q_goal.cost < best_goal_cost:\n                        best_goal_cost = q_goal.cost\n                        best_goal_vertex = q_goal\n                    goal_connected = True\n                    # Early stop if path is sufficiently good (e.g., within scaling factor of straight-line dist)\n                    straight_line_dist = Map.get_distance(start_vertex.position, goal_vertex_pos)\n                    if best_goal_cost <= 1.2 * straight_line_dist:\n                        break\n\n            self.key_frame()\n\n        if goal_connected and best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Sample-Based Path Planning algorithm inspired by RRT*, combining:\n    - Goal-biased sampling (20% goal bias to improve connection success)\n    - Adaptive max_dist step size that shrinks as tree grows (finer resolution near goal)\n    - Rewiring step: after adding a vertex, connects to better parent in neighborhood and rewires neighbors if cost can be improved\n    - Path shortcutting in extraction for smoother path\n    - Early stopping if path found or 10 seconds exceeded\n    This approach aims to improve efficiency, solution quality, robustness, and success rate over standard RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services, \n            Vertex(self._get_grid().agent.position), \n            Vertex(self._get_grid().goal.position), \n            [])\n        self._graph.edges_removable = True  # allow edge rewiring\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self) -> float:\n        # Shrink max_dist as tree grows to improve precision near goal;\n        # min 2, max 15 based on size of graph, reduce with size to max 0.1 step per 50 nodes\n        base_max = 15.0\n        min_max = 2.0\n        decay = 0.1 * (self._graph.size // 50)\n        result = max(min_max, base_max - decay)\n        return result\n\n    def _get_random_sample_biased(self, goal_bias: float = 0.2) -> Point:\n        # With certain probability sample goal position to bias search\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _get_near_vertices(self, q_new: Vertex, radius_factor=1.5) -> List[Vertex]:\n        # Radius depends on tree size for rewiring; scales with sqrt( (log n) / n ), simplified here\n        n = max(self._graph.size, 1)\n        radius = radius_factor * (np.log(n) / n) ** 0.5 * self._get_adaptive_max_dist()\n        if radius < 1.0:\n            radius = 1.0\n        near = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        return near\n\n    def _choose_parent(self, q_near_candidates: List[Vertex], q_new_pos: Point) -> Vertex:\n        # Choose best parent with lowest cost + movement_cost if line valid\n        best_parent = None\n        best_cost = float('inf')\n        for q_near in q_near_candidates:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new_pos)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # Try to improve cost of neighbors by rewiring through q_new\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                # Rewire: remove old parent edges, add q_new as parent\n                # For simplicity, remove all parents (assume tree)\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_new\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut the path by skipping intermediate vertices when possible\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(shortcut_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Skip intermediate points between i and j\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, just append next vertex\n                shortcut_path.append(path[i+1])\n                i += 1\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Find path back to start and perform shortcutting\n        path: List[Vertex] = [q_new]\n        while len(path[-1].parents) != 0:\n            # Pick parent with lowest cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut path to make smoother and shorter\n        path = self._shortcut_path(path)\n\n        # Animate movement along the path\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_iterations = 10000\n        goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 1\n\n        root_start = self._graph.root_vertex_start\n        root_start.cost = 0.0\n\n        for i in range(max_iterations):\n            # Check timeout: stop if path not found in 10 seconds\n            if time() - start_time > 10.0:\n                break\n            \n            max_dist = self._get_adaptive_max_dist()\n            q_sample = self._get_random_sample_biased(goal_bias=0.2)\n\n            q_near = self._graph.get_nearest_vertex([root_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # New vertex in direction limited by max_dist\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Look for best parent among neighborhood near q_new (including q_near)\n            near_vertices = self._get_near_vertices(q_new)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n            best_parent = self._choose_parent(near_vertices, q_new.position)\n            if best_parent is None:\n                continue\n\n            # Set cost for q_new and add to graph\n            cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            q_new.cost = cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to q_new if it improves their cost\n            self._rewire(q_new, near_vertices)\n\n            # Check if reached goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved variant inspired by RRT*, combining:\n    - Goal-biased sampling with a probability to directly sample goal point for faster convergence.\n    - Adaptive step size: max_dist shrinks near obstacles or goal to improve path precision.\n    - Rewiring to reduce path cost and improve path smoothness: it tries to reconnect nearby vertices through the new vertex if it reduces cost.\n    - Early stopping if path found and successive improvements are minimal.\n    - Timeout of 10 seconds to limit planning duration.\n    - Shortcut smoothing in path extraction by iteratively shortcutting collision-free path segments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    import time\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow rewiring/removal\n        self._goal_sample_rate = 0.2  # 20% of the time sample goal directly (goal bias)\n        self._max_dist = 10.0\n        self._rewire_radius = 15.0  # radius to look for neighbors to rewire\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Decrease max_dist if close to obstacles or goal\n        \"\"\"\n        grid = self._get_grid()\n        dist_goal = grid.get_distance(pos, grid.goal.position)\n        dist_to_obstacle = 1e9\n        # Approximate nearest obstacle distance by checking neighbors (up to 8 neighbors)\n        neighbors = grid.get_next_positions(pos)\n        for npos in neighbors:\n            if not grid.is_agent_valid_pos(npos):\n                d = grid.get_distance(pos, npos)\n                if d < dist_to_obstacle:\n                    dist_to_obstacle = d\n        # Reduce max_dist near obstacles or goal\n        min_dist = min(dist_goal, dist_to_obstacle)\n        if min_dist < 1.0:\n            return max(1.0, self._max_dist * 0.1)\n        if min_dist < 5.0:\n            return max(2.0, self._max_dist * 0.3)\n        if min_dist < 10.0:\n            return max(4.0, self._max_dist * 0.6)\n        return self._max_dist\n\n    def _get_random_sample_biased(self) -> Point:\n        \"\"\"\n        Sample goal with probability self._goal_sample_rate, else random valid sample.\n        \"\"\"\n        from random import random\n        grid = self._get_grid()\n        if random() < self._goal_sample_rate:\n            return grid.goal.position\n        else:\n            return self._get_random_sample()\n\n    def _rewire(self, new_vertex: Vertex):\n        \"\"\"\n        Rewiring step of RRT*: For all neighbors within radius, check if passing through new_vertex reduces cost.\n        \"\"\"\n        grid = self._get_grid()\n        neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, new_vertex.position, self._rewire_radius)\n        for neighbor in neighbors:\n            if neighbor == new_vertex:\n                continue\n            # check if line from new_vertex to neighbor is valid\n            line_seq = grid.get_line_sequence(new_vertex.position, neighbor.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            movement_cost = grid.get_movement_cost(new_vertex.position, neighbor.position)\n            new_cost = new_vertex.cost + movement_cost\n            if new_cost < neighbor.cost:\n                # Change parent edge to new_vertex, adjust cost recursively\n                # Remove old edges:\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                self._graph.add_edge(new_vertex, neighbor)\n                neighbor.cost = new_cost\n                self._update_costs_recursive(neighbor)\n\n    def _update_costs_recursive(self, vertex: Vertex):\n        \"\"\"\n        After rewiring, recursively update costs for children.\n        \"\"\"\n        grid = self._get_grid()\n        for child in vertex.children:\n            line_seq = grid.get_line_sequence(vertex.position, child.position)\n            if grid.is_valid_line_sequence(line_seq):\n                movement_cost = grid.get_movement_cost(vertex.position, child.position)\n                new_cost = vertex.cost + movement_cost\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    self._update_costs_recursive(child)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        grid = self._get_grid()\n        # Add goal vertex connected from q_new\n        goal_v = Vertex(grid.goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        # Backtrack path from goal to start\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            # Choose parent with smallest cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut smoothing: try to shortcut path edges to reduce length\n        path = self._shortcut_path(path)\n\n        # Animate moving the agent along the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Try to shortcut the path by removing unnecessary intermediate vertices.\n        Uses iterative check for collision-free shortcut edges.\n        \"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(path[i].position, path[j].position)):\n                    # shortcut possible, jump from i to j\n                    shortened_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, increment normally\n                shortened_path.append(path[i + 1])\n                i += 1\n        # ensure last vertex is included\n        if shortened_path[-1] != path[-1]:\n            shortened_path.append(path[-1])\n        return shortened_path\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        \"\"\"\n        Override to include updating cost for new vertex.\n        \"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir / dist\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        new_vertex = Vertex(q_new_pos)\n        # Calculate cost to new vertex from q_near\n        movement_cost = self._get_grid().get_movement_cost(q_near.position, q_new_pos)\n        new_vertex.cost = q_near.cost + movement_cost\n        return new_vertex\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        no_improvement_iters = 0\n        best_cost = float('inf')\n        best_goal_vertex = None\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:  # timeout 10 seconds\n                break\n\n            q_sample = self._get_random_sample_biased()\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            adaptive_max_dist = self._get_adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Prevent duplicate vertex addition at same position\n            existing_vertex_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_new.position)\n            if existing_vertex_near.position == q_new.position:\n                continue\n\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors for improved costs\n            self._rewire(q_new)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Found path candidate\n                if q_new.cost < best_cost:\n                    best_cost = q_new.cost\n                    best_goal_vertex = q_new\n                    no_improvement_iters = 0\n                else:\n                    no_improvement_iters += 1\n                if no_improvement_iters > 50:\n                    # Early stop if no improvement after 50 iterations\n                    break\n\n            self.key_frame()\n\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm builds upon an RRT* foundation, enhanced by\n    adaptive clearance-aware sampling and heuristic-guided tree expansion. It incorporates:\n\n    - Clearance-guided sampling: samples are biased towards regions with larger clearance\n      from obstacles by using obstacle boundary distance estimation.\n    - Adaptive step size scaled by local clearance to prevent collisions and improve efficiency.\n    - Heuristic combined cost for vertex selection (cost-to-come + estimated cost-to-go).\n    - Dynamic rewiring radius adapting to tree size for better path optimization.\n    - Early stopping once a sufficiently low-cost path is found or on timeout (10s max).\n    - Path shortcutting and smoothing through post-processing.\n    \n    This combination aims to improve success rate, path smoothness, and planning speed,\n    especially in cluttered grids where clearance awareness reduces wasted expansions.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0        # Base max extending distance (adaptive)\n        self._goal_bias = 0.15            # Increased goal bias to speed convergence\n        self._rewire_radius_base = 20.0   # Base radius for rewiring, will adapt dynamically\n        self._min_clearance_threshold = 2.0  # Minimum clearance considered safe for stepping\n\n    def _estimate_clearance(self, point: Point) -> float:\n        # Rough clearance estimate by checking neighbors' validity up to radius 5\n        # Returns minimal distance from obstacles\n        max_check_radius = 5\n        grid = self._get_grid()\n        for r in range(1, max_check_radius + 1):\n            # Check positions in the ring of radius r around point\n            offsets = []\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    if abs(dx) == r or abs(dy) == r:\n                        offsets.append((dx, dy))\n            all_valid = True\n            for ox, oy in offsets:\n                pos = Point(point.x + ox, point.y + oy)\n                if not grid.is_agent_valid_pos(pos):\n                    # Clearance is approx distance to this obstacle\n                    return r - 1.0 if r > 1 else 0.5\n        return float(max_check_radius)  # Clear zone radius 5 or more\n\n    def _get_clearance_biased_sample(self) -> Point:\n        import random\n        grid = self._get_grid()\n\n        # With goal bias probability, sample goal position directly\n        if random.random() < self._goal_bias:\n            return grid.goal.position\n\n        # Sample multiple candidates and pick the one with max clearance\n        best_sample = None\n        best_clearance = -1.0\n        sample_attempts = 30\n        for _ in range(sample_attempts):\n            rand_coords = np.random.randint(0, grid.size, size=grid.size.n_dim)\n            sample = Point(*rand_coords)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            clearance = self._estimate_clearance(sample)\n            if clearance > best_clearance:\n                best_clearance = clearance\n                best_sample = sample\n            if best_clearance >= self._min_clearance_threshold:\n                # Early break on sufficiently good sample\n                break\n        if best_sample is None:\n            # Fallback to uniform random valid sample if none found with clearance\n            while True:\n                rand_coords = np.random.randint(0, grid.size, size=grid.size.n_dim)\n                sample = Point(*rand_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        return best_sample\n\n    def _choose_best_vertex(self, near_vertices: list, q_sample: Point) -> Vertex:\n        # Choose vertex minimizing cost-to-come + heuristic cost-to-go\n        grid = self._get_grid()\n        best_vertex = None\n        best_score = float('inf')\n\n        for v in near_vertices:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(v.position, q_sample)):\n                continue\n            cost_to_sample = v.cost + self._cost(v, Vertex(q_sample))\n            heuristic = Map.get_distance(q_sample, grid.goal.position)\n            score = cost_to_sample + heuristic\n            if score < best_score:\n                best_score = score\n                best_vertex = v\n        if best_vertex is not None:\n            # Set cost for q_new to cost through best_vertex (will be used later)\n            # q_new.cost is set outside since q_new not instantiated here\n            pass\n        return best_vertex\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        max_iterations = 8000  # Slightly reduced due to clearance-aware sampling efficiency\n        grid = self._get_grid()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                break\n\n            # Sample with clearance bias + goal bias incorporated\n            q_sample = self._get_clearance_biased_sample()\n\n            # Collect vertices for nearest search (only from start-root tree)\n            vertices = [v for v in self._graph.root_vertices if v.cost < float('inf')]\n\n            if not vertices:\n                continue\n\n            # Find nearest vertex in the tree to q_sample by Euclidean\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Determine adaptive step size based on clearance at q_near and q_sample\n            clearance_near = self._estimate_clearance(q_near.position)\n            clearance_sample = self._estimate_clearance(q_sample)\n            clearance_min = min(clearance_near, clearance_sample)\n            adaptive_max_dist = max(1.0, min(self._max_dist_base, clearance_min * 2.5))\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(adaptive_max_dist, dist_to_sample)\n\n            # Generate new vertex extending towards sample\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            # Check motion validity for final extension\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Dynamically adapt rewire radius smaller scale on large trees for efficiency\n            radius_scale = max(0.5, min(1.0, 40.0 / max(1, self._graph.size)))\n            rewire_radius = self._rewire_radius_base * radius_scale\n\n            # Get neighbors for rewiring\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            # Choose best parent vertex using heuristic-guided selection\n            best_parent = self._choose_best_vertex(near_vertices, q_new.position)\n            if best_parent is None:\n                # Fallback to default nearest if no heuristic suitable parent found\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n            else:\n                # Assign cost to q_new through best_parent\n                q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n\n            # Add edge and vertex to the graph/tree\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices through q_new to reduce cost\n            self._rewire(near_vertices, q_new)\n\n            # Check if goal is reached or close enough\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position, goal=grid.goal):\n                q_goal = Vertex(grid.goal.position)\n                goal_line_seq = grid.get_line_sequence(q_new.position, q_goal.position)\n                if grid.is_valid_line_sequence(goal_line_seq):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    # Update best goal vertex only if better cost found\n                    if q_goal.cost < best_goal_cost:\n                        best_goal_cost = q_goal.cost\n                        best_goal_vertex = q_goal\n\n            # Early stopping if good enough goal found (within 5 steps of base max dist)\n            if best_goal_vertex is not None and best_goal_cost <= start_vertex.cost + Map.get_distance(start_vertex.position, grid.goal.position) + 5.0:\n                break\n\n            self.key_frame()\n\n        # If a goal vertex was found, extract and smooth path\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* Inspired Path Planning Algorithm with Goal Biasing, Adaptive Step Size, Rewiring and Path Shortcutting.\n    This algorithm expands on the base RRT approach by:\n    - Introducing goal-biased sampling to guide tree growth towards goal more frequently.\n    - Adaptive max_dist step size that shrinks near obstacles or goal for finer exploration.\n    - Employing RRT* style rewiring to optimize paths locally, improving path quality and smoothness.\n    - A path shortcutting post-processing step to further smooth and shorten the found path.\n    - Early stopping after success or if execution time exceeds 10 seconds to improve robustness and timely failure.\n    - The underlying graph is a Forest allowing multiple roots but rewiring keeps graph more tree-like.\n    These improvements aim to achieve faster convergence, higher success rates, and better path quality in grid environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True  # Enable removing edges for rewiring\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new, store_connectivity=True)\n\n    def _get_random_sample(self, goal_sample_rate: float = 0.1) -> Point:\n        # With probability goal_sample_rate, sample goal to bias tree expansion \n        if np.random.random() < goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_parent(self, q_candidates: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose best parent with lowest cost + movement cost, validating path exists\n        best_parent = None\n        best_cost = float('inf')\n        for q_near in q_candidates:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = q_near\n        if best_parent:\n            q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, radius: float) -> None:\n        # Try to rewire neighbors within radius to q_new for lower cost paths\n        neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Rewire edge\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Path shortcutting by attempting to connect non-adjacent vertices directly if valid\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]  # always include start\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, move one step forward\n                shortcut_path.append(path[i+1])\n                i += 1\n        # Remove duplicates (can happen if late breaks)\n        final_path = []\n        seen = set()\n        for v in shortcut_path:\n            if v.position not in seen:\n                final_path.append(v)\n                seen.add(v.position)\n        return final_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path from goal to start by following parents with lowest cost\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            # Select parent with minimal cost (should normally be single parent)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut path to improve smoothness\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_max_dist(self, q_near: Vertex, q_sample: Point) -> float:\n        # Adapt step size: shorter near goal or closer to obstacles\n        base_dist = 10.0\n        d_to_goal = Map.get_distance(q_near.position, self._get_grid().goal.position)\n        adaptive_dist = min(base_dist, d_to_goal)\n        # Detect obstacles close to q_near by checking neighbors invalid positions\n        neighbors = self._get_grid().get_next_positions(q_near.position)\n        invalid_count = sum(not self._get_grid().is_agent_valid_pos(n) for n in neighbors)\n        if invalid_count > 0:\n            adaptive_dist = max(2.0, adaptive_dist * 0.5)\n        return adaptive_dist\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_iterations = 10000\n        goal_sample_rate = 0.15  # 15% goal biased sampling\n        radius_rewire = 15.0\n\n        for iteration in range(max_iterations):\n            if time() - start_time > 10.0:  # 10 seconds time limit\n                return  # Fail early if timeout\n\n            q_sample = self._get_random_sample(goal_sample_rate)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near, q_sample)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq_to_new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq_to_new):\n                continue\n\n            # Find near vertices for rewiring (RRT* style)\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius_rewire)\n            q_best_parent = self._choose_parent(near_vertices + [q_near], q_new)\n            if q_best_parent is None:\n                continue\n\n            # Add edge from best parent\n            self._graph.add_edge(q_best_parent, q_new)\n\n            # Rewire neighbors if cheaper paths via q_new exist\n            self._rewire(q_new, radius_rewire)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15        # Slightly higher goal bias for focused sampling\n        self._rewire_radius = 15.0    # Shrinking rewire radius for better memory\n        self._vertex_limit = 1500     # Limit max vertices for memory efficiency\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            attempts = 0\n            while attempts < 50:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            # fallback to goal if sampling fails repeatedly\n            return self._get_grid().goal.position\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove all existing parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"Shrink rewire radius over time for efficiency and memory.\"\"\"\n        min_radius = 5.0\n        radius = self._rewire_radius * (1.0 - iteration / max_iterations)\n        return max(radius, min_radius)\n\n    def _limit_graph_size(self) -> None:\n        \"\"\"Limit max vertex count in graph for memory efficiency by pruning farthest or high cost vertices.\"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Sort vertices by cost descending, skip root start and goal\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            # Remove all edges to/from vertex to prune it\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            # Remove vertex from roots if present\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        # Rebuild size count\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 8000\n        max_dist_base = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = min(max_dist_base, dist_to_sample)\n\n            # Further adapt step based on costs to encourage finer exploration near obstacles or goal\n            adaptive_step *= 0.7 + 0.3 * (1 - min(q_near.cost / 100.0, 1.0))\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrinking rewire radius to save memory and speed later on\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # Fallback to nearest vertex if viable\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            # Prune to keep memory low if vertices grow large\n            self._limit_graph_size()\n\n            # Check goal proximity with radius for early success\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* (Rapidly-exploring Random Tree star) variant with \n    goal bias sampling, adaptive step size, and path rewiring for path quality.\n    It improves efficiency and robustness by:\n    - Biasing sampling towards the goal (20% samples closer to goal)\n    - Dynamically adapting extension length (max_dist) based on local neighbor density\n    - Using rewiring to optimize paths (shorter costs)\n    - Shortcutting/smoothing path before extraction\n    - Early stopping on success or after 10 seconds\n    - Maintaining memory efficiency by reusing vertices and edges carefully",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow rewiring\n        self._init_displays()\n        self._goal_radius = 5.0   # radius around goal for rewiring & stopping\n        self._goal_bias = 0.2     # 20% random samples biased towards goal\n        self._max_iterations = 10000\n        self._base_max_dist = 10.0\n        self._rewiring_radius = 15.0\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling: with probability goal_bias pick near goal, else random valid\n        if np.random.random() < self._goal_bias:\n            # Sample near goal within a small radius to encourage connecting goal faster\n            goal_pos = self._get_grid().goal.position\n            for _ in range(10):\n                rand_offset = np.random.randint(-3, 4, size=self._get_grid().size.n_dim)\n                candidate = Point(*(goal_pos.to_tensor().numpy() + rand_offset))\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            # fallback random if no valid near goal found\n        # Uniform random valid sampling\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewiring_radius)\n\n    def _compute_cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost is cumulative cost to frm + step cost frm->to\n        step_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return frm.cost + step_cost\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose parent in near_vertices minimizing cost to q_new (if valid path exists)\n        min_cost = None\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = self._compute_cost(v, q_new)\n            if min_cost is None or cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is None:\n            # As fallback, connect to nearest\n            best_parent = self._graph.get_nearest_vertex(self._graph.root_vertices, q_new.position)\n            min_cost = self._compute_cost(best_parent, q_new)\n        q_new.cost = min_cost if min_cost is not None else 0.0\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire near vertices for shorter paths via q_new\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = self._compute_cost(q_new, v)\n            if new_cost < v.cost:\n                # Remove old parent edges\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                # Add new edge from q_new to v\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut/smooth the path by checking feasibility between non-adjacent nodes\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path)-1\n            while j > i+1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                shortcut_path.append(path[i+1])\n                i = i + 1\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract path from start to goal by following parents\n        path: List[Vertex] = []\n        current = q_new\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # pick parent with min cost (there could be multiple)\n            current = min(current.parents, key=lambda p: p.cost)\n\n        path.reverse()\n\n        # Smooth path by shortcutting\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adapt_max_dist(self, near_vertices_count: int) -> float:\n        # Adapt step size smaller if density is high, bigger if density low\n        if near_vertices_count > 20:\n            return max(3.0, self._base_max_dist * 0.25)\n        elif near_vertices_count > 10:\n            return max(5.0, self._base_max_dist * 0.5)\n        else:\n            return self._base_max_dist\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        self._graph.add_edge(start_vertex, start_vertex)  # Add the single start vertex to graph explicitly\n\n        for i in range(self._max_iterations):\n            if (time() - start_time) > 10.0:\n                # Timeout after 10 seconds => fail search\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Get near vertices for rewiring and adapt step\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_near.position, self._rewiring_radius)\n            max_dist = self._adapt_max_dist(len(near_vertices))\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            near_vertices_for_parent = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewiring_radius)\n            parent = self._choose_parent(near_vertices_for_parent, q_new)\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(near_vertices_for_parent, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    PathPlanning implements an improved version of the RRT algorithm inspired by RRT* with goal biasing,\n    adaptive step size, and rewiring to optimize path quality while improving success rate.\n    Key improvements:\n    - Goal-biased sampling to accelerate convergence.\n    - Adaptive max_dist that shrinks near goal for finer resolution.\n    - Rewiring nearby vertices for lower cost paths (RRT* style).\n    - Path shortcutting during extraction for smoother final paths.\n    - Early stopping if computation exceeds 10 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist_init: float\n    _goal_sample_rate: float  # Probability to sample goal directly\n    _rewire_radius_factor: float  # Factor to determine radius for rewiring\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._max_dist_init = 15.0\n        self._goal_sample_rate = 0.15  # 15% goal bias sampling\n        self._rewire_radius_factor = 30.0  # radius factor for rewiring\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # allow rewiring/removable edges\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Goal biasing: with some probability sample the goal directly.\"\"\"\n        import random\n\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"Create new vertex at most max_dist away from q_near toward q_sample.\"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_rewire_radius(self, size: int) -> float:\n        \"\"\"Compute radius for rewiring based on current graph size and environment dimensions.\"\"\"\n        dim = self._get_grid().size.n_dim\n        gamma_rrt_star = self._rewire_radius_factor\n        r = gamma_rrt_star * (np.log(size + 1) / (size + 1)) ** (1 / dim)\n        # Limit radius max to something sensible related to max_dist_init\n        radius = min(r, self._max_dist_init * 2)\n        return radius\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"Chooses the best parent for q_new from candidates q_near_list via lowest cost + valid path.\"\"\"\n        cost_min = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n\n        for q_near in q_near_list:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            move_cost = grid.get_movement_cost(q_near.position, q_new.position)\n            cost = q_near.cost + move_cost\n            if cost < cost_min:\n                cost_min = cost\n                best_parent = q_near\n\n        if best_parent:\n            q_new.cost = cost_min\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]):\n        \"\"\"Attempt to rewire nearby vertices through q_new to improve path cost.\"\"\"\n        grid = self._get_grid()\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            move_cost = grid.get_movement_cost(q_new.position, q_near.position)\n            new_cost = q_new.cost + move_cost\n            if new_cost < q_near.cost:\n                # remove old parent edge(s)\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # add new edge from q_new\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Path shortcutting by trying to connect nonadjacent vertices directly.\"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = grid.get_line_sequence(shortened_path[-1].position, path[next_idx].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _extract_path(self, q_new: Vertex):\n        \"\"\"Extract shortest path from start to goal and move agent along it with shortcutting.\"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        # Connect q_new to goal vertex if not connected\n        # Only connect if line is valid\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(q_new.position, goal_v.position)\n        if grid.is_valid_line_sequence(line_seq):\n            self._graph.add_edge(q_new, goal_v)\n        else:\n            # fallback: try reconnect the goal to nearest existing vertex\n            q_near_goal = self._graph.get_nearest_vertex(self._graph.root_vertices, goal_v.position)\n            if q_near_goal and grid.is_valid_line_sequence(grid.get_line_sequence(q_near_goal.position, goal_v.position)):\n                self._graph.add_edge(q_near_goal, goal_v)\n            else:\n                # if cannot connect goal, treat goal_v as isolated vertex; return early\n                return\n\n        # Trace path backward from goal to start.\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut path for smoother trajectory\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_time_sec = 10.0\n        start_time = time()\n\n        # max_dist will be adaptive, shrinks near goal for finer planning resolution\n        max_dist = self._max_dist_init\n        goal_pos = self._get_grid().goal.position\n        start_pos = self._get_grid().agent.position\n\n        # Initialize costs for root start vertex\n        self._graph.root_vertex_start.cost = 0.0\n\n        iterations = 10000\n        for i in range(iterations):\n            if time() - start_time > max_time_sec:\n                # timeout, path not found within time limit\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adapt max_dist based on distance to goal for finer control near goal\n            dist_to_goal = Map.get_distance(q_near.position, goal_pos)\n            adaptive_max_dist = max(min(max_dist, dist_to_goal / 2.0), 3.0)\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Get nearby vertices for possible rewiring\n            near_radius = self._get_rewire_radius(self._graph.size)\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, near_radius)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            # Choose best parent from near vertices\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire other vertices if better cost through q_new\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is a hybrid of heuristic-guided A*-like vertex expansion combined with informed sampling and\n    bidirectional search from both start and goal. Unlike RRT*, it uses a priority queue (min-heap) keyed on a\n    combined cost-to-come + heuristic-to-goal (A* cost) for vertex expansion, thus focusing exploration on the most\n    promising frontier nodes. Sampling is adaptively concentrated around frontier vertices and goal vicinity to\n    improve success rate and path quality. The bidirectional Forest structure allows fast connection attempts from\n    both directions. Adaptive max step size ensures efficient coverage and obstacle finesse. Upon connection, the \n    algorithm extracts the shortest combined path and performs shortcut smoothing for path quality. Early stopping\n    occurs upon successful connection or 10 seconds timeout to ensure practical efficiency.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This algorithm is a hybrid of heuristic-guided A*-like vertex expansion combined with informed sampling and\n    bidirectional search from both start and goal. Unlike RRT*, it uses a priority queue (min-heap) keyed on a\n    combined cost-to-come + heuristic-to-goal (A* cost) for vertex expansion, thus focusing exploration on the most\n    promising frontier nodes. Sampling is adaptively concentrated around frontier vertices and goal vicinity to\n    improve success rate and path quality. The bidirectional Forest structure allows fast connection attempts from\n    both directions. Adaptive max step size ensures efficient coverage and obstacle finesse. Upon connection, the \n    algorithm extracts the shortest combined path and performs shortcut smoothing for path quality. Early stopping\n    occurs upon successful connection or 10 seconds timeout to ensure practical efficiency.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters for adaptive step, sampling\n        self._max_dist_base = 20.0           # slightly larger max step for faster expansion\n        self._goal_sample_prob = 0.2         # increase goal bias for more focused sampling\n\n        # Priority queue storage: vertex -> (cost + heuristic)\n        self._open_set = None                 # will be initialized before planning\n\n        self._vertex_limit = 2000            # allow more vertices due to bidirectional search\n\n    def _heuristic(self, point: Point) -> float:\n        \"\"\"Straight-line distance heuristic to goal.\"\"\"\n        return Map.get_distance(point, self._get_grid().goal.position)\n\n    def _combined_cost(self, vertex: Vertex) -> float:\n        \"\"\"F = cost-to-come + heuristic-to-goal.\"\"\"\n        return vertex.cost + self._heuristic(vertex.position)\n\n    def _sample_near_frontier(self, frontier: list, radius: float = 10.0) -> Point:\n        \"\"\"\n        Samples a random point near the current frontier vertices for focused expansion.\n        Falls back to general uniform sampling if frontier empty.\n        \"\"\"\n        import random, numpy as np\n        if frontier:\n            base_vertex = random.choice(frontier)\n            d = np.random.uniform(0, radius)\n            angle = np.random.uniform(0, 2 * np.pi)\n            dx = int(round(d * np.cos(angle)))\n            dy = int(round(d * np.sin(angle)))\n            sample_point = Point(base_vertex.position.x + dx, base_vertex.position.y + dy)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n        # fallback: uniform random valid sample\n        attempts = 0\n        while attempts < 50:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample_point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n            attempts += 1\n        # fallback to goal if all fail\n        return self._get_grid().goal.position\n\n    def _get_new_vertex_biased(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Similar to _get_new_vertex, but clipping max_dist adaptively based on environment.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_nearest_vertex_in_forest(self, forest: Forest, point: Point) -> Vertex:\n        \"\"\"\n        Return nearest vertex in either root_vertex_start or root_vertex_goal subtrees.\n        \"\"\"\n        v_start = forest.get_nearest_vertex([forest.root_vertex_start], point)\n        v_goal = forest.get_nearest_vertex([forest.root_vertex_goal], point)\n        dist_start = Map.get_distance(v_start.position, point)\n        dist_goal = Map.get_distance(v_goal.position, point)\n        return v_start if dist_start < dist_goal else v_goal\n\n    def _connect_vertices(self, v_start: Vertex, v_goal: Vertex) -> bool:\n        \"\"\"\n        Try connecting two vertices directly if possible and add edge.\n        Returns True if connected successfully.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(v_start.position, v_goal.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            self._graph.add_edge(v_start, v_goal)\n            return True\n        return False\n\n    def _extract_bidirectional_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from start to meet_vertex_start, from meet_vertex_goal to goal, then join and shortcut.\n        \"\"\"\n        path_start = []\n        current = meet_vertex_start\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(current)\n            current = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        current = meet_vertex_goal\n        while current != self._graph.root_vertex_goal:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(current)\n            current = parent\n        path_goal.append(self._graph.root_vertex_goal)  # goal at end (root_vertex_goal)\n        # forward from meet_vertex_goal to goal;\n        # We reverse path_goal since parents point backward from children.\n        path_goal.reverse()\n\n        # Full path combined\n        full_path = path_start + path_goal[1:]  # avoid duplicate meet_vertex\n\n        # Shortcut path for smoothing\n        smoothed_path = self._shortcut_path(full_path)\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _limit_graph_size_bidirectional(self) -> None:\n        \"\"\"\n        Maintain graph size limit by pruning high-cost leaves on both sides.\n        \"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Collect all vertices except roots\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        vertices_sorted = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices_sorted[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_time = time.time()\n        max_duration = 10.0  # seconds timeout\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Bidirectional frontier sets\n        frontier_start = [start_vertex]\n        frontier_goal = [goal_vertex]\n\n        # Priority queues for expansion [ (f_score, vertex, tree_flag) ]\n        # tree_flag: 0=start tree, 1=goal tree\n        open_set = []\n        heapq.heappush(open_set, (self._combined_cost(start_vertex), start_vertex, 0))\n        heapq.heappush(open_set, (self._combined_cost(goal_vertex), goal_vertex, 1))\n\n        # Visited sets (positions) for quick collision detection of paths between trees\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        # Parameters\n        max_iterations = 10000\n        max_dist_base = self._max_dist_base\n\n        for iteration in range(max_iterations):\n\n            if time.time() - start_time > max_duration:\n                # Timeout exit, no path found\n                break\n\n            if not open_set:\n                # No more vertices to expand\n                break\n\n            # Pop the vertex with lowest f_score\n            f_score, current_vertex, tree_flag = heapq.heappop(open_set)\n\n            # Sampling biased near frontier of the current tree\n            if tree_flag == 0:\n                q_sample = self._sample_near_frontier(frontier_start)\n            else:\n                q_sample = self._sample_near_frontier(frontier_goal)\n\n            q_near = self._get_nearest_vertex_in_forest(self._graph, q_sample)\n            if q_near.position == q_sample:\n                # Already exists\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = min(max_dist_base, dist_to_sample)\n\n            # Adaptive step smaller near obstacles or high cost (heuristic)\n            adaptive_step *= 0.6 + 0.4 * (1 - min(q_near.cost / 80.0, 1.0))\n\n            q_new = self._get_new_vertex_biased(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Cost to come update\n            new_cost = q_near.cost + self._cost(q_near, q_new)\n            q_new.cost = new_cost\n\n            # Add q_new to the appropriate forest subtree depending on tree_flag\n            if tree_flag == 0:\n                # Start tree expansion\n                self._graph.add_edge(q_near, q_new)\n                frontier_start.append(q_new)\n                visited_start[q_new.position] = q_new\n            else:\n                # Goal tree expansion\n                self._graph.add_edge(q_near, q_new)\n                frontier_goal.append(q_new)\n                visited_goal[q_new.position] = q_new\n\n            # Add new vertex to open set\n            heapq.heappush(open_set, (self._combined_cost(q_new), q_new, tree_flag))\n\n            # Attempt connection: Check if q_new is near any vertex on the opposite tree\n            opposite_visited = visited_goal if tree_flag == 0 else visited_start\n\n            connection_radius = max(5.0, adaptive_step * 1.5)\n            for pos, vertex in opposite_visited.items():\n                if Map.get_distance(q_new.position, pos) <= connection_radius:\n                    # Try connecting q_new and vertex in opposite tree\n                    if self._connect_vertices(q_new, vertex):\n                        # Extract path via bidirectional meet\n                        if tree_flag == 0:\n                            meet_start = q_new\n                            meet_goal = vertex\n                        else:\n                            meet_start = vertex\n                            meet_goal = q_new\n                        self._extract_bidirectional_path(meet_start, meet_goal)\n                        return\n\n            # Maintain graph size limit to keep planning efficient\n            self._limit_graph_size_bidirectional()\n\n            # Periodic pruning of frontier lists for efficiency\n            if iteration % 200 == 0 and len(frontier_start) > 100:\n                frontier_start = frontier_start[-100:]\n            if iteration % 200 == 0 and len(frontier_goal) > 100:\n                frontier_goal = frontier_goal[-100:]\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"This algorithm implements a hybrid heuristic-guided bidirectional Rapidly-exploring Random Tree \"\n    \"(RRT) with adaptive batch sampling and dynamic goal region expansion. It constructs two trees \"\n    \"(start-tree and goal-tree) growing toward each other to improve connection success and planning \"\n    \"efficiency. Sampling is performed in adaptive batches combining uniform, heuristic-informed (towards \"\n    \"midpoint between trees), and goal-biased samples to accelerate convergence. Step sizes adapt based \"\n    \"on local obstacle density and distance to goal, improving exploration vs. exploitation balance. \"\n    \"The connection attempt between trees leverages validated line-of-sight checks to identify viable \"\n    \"paths early. Once connected, the extracted path is smoothed via shortcutting to improve quality. \"\n    \"An early stopping condition triggers on a successful path found or a 10-second timeout to ensure \"\n    \"timely responsiveness.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\n    \"This algorithm implements a hybrid heuristic-guided bidirectional Rapidly-exploring Random Tree \"\n    \"(RRT) with adaptive batch sampling and dynamic goal region expansion. It constructs two trees \"\n    \"(start-tree and goal-tree) growing toward each other to improve connection success and planning \"\n    \"efficiency. Sampling is performed in adaptive batches combining uniform, heuristic-informed (towards \"\n    \"midpoint between trees), and goal-biased samples to accelerate convergence. Step sizes adapt based \"\n    \"on local obstacle density and distance to goal, improving exploration vs. exploitation balance. \"\n    \"The connection attempt between trees leverages validated line-of-sight checks to identify viable \"\n    \"paths early. Once connected, the extracted path is smoothed via shortcutting to improve quality. \"\n    \"An early stopping condition triggers on a successful path found or a 10-second timeout to ensure \"\n    \"timely responsiveness.\"\n    }\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Added members for bidirectional planning and adaptive batch size\n        self._max_dist_base = 20.0                # Base adaptive max step length\n        self._goal_bias = 0.2                     # Bias towards goal in sampling\n        self._batch_size = 50                     # Number of samples per iteration batch\n        self._connect_threshold = 5.0             # Distance threshold to try connection between trees\n        self._vertex_limit = 2000                 # Vertex count limit to prune memory\n        self._search_timeout = 10.0               # 10 seconds timeout\n\n    def _sample_batch(self, center: Point, radius: float, count: int) -> list:\n        # Samples points within a radius around a center using uniform validity checks.\n        samples = []\n        attempts = 0\n        max_attempts = count * 10\n        grid_size = self._get_grid().size\n        while len(samples) < count and attempts < max_attempts:\n            rand_coords = [\n                int(max(0, min(grid_size[i] - 1, center.to_list()[i] + \n                                np.random.randint(-radius, radius + 1))))\n                for i in range(grid_size.n_dim)\n            ]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                samples.append(sample)\n            attempts += 1\n        return samples\n\n    def _adaptive_max_dist(self, near_vertex: Vertex) -> float:\n        # Adaptive step size decreases near obstacles and shrinks near goal for refined search\n        dist_to_goal = Map.get_distance(near_vertex.position, self._get_grid().goal.position)\n        obstacles = self._get_grid().obstacles\n        # Estimate local obstacle density in the neighborhood (count obstacles within radius)\n        neighborhood_radius = 10\n        obstacle_density = 0\n        obstacle_points = set()\n        for obs in obstacles:\n            obs_bound = self._get_grid().get_obstacle_bound(obs.position)\n            obstacle_points.update(obs_bound)\n        nearby_obstacles = 0\n        for op in obstacle_points:\n            if Map.get_distance(op, near_vertex.position) <= neighborhood_radius:\n                nearby_obstacles += 1\n        if nearby_obstacles > 0:\n            obstacle_density = nearby_obstacles / (neighborhood_radius ** 2)\n        else:\n            obstacle_density = 0.0\n\n        # Scale max_dist down by obstacle density and proximity to goal\n        scale_dist = self._max_dist_base * (1.0 / (1.0 + obstacle_density)) * min(1.0, dist_to_goal / 50.0)\n        # Lower bound step size\n        return max(3.0, scale_dist)\n\n    def _choose_best_connection(self, edges_tree: Forest, q_new_start: Vertex, q_new_goal: Vertex) -> tuple:\n        # Attempts to connect the two trees by checking line sequences between new samples\n        line_seq = self._get_grid().get_line_sequence(q_new_start.position, q_new_goal.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        cost = q_new_start.cost + self._cost(q_new_start, q_new_goal) + q_new_goal.cost\n        return cost\n\n    def _extract_bidirectional_path(self, q_start: Vertex, q_goal: Vertex, graph: Forest) -> None:\n        # Trace from q_start to root start\n        path_start = [q_start]\n        current = q_start\n        while current != graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(parent)\n            current = parent\n        path_start.reverse()\n\n        # Trace from q_goal to root goal\n        path_goal = [q_goal]\n        current = q_goal\n        while current != graph.root_vertex_goal:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(parent)\n            current = parent\n\n        # Combine paths (goal-tree part reversed)\n        full_path = path_start + path_goal\n\n        # Smooth path with shortcutting\n        smoothed = self._shortcut_path(full_path)\n\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _limit_graph_size(self) -> None:\n        # Limit vertex count in graph for memory efficiency by pruning farthest/high cost vertices\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_tree = Forest(self._services, self._graph.root_vertex_start, None, [])\n        goal_tree = Forest(self._services, self._graph.root_vertex_goal, None, [])\n        start_tree.root_vertex_goal = None\n        goal_tree.root_vertex_start = None\n\n        # Initialize costs\n        start_tree.root_vertex_start.cost = 0.0\n        goal_tree.root_vertex_goal.cost = 0.0\n\n        # Bidirectional trees vertex storage\n        start_vertices = [start_tree.root_vertex_start]\n        goal_vertices = [goal_tree.root_vertex_goal]\n\n        goal_pos = self._get_grid().goal.position\n        start_pos = self._get_grid().agent.position\n\n        max_iterations = 5000    # Somewhat less to keep efficiency\n        batch_size = self._batch_size\n\n        # Midpoint heuristic for adaptive sampling center\n        def midpoint(a: Point, b: Point) -> Point:\n            coords = [(a.to_list()[i] + b.to_list()[i]) // 2 for i in range(a.n_dim)]\n            return Point(*coords)\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > self._search_timeout:\n                break  # Timeout\n\n            # Alternate expansions: Even iterations start_tree, odd goal_tree\n            if iteration % 2 == 0:\n                expanding_tree = start_tree\n                other_tree = goal_tree\n                vertices_expanding = start_vertices\n                vertices_other = goal_vertices\n            else:\n                expanding_tree = goal_tree\n                other_tree = start_tree\n                vertices_expanding = goal_vertices\n                vertices_other = start_vertices\n\n            # Adaptive sampling center towards midpoint of closest nodes between trees\n            nearest_start = expanding_tree.get_nearest_vertex(vertices_expanding, self._get_grid().goal.position if iteration%2==0 else self._get_grid().agent.position)\n            nearest_goal = other_tree.get_nearest_vertex(vertices_other, nearest_start.position)\n            mid = midpoint(nearest_start.position, nearest_goal.position)\n\n            # Adaptive radius based on iteration count and environment size\n            radius = max(10.0, self._max_dist_base * (1.0 - iteration / max_iterations))\n\n            # Sample batch around midpoint and some goal bias samples to maintain goal focus\n            batch_samples = self._sample_batch(mid, radius, int(batch_size * 0.7))\n            # Include some uniformly random valid samples for exploration\n            uniform_samples = []\n            attempts_uniform = 0\n            grid_size = self._get_grid().size\n            while len(uniform_samples) < int(batch_size * 0.3) and attempts_uniform < int(batch_size * 10):\n                candidate_coords = [np.random.randint(0, grid_size[i]) for i in range(grid_size.n_dim)]\n                sample = Point(*candidate_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    uniform_samples.append(sample)\n                attempts_uniform += 1\n\n            samples = batch_samples + uniform_samples\n\n            new_vertices = []\n            for q_sample in samples:\n                q_near = expanding_tree.get_nearest_vertex(vertices_expanding, q_sample)\n                if q_near.position == q_sample:\n                    continue\n\n                max_dist = self._adaptive_max_dist(q_near)\n\n                dir = q_sample.to_tensor() - q_near.position.to_tensor()\n                dist = torch.norm(dir)\n                if dist <= max_dist:\n                    q_new_pos = q_sample\n                else:\n                    dir_normalized = dir / dist\n                    q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n                if not self._get_grid().is_agent_valid_pos(q_new_pos):\n                    continue\n\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                q_new = Vertex(q_new_pos)\n                q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                expanding_tree.add_edge(q_near, q_new)\n                new_vertices.append(q_new)\n                vertices_expanding.append(q_new)\n\n            # Try to connect newly added vertices in expanding_tree to closest in other_tree\n            connected = False\n            for v_new in new_vertices:\n                nearest_in_other = other_tree.get_nearest_vertex(vertices_other, v_new.position)\n                dist_between = Map.get_distance(v_new.position, nearest_in_other.position)\n                if dist_between <= self._connect_threshold:\n                    # Check if valid line path exists between trees' new vertices to connect\n                    line_seq = self._get_grid().get_line_sequence(v_new.position, nearest_in_other.position)\n                    if not self._get_grid().is_valid_line_sequence(line_seq):\n                        continue\n\n                    # Add connecting edge between v_new in expanding_tree and nearest_in_other in other_tree\n                    # This creates a combined path from start to goal\n                    # As Forest does not natively support cross edges, we merge vertices temporarily\n                    # We add edge v_new->nearest_in_other if expanding_tree == start_tree else vice versa\n                    if expanding_tree == start_tree:\n                        expanding_tree.add_edge(v_new, nearest_in_other)\n                    else:\n                        other_tree.add_edge(nearest_in_other, v_new)\n\n                    # Extract full path (bidirectional)\n                    self._extract_bidirectional_path(v_new if expanding_tree == start_tree else nearest_in_other,\n                                                    nearest_in_other if expanding_tree == start_tree else v_new,\n                                                    self._graph)\n\n                    connected = True\n                    break\n            if connected:\n                break\n\n            self._limit_graph_size()\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm combines systematic grid-aware A*-inspired heuristic guided sampling \n    with progressive subtree rewiring for fast convergence and robust connectivity. \n    \n    Key features:\n    - Uses a priority queue (min-heap) over vertices based on f = g + h costs for expansion.\n    - Samples new nodes biased towards frontier areas near current best paths (heuristic frontier sampling).\n    - Adaptive step length modulated by distance-to-goal and obstacle proximity.\n    - Incremental local rewiring within dynamically chosen neighborhoods to optimize paths.\n    - Early termination upon reaching goal within defined radius.\n    - Incorporates path smoothing via shortcutting on final extracted path.\n    - Enforces a global timeout of 10 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This algorithm combines systematic grid-aware A*-inspired heuristic guided sampling \n    with progressive subtree rewiring for fast convergence and robust connectivity. \n    \n    Key features:\n    - Uses a priority queue (min-heap) over vertices based on f = g + h costs for expansion.\n    - Samples new nodes biased towards frontier areas near current best paths (heuristic frontier sampling).\n    - Adaptive step length modulated by distance-to-goal and obstacle proximity.\n    - Incremental local rewiring within dynamically chosen neighborhoods to optimize paths.\n    - Early termination upon reaching goal within defined radius.\n    - Incorporates path smoothing via shortcutting on final extracted path.\n    - Enforces a global timeout of 10 seconds.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap = []               # Min-heap for frontier vertices (f = g + h)\n        self._max_iter = 6000         # Max iterations before timeout/failure\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0          # seconds limit\n        self._base_step = 12.0        # Base adaptive step distance\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 1200\n\n    def _heuristic(self, pos: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(pos, goal_pos)\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = self._heuristic(to_pos)\n        # Step shrinks near goal and obstacles to improve precision\n        max_step = self._base_step\n        # Reduce step near goal radius\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n        # Check obstacle proximity along direction, reduce step if near\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5  # Penalize invalid/obstacle-filled directions with smaller step\n        return max_step\n\n    def _get_new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _get_frontier_sample(self) -> Point:\n        # Sample near frontier vertices in the heap using Gaussian jitter to guide exploration\n        import random\n        import numpy as np\n        if not self._heap:\n            # fallback random valid sample in environment\n            for _ in range(50):\n                rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        f_min_vertex = self._heap[0][1]\n        base_pos = f_min_vertex.position\n\n        dim = self._get_grid().size.n_dim\n        std_dev = 8.0  # exploration jitter scale\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(self._get_grid().size[i]-1, int(round(val))))\n            jittered_coords.append(val)\n\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n        else:\n            # fallback to goal biased sampling for valid position\n            return self._get_goal_biased_sample()\n\n    def _goal_biased_sample(self) -> Point:\n        import random\n        # Slight goal bias for direct attraction but mostly frontier sampling is used\n        if random.random() < 0.2:\n            return self._get_grid().goal.position\n        else:\n            return self._get_frontier_sample()\n\n    def _choose_parent_and_cost(self, near_vertices, q_new: Vertex) -> Vertex:\n        # Choose best parent minimizing cost + heuristic\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        # Attempt local rewiring in neighbors to reduce path cost\n        for v in neighbors:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                # Remove all parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                # Additionally update costs downstream in DFS fashion to propagate gains\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            current = stack.pop()\n            for child in current.children:\n                new_cost = current.cost + self._cost(current, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_excess_vertices(self) -> None:\n        # Prune vertices with highest cost or furthest from goal when size exceeds limit\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n        # Ignore start and goal vertices\n        candidates = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        if not candidates:\n            return\n\n        # Sort primarily by distance to goal + cost descending to prune worst vertices\n        goal_pos = self._get_grid().goal.position\n        def prune_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n        candidates = sorted(candidates, key=prune_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n        start_f = self._heuristic(start_vertex.position)\n        self._heap = []\n        heapq.heappush(self._heap, (start_f, start_vertex))\n\n        visited_positions = set()\n        visited_positions.add(start_vertex.position)\n\n        start_time = time.time()\n\n        iterations = 0\n\n        while self._heap and iterations < self._max_iter:\n            iterations += 1\n\n            if time.time() - start_time > self._timeout:\n                # Timeout condition: no path found within time limit\n                break\n\n            _, current_vertex = heapq.heappop(self._heap)\n\n            # Early success check\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=current_vertex.position, goal=self._get_grid().goal):\n                # Connect to goal directly if possible\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(current_vertex.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = current_vertex.cost + self._cost(current_vertex, q_goal)\n                    self._graph.add_edge(current_vertex, q_goal)\n                    self._extract_path(q_goal)\n                break\n\n            # Generate new sample biased by current frontiers\n            q_sample_pos = self._goal_biased_sample()\n\n            # Find nearest vertex to sample in graph\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n\n            if q_near.position == q_sample_pos:\n                continue\n\n            adaptive_step = self._generate_adaptive_step(q_near.position, q_sample_pos)\n\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n\n            # Validate path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Prevent duplicating vertices in same position\n            if q_new.position in visited_positions:\n                continue\n\n            # Find local neighbors for cost computation and rewiring\n            rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback: connect to nearest if feasible\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_positions.add(q_new.position)\n\n            # Insert new vertex into the heap with f = g + h for future expansions\n            f_q_new = q_new.cost + self._heuristic(q_new.position)\n            heapq.heappush(self._heap, (f_q_new, q_new))\n\n            # Attempt local rewiring to optimize paths close to q_new\n            self._rewire_locally(q_new, near_vertices)\n\n            # Prune excess vertices for memory and speed\n            self._prune_excess_vertices()\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved sample-based planner inspired by RRT* and heuristic-guided planning.\n    It combines goal-biased adaptive sampling, cost-to-come plus heuristic (A*-like) guided vertex expansion,\n    adaptive step size based on distance to goal, and rewiring for path optimization.\n    Additionally, it performs shortcut smoothing on the final path for better path quality.\n    It terminates early when a path within threshold cost is found or after 10 seconds timeout.\n    This design aims for faster convergence to high-quality paths with better robustness and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring edges for optimization\n        self._init_displays()\n\n        # Additional members for adaptive step sizing and timing\n        self._max_dist_base = 10.0\n        self._goal_sample_rate = 0.2  # 20% bias sampling directly towards goal\n        self._rewire_radius = 15.0\n\n    def _get_adaptive_max_dist(self, from_pos: Point) -> float:\n        \"\"\"Adaptive step size: smaller near goal, larger far away.\"\"\"\n        dist_to_goal = self._get_grid().get_distance(from_pos, self._get_grid().goal.position)\n        max_dist = min(self._max_dist_base, max(3.0, dist_to_goal / 2))\n        return max_dist\n\n    def _choose_parent_and_rewire(self, q_new: Vertex, neighbors: list[Vertex]) -> Vertex:\n        \"\"\"Choose the best parent from neighbors based on cost + movement cost, and rewire neighbors if beneficial.\"\"\"\n        best_parent = None\n        best_cost = float('inf')\n        g_grid = self._get_grid()\n\n        # Choose best parent for q_new\n        for q_near in neighbors:\n            line_seq = g_grid.get_line_sequence(q_near.position, q_new.position)\n            if not g_grid.is_valid_line_sequence(line_seq):\n                continue\n            move_cost = g_grid.get_movement_cost(q_near.position, q_new.position)\n            cost_candidate = q_near.cost + move_cost\n            if cost_candidate < best_cost:\n                best_cost = cost_candidate\n                best_parent = q_near\n\n        if best_parent is None:\n            return None  # no valid parent, reject q_new\n\n        # Set q_new cost and add edge to best parent\n        q_new.cost = best_cost\n        self._graph.add_edge(best_parent, q_new)\n\n        # Rewire neighbors for optimization if cost improves\n        for q_near in neighbors:\n            if q_near == best_parent:\n                continue\n            line_seq = g_grid.get_line_sequence(q_new.position, q_near.position)\n            if not g_grid.is_valid_line_sequence(line_seq):\n                continue\n            move_cost = g_grid.get_movement_cost(q_new.position, q_near.position)\n            new_cost = q_new.cost + move_cost\n            if new_cost < q_near.cost:\n                # Rewire: remove old edges, add new edge from q_new to q_near\n                # Since Forest edges are directed, remove all parents edges for q_near and add new one\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                q_near.cost = new_cost\n                self._graph.add_edge(q_new, q_near)\n\n        return q_new\n\n    def _get_random_sample(self) -> Point:\n        g_grid = self._get_grid()\n        # Goal biased sampling\n        if np.random.rand() < self._goal_sample_rate:\n            goal_pos = g_grid.goal.position\n            # Perturb goal position within small radius (3) to avoid too deterministic\n            dx = np.random.randint(-3, 4)\n            dy = np.random.randint(-3, 4) if g_grid.size.n_dim > 1 else 0\n            # Clamp within grid bounds\n            pos = Point(\n                max(0, min(g_grid.size.x - 1, goal_pos.x + dx)),\n                max(0, min(g_grid.size.y - 1, goal_pos.y + dy)) if g_grid.size.n_dim > 1 else goal_pos.y\n            )\n            if g_grid.is_agent_valid_pos(pos):\n                return pos\n        # Uniform random sampling otherwise\n        while True:\n            rand_pos = np.random.randint(0, g_grid.size, g_grid.size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if g_grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_end: Vertex) -> None:\n        \"\"\"\n        Extracts and smooths the path then moves the agent along the path with key frames.\n        \"\"\"\n        g_grid = self._get_grid()\n        path = []\n        current = q_end\n\n        # Backtrack to start\n        while current.parents:\n            path.append(current)\n            current = next(iter(current.parents))\n        path.append(current)  # Add start vertex\n        path.reverse()\n\n        # Shortcut smoothing: attempt to shortcut between non-adjacent vertices if path valid\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = g_grid.get_line_sequence(path[idx].position, path[test_idx].position)\n                if g_grid.is_valid_line_sequence(line_seq):\n                    next_idx = test_idx\n                    break\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n\n        # Move agent along smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        g_grid = self._get_grid()\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        max_iterations = 10000\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n\n        for i in range(max_iterations):\n            # Stop if timeout >10s\n            if time.time() - start_time > 10.0:\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            # New vertex is towards q_sample bounded by max_dist\n            direction = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(direction)\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                direction_normalized = direction / dist\n                new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            q_new = Vertex(q_new_pos)\n\n            # Check if valid edge from nearest to new\n            line_seq = g_grid.get_line_sequence(q_near.position, q_new.position)\n            if not g_grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within radius for rewiring\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n\n            # Choose parent & rewire if possible\n            q_new_with_parent = self._choose_parent_and_rewire(q_new, neighbors)\n            if not q_new_with_parent:\n                continue\n\n            # Add q_new_with_parent vertex to forest root vertices list if needed\n            if q_new_with_parent not in self._graph.root_vertices:\n                self._graph.root_vertices.append(q_new_with_parent)\n\n            # Check if q_new is close enough to goal to connect\n            dist_to_goal = g_grid.get_distance(q_new.position, g_grid.goal.position)\n            if dist_to_goal <= self._max_dist_base:\n                # Check if connection to goal is valid\n                line_seq_goal = g_grid.get_line_sequence(q_new.position, g_grid.goal.position)\n                if g_grid.is_valid_line_sequence(line_seq_goal):\n                    # Create goal vertex and link\n                    goal_v = Vertex(g_grid.goal.position)\n                    move_cost = g_grid.get_movement_cost(q_new.position, goal_v.position)\n                    goal_v.cost = q_new_with_parent.cost + move_cost\n                    self._graph.add_edge(q_new_with_parent, goal_v)\n\n                    # Mark as found path if cost improved\n                    if goal_v.cost < best_goal_cost:\n                        best_goal_cost = goal_v.cost\n                        best_goal_vertex = goal_v\n                        # Add to root vertices to include in graph traversal\n                        if goal_v not in self._graph.root_vertices:\n                            self._graph.root_vertices.append(goal_v)\n\n            # Early stopping if path found with reasonable cost (e.g. less or equal to heuristic straight line cost)\n            if best_goal_vertex is not None:\n                heuristic_cost = g_grid.get_distance(g_grid.agent.position, g_grid.goal.position)\n                if best_goal_cost <= heuristic_cost * 1.1:  # 10% margin\n                    break\n\n            self.key_frame()\n\n        # If path found, extract, smooth and animate it\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)\n        else:\n            # No path found - optionally handle fail state or keep agent at start\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Heuristic-Driven Bidirectional RRT* with Adaptive Sampling and Path Refinement.\n\n    This algorithm grows two trees simultaneously from the start and goal, improving robustness\n    by exploring from both ends. It uses heuristic-guided sampling with an adaptive bias that \n    increases goal-directed samples as progress is made. New vertices are created by stepping \n    adaptively towards samples, constrained by obstacle checks. Rewiring is applied locally \n    within a radius decreasing over time, balancing exploration and path cost improvement. \n    Once the trees connect, the path is extracted from the connection point, then shortcut \n    smoothed for quality. An early stopping condition stops the search after connection or a \n    timeout (~10s). This algorithm targets improved success rate, efficiency, and path quality \n    by combining bidirectional search with RRT*-like optimization and heuristic-driven sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        start_vertex = Vertex(grid.agent.position)\n        goal_vertex = Vertex(grid.goal.position)\n        # Using CyclicGraph as it supports edges being added both ways and rewiring\n        self._graph = CyclicGraph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Adaptive parameters\n        self._max_dist_base = 20.0\n        self._goal_bias_start = 0.10\n        self._goal_bias_end = 0.40\n        self._rewire_radius_start = 20.0\n        self._rewire_radius_min = 5.0\n        self._max_iterations = 7000\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _choose_best_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        best_parent = None\n        min_cost = float('inf')\n        grid = self._get_grid()\n        for v in near_vertices:\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire_nearby(self, near_vertices: list, q_new: Vertex) -> None:\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_bidirectional_path(self, connect_v_start: Vertex, connect_v_goal: Vertex) -> None:\n        # Extract path from start tree root to connection vertex\n        path_start = [connect_v_start]\n        curr = connect_v_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            curr = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n        path_start.reverse()\n\n        # Extract path from goal tree root to connection vertex\n        path_goal = [connect_v_goal]\n        curr = connect_v_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            curr = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n\n        # Full path is start path + reversed goal path excluding the connection repeated point\n        full_path = path_start + path_goal[1:]\n\n        path_smoothed = self._shortcut_path(full_path)\n\n        # Move agent along path with key frames\n        for v in path_smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_goal_bias(self, iteration: int) -> float:\n        # Linearly interpolate goal bias from start to end over max iterations\n        frac = iteration / self._max_iterations\n        bias = self._goal_bias_start + frac * (self._goal_bias_end - self._goal_bias_start)\n        return bias\n\n    def _adaptive_rewire_radius(self, iteration: int) -> float:\n        # Decrease rewiring radius linearly with iteration count\n        radius = self._rewire_radius_start * (1.0 - iteration / self._max_iterations)\n        return max(radius, self._rewire_radius_min)\n\n    def _goal_biased_sample(self, for_start_tree: bool, iteration: int) -> Point:\n        \"\"\"\n        Sample with adaptive bias towards goal or start depending on which tree\n        to encourage expansion towards opposite tree\n        \"\"\"\n        import random\n        grid = self._get_grid()\n        if random.random() < self._adaptive_goal_bias(iteration):\n            return grid.goal.position if for_start_tree else grid.agent.position\n\n        attempts = 0\n        max_attempts = 50\n        while attempts < max_attempts:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n\n        # fallback if sampling failed repeatedly\n        return grid.goal.position if for_start_tree else grid.agent.position\n\n    def _connect_trees(self, q_new: Vertex, other_tree_roots: list, connection_radius: float) -> Vertex:\n        \"\"\"\n        Try to connect q_new vertex to the other tree within connection radius.\n        Return the connection vertex from other tree if successful, else None.\n        \"\"\"\n        grid = self._get_grid()\n        near_other = self._graph.get_vertices_within_radius(other_tree_roots, q_new.position, connection_radius)\n        for v in near_other:\n            line_seq = grid.get_line_sequence(q_new.position, v.position)\n            if grid.is_valid_line_sequence(line_seq):\n                return v\n        return None\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        grid = self._get_grid()\n        start_time = time.time()\n\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n        root_start.cost = 0.0\n        root_goal.cost = 0.0\n\n        # Maintain two sets of vertices representing two trees\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        max_dist_base = self._max_dist_base\n        max_iterations = self._max_iterations\n        connection_radius = 10.0\n\n        # Alternate expansion between start tree and goal tree\n        expand_start_tree = True\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout condition\n                break\n\n            # Alternate sampling tree\n            if expand_start_tree:\n                q_sample = self._goal_biased_sample(True, iteration)\n                nearest_tree = tree_start\n                other_tree = tree_goal\n            else:\n                q_sample = self._goal_biased_sample(False, iteration)\n                nearest_tree = tree_goal\n                other_tree = tree_start\n\n            # Get nearest vertex in the tree to sample\n            q_near = self._graph.get_nearest_vertex(nearest_tree, q_sample)\n            if q_near.position == q_sample:\n                expand_start_tree = not expand_start_tree\n                self.key_frame()\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            # Adaptive step size reduced closer to goal or over iterations for precision\n            step_scale = 0.5 + 0.5 * (1 - min(q_near.cost / 100.0, 1.0))\n            adaptive_step = min(max_dist_base, dist_to_sample) * step_scale\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                expand_start_tree = not expand_start_tree\n                self.key_frame()\n                continue\n\n            # Prepare near vertices for parent choosing and rewiring\n            cur_rewire_radius = self._adaptive_rewire_radius(iteration)\n            near_vertices = self._graph.get_vertices_within_radius(nearest_tree, q_new.position, cur_rewire_radius)\n\n            # Choose best parent for q_new among near_vertices\n            best_parent = self._choose_best_parent(near_vertices, q_new)\n            if best_parent is None:\n                # fallback - if no better parent found use q_near if valid\n                cost_fallback = q_near.cost + self._cost(q_near, q_new)\n                q_new.cost = cost_fallback\n                best_parent = q_near\n\n            self._graph.add_edge(best_parent, q_new)\n            nearest_tree.append(q_new)\n\n            # Rewiring near vertices to q_new if improves cost\n            self._rewire_nearby(near_vertices, q_new)\n\n            # Try to connect to other tree within connection radius\n            connection_vertex = self._connect_trees(q_new, other_tree, connection_radius)\n            if connection_vertex:\n                # Connect the trees\n                self._graph.add_edge(q_new, connection_vertex)\n\n                # Extract and move the path from start to goal through the connecting vertices\n                if expand_start_tree:\n                    self._extract_bidirectional_path(q_new, connection_vertex)\n                else:\n                    self._extract_bidirectional_path(connection_vertex, q_new)\n                break\n\n            expand_start_tree = not expand_start_tree\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm combines elements of RRT* exploration with heuristic-guided graph pruning and multi-step lookahead expansions to improve planning efficiency and path quality.\n    It iteratively grows a forest with goal-biased and heuristic-informed sampling, but instead of single-step extension, it generates multiple candidate expansions per iteration.\n    For each new vertex, it performs a heuristic cost evaluation using an A*-style cost-to-go estimate with obstacle-aware movement cost, then selectively rewires the graph locally to optimize paths.\n    A limited \"beam\" of best expansions are retained per iteration to focus computational effort on promising branches while discarding low-quality expansions early.\n    The algorithm also dynamically adapts extension step sizes according to local obstacle density to maintain progress in cluttered and open regions.\n    Early stopping is triggered upon discovering a valid goal path with satisfying cost quality, capped by a maximum 10-second runtime, ensuring responsive search termination.\n    Path shortcutting employs multi-point jumps ahead for smoother extracted routes. \n    This controlled expansion and pruning mechanism balances exploration with exploitation and refines path quality beyond classical RRT* variations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 12.0\n        self._goal_bias = 0.15\n        self._rewire_radius = 18.0\n        self._beam_width = 5          # Number of candidates to retain per iteration\n        self._multi_step = 3          # Number of steps to try extending each sampled expansion\n\n    def _heuristic_cost(self, frm: Vertex, to: Vertex) -> float:\n        # Estimation: cost so far + euclidean distance heuristic to goal\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        heuristic = Map.get_distance(to.position, self._get_grid().goal.position)\n        return frm.cost + dist + move_cost + heuristic * 0.9  # heuristic weighted below actual cost\n\n    def _adaptive_max_dist(self, position: Point) -> float:\n        # Adaptive step size based on local obstacle density around position\n        grid = self._get_grid()\n        obstacle_count = 0\n        check_radius = 5  # points to check around\n\n        for dx in range(-check_radius, check_radius + 1):\n            for dy in range(-check_radius, check_radius + 1):\n                for dz in range(0, grid.size.n_dim > 2 and check_radius * 2 + 1 or 1):\n                    candidate = Point(position.x + dx, position.y + dy)\n                    if grid.size.n_dim == 3:\n                        candidate = Point(position.x + dx, position.y + dy, position.z + dz)\n                    if not grid.is_agent_valid_pos(candidate):\n                        obstacle_count += 1\n                        if obstacle_count > (check_radius ** 2) * 3:  # threshold\n                            return max(6.0, self._max_dist_base / 2)\n        return self._max_dist_base\n\n    def _get_goal_biased_or_heuristic_sample(self) -> Point:\n        import random\n\n        # 15% chance sample goal directly\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n\n        # 35% chance sample near best existing vertex towards goal (heuristic bias)\n        if random.random() < 0.35 and self._graph.size > 0:\n            start_vertices = [self._graph.root_vertex_start]\n            best_vertex = None\n            best_score = float('inf')\n            goal_pos = self._get_grid().goal.position\n            \n            for _ in range(20):\n                candidate = self._get_random_sample()\n                nearest = self._graph.get_nearest_vertex(start_vertices, candidate)\n                score = nearest.cost + Map.get_distance(candidate, goal_pos)\n                if score < best_score:\n                    best_score = score\n                    best_vertex = candidate\n            return best_vertex if best_vertex is not None else self._get_random_sample()\n        \n        # Else uniform random valid sample\n        return self._get_random_sample()\n    \n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = tuple(int(v) for v in np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim))\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_norm)\n        return Vertex(new_pos)\n\n    def _choose_best_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _rewire_nearby(self, near_vertices: list, q_new: Vertex) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _multi_step_expand(self, q_start: Vertex, target: Point, steps: int, max_dist_base: float):\n        # Attempt multi-step expansions towards target with adaptive max_dist, yielding viable new vertices\n        expansions = []\n        last_vertex = q_start\n        for step_i in range(steps):\n            max_dist = self._adaptive_max_dist(last_vertex.position)\n            q_new = self._get_new_vertex(last_vertex, target, max_dist)\n            if q_new.position == last_vertex.position:\n                break\n            line_seq = self._get_grid().get_line_sequence(last_vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                break\n            q_new.cost = last_vertex.cost + self._cost(last_vertex, q_new)\n            expansions.append((last_vertex, q_new))\n            last_vertex = q_new\n        return expansions\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Collect path back to start via best cost parent\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path.append(current)\n        path.reverse()\n\n        # Multi-point shortcutting for better smoothing\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = min(i + 3, len(path) - 1)\n            while j > i:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            if j == i:\n                i += 1  # fallback to next if no shortcut found\n\n        for vertex in shortcut_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_time = time.time()\n        max_runtime = 10.0\n        max_iterations = 8000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_pos = self._get_grid().goal.position\n\n        frontier = [(0.0, start_vertex)]  # priority queue: (priority cost, Vertex)\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > max_runtime:\n                break\n\n            candidates = []\n            # Sample a batch of points to expand towards (beam sampling)\n            for _ in range(10):\n                sample = self._get_goal_biased_or_heuristic_sample()\n                nearest_vertex = self._graph.get_nearest_vertex([start_vertex], sample)\n\n                expansions = self._multi_step_expand(nearest_vertex, sample, self._multi_step, self._max_dist_base)\n                for parent, new_vertex in expansions:\n                    if new_vertex.position == parent.position:\n                        continue\n                    if any(v.position == new_vertex.position for v in self._graph.root_vertices):\n                        continue\n                    # Store combined heuristic cost as priority\n                    total_cost = self._heuristic_cost(parent, new_vertex)\n                    candidates.append((total_cost, parent, new_vertex))\n\n            # Keep only top beam_width expansions based on heuristic cost\n            if not candidates:\n                self.key_frame()\n                continue\n            candidates.sort(key=lambda x: x[0])\n            top_candidates = candidates[:self._beam_width]\n\n            added_vertices = []\n\n            for total_cost, parent, q_new in top_candidates:\n                near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n                best_parent = self._choose_best_parent(near_vertices, q_new)\n                if best_parent is None:\n                    # fallback to parent if valid\n                    line_seq = self._get_grid().get_line_sequence(parent.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        q_new.cost = parent.cost + self._cost(parent, q_new)\n                        best_parent = parent\n                    else:\n                        continue\n                self._graph.add_edge(best_parent, q_new)\n                added_vertices.append(q_new)\n\n                self._rewire_nearby(near_vertices, q_new)\n\n                # Check goal reached early\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                    q_goal = Vertex(goal_pos)\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                        q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                        self._graph.add_edge(q_new, q_goal)\n                        self._extract_path(q_goal)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Enhanced Bi-Directional RRT* inspired algorithm integrating:\n    - Bidirectional growth from both start and goal vertices to improve connection chances and reduce search space.\n    - Adaptive step sizes influenced by proximity to obstacles and goal for safer and more precise expansions.\n    - Heuristic-driven sampling with goal bias and guided samples towards less-explored frontier regions.\n    - Local rewiring within neighborhoods to optimize path cost (RRT* style).\n    - Early stopping upon connection or timeout (10 seconds).\n    - Path extraction with geodesic shortcut smoothing for higher quality, shorter paths.\n    - Utilizes Forest structure supporting two root vertices for efficient bidirectional graph growth.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    Enhanced Bi-Directional RRT* inspired algorithm integrating:\n    - Bidirectional growth from both start and goal vertices to improve connection chances and reduce search space.\n    - Adaptive step sizes influenced by proximity to obstacles and goal for safer and more precise expansions.\n    - Heuristic-driven sampling with goal bias and guided samples towards less-explored frontier regions.\n    - Local rewiring within neighborhoods to optimize path cost (RRT* style).\n    - Early stopping upon connection or timeout (10 seconds).\n    - Path extraction with geodesic shortcut smoothing for higher quality, shorter paths.\n    - Utilizes Forest structure supporting two root vertices for efficient bidirectional graph growth.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Initialize bidirectional forest with start and goal root vertices\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_iterations = 4000\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0  # seconds\n\n        self._base_step = 14.0\n        self._rewire_radius = 12.0\n        self._visited_positions = set()\n        import heapq\n        self._forward_heap = []  # For start tree expansion: min-heap by f=g+h\n        self._backward_heap = [] # For goal tree expansion: min-heap by f=g+h\n\n    def _heuristic(self, pos: Point, target: Point) -> float:\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = self._heuristic(to_pos, self._get_grid().goal.position)\n        max_step = self._base_step\n        if dist_to_goal < 15.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 15.0)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.4\n        return max_step\n\n    def _new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos = Point.from_tensor(start.to_tensor() + direction * max_step)\n        return Vertex(new_pos)\n\n    def _random_sample(self, bias_pos: Point = None, bias_prob: float = 0.2) -> Point:\n        import random\n        import numpy as np\n        if bias_pos is not None and random.random() < bias_prob:\n            # Slight Gaussian jitter from biased position for focused exploration\n            std_dev = 6.0\n            jittered_coords = []\n            for i in range(self._get_grid().size.n_dim):\n                jitter = random.gauss(0, std_dev)\n                val = bias_pos[i] + jitter\n                val = max(0, min(self._get_grid().size[i] - 1, int(round(val))))\n                jittered_coords.append(val)\n            candidate = Point(*jittered_coords)\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n        # Otherwise uniform random sampling\n        for _ in range(100):\n            rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            candidate = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n        # As fallback, return goal position\n        return self._get_grid().goal.position\n\n    def _choose_parent_and_cost(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            tentative_cost = v.cost + self._edge_cost(v, q_new)\n            if tentative_cost < min_cost:\n                min_cost = tentative_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _edge_cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _rewire_neighborhood(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v == q_new or v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._edge_cost(q_new, v)\n            if new_cost < v.cost:\n                # Remove all parents to keep graph simple\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost(v)\n\n    def _propagate_cost(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._edge_cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _extract_bidirectional_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        # Extract path from start root to connection_vertex_start\n        path_start = [connection_vertex_start]\n        curr = connection_vertex_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            curr = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n        path_start.reverse()\n\n        # Extract path from goal root to connection_vertex_goal\n        path_goal = [connection_vertex_goal]\n        curr = connection_vertex_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            curr = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n\n        full_path = path_start + path_goal\n\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        grid = self._get_grid()\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        self._visited_positions = set()\n        self._visited_positions.add(start_v.position)\n        self._visited_positions.add(goal_v.position)\n\n        self._forward_heap.clear()\n        self._backward_heap.clear()\n\n        f_start = self._heuristic(start_v.position, goal_v.position)\n        f_goal = self._heuristic(goal_v.position, start_v.position)\n\n        heapq.heappush(self._forward_heap, (f_start, start_v))\n        heapq.heappush(self._backward_heap, (f_goal, goal_v))\n\n        start_time = time.time()\n        max_iter = self._max_iterations\n\n        # To track vertices per tree by position for connectivity checking\n        forward_vertices = {start_v.position: start_v}\n        backward_vertices = {goal_v.position: goal_v}\n\n        connected_vertex_start = None\n        connected_vertex_goal = None\n\n        for iteration in range(max_iter):\n            if time.time() - start_time > self._timeout:\n                break\n\n            # Alternate expansion between forward and backward trees\n            # Expand forward tree\n            if self._forward_heap:\n                _, current = heapq.heappop(self._forward_heap)\n                sample_pos = self._random_sample(bias_pos=goal_v.position, bias_prob=0.15)\n                q_new = self._expand_tree(current, sample_pos, forward_vertices, backward_vertices, True)\n                if q_new:\n                    if q_new.position in backward_vertices:\n                        # Path connected\n                        connected_vertex_start = q_new\n                        connected_vertex_goal = backward_vertices[q_new.position]\n                        break\n\n            if time.time() - start_time > self._timeout:\n                break\n\n            # Expand backward tree\n            if self._backward_heap:\n                _, current = heapq.heappop(self._backward_heap)\n                sample_pos_b = self._random_sample(bias_pos=start_v.position, bias_prob=0.15)\n                q_new_b = self._expand_tree(current, sample_pos_b, backward_vertices, forward_vertices, False)\n                if q_new_b:\n                    if q_new_b.position in forward_vertices:\n                        # Path connected\n                        connected_vertex_start = forward_vertices[q_new_b.position]\n                        connected_vertex_goal = q_new_b\n                        break\n\n            self.key_frame()\n\n        if connected_vertex_start and connected_vertex_goal:\n            self._extract_bidirectional_path(connected_vertex_start, connected_vertex_goal)\n\n    def _expand_tree(self, current: Vertex, sample_pos: Point,\n                     tree_vertices: dict, other_tree_vertices: dict, is_forward: bool) -> Vertex or None:\n        adaptive_step = self._adaptive_step(current.position, sample_pos)\n        q_new = self._new_vertex_on_line(current.position, sample_pos, adaptive_step)\n\n        if q_new.position in self._visited_positions:\n            return None\n\n        line_seq = self._get_grid().get_line_sequence(current.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        # Find near neighbors for rewiring\n        neighbors = self._graph.get_vertices_within_radius(list(tree_vertices.values()), q_new.position, self._rewire_radius)\n        best_parent = self._choose_parent_and_cost(neighbors, q_new)\n        if best_parent is None:\n            # Fallback: attach directly to current if possible\n            if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(current.position, q_new.position)):\n                q_new.cost = current.cost + self._edge_cost(current, q_new)\n                best_parent = current\n            else:\n                return None\n        self._graph.add_edge(best_parent, q_new)\n        tree_vertices[q_new.position] = q_new\n        self._visited_positions.add(q_new.position)\n\n        f_val = q_new.cost + self._heuristic(q_new.position, self._get_grid().goal.position if is_forward else self._get_grid().agent.position)\n        if is_forward:\n            heapq.heappush(self._forward_heap, (f_val, q_new))\n        else:\n            heapq.heappush(self._backward_heap, (f_val, q_new))\n\n        # Rewire locally for path cost improvements\n        self._rewire_neighborhood(q_new, neighbors)\n\n        return q_new",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* inspired planner that enhances the provided RRT baseline by:\n    - Employing goal-biased sampling to direct exploration towards the goal with a certain probability.\n    - Using an adaptive max step size that shortens near the goal to improve connection quality.\n    - Incorporating rewiring (RRT* style) to optimize cost by connecting new vertices through lower-cost nearby vertices.\n    - Performing path shortcutting at the end for smoother, shorter paths.\n    - Imposing a 10 seconds time limit to ensure timely planning.\n    These improvements lead to more efficient exploration, higher success rate, better path quality, and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_time_sec: float\n    _goal_sample_rate: float\n    _max_dist_init: float\n    _rewire_radius_factor: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True   # Allow edge rewiring\n        \n        # Parameters for adaptive and improved sampling\n        self._max_time_sec = 10.0            # maximum allowed planning time in seconds\n        self._goal_sample_rate = 0.1         # 10% goal bias for sampling\n        self._max_dist_init = 14.0           # initial max step size\n        self._rewire_radius_factor = 20.0    # radius factor for rewiring (depends on environment size)\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"Adaptive max_dist reduces near goal for finer connections.\"\"\"\n        dist_to_goal = self._get_grid().get_distance(pos, self._get_grid().goal.position)\n        max_dist = max(4.0, min(self._max_dist_init, dist_to_goal / 2.0))\n        return max_dist\n\n    def _get_goal_biased_sample(self) -> Point:\n        \"\"\"Sample with goal bias: with probability goal_sample_rate sample the goal directly.\"\"\"\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _choose_parent(self, q_near_candidates: List[Vertex], q_new_pos: Point) -> Vertex:\n        \"\"\"Choose parent with minimal cost + cost(q_parent->q_new).\"\"\"\n        min_cost = float(\"inf\")\n        best_parent = None\n        for q_near in q_near_candidates:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost_to_new = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new_pos)\n                if cost_to_new < min_cost:\n                    min_cost = cost_to_new\n                    best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbor_vertices: List[Vertex]):\n        \"\"\"Try to improve neighboring vertices' costs via q_new.\"\"\"\n        for q_near in neighbor_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                # Remove old parent edge(s)\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_near)\n                # Update cost and propagate cost update downstream\n                def update_costs(vertex: Vertex, current_cost: float):\n                    vertex.cost = current_cost\n                    for child in vertex.children:\n                        ccost = current_cost + self._get_grid().get_movement_cost(vertex.position, child.position)\n                        update_costs(child, ccost)\n                update_costs(q_near, cost_through_new)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Shortcut path by attempting to connect further vertices directly.\"\"\"\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, just go to next vertex\n                shortcut_path.append(path[i+1])\n                i += 1\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"Extract path from q_new to start and perform smoothing (shortcutting).\"\"\"\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            # Choose parent with minimum cost (best parent)\n            min_c = float(\"inf\")\n            chosen_parent = None\n            for parent in path[-1].parents:\n                if parent.cost < min_c:\n                    min_c = parent.cost\n                    chosen_parent = parent\n            path.append(chosen_parent)\n\n        del path[-1]  # remove start's parent placeholder (None)\n        path.reverse()\n\n        # Shortcut path for smoothing\n        smooth_path = self._shortcut_path(path)\n\n        # Animate smooth path\n        for p in smooth_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        from random import uniform\n\n        start_time = time.time()\n        max_iterations = 10000\n        grid = self._get_grid()\n\n        # Initialize start vertex cost\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(max_iterations):\n            if (time.time() - start_time) > self._max_time_sec:\n                # Timeout: failed to find path in allowed time\n                break\n\n            q_sample: Point = self._get_goal_biased_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            q_new_vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            q_new = q_new_vertex.position\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors for parent selection and rewiring\n            # Radius depends on problem size and iteration (standard RRT* heuristic)\n            dim = grid.size.n_dim\n            r = min(self._rewire_radius_factor * (np.log(i + 2) / (i + 1))**(1/dim), max_dist)\n            neighbors: List[Vertex] = self._graph.get_vertices_within_radius([start_vertex], q_new, r)\n            if not neighbors:\n                neighbors = [q_near]\n\n            parent = self._choose_parent(neighbors, q_new)\n            if parent is None:\n                parent = q_near\n\n            q_new_vertex.cost = parent.cost + grid.get_movement_cost(parent.position, q_new)\n            self._graph.add_edge(parent, q_new_vertex)\n\n            # Rewire neighbors to optimize path costs around q_new\n            self._rewire(q_new_vertex, neighbors)\n\n            # Check goal condition\n            if grid.is_agent_in_goal_radius(agent_pos=q_new):\n                self._extract_path(q_new_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An enhanced RRT*-inspired path planner that integrates heuristic-guided sampling,\n    dynamic adaptive step sizes based on heuristic cost-to-go estimates (using Euclidean distance),\n    and an improved rewiring strategy restricted to a variable radius shrinking over iterations.\n    The algorithm uses a goal bias and introduces informed sampling within an ellipsoidal heuristic\n    region to focus exploration towards promising paths. Memory is managed by dynamically pruning\n    high-cost vertices using heuristic and cost-based metrics. Early stopping occurs upon reaching\n    the goal within a defined radius or timeout (~10s). Extracted paths are shortcut-smoothed for\n    improved final path quality and practical trajectory usage.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An enhanced RRT*-inspired path planner that integrates heuristic-guided sampling,\n    dynamic adaptive step sizes based on heuristic cost-to-go estimates (using Euclidean distance),\n    and an improved rewiring strategy restricted to a variable radius shrinking over iterations.\n    The algorithm uses a goal bias and introduces informed sampling within an ellipsoidal heuristic\n    region to focus exploration towards promising paths. Memory is managed by dynamically pruning\n    high-cost vertices using heuristic and cost-based metrics. Early stopping occurs upon reaching\n    the goal within a defined radius or timeout (~10s). Extracted paths are shortcut-smoothed for\n    improved final path quality and practical trajectory usage.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 20.0          # Increased base max step for faster expansion\n        self._goal_bias = 0.2               # Slightly higher goal bias for quicker goal sampling\n        self._rewire_radius = 20.0          # Shrinking rewire radius\n        self._vertex_limit = 1200            # Slightly tighter limit for improved memory\n        self._informed_sampling_enabled = True  # Enable heuristic-informed sampling\n\n    def _euclidean_distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _heuristic_cost(self, vertex: Vertex, goal_pos: Point) -> float:\n        # Use Euclidean distance from vertex to goal as heuristic\n        return self._euclidean_distance(vertex.position, goal_pos)\n\n    def _get_adaptive_step_size(self, q_near: Vertex, q_sample: Point, iteration: int, max_iterations: int) -> float:\n        dist_to_sample = self._euclidean_distance(q_near.position, q_sample)\n        base_step = min(self._max_dist_base, dist_to_sample)\n        # Adapt step smaller as iteration progresses, encourage finer exploration near goal\n        factor = 0.5 + 0.5 * (1 - iteration / max_iterations)\n        # Reduce step if near high cost or near goal\n        cost_factor = 0.7 + 0.3 * (1 - min(q_near.cost / 100.0, 1.0))\n        return base_step * factor * cost_factor\n\n    def _informed_sample(self, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Informed sampling in an ellipsoidal region between start and goal to guide sampling.\n        If informed sampling is disabled or fails, falls back to uniform random or goal biased.\n        \"\"\"\n        import random\n        if random.random() < self._goal_bias:\n            return goal\n\n        c_best = self._euclidean_distance(start, goal)\n        c_min = c_best\n        if c_best == 0:\n            return goal\n\n        # Define ellipse major axis unit vector\n        dx = goal.x - start.x\n        dy = goal.y - start.y\n        dz = 0\n        if hasattr(start, 'z'):\n            dz = goal.z - start.z\n        n_dim = len(start.to_tensor())\n        center_coords = [(start.x + goal.x) / 2, (start.y + goal.y) / 2]\n        if n_dim > 2:\n            center_coords.append((start.z + goal.z) / 2)\n        center = Point(*center_coords)\n\n        # Rotation matrix aligning x-axis to vector from start to goal (for 2D / 3D)\n        # For simple 2D, rotation is simple, for nD approx identity (since we do only sampling axis-aligned)\n        direction = goal.to_tensor() - start.to_tensor()\n        norm_dir = torch.norm(direction)\n        if norm_dir == 0:\n            return goal\n        direction_unit = direction / norm_dir\n\n        # Radii for ellipse based on c_best (current best path cost) and heuristic\n        # Large radii for dimensions other than start-goal axis\n        r1 = c_best / 2\n        r_others = (c_best ** 2 - c_min ** 2) ** 0.5 / 2 if c_best > c_min else r1\n\n        attempts = 0\n        max_attempts = 30\n        while attempts < max_attempts:\n            # Sample random point in unit n-ball scaled by ellipse radii\n            if n_dim == 2:\n                # Sample in unit circle\n                theta = random.uniform(0, 2 * 3.1415926)\n                r = random.uniform(0, 1) ** 0.5\n                sample_x = r * r1 * torch.cos(torch.tensor(theta)).item()\n                sample_y = r * r_others * torch.sin(torch.tensor(theta)).item()\n                # Rotate and translate back\n                rot_x = sample_x * direction_unit[0] + sample_y * -direction_unit[1]\n                rot_y = sample_x * direction_unit[1] + sample_y * direction_unit[0]\n                sampled_point_coords = [\n                    center.x + rot_x,\n                    center.y + rot_y\n                ]\n                sample = Point(*map(int, map(round, sampled_point_coords)))\n            else:\n                # For nD, sample axis-aligned approx ellipsoid box\n                sample_coords = []\n                for i in range(n_dim):\n                    r = random.uniform(-1, 1)\n                    radius = r1 if i == 0 else r_others\n                    sample_coords.append(int(round(center.to_tensor()[i].item() + r * radius)))\n                sample = Point(*sample_coords)\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n\n        # Fallback to random or goal sample in case of failure\n        return self._get_goal_biased_sample()\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            # Add heuristic cost to total cost for better A* style parent choice\n            heuristic_to_goal = self._heuristic_cost(q_new, self._get_grid().goal.position)\n            total_cost = cost + heuristic_to_goal * 0.3  # weight 0.3 to heuristic\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        goal_pos = self._get_grid().goal.position\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew + self._heuristic_cost(v, goal_pos)*0.3 < v.cost:\n                # Remove all existing parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _limit_graph_size(self) -> None:\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Sort by combined cost plus heuristic for better pruning choice\n        goal_pos = self._get_grid().goal.position\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        vertices = sorted(vertices, key=lambda v: v.cost + self._heuristic_cost(v, goal_pos), reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        min_radius = 6.0\n        radius = self._rewire_radius * (1.0 - iteration / max_iterations)\n        return max(radius, min_radius)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Apply enhanced shortcut smoothing with multiple passes\n        def shortcut_path_multistep(path: list, passes: int = 3) -> list:\n            for _ in range(passes):\n                shortcut_path = [path[0]]\n                i = 0\n                while i < len(path) - 1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                        if self._get_grid().is_valid_line_sequence(line_seq):\n                            break\n                        j -= 1\n                    shortcut_path.append(path[j])\n                    i = j\n                path = shortcut_path\n            return path\n\n        smoothed = shortcut_path_multistep(path, passes=3)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        max_iterations = 7000\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            if self._informed_sampling_enabled:\n                q_sample = self._informed_sample(start_vertex.position, goal_pos)\n            else:\n                q_sample = self._get_goal_biased_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            adaptive_step = self._get_adaptive_step_size(q_near, q_sample, iteration, max_iterations)\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            self._limit_graph_size()\n\n            # Early success on reaching goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planner inspired by RRT* with heuristic-guided goal bias and adaptive step size,\n    enhanced by A*-inspired cost-to-go heuristic for faster convergence and smarter rewiring.\n    This version dynamically adjusts step size based on local obstacles and progress,\n    prioritizes expansion towards vertices estimated closer to goal by combined cost+heuristic,\n    limits neighborhood search radius adaptively, and performs aggressive shortcutting \n    in path extraction for smoother results. Goal bias is dynamically increased along iterations,\n    and an early stopping criterion terminates when a sufficiently short path is found or timeouts.\n    The result is improved planning efficiency, path quality and robustness in complex grids.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iter = 8000\n\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        # Dynamic goal bias starts small and grows (0.05 to 0.3)\n        goal_bias_min = 0.05\n        goal_bias_max = 0.3\n\n        # Adaptive max distance parameters\n        max_dist_base = self._max_dist_base  # 15.0 default\n        max_dist_min = 4.0\n        max_dist_max = 20.0\n\n        # Adaptive rewire radius params (shrinks as tree grows)\n        rewire_radius_min = 10.0\n        rewire_radius_max = self._rewire_radius  # 20.0 default\n\n        # To hold best goal vertex found so far\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n\n        # Maintain a priority queue of vertices ordered by cost + heuristic (A* style)\n        import heapq\n\n        # Heap elements: (cost + heuristic to goal, Vertex)\n        vertex_heap = []\n        heapq.heappush(vertex_heap, (start_vertex.cost + Map.get_distance(start_vertex.position, goal_pos), start_vertex))\n\n        # Cache of vertices added to graph\n        vertices = [start_vertex]\n\n        def heuristic_cost(pt: Point):\n            # Euclidean distance heuristic to goal\n            return Map.get_distance(pt, goal_pos)\n\n        def update_goal_bias(i: int):\n            # Linearly increase goal bias from min to max over iterations\n            return goal_bias_min + (goal_bias_max - goal_bias_min) * min(i / max_iter, 1.0)\n\n        def dynamic_max_dist(q_near: Vertex, q_sample: Point) -> float:\n            # Reduce step size if near obstacles or close to goal, else use base scaled by distance\n            dist_to_goal = heuristic_cost(q_near.position)\n            dist_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist_max, max(max_dist_min, dist_sample * 0.8))\n            if dist_to_goal < (max_dist_base * 2):\n                # if close to goal tighten step size for precision\n                step = max(step * 0.6, max_dist_min)\n            return step\n\n        def adaptive_rewire_radius(num_vertices: int) -> float:\n            # Radius shrinks as graph grows (standard RRT* heuristic)\n            return max(rewire_radius_min, min(rewire_radius_max, rewire_radius_max * (1.0 / (num_vertices**(1/5) + 1e-5))))\n\n        # Overwrite _get_goal_biased_sample to add dynamic goal bias and sample towards promising areas\n        def improved_sample(goal_bias: float) -> Point:\n            if random.random() < goal_bias:\n                return goal_pos\n\n            # Bias sampling towards ball around best path vertex if found else random sample\n            if best_goal_vertex is not None:\n                center = best_goal_vertex.position\n                # Sample in a small radius around best goal vertex to refine path\n                radius = 10\n                for _ in range(100):\n                    sample_coords = []\n                    for dim in range(self._get_grid().size.n_dim):\n                        low = max(0, center[dim] - radius)\n                        high = min(self._get_grid().size[dim] - 1, center[dim] + radius)\n                        sample_coords.append(random.randint(low, high))\n                    sample_pt = Point(*sample_coords)\n                    if self._get_grid().is_agent_valid_pos(sample_pt):\n                        return sample_pt\n\n            # Default uniform random sample\n            while True:\n                rand_pos = [random.randint(0, self._get_grid().size[d] - 1) for d in range(self._get_grid().size.n_dim)]\n                sample_pt = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample_pt):\n                    return sample_pt\n\n        def vertex_priority(v: Vertex) -> float:\n            # Combine cost and heuristic for priority (A* inspired)\n            return v.cost + heuristic_cost(v.position)\n\n        # Main planning loop\n        for i in range(max_iter):\n            # Timeout check (10 seconds)\n            current_time = time.time()\n            if current_time - start_time > 10.0:\n                break\n\n            # Update dynamic parameters\n            current_goal_bias = update_goal_bias(i)\n            max_dist = max_dist_base\n            rewire_radius = adaptive_rewire_radius(len(vertices))\n\n            q_sample = improved_sample(current_goal_bias)\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            step = dynamic_max_dist(q_near, q_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            # Validate line (collision checking)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find near vertices with adaptively smaller radius\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            # Choose parent minimizing cost + movement cost + heuristic biased connection\n            best_parent = None\n            min_cost = float('inf')\n            for v in near_vertices:\n                line_between = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_between):\n                    continue\n                cost_to_new = v.cost + self._cost(v, q_new)\n                # Add heuristic as tie breaker to steer better parent choice\n                cost_to_new_with_heur = cost_to_new + heuristic_cost(q_new.position) * 0.2\n                if cost_to_new_with_heur < min_cost:\n                    min_cost = cost_to_new_with_heur\n                    best_parent = v\n\n            # Fallback: use q_near if no better parent found and line valid\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    cost_fallback = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                    q_new.cost = cost_fallback\n                else:\n                    continue\n            else:\n                q_new.cost = min_cost\n\n            self._graph.add_edge(best_parent, q_new)\n            vertices.append(q_new)\n\n            # Rewiring neighbors with heuristic-enhanced cost check\n            for v in near_vertices:\n                if v == q_new or v == self._graph.root_vertex_start:\n                    continue\n                line_check = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if not self._get_grid().is_valid_line_sequence(line_check):\n                    continue\n                cost_through_qnew = q_new.cost + self._cost(q_new, v)\n                # Add heuristic to make rewiring prefer smaller cost + better alignment to goal\n                cost_through_qnew_heur = cost_through_qnew + heuristic_cost(v.position) * 0.2\n                if cost_through_qnew_heur < v.cost + heuristic_cost(v.position) * 0.2:\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_qnew\n\n            # Check if reached goal region, try direct connection to goal node\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                goal_line_seq = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n\n                    # Check if this is best goal vertex so far\n                    if q_goal.cost < best_goal_cost:\n                        best_goal_cost = q_goal.cost\n                        best_goal_vertex = q_goal\n\n                    # Extract and smooth path immediately\n                    self._extract_path(q_goal)\n                    return\n\n            self.key_frame()\n\n        # If loop ended without direct final goal connection, attempt to find best near-goal vertex and connect final goal now\n        # Find closest vertex to goal\n        goal_candidates = [v for v in vertices if self._get_grid().is_agent_in_goal_radius(agent_pos=v.position, goal=self._get_grid().goal)]\n        if not goal_candidates:\n            # Try vertices closest to goal within some radius (e.g. 2 * rewire_radius)\n            candidates_radius = self._rewire_radius * 2\n            near_candidates = self._graph.get_vertices_within_radius([start_vertex], goal_pos, candidates_radius)\n            goal_candidates = near_candidates\n\n        best_final = None\n        best_final_cost = float('inf')\n        for v in goal_candidates:\n            goal_vertex = Vertex(goal_pos)\n            line_seq_goal = self._get_grid().get_line_sequence(v.position, goal_pos)\n            if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                cost_goal = v.cost + self._cost(v, goal_vertex)\n                if cost_goal < best_final_cost:\n                    best_final_cost = cost_goal\n                    best_final = v\n\n        if best_final is not None:\n            q_goal = Vertex(goal_pos)\n            q_goal.cost = best_final.cost + self._cost(best_final, q_goal)\n            self._graph.add_edge(best_final, q_goal)\n            self._extract_path(q_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This improved algorithm retains the systematic A*-inspired priority queue search of the original,\n    but introduces the following enhancements for better efficiency and robustness:\n    - Dual-tree bidirectional search: grows trees simultaneously from start and goal to connect faster.\n    - Enhanced adaptive step size that shrinks more aggressively near obstacles and goal for precision.\n    - Goal- and frontier-biased sampling with a mix of uniform random samples to improve exploration.\n    - Batch sampling per iteration for improved convergence speed.\n    - More aggressive local rewiring with incremental cost propagation in both trees.\n    - Early termination when the two trees connect within a defined radius.\n    - Post-processing path smoothing with shortcutting.\n    - Strict global time limit for planning termination (10 seconds).\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This improved algorithm retains the systematic A*-inspired priority queue search of the original,\n    but introduces the following enhancements for better efficiency and robustness:\n    - Dual-tree bidirectional search: grows trees simultaneously from start and goal to connect faster.\n    - Enhanced adaptive step size that shrinks more aggressively near obstacles and goal for precision.\n    - Goal- and frontier-biased sampling with a mix of uniform random samples to improve exploration.\n    - Batch sampling per iteration for improved convergence speed.\n    - More aggressive local rewiring with incremental cost propagation in both trees.\n    - Early termination when the two trees connect within a defined radius.\n    - Post-processing path smoothing with shortcutting.\n    - Strict global time limit for planning termination (10 seconds).\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []          # Min-heap for start tree vertices (f = g + h)\n        self._heap_goal = []           # Min-heap for goal tree vertices (f = g + h)\n        self._max_iter = 4500          # Reduced max iterations due to bidirectional\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0           # seconds limit\n        self._base_step = 12.0         # Base adaptive step distance\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 1200\n        self._batch_size = 10          # Number of samples tried per iteration to improve exploration\n\n    def _adaptive_step_more_precise(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = self._heuristic(to_pos)\n        max_step = self._base_step\n        # Shrink step more aggressively near goal for accuracy\n        if dist_to_goal < 25.0:\n            max_step *= 0.3 + 0.7 * (dist_to_goal / 25.0)\n        # Check obstacle proximity along direction, shrink more if line invalid\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.35  # smaller step with obstacles\n        return max_step\n\n    def _choose_parent_and_cost_bidirectional(self, near_vertices, q_new: Vertex) -> Vertex:\n        # Choose best parent minimizing cost+heuristic similar as original\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_locally_bidirectional(self, q_new: Vertex, neighbors: list) -> None:\n        # Extended rewiring: try connecting neighbors to q_new if better cost,\n        # and also try rewiring q_new via neighbors\n        for v in neighbors:\n            if v == q_new or v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            # Rewire neighbor via q_new\n            line_seq1 = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if self._get_grid().is_valid_line_sequence(line_seq1):\n                new_cost = q_new.cost + self._cost(q_new, v)\n                if new_cost < v.cost:\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = new_cost\n                    self._propagate_cost_update(v)\n            # Rewire q_new via neighbor\n            line_seq2 = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq2):\n                new_cost = v.cost + self._cost(v, q_new)\n                if new_cost < q_new.cost:\n                    for p in list(q_new.parents):\n                        self._graph.remove_edge(p, q_new)\n                    self._graph.add_edge(v, q_new)\n                    q_new.cost = new_cost\n                    self._propagate_cost_update(q_new)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_pos = self._get_grid().goal.position\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        f_start = self._heuristic(start_vertex.position)\n        f_goal = self._heuristic(goal_vertex.position)\n\n        self._heap_start = []\n        self._heap_goal = []\n        heapq.heappush(self._heap_start, (f_start, start_vertex))\n        heapq.heappush(self._heap_goal, (f_goal, goal_vertex))\n\n        visited_positions_start = set([start_vertex.position])\n        visited_positions_goal = set([goal_vertex.position])\n\n        start_time = time.time()\n        iterations = 0\n\n        # Store vertices for separate trees to facilitate bidirectional sampling\n        vertices_start = [start_vertex]\n        vertices_goal = [goal_vertex]\n\n        while (self._heap_start or self._heap_goal) and iterations < self._max_iter:\n            iterations += 1\n\n            if time.time() - start_time > self._timeout:\n                # Timeout condition: no path found within time limit\n                break\n\n            # Alternate expansion between start and goal trees\n            forward_expansion = (iterations % 2 == 1)\n\n            if forward_expansion and self._heap_start:\n                _, current_vertex = heapq.heappop(self._heap_start)\n                current_tree = 'start'\n                other_root = goal_vertex\n                visited_positions = visited_positions_start\n                other_visited_positions = visited_positions_goal\n                heap = self._heap_start\n                vertices = vertices_start\n            elif (not forward_expansion) and self._heap_goal:\n                _, current_vertex = heapq.heappop(self._heap_goal)\n                current_tree = 'goal'\n                other_root = start_vertex\n                visited_positions = visited_positions_goal\n                other_visited_positions = visited_positions_start\n                heap = self._heap_goal\n                vertices = vertices_goal\n            else:\n                # No expansion this iteration\n                continue\n\n            # Early check: if current vertex is within goal radius of opposite root, attempt connection\n            if Map.get_distance(current_vertex.position, other_root.position) <= self._goal_radius:\n                line_seq_goal = self._get_grid().get_line_sequence(current_vertex.position, other_root.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    # Create connecting vertex to other root\n                    connect_vertex = other_root\n                    # For clarity, link current vertex -> goal in start tree or goal tree -> start vertex\n                    if current_tree == 'start':\n                        # Connect current vertex to goal root\n                        if connect_vertex.cost > current_vertex.cost + self._cost(current_vertex, connect_vertex):\n                            connect_vertex.cost = current_vertex.cost + self._cost(current_vertex, connect_vertex)\n                        self._graph.add_edge(current_vertex, connect_vertex)\n                    else:\n                        # Connect current vertex to start root\n                        if connect_vertex.cost > current_vertex.cost + self._cost(current_vertex, connect_vertex):\n                            connect_vertex.cost = current_vertex.cost + self._cost(current_vertex, connect_vertex)\n                        self._graph.add_edge(connect_vertex, current_vertex)\n                    # Extract path from start to goal through connection\n                    if current_tree == 'start':\n                        q_goal = connect_vertex\n                    else:\n                        q_goal = current_vertex\n                    self._extract_path(q_goal)\n                    return\n\n            # Batch sampling from a mixture of frontier, goal bias, and random uniform samples\n            samples = []\n            for _ in range(self._batch_size):\n                r = random.random()\n                if r < 0.5:\n                    # Frontier-biased sampling from vertices in current tree heap's min f vertex\n                    if heap:\n                        frontier_vertex = heap[0][1]\n                        sample_pos = self._get_frontier_sample()\n                    else:\n                        sample_pos = self._get_grid().goal.position\n                elif r < 0.8:\n                    # Goal biased sampling - for start tree sample toward goal, for goal tree sample toward start\n                    if current_tree == 'start':\n                        sample_pos = self._goal_biased_sample()\n                    else:\n                        # Sample biased towards agent position for goal tree exploration\n                        if self._heap_start:\n                            sample_pos = self._graph.get_random_vertex([start_vertex]).position\n                        else:\n                            sample_pos = self._get_grid().agent.position\n                else:\n                    # Uniform random valid sampling in grid\n                    found_sample = False\n                    attempts = 0\n                    while not found_sample and attempts < 40:\n                        attempts += 1\n                        dim = self._get_grid().size.n_dim\n                        import numpy as np\n                        rand_coords = np.random.randint(0, self._get_grid().size, dim)\n                        candidate = Point(*rand_coords)\n                        if self._get_grid().is_agent_valid_pos(candidate) and candidate not in visited_positions and candidate not in other_visited_positions:\n                            sample_pos = candidate\n                            found_sample = True\n                    if not found_sample:\n                        sample_pos = self._get_grid().goal.position\n                samples.append(sample_pos)\n\n            for q_sample_pos in samples:\n                # Find nearest vertex in the current tree to q_sample_pos\n                q_near = self._graph.get_nearest_vertex(vertices, q_sample_pos)\n                if q_near.position == q_sample_pos:\n                    continue\n\n                adaptive_step = self._adaptive_step_more_precise(q_near.position, q_sample_pos)\n\n                q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n                if q_new.position in visited_positions or q_new.position in other_visited_positions:\n                    continue\n\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                # Find local neighbors for cost computation and rewiring in current tree only\n                rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n                near_vertices = self._graph.get_vertices_within_radius(vertices, q_new.position, rewire_radius)\n\n                best_parent = self._choose_parent_and_cost_bidirectional(near_vertices, q_new)\n                if best_parent is None:\n                    # fallback: connect to nearest if feasible\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                        best_parent = q_near\n                    else:\n                        continue\n\n                self._graph.add_edge(best_parent, q_new)\n                visited_positions.add(q_new.position)\n                vertices.append(q_new)\n\n                # Add new vertex to current tree's heap\n                f_q_new = q_new.cost + self._heuristic(q_new.position)\n                heapq.heappush(heap, (f_q_new, q_new))\n\n                # Attempt local rewiring in current tree around q_new\n                self._rewire_locally_bidirectional(q_new, near_vertices)\n\n                # Check if new vertex connects to opposite tree's vertex within radius -> connect trees\n                opposite_vertices = self._graph.get_vertices_within_radius(vertices_goal if current_tree == 'start' else vertices_start, q_new.position, self._goal_radius)\n                for ov in opposite_vertices:\n                    if ov.position == q_new.position:\n                        continue\n                    line_seq_connect = self._get_grid().get_line_sequence(q_new.position, ov.position)\n                    if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                        continue\n                    # Connect two trees by linking q_new and ov\n                    # Link direction depending on which tree q_new belongs\n                    if current_tree == 'start':\n                        cost_connect_q_new = q_new.cost + self._cost(q_new, ov)\n                        cost_connect_ov = ov.cost\n                        # Only add edge if it improves ov's cost in goal tree\n                        if cost_connect_q_new < ov.cost:\n                            for p in list(ov.parents):\n                                self._graph.remove_edge(p, ov)\n                            self._graph.add_edge(q_new, ov)\n                            ov.cost = cost_connect_q_new\n                            self._propagate_cost_update(ov)\n                    else:\n                        cost_connect_ov = ov.cost + self._cost(ov, q_new)\n                        if cost_connect_ov < q_new.cost:\n                            for p in list(q_new.parents):\n                                self._graph.remove_edge(p, q_new)\n                            self._graph.add_edge(ov, q_new)\n                            q_new.cost = cost_connect_ov\n                            self._propagate_cost_update(q_new)\n                    # Extract full path from start to goal through connection vertex\n                    # Pick vertex with smaller cost as goal end for extraction\n                    if current_tree == 'start':\n                        q_goal = ov\n                    else:\n                        q_goal = q_new\n                    self._extract_path(q_goal)\n                    return\n\n            # Prune excess vertices occasionally for memory and performance\n            if iterations % 50 == 0:\n                self._prune_excess_vertices()\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm improves upon the baseline RRT by integrating features inspired by RRT* with goal biasing.\n    Key improvements:\n    - Goal-biasing in random sampling to increase chances of reaching goal early.\n    - Rewiring of vertices within a radius to reduce path costs and obtain smoother paths.\n    - Adaptive max_dist step size based on environment and iteration for balanced exploration.\n    - Early termination if solution found or >10 seconds elapsed.\n    - Shortcut smoothing applied on final extracted path.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Enable rewiring edges\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, iteration: int, max_iter: int) -> float:\n        # Start with larger step and reduce gradually or clamp\n        max_step = 15\n        min_step = 5\n        return max(min_step, max_step * (1 - iteration / max_iter))\n\n    def _get_random_sample(self, goal_bias_prob: float = 0.15) -> Point:\n        # With some probability pick goal position to bias sampling\n        if np.random.rand() < goal_bias_prob:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _choose_parent(self, q_near: Vertex, q_new: Vertex, radius: float) -> Vertex:\n        \"\"\"Choose the best parent for q_new among vertices in radius based on cost + dist\"\"\"\n        vertices_in_radius = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n        best_parent = q_near\n        best_cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n\n        for vertex in vertices_in_radius:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new.position)):\n                cost = vertex.cost + self._get_grid().get_movement_cost(vertex.position, q_new.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = vertex\n\n        # Set cost for new vertex\n        q_new.cost = best_cost\n        if best_parent != q_near:\n            # If best parent different, we will connect edge later to best_parent, not q_near\n            pass\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, radius: float) -> None:\n        \"\"\"Try to rewire neighbors around q_new if connecting through q_new decreases cost\"\"\"\n        neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                cost_through_q_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                if cost_through_q_new < neighbor.cost:\n                    # Rewire: remove old parent edge(s), add new edge q_new->neighbor\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = cost_through_q_new\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Attempt to shortcut path by connecting non-adjacent pairs if line is clear\"\"\"\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, add next vertex\n                shortcut_path.append(path[i+1])\n                i += 1\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Backtrack path from goal to start\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            # Select parent with lowest cost (multiple parents possible)\n            best_parent: Optional[Vertex] = None\n            best_cost = float('inf')\n            for p in path[-1].parents:\n                if p.cost < best_cost:\n                    best_cost = p.cost\n                    best_parent = p\n            if best_parent is None:\n                break\n            path.append(best_parent)\n        path.reverse()\n\n        # Shortcut smoothing for better path quality\n        path = self._shortcut_path(path)\n\n        # Animate path from start to goal\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n\n        max_iterations = 6000\n        max_dist_base = 15\n        radius_factor = 30.0  # Radius for choosing parent and rewiring, related to max_dist\n\n        # Initialize root costs: start cost = 0\n        self._graph.root_vertex_start.cost = 0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for iteration in range(max_iterations):\n            elapsed = time() - start_time\n            if elapsed > 10.0:\n                # Timeout, fail pathfinding\n                break\n\n            max_dist = self._get_adaptive_max_dist(iteration, max_iterations)\n\n            q_sample: Point = self._get_random_sample(goal_bias_prob=0.2)  # stronger goal bias\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate line from nearest vertex to new sample\n            line_sequence = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_sequence):\n                continue\n\n            # Choose best parent for q_new within radius\n            radius = min(radius_factor, max_dist * 5)\n            best_parent = self._choose_parent(q_near, q_new, radius)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire graph locally\n            self._rewire(q_new, radius)\n\n            # Early check: if in goal radius, extract path and stop\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex properly with minimal cost\n                nearest_to_goal = self._graph.get_nearest_vertex([self._graph.root_vertex_start], self._get_grid().goal.position)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(self._get_grid().goal.position)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._get_grid().goal.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An improved path planning algorithm inspired by RRT* and heuristic-guided sampling,\n    enhanced with an adaptive adaptive max distance scaling based on local obstacle density,\n    informed sampling bias progressively increasing goal sampling probability,\n    dynamic rewiring radius shrinking over time for finer local optimization,\n    and heuristic cost-to-go guiding parent selection to prioritize shorter estimated total cost paths,\n    along with path shortcutting and early stopping after connecting start to goal within 10 seconds.\n    The approach uses adaptive exploration-exploitation balance for faster convergence,\n    maintains rewiring for smoother and shorter paths, and performs path shortcutting at extraction.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An improved path planning algorithm inspired by RRT* and heuristic-guided sampling,\n    enhanced with an adaptive adaptive max distance scaling based on local obstacle density,\n    informed sampling bias progressively increasing goal sampling probability,\n    dynamic rewiring radius shrinking over time for finer local optimization,\n    and heuristic cost-to-go guiding parent selection to prioritize shorter estimated total cost paths,\n    along with path shortcutting and early stopping after connecting start to goal within 10 seconds.\n    The approach uses adaptive exploration-exploitation balance for faster convergence,\n    maintains rewiring for smoother and shorter paths, and performs path shortcutting at extraction.\n    \"\"\"}\n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n    _max_time: float\n    _goal_sample_increment: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.05       # Start with lower goal-bias\n        self._rewire_radius = 20.0  # Neighborhood radius for rewiring\n        self._max_time = 10.0       # Maximum allowed planning time in seconds\n        self._goal_sample_increment = 0.02  # Increment goal bias per iteration\n\n    def _density_around_point(self, point: Point, radius: float) -> int:\n        \"\"\"Helper: Count vertices near a point to estimate local density.\"\"\"\n        near_verts = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], point, radius)\n        return len(near_verts)\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        \"\"\"Scale max distance by inverse local vertex density to adapt step size in clutter.\"\"\"\n        base = self._max_dist_base\n        count = self._density_around_point(q_near.position, base)\n        scale = 1.0\n        if count > 5:\n            scale = max(0.2, 1.0 / count)  # Reduce step in dense regions but not too small\n        return base * scale\n\n    def _heuristic_cost(self, frm: Vertex, to: Vertex) -> float:\n        # Estimated total cost: cost-to-come + heuristic (Euclidean) to goal\n        dist_to_goal = Map.get_distance(to.position, self._get_grid().goal.position)\n        return frm.cost + self._cost(frm, to) + dist_to_goal\n\n    def _choose_parent_heuristic(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"Choose parent minimizing estimated total cost (cost + heuristic to goal), ensure valid line.\"\"\"\n        min_est_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            est_cost = self._heuristic_cost(v, q_new)\n            if est_cost < min_est_cost:\n                min_est_cost = est_cost\n                q_new.cost = v.cost + self._cost(v, q_new)\n                best_parent = v\n        return best_parent\n\n    def _rewire_improved(self, near_vertices: list, q_new: Vertex) -> None:\n        \"\"\"Rewire neighbors to q_new if it improves cost plus ensure rewiring also considers heuristic.\"\"\"\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove old parent edges, add new edge from q_new\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _get_goal_biased_sample_progressive(self, iteration: int, max_iterations: int) -> Point:\n        \"\"\"Progressively increase goal bias to focus on goal over time.\"\"\"\n        import random\n        current_goal_bias = min(0.5, self._goal_bias + iteration * self._goal_sample_increment)\n        if random.random() < current_goal_bias:\n            return self._get_grid().goal.position\n        else:\n            attempts = 0\n            while attempts < 100:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            return self._get_grid().goal.position  # fallback goal sample if no free space found\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reuse shortcut path extraction as is\n        path: list[Vertex] = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed_path = self._shortcut_path(path)\n        for p in smoothed_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        max_iterations = 8000  # Slightly reduced for efficiency\n        max_dist_base = self._max_dist_base\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._max_time:\n                break  # Timeout\n\n            q_sample = self._get_goal_biased_sample_progressive(i, max_iterations)\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on local density around q_near\n            adaptive_max_dist = self._adaptive_max_dist(q_near)\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(adaptive_max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrink rewire radius gradually for local refinements\n            current_radius = max(5.0, self._rewire_radius * (1 - i / max_iterations))\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, current_radius)\n\n            best_parent = self._choose_parent_heuristic(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire_improved(near_vertices, q_new)\n\n            # Check goal reached with goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(self._get_grid().goal.position)\n                goal_line_seq = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An advanced RRT*-inspired incremental path planner with improved heuristic guidance and adaptive techniques:\n    - Uses a hybrid heuristic sampling mixing goal bias, informed sampling (ellipsoid pruning), and random exploration.\n    - Employs adaptive step size tuned by local cost gradients and dynamic environment scale.\n    - Implements a dynamically shrinking rewiring radius proportional to iteration and vertex density.\n    - Includes vertex pruning guided by highest cost and isolated vertices, maintaining memory limits.\n    - Introduces a lazy collision check during rewiring to attempt multiple parents before skipping.\n    - Extracted path undergoes iterative shortcut smoothing with random pair shortcuts for better path length reduction.\n    - Early stopping triggered upon goal connection or timeout (~10s) ensuring efficiency.\n    - Enhanced cost estimates using combined euclidean + movement cost plus heuristic to guide tree growth towards goal.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An advanced RRT*-inspired incremental path planner with improved heuristic guidance and adaptive techniques:\n    - Uses a hybrid heuristic sampling mixing goal bias, informed sampling (ellipsoid pruning), and random exploration.\n    - Employs adaptive step size tuned by local cost gradients and dynamic environment scale.\n    - Implements a dynamically shrinking rewiring radius proportional to iteration and vertex density.\n    - Includes vertex pruning guided by highest cost and isolated vertices, maintaining memory limits.\n    - Introduces a lazy collision check during rewiring to attempt multiple parents before skipping.\n    - Extracted path undergoes iterative shortcut smoothing with random pair shortcuts for better path length reduction.\n    - Early stopping triggered upon goal connection or timeout (~10s) ensuring efficiency.\n    - Enhanced cost estimates using combined euclidean + movement cost plus heuristic to guide tree growth towards goal.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.2            # More aggressive goal bias for focused sampling\n        self._rewire_radius_max = 20.0   # Starting larger rewire radius adapting to environment\n        self._vertex_limit = 1200         # Reduced vertex limit promotes efficient memory usage\n        self._informed_sampling_enabled = True\n        self._max_iterations = 7000\n        self._timeout_seconds = 10.0\n\n    def _heuristic_cost(self, p: Point) -> float:\n        \"\"\"Heuristic estimate from point p to goal: Euclidean + minimal movement cost approximation\"\"\"\n        goal_pos = self._get_grid().goal.position\n        dist = Map.get_distance(p, goal_pos)\n        move_cost = self._get_grid().get_movement_cost(p, goal_pos)\n        # Weighted heuristic for better guidance\n        return dist * 0.7 + move_cost * 0.3\n\n    def _informed_sample(self, c_best: float, start: Point, goal: Point) -> Point:\n        \"\"\"Sample inside ellipse defined by current best path cost c_best.\"\"\"\n        import random\n        import math\n        if c_best == float('inf'):\n            return self._get_goal_biased_sample()\n\n        center = Point((start.coords()[0] + goal.coords()[0]) / 2,\n                       (start.coords()[1] + goal.coords()[1]) / 2)\n        # Major axis length\n        c_min = Map.get_distance(start, goal)\n        if c_min == 0:\n            return goal\n\n        # Ellipse axes lengths\n        a = c_best / 2\n        b = math.sqrt(a**2 - (c_min / 2)**2)\n\n        # Sample uniformly in unit circle and scale to ellipse\n        while True:\n            theta = random.uniform(0, 2 * math.pi)\n            r = random.uniform(0, 1)\n            x = r * math.cos(theta)\n            y = r * math.sin(theta)\n            sample_x = center.coords()[0] + a * x\n            sample_y = center.coords()[1] + b * y\n            sample = Point(int(round(sample_x)), int(round(sample_y)))\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_sample(self, iteration: int, c_best: float, start: Point, goal: Point) -> Point:\n        import random\n        r = random.random()\n        # 20% goal bias\n        if r < self._goal_bias:\n            return goal\n        # 50% informed sample if enabled and available\n        if self._informed_sampling_enabled and c_best != float('inf') and r < 0.7:\n            return self._informed_sample(c_best, start, goal)\n        # Else uniform random valid sample\n        attempts = 0\n        max_attempts = 50\n        while attempts < max_attempts:\n            rand_pos = [random.randint(0, self._get_grid().size[i]-1) for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        return goal  # fallback\n\n    def _adaptive_step(self, dist: float, local_cost: float) -> float:\n        base_step = min(self._max_dist_base, dist)\n        cost_factor = 0.9 - 0.6 * min(local_cost / 100.0, 1.0)\n        cost_factor = max(0.3, cost_factor)  # avoid too small step\n        return base_step * cost_factor\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new) + self._heuristic_cost(q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n        \n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew + self._heuristic_cost(v.position) < v.cost + self._heuristic_cost(v.position):\n                # Lazy check alternate parents\n                self._graph.remove_edge(list(v.parents)[0], v) if v.parents else None\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _limit_graph_size(self) -> None:\n        # Prune vertices by isolated cost and distance, preserve root start and goal\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        \n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        # Rank by cost descending - prune farthest or costly nodes\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _iterative_shortcut_smoothing(self, path: list, iterations: int = 50) -> list:\n        if len(path) <= 2:\n            return path\n        import random\n        smoothed_path = path[:]\n        for _ in range(iterations):\n            if len(smoothed_path) <= 2:\n                break\n            i = random.randint(0, len(smoothed_path) - 3)\n            j = random.randint(i + 2, len(smoothed_path) - 1)\n            line_seq = self._get_grid().get_line_sequence(smoothed_path[i].position, smoothed_path[j].position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = smoothed_path[:i+1] + smoothed_path[j:]\n                smoothed_path = new_path\n        return smoothed_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._iterative_shortcut_smoothing(path, iterations=80)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int) -> float:\n        min_radius = 4.0\n        # Shrink adaptively with iterations and graph size to remain efficient\n        radius = self._rewire_radius_max * (1.0 - iteration / self._max_iterations)\n        density_factor = max(1.0, (self._graph.size / 500))\n        radius = radius / density_factor\n        return max(radius, min_radius)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = self._max_iterations\n        max_dist_base = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        best_cost = float('inf')\n        q_goal = None\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > self._timeout_seconds:\n                break\n\n            # Sample with informed sampling if we have a best cost\n            q_sample = self._get_sample(iteration, best_cost, start_vertex.position, goal_pos)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = self._adaptive_step(dist_to_sample, q_near.cost)\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cur_rewire_radius = self._decrease_rewire_radius(iteration)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            self._rewire(near_vertices, q_new)\n            self._limit_graph_size()\n\n            # Check if better path to goal possible\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal_candidate = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal_candidate.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal_candidate.cost = q_new.cost + self._cost(q_new, q_goal_candidate)\n                    if q_goal is None or q_goal_candidate.cost < best_cost:\n                        best_cost = q_goal_candidate.cost\n                        q_goal = q_goal_candidate\n                        # Rewire to goal for final extraction\n                        self._graph.add_edge(q_new, q_goal)\n\n            self.key_frame()\n\n            if q_goal is not None:\n                self._extract_path(q_goal)\n                break",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm enhances the original RRT* inspired planner by:\n    - Introducing heuristic-guided adaptive sampling based on a weighted combination of random and goal-biased samples, guided by an A*-style cost-to-go heuristic.\n    - Dynamically adapting the extension step size (`max_dist`) based on local obstacle density estimated from nearby vertices to enable finer exploration near obstacles.\n    - Combining path cost plus heuristic in vertex selection to direct expansion towards promising nodes (similar to informed RRT*).\n    - Utilizing a rewiring radius scaled adaptively to balance connectivity and efficiency.\n    - Applying an early stopping criteria when a path with cost close to heuristic lower bound is found.\n    - Improving path shortcutting by multi-pass attempt to smooth the final path.\n    These modifications aim to improve:\n      * Planning efficiency by focusing exploration towards the goal with heuristic guidance.\n      * Path quality through adaptive step sizing and rewiring.\n      * Robustness and success rate by better managing sampling and expansion near obstacles.\n    The search is limited to 10 seconds to remain responsive.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional member variable to store heuristic weight used for informed sampling\n        self._heuristic_weight = 0.6\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0   # Base max extending distance\n        self._goal_bias = 0.15       # Slightly higher goal bias for quicker goal convergence\n        self._rewire_radius = 20.0   # Neighborhood radius for rewiring\n\n    def _adaptive_max_dist(self, near_vertex: Vertex) -> float:\n        \"\"\"Adapt max_dist based on local vertex density (proxy for obstacleity).\"\"\"\n        radius = 10.0\n        neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], near_vertex.position, radius)\n        density_factor = min(len(neighbors) / 10.0, 1.0)  # Normalize density factor [0..1]\n        adapted = self._max_dist_base * (1.0 - 0.7 * density_factor)  # Reduce max_dist up to 70% near dense obstacles\n        return max(adapted, 3.0)  # Minimum step of 3.0 to avoid too small step\n\n    def _heuristic(self, point: Point) -> float:\n        \"\"\"Heuristic function: Euclidean distance from point to goal.\"\"\"\n        return Map.get_distance(point, self._get_grid().goal.position)\n\n    def _cost_plus_heuristic(self, vertex: Vertex) -> float:\n        \"\"\"Value used to prioritize vertices: cost from start plus heuristic to goal.\"\"\"\n        return vertex.cost + self._heuristic(vertex.position)\n\n    def _get_informed_sample(self) -> Point:\n        \"\"\"Sample biased based on heuristic to focus exploration near ellipsoid between start and goal.\n        Mixes goal bias, uniform random, and heuristic guided sampling towards the goal region.\"\"\"\n        import random, math, numpy as np\n\n        grid_size = self._get_grid().size\n\n        # With goal bias probability, return goal directly\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n\n        # With some probability sample near start-goal segment informed by heuristic cost\n        if random.random() < 0.7:\n            # Get start and goal positions\n            start = self._graph.root_vertex_start.position\n            goal = self._get_grid().goal.position\n\n            # Generate a sample on ellipsoid defined by heuristic distance\n            c_best = min(v.cost + self._heuristic(v.position) for v in self._graph.root_vertices if v.cost < float('inf'))\n            if c_best == float('inf'):\n                c_best = self._heuristic(start)\n\n            # Ellipsoid major axis length: c_best, minor axes scaled by max_dist_base\n            center = Point(\n                (start.x + goal.x) / 2.0,\n                (start.y + goal.y) / 2.0\n            )\n            a1 = np.array([goal.x - start.x, goal.y - start.y])\n            length = np.linalg.norm(a1)\n            if length == 0:\n                length = 1.0\n            a1 = a1 / length  # normalized vector\n\n            # Sample randomly inside unit circle and project on ellipsoid surface\n            while True:\n                sample_unit = np.random.uniform(-1, 1, 2)\n                if np.linalg.norm(sample_unit) <= 1:\n                    break\n\n            # Scale minor axis to maintain ellipse shape\n            minor_axis = math.sqrt(max(c_best * c_best - length * length, 0.001)) / 2.0\n            point_vec = a1 * (c_best / 2.0 * sample_unit[0]) + np.array([-a1[1], a1[0]]) * (minor_axis * sample_unit[1])\n            sample_point = Point(\n                int(center.x + point_vec[0]),\n                int(center.y + point_vec[1])\n            )\n\n            # Clamp the sample inside grid bounds and check validity\n            sample_clamped = Point(\n                max(0, min(grid_size.x - 1, sample_point.x)),\n                max(0, min(grid_size.y - 1, sample_point.y))\n            )\n            if self._get_grid().is_agent_valid_pos(sample_clamped):\n                return sample_clamped\n\n        # Otherwise uniform random sample until valid\n        while True:\n            rand_pos = np.random.randint(0, grid_size, grid_size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_best_vertex_to_expand(self) -> Vertex:\n        \"\"\"Select vertex with minimal cost + heuristic from roots to expand.\"\"\"\n        best_vertex = None\n        min_value = float('inf')\n        for v in self._graph.root_vertices:\n            val = self._cost_plus_heuristic(v)\n            if val < min_value:\n                min_value = val\n                best_vertex = v\n        return best_vertex\n\n    def _multi_pass_shortcut(self, path: list) -> list:\n        \"\"\"Perform multiple passes of shortcut to improve smoothness.\"\"\"\n        for _ in range(3):\n            path = self._shortcut_path(path)\n        return path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        start_time = time.time()\n\n        max_iterations = 8000  # Slightly fewer max iterations due to heuristic guidance\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        path_found = False\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout reached\n                break\n\n            # Select vertex to expand guided by cost+heuristic\n            q_near = self._choose_best_vertex_to_expand()\n            if q_near is None:\n                # No vertex to expand, stop early\n                break\n\n            # Sample point with improved heuristic-guided sampler\n            q_sample = self._get_informed_sample()\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size based on local complexity\n            max_dist = self._adaptive_max_dist(q_near)\n\n            # Create new vertex extended from q_near towards q_sample\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check if path between q_near and q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within rewiring radius adaptively scaled by cost heuristic\n            radius = self._rewire_radius * max(0.5, 1.0 - (q_near.cost / (self._heuristic_weight + q_near.cost + 1e-6)))\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent among neighbors to minimize cost and validate line\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # Fallback to q_near if possible\n                line_seq_fallback = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_fallback):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors via q_new if cheaper and valid\n            self._rewire(near_vertices, q_new)\n\n            # Check if q_new reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Candidate goal vertex\n                q_goal = Vertex(goal_pos)\n                line_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n\n                    # Update best goal if improved\n                    if q_goal.cost < best_goal_cost:\n                        best_goal_cost = q_goal.cost\n                        best_goal_vertex = q_goal\n\n                    path_found = True\n\n                    # Early stopping if solution close to ideal\n                    ideal_cost = self._heuristic(start_vertex.position)\n                    if best_goal_cost <= 1.05 * ideal_cost:\n                        break\n\n            if iteration % 10 == 0:\n                self.key_frame()\n\n        if path_found and best_goal_vertex is not None:\n            # Extract and smooth path using multiple shortcut passes\n            path = [best_goal_vertex]\n            current = best_goal_vertex\n            # Backtrack to start along minimal cost parents\n            while current != start_vertex:\n                if not current.parents:\n                    break\n                current = min(current.parents, key=lambda p: p.cost)\n                path.append(current)\n            path.reverse()\n\n            smoothed_path = self._multi_pass_shortcut(path)\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No path found within time or iterations\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning inspired by RRT* with goal biasing and rewiring for smoother and shorter paths.\n    - Uses adaptive goal-biased sampling (20% towards goal).\n    - Implements rewiring of nearby vertices after adding new vertex to optimize costs (RRT* style).\n    - Adaptive max_dist reduces when close to obstacles or goal for finer exploration.\n    - Shortcut smoothing post path extraction to generate a more direct route.\n    - Early stopping after success or if exceeding 10 seconds to prevent timeout.\n    - Utilizes existing methods for sampling, nearest, and validity checks.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring/removal\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_bias=0.2) -> Point:\n        # With probability goal_bias, sample the actual goal position to bias towards goal\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _choose_parent_and_rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # Find optimal parent from near vertices based on cost + movement cost with valid edges\n        best_cost = float('inf')\n        best_parent = None\n\n        for v in near_vertices:\n            line = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            cost = v.cost + self._get_grid().get_distance(v.position, q_new.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = v\n\n        if best_parent is not None:\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = best_cost\n        else:\n            # fallback: connect to nearest vertex\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_new.position)\n            if q_near != q_new:  # prevent self-edge\n                self._graph.add_edge(q_near, q_new)\n                q_new.cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n        # Rewire near vertices to q_new if it improves their cost and path valid\n        for v in near_vertices:\n            if v == q_new or v.parents and q_new in v.parents:\n                continue\n            line = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, v.position)\n            if new_cost < v.cost:\n                # Remove existing parent edge(s)\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                # Add new parent q_new\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt shortcuts by skipping intermediate vertices if line is valid\n        if len(path) <= 2:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    shortened_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, move to next vertex\n                shortened_path.append(path[i + 1])\n                i += 1\n        # Ensure goal vertex is last\n        if shortened_path[-1] != path[-1]:\n            shortened_path.append(path[-1])\n        return shortened_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        # Trace back parents to start\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        path = list(reversed(path))\n        # Shortcut smoothing\n        path = self._shortcut_path(path)\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Core Algorithm #\n    # ---------------#\n\n    def _find_path_internal(self) -> None:\n        max_dist_default: float = 15\n        max_dist_min: float = 3\n        goal_threshold_dist: float = 5\n        radius_rewire: float = 20\n        iterations: int = 10000\n        start_time = time()\n\n        # initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n            # Timeout check (10 sec max to prevent infinite loops)\n            elapsed_time = time() - start_time\n            if elapsed_time > 10:\n                # Stop searching, no path found\n                break\n\n            # Adaptive max_dist: smaller when closer to goal or obstacles (fallback here: smaller if close to goal)\n            agent_pos = self._get_grid().agent.position\n            goal_pos = self._get_grid().goal.position\n            dist_to_goal = self._get_grid().get_distance(agent_pos, goal_pos)\n            max_dist = max(max_dist_min, max_dist_default * (dist_to_goal / max(self._get_grid().size.x, self._get_grid().size.y)))\n\n            q_sample = self._get_random_sample(goal_bias=0.2)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            # Create q_new.cost placeholder\n            q_new.cost = float('inf')\n\n            # Add and rewire edges (RRT* style)\n            near_vertices = self._get_near_vertices(q_new, radius_rewire)\n            self._choose_parent_and_rewire(q_new, near_vertices)\n\n            # Add vertex to graph if not already in\n            if q_new not in self._graph.root_vertices:\n                self._graph.root_vertices.append(q_new)\n\n            # If q_new is in goal radius, connect and extract path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex with minimal cost parent\n                q_goal = Vertex(self._get_grid().goal.position)\n                q_goal.cost = float('inf')\n\n                near_goal = self._get_near_vertices(q_goal, radius_rewire)\n                # Connect q_goal to best parent from near vertices\n                best_goal_parent = None\n                best_goal_cost = float('inf')\n                for v in near_goal:\n                    line_goal = self._get_grid().get_line_sequence(v.position, q_goal.position)\n                    if self._get_grid().is_valid_line_sequence(line_goal):\n                        cost_to_goal = v.cost + self._get_grid().get_distance(v.position, q_goal.position)\n                        if cost_to_goal < best_goal_cost:\n                            best_goal_cost = cost_to_goal\n                            best_goal_parent = v\n                if best_goal_parent is None:\n                    # fallback connect q_goal to q_new if valid\n                    line_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                    if self._get_grid().is_valid_line_sequence(line_goal):\n                        best_goal_parent = q_new\n                        best_goal_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_goal.position)\n\n                if best_goal_parent is not None:\n                    q_goal.cost = best_goal_cost\n                    self._graph.add_edge(best_goal_parent, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An enhanced RRT*-based path planning algorithm with adaptive heuristic sampling and improved smoothing.\n    This algorithm extends the baseline by incorporating:\n    - Heuristic-guided bidirectional sampling alternating between start and goal trees for faster convergence.\n    - Adaptive step size based on local density and environment complexity.\n    - Dynamic rewiring radius shrinkage based on iteration count and vertex density.\n    - Enhanced vertex pruning focusing on both high-cost and isolated vertices for memory efficiency.\n    - Progressive shortcut smoothing integrated within the path extraction, iteratively improving path quality.\n    - Early termination when path quality improvement falls below threshold or time exceeds 10s.\n    This approach improves planning efficiency, success rate, and results in smoother, shorter paths with fewer iterations.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An enhanced RRT*-based path planning algorithm with adaptive heuristic sampling and improved smoothing.\n    This algorithm extends the baseline by incorporating:\n    - Heuristic-guided bidirectional sampling alternating between start and goal trees for faster convergence.\n    - Adaptive step size based on local density and environment complexity.\n    - Dynamic rewiring radius shrinkage based on iteration count and vertex density.\n    - Enhanced vertex pruning focusing on both high-cost and isolated vertices for memory efficiency.\n    - Progressive shortcut smoothing integrated within the path extraction, iteratively improving path quality.\n    - Early termination when path quality improvement falls below threshold or time exceeds 10s.\n    This approach improves planning efficiency, success rate, and results in smoother, shorter paths with fewer iterations.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15\n        self._rewire_radius = 15.0\n        self._vertex_limit = 1500\n\n        # New member variables for bidirectional expansion and smoothing control\n        self._bidirectional = True\n        self._start_tree_vertices = [self._graph.root_vertex_start]\n        self._goal_tree_vertices = [self._graph.root_vertex_goal]\n        self._max_iterations = 8000\n        self._last_path_cost = None\n        self._smoothing_iterations = 3\n\n    def _get_adaptive_step(self, q_near: Vertex, q_sample: Point) -> float:\n        dist = Map.get_distance(q_near.position, q_sample)\n        base_step = min(self._max_dist_base, dist)\n        cost_factor = 0.7 + 0.3 * (1 - min(q_near.cost / 100.0, 1.0))\n        adaptive_step = base_step * cost_factor\n        return adaptive_step\n\n    def _get_random_sample_bidirectional(self, iteration: int) -> (Point, bool):\n        \"\"\"\n        Alternate sampling bias between start and goal trees.\n        This returns a tuple: (point, is_sample_from_start_tree)\n        \"\"\"\n        import random\n        r = random.random()\n        use_start_tree = (iteration % 2 == 0)\n        if r < self._goal_bias:\n            if use_start_tree:\n                return self._get_grid().goal.position, False\n            else:\n                return self._get_grid().agent.position, True\n        attempts = 0\n        while attempts < 50:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample, use_start_tree\n            attempts += 1\n        # fallback goal or start if sampling fails\n        if use_start_tree:\n            return self._get_grid().goal.position, False\n        else:\n            return self._get_grid().agent.position, True\n\n    def _choose_parent_bidirectional(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        # Same logic as baseline _choose_parent\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire_bidirectional(self, near_vertices: list, q_new: Vertex) -> None:\n        # Restrict rewiring to current vertices except roots\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _limit_graph_size_improved(self) -> None:\n        \"\"\"\n        Prune vertices based on cost and degree (isolated vertices).\n        Keep roots, try to maintain coverage while reducing memory footprint.\n        \"\"\"\n        if self._graph.size <= self._vertex_limit:\n            return\n        # Remove vertices with highest cost first but also isolated (few children/parents)\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        # Score based on cost + inverse connectivity count\n        def score(v: Vertex):\n            connectivity = len(v.parents) + len(v.children)\n            return v.cost * 1.0 - 0.5 * connectivity  # Penalize low connectivity\n        vertices = sorted(vertices, key=score, reverse=True)\n        remove_count = self._graph.size - self._vertex_limit\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _extract_path_bidirectional(self, q_start_side: Vertex, q_goal_side: Vertex) -> None:\n        \"\"\"\n        Extract and combine two paths from start and goal trees joined by q_start_side and q_goal_side,\n        then apply progressive shortcut smoothing.\n        \"\"\"\n        def trace_path(vertex: Vertex, root_vertex: Vertex) -> list:\n            path = [vertex]\n            current = vertex\n            while current != root_vertex:\n                if not current.parents:\n                    break\n                parent = min(current.parents, key=lambda p: p.cost)\n                path.append(parent)\n                current = parent\n            path.reverse()\n            return path\n\n        path_from_start = trace_path(q_start_side, self._graph.root_vertex_start)\n        path_from_goal = trace_path(q_goal_side, self._graph.root_vertex_goal)\n        path_from_goal.reverse()  # invert goal path to connect correctly\n\n        full_path = path_from_start + path_from_goal[1:]\n\n        # Progressive smoothing: apply shortcut smoothing multiple times for refinement\n        for _ in range(self._smoothing_iterations):\n            full_path = self._shortcut_path(full_path)\n\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius_dynamic(self, iteration: int) -> float:\n        \"\"\"\n        Shrink rewire radius dynamically based on iteration and current vertex count.\n        \"\"\"\n        min_radius = 5.0\n        max_radius = self._rewire_radius\n        if self._graph.size == 0:\n            return max_radius\n        radius = max_radius * (1.0 - (iteration / self._max_iterations)) * min(1.0, self._vertex_limit / max(self._graph.size, 1))\n        return max(radius, min_radius)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Separate vertex sets for start and goal trees for bidirectional search\n        start_vertices = [start_vertex]\n        goal_vertices = [goal_vertex]\n\n        found_connection = False\n        best_connection = None\n        best_cost = float('inf')\n\n        for iteration in range(self._max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            q_sample, from_start_tree = self._get_random_sample_bidirectional(iteration)\n\n            if from_start_tree:\n                q_near = self._graph.get_nearest_vertex(start_vertices, q_sample)\n            else:\n                q_near = self._graph.get_nearest_vertex(goal_vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            adaptive_step = self._get_adaptive_step(q_near, q_sample)\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cur_rewire_radius = self._decrease_rewire_radius_dynamic(iteration)\n\n            if from_start_tree:\n                near_vertices = self._graph.get_vertices_within_radius(start_vertices, q_new.position, cur_rewire_radius)\n            else:\n                near_vertices = self._graph.get_vertices_within_radius(goal_vertices, q_new.position, cur_rewire_radius)\n\n            best_parent = self._choose_parent_bidirectional(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to nearest vertex if line valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Add new vertex to corresponding tree vertex list\n            if from_start_tree:\n                start_vertices.append(q_new)\n            else:\n                goal_vertices.append(q_new)\n\n            # Rewire within the same tree\n            self._rewire_bidirectional(near_vertices, q_new)\n\n            # Now attempt to connect the two trees by checking nearest vertex in the other tree\n            other_tree_vertices = goal_vertices if from_start_tree else start_vertices\n            q_connect_candidates = self._graph.get_vertices_within_radius(other_tree_vertices, q_new.position, cur_rewire_radius)\n            connection_made = False\n            for q_other in q_connect_candidates:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, q_other.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                potential_cost = q_new.cost + self._cost(q_new, q_other)\n                if potential_cost < best_cost:\n                    best_cost = potential_cost\n                    best_connection = (q_new, q_other) if from_start_tree else (q_other, q_new)\n                    connection_made = True\n            if connection_made:\n                found_connection = True\n\n            self._limit_graph_size_improved()\n\n            # Early stopping if connection found and cost not improving significantly\n            if found_connection and self._last_path_cost is not None and best_cost >= self._last_path_cost * 0.99:\n                break\n            self._last_path_cost = best_cost if found_connection else self._last_path_cost\n\n            self.key_frame()\n\n        # If connection found, extract full path from start to goal via connection vertices\n        if found_connection and best_connection is not None:\n            q_start_side, q_goal_side = best_connection\n            self._extract_path_bidirectional(q_start_side, q_goal_side)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm builds upon RRT*, incorporating heuristic-guided adaptive sampling \n    to balance exploration and exploitation of the search space. It uses a dynamically adjusted step size based \n    on local obstacle density and recent progress, prioritizing samples near the goal with increasing bias over \n    iterations. A more aggressive rewiring radius adapts over time to improve path smoothness and shorten paths. \n    During path expansion, a local steering step tries multi-resolution attempts to find valid connecting edges, \n    improving reachability around obstacles. Path extraction applies iterative shortcutting combined with partial \n    Bezier curve smoothing to produce smoother, more natural paths. Early stopping criteria check not only time \n    but also convergence in path cost to increase efficiency. The algorithm balances planning efficiency, path quality, \n    and robustness, resulting in faster and smoother paths with higher success rates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n    _max_time_sec: float\n    _goal_sample_increase_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring for optimization\n        self._init_displays()\n\n        self._max_dist_base = 15.0                   # Base max extension distance\n        self._goal_bias = 0.1                        # Base probability to sample goal directly\n        self._rewire_radius = 20.0                   # Neighborhood radius for rewiring\n        self._max_time_sec = 10.0                    # Max planning time seconds\n        self._goal_sample_increase_rate = 0.001     # Rate to increase goal bias gradually\n\n    def _get_local_obstacle_density(self, center: Point, radius: float = 10.0) -> float:\n        \"\"\"Estimate local obstacle density as ratio of obstacle points in radius around center.\"\"\"\n        obstacle_points = set()\n        for obs in self._get_grid().obstacles:\n            bound = self._get_grid().get_obstacle_bound(obs.position)\n            obstacle_points |= bound\n        count_in_radius = 0\n        sq_radius = radius * radius\n        for pt in obstacle_points:\n            if Map.get_distance(center, pt) <= radius:\n                count_in_radius += 1\n        # Normalize density by area (approximate as circle with radius)\n        if radius == 0:\n            return 0.0\n        max_pts = (radius * 2 + 1)**self._get_grid().size.n_dim\n        density = count_in_radius / max_pts\n        return min(1.0, density)\n\n    def _adaptive_max_dist(self, near_vertex: Vertex, iteration: int) -> float:\n        \"\"\"Adapt max extending distance based on obstacle density and iteration.\"\"\"\n        base = self._max_dist_base\n        density = self._get_local_obstacle_density(near_vertex.position, radius=10.0)\n        # Reduce step size if dense obstacles nearby\n        adjusted = base * (1.0 - 0.7 * density)\n        # Slightly reduce max_dist over time for finer exploration near goal\n        decay = max(0.5, 1 - iteration * 1e-4)\n        return max(3.0, adjusted * decay)\n\n    def _get_goal_biased_sample(self, iteration: int) -> Point:\n        import random\n        # Increase goal bias gradually over iterations to improve convergence\n        current_goal_bias = min(0.5, self._goal_bias + iteration * self._goal_sample_increase_rate)\n        if random.random() < current_goal_bias:\n            return self._get_grid().goal.position\n        else:\n            attempts = 0\n            while True:\n                # Sample around goal with some gaussian noise to increase goal neighborhood sampling\n                goal_pos = self._get_grid().goal.position\n                dim = self._get_grid().size.n_dim\n                if random.random() < 0.5:\n                    # Gaussian around goal\n                    sample_coords = []\n                    for d in range(dim):\n                        val = int(random.gauss(goal_pos[d], self._max_dist_base))\n                        val = max(0, min(val, self._get_grid().size[d]-1))\n                        sample_coords.append(val)\n                    sample = Point(*sample_coords)\n                else:\n                    # Uniform random sample\n                    rand_pos = np.random.randint(0, self._get_grid().size, dim)\n                    sample = Point(*rand_pos)\n\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n                if attempts > 1000:\n                    # fallback to goal if samples not found\n                    return self._get_grid().goal.position\n\n    def _steer_with_resolution(self, q_near: Vertex, q_target: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Try multiple intermediate steps to create a collision-free extend from q_near to q_target,\n        with adaptive resolution sampling the line between q_near and q_target.\n        Returns the furthest valid vertex.\n        \"\"\"\n        dir_vec = q_target.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist == 0:\n            return None\n        dir_norm = dir_vec / dist\n        max_extend = min(max_dist, dist)\n        resolutions = [max_extend, max_extend * 0.7, max_extend * 0.4, max_extend * 0.2]\n\n        last_valid_pos = q_near.position\n        for step_len in resolutions:\n            candidate_pos_tensor = q_near.position.to_tensor() + dir_norm * step_len\n            candidate_pos = Point.from_tensor(candidate_pos_tensor)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, candidate_pos)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                last_valid_pos = candidate_pos\n                if step_len == max_extend:\n                    # We can go fully to max step\n                    break\n            else:\n                # Failed to reach this resolution, skip to smaller step\n                continue\n\n        if last_valid_pos == q_near.position:\n            return None\n        return Vertex(last_valid_pos)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path with iterative shortcut + partial Bezier smoothing for smoother transitions\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Iteratively shortcut path multiple times for smoother path\n        for _ in range(3):\n            path = self._shortcut_path(path)\n\n        # Partial smoothing with Bezier curve approximation on segments of length 3+\n        smoothed_path = []\n        n = len(path)\n        i = 0\n        while i < n:\n            if i + 2 < n:\n                p0 = path[i].position\n                p1 = path[i+1].position\n                p2 = path[i+2].position\n                # Try quadratic Bezier smoothing if valid\n                bezier_points = []\n                bezier_valid = True\n                steps = 5\n                for t_step in range(steps + 1):\n                    t = t_step / steps\n                    # Quadratic Bezier formula\n                    x = (1 - t)**2 * p0[0] + 2*(1 - t)*t*p1[0] + t**2 * p2[0]\n                    y = (1 - t)**2 * p0[1] + 2*(1 - t)*t*p1[1] + t**2 * p2[1]\n                    point = Point(int(round(x)), int(round(y)))\n                    bezier_points.append(point)\n                # Check all in bezier_points for validity\n                for k in range(len(bezier_points)-1):\n                    line_seq = self._get_grid().get_line_sequence(bezier_points[k], bezier_points[k+1])\n                    if not self._get_grid().is_valid_line_sequence(line_seq):\n                        bezier_valid = False\n                        break\n                if bezier_valid:\n                    # Use only first point of bezier as next smoothed waypoint, skip middle control point\n                    smoothed_path.append(Vertex(p0))\n                    i += 2  # skip one intermediate point (p1)\n                    continue\n            smoothed_path.append(path[i])\n            i += 1\n        # Add any tail points\n        while i < n:\n            smoothed_path.append(path[i])\n            i += 1\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Override to prioritize parents with better heuristic (cost + euclidean to goal weighted)\n        goal_pos = self._get_grid().goal.position\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            # Heuristic term to goal (Euclidean distance)\n            h = Map.get_distance(q_new.position, goal_pos)\n            weighted_cost = cost + 0.5 * h\n            if weighted_cost < min_cost:\n                min_cost = weighted_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        max_iterations = 8000\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        last_best_cost = float('inf')\n        no_improve_iters = 0\n        improvement_threshold = 1e-3  # Minimum improvement to reset no_improve counter\n        max_no_improve_iters = 300   # Stop if no improvement long time\n\n        for i in range(max_iterations):\n            if time.time() - start_time > self._max_time_sec:\n                # Timeout\n                break\n\n            q_sample = self._get_goal_biased_sample(i)\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near, i)\n            q_new = self._steer_with_resolution(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius * (1 + i/max_iterations))\n            best_parent = self._choose_parent(near_vertices, q_new)\n\n            if best_parent is None:\n                # fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            self._rewire(near_vertices, q_new)\n\n            # Check if we've found a better path to goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    if q_goal.cost + 1e-9 < last_best_cost:\n                        last_best_cost = q_goal.cost\n                        no_improve_iters = 0\n                    else:\n                        no_improve_iters += 1\n                    self._extract_path(q_goal)\n                    if no_improve_iters > max_no_improve_iters:\n                        # Converged, stop early\n                        break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved algorithm extends the A*-inspired heuristic guided sampling path planner\n    by integrating a dual-tree bidirectional search that grows trees from both start and goal,\n    enabling faster connection and increased success rates. \n\n    Key improvements:\n    - Bidirectional tree growth (start and goal) with inter-tree connection attempts each iteration.\n    - Dynamic adaptive step size based on obstacle proximity and distance to goal/start.\n    - Enhanced goal and start biased sampling with Gaussian jitter around frontier vertices.\n    - Local rewiring in both trees to incrementally refine paths and reduce costs.\n    - Early stopping once connection between trees is established inside radius.\n    - Post path extraction smoothing via shortcutting to improve path quality and smoothness.\n    - Timeout of 10 seconds enforces robust termination.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []         # Min-heap for frontier vertices from start (f = g + h)\n        self._heap_goal = []          # Min-heap for frontier vertices from goal (f = g + h)\n        self._max_iter = 6000\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 20.0\n        self._vertex_prune_limit = 1200\n\n    def _heuristic(self, pos: Point, target: Point) -> float:\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = Map.get_distance(to_pos, self._graph.root_vertex_goal.position)\n        max_step = self._base_step\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n        return max_step\n\n    def _get_new_vertex(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _sample_near_frontier(self, heap: list) -> Point:\n        import random\n        import numpy as np\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n        std_dev = 7.0  # slightly smaller jitter for tighter sampling\n\n        if not heap:\n            # fallback random uniform valid sampling\n            for _ in range(50):\n                rand_coords = np.random.randint(0, grid_size, dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        best_vertex = heap[0][1]\n        base_pos = best_vertex.position\n\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            jittered_coords.append(val)\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n\n        # fallback: random near root vertices if frontier sample invalid\n        # pick random root vertex position plus small gaussian\n        roots = [v.position for v in [self._graph.root_vertex_start, self._graph.root_vertex_goal]]\n        fallback_base = random.choice(roots)\n        fallback_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = fallback_base[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            fallback_coords.append(val)\n        fallback_sample = Point(*fallback_coords)\n        if self._get_grid().is_agent_valid_pos(fallback_sample):\n            return fallback_sample\n\n        # Final fallback: goal position, guaranteed valid\n        return self._get_grid().goal.position\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex, root_vertex: Vertex) -> Vertex:\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position, root_vertex.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        path_start = []\n        curr = connect_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n            curr = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n            curr = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        # Concatenate start and goal paths crossing the connection edge\n        full_path = path_start + path_goal\n\n        # Shortcut and smooth the path\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list) -> None:\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n\n        # Candidates excluding roots\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def sort_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n        candidates_sorted = sorted(candidates, key=sort_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n        # Also prune heaps accordingly\n        def prune_heap(heap):\n            filtered_heap = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered_heap:\n                heap.append(item)\n\n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        heapq.heapify(self._heap_start)\n        heapq.heapify(self._heap_goal)\n\n        self._heap_start = []\n        self._heap_goal = []\n\n        heapq.heappush(self._heap_start, (self._heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_v.position, start_v.position), goal_v))\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        start_time = time.time()\n        iterations = 0\n\n        # Alternate expansions from start and goal trees\n        expand_from_start = True\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                break\n\n            if expand_from_start and self._heap_start:\n                _, current_v = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opposite_visited = visited_goal\n                current_visited = visited_start\n                current_heap = self._heap_start\n            elif (not expand_from_start) and self._heap_goal:\n                _, current_v = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opposite_visited = visited_start\n                current_visited = visited_goal\n                current_heap = self._heap_goal\n            else:\n                # if one heap is empty, switch\n                expand_from_start = not expand_from_start\n                continue\n\n            # Sample around frontier in current tree\n            sample_pos = self._sample_near_frontier(current_heap)\n\n            # Find nearest vertex in current tree\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            rewire_r = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vs = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_r)\n\n            best_parent = self._choose_best_parent(near_vs, q_new, tree_root)\n            if not best_parent:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    expand_from_start = not expand_from_start\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n            f_q_new = q_new.cost + self._heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_q_new, q_new))\n\n            self._rewire_neighbors(q_new, near_vs)\n            self._prune_vertices(self._heap_start, self._heap_goal)\n\n            # Check connection to opposite tree vertices within small radius\n            connection_radius = self._goal_radius\n            opposite_near = self._graph.get_vertices_within_radius([goal_v if expand_from_start else start_v], q_new.position, connection_radius)\n\n            connected_vertex_opposite = None\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                connected_vertex_opposite = v_opp\n                break\n\n            if connected_vertex_opposite:\n                # Connect the two trees\n                if expand_from_start:\n                    self._graph.add_edge(q_new, connected_vertex_opposite)\n                    self._extract_bidirectional_path(q_new, connected_vertex_opposite)\n                else:\n                    self._graph.add_edge(connected_vertex_opposite, q_new)\n                    self._extract_bidirectional_path(connected_vertex_opposite, q_new)\n                break\n\n            expand_from_start = not expand_from_start",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This path planning algorithm extends the original RRT*-inspired planner by integrating clearance-aware sampling and obstacle proximity heuristics to improve path quality and robustness. \n    Key improvements include adaptive obstacle clearance bias in sampling to prefer collision-free wide passages, dynamic step sizing based on local obstacle density, and enhanced rewiring that prioritizes safer, clearer connections. \n    The algorithm uses heuristic-guided expansion balancing cost-to-go and obstacle clearance, goal-biasing with safety margins, and a pruning scheme that favors well-connected, low-cost vertices maintaining a tighter vertex limit for memory efficiency. \n    Resulting paths exhibit improved clearance from obstacles, higher success rate within a 10-second planning window, and smoother trajectories after shortcut smoothing.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This path planning algorithm extends the original RRT*-inspired planner by integrating clearance-aware sampling and obstacle proximity heuristics to improve path quality and robustness. \n    Key improvements include adaptive obstacle clearance bias in sampling to prefer collision-free wide passages, dynamic step sizing based on local obstacle density, and enhanced rewiring that prioritizes safer, clearer connections. \n    The algorithm uses heuristic-guided expansion balancing cost-to-go and obstacle clearance, goal-biasing with safety margins, and a pruning scheme that favors well-connected, low-cost vertices maintaining a tighter vertex limit for memory efficiency. \n    Resulting paths exhibit improved clearance from obstacles, higher success rate within a 10-second planning window, and smoother trajectories after shortcut smoothing.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.18        # Slightly increased goal bias for focused sampling\n        self._rewire_radius = 14.0    # Slightly smaller initial rewire radius\n        self._vertex_limit = 1300     # More strict vertex limit to reduce memory usage\n        self._clearance_weight = 3.0  # Weight for clearance in cost heuristic\n\n    def _sample_with_clearance(self) -> Point:\n        \"\"\"Sample with clearance bias to favor locations with higher obstacle clearance.\"\"\"\n        import random\n        grid = self._get_grid()\n        size_dim = grid.size.n_dim\n        attempts = 0\n        def clearance_at(p: Point) -> float:\n            # Approximate clearance by min distance to obstacles around point:\n            obs_positions = [obs.position for obs in grid.obstacles]\n            if not obs_positions:\n                return float('inf')\n            min_dist = min([Map.get_distance(p, obs_pos) - getattr(obs, 'radius',1.0) for obs_pos, obs in zip(obs_positions, grid.obstacles)])\n            return max(min_dist, 0.0)\n\n        # Goal bias sampling\n        if random.random() < self._goal_bias:\n            return grid.goal.position\n\n        best_sample = None\n        best_clearance = -1.0\n        max_samples = 40\n        while attempts < max_samples:\n            rand_coords = np.random.randint(0, grid.size, size_dim)\n            p = Point(*rand_coords)\n            if not grid.is_agent_valid_pos(p):\n                attempts += 1\n                continue\n            cur_clearance = clearance_at(p)\n            # Accept sample probabilistically better clearance\n            if cur_clearance > best_clearance:\n                best_clearance = cur_clearance\n                best_sample = p\n            attempts += 1\n        if best_sample is None:\n            return grid.goal.position\n        return best_sample\n\n    def _cost_clearance_aware(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"Cost function combining distance, movement cost, and clearance heuristic.\"\"\"\n        grid = self._get_grid()\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = grid.get_movement_cost(frm.position, to.position)\n        # Approximate clearance by min distance to obstacles along the line between frm and to\n        line_seq = grid.get_line_sequence(frm.position, to.position)\n        clearance_values = []\n        for p in line_seq:\n            dist_obs = float('inf')\n            for obs in grid.obstacles:\n                d = Map.get_distance(p, obs.position) - getattr(obs, 'radius', 1.0)\n                if d < dist_obs:\n                    dist_obs = d\n            clearance_values.append(max(dist_obs, 0.0))\n        if clearance_values:\n            min_clearance = min(clearance_values)\n        else:\n            min_clearance = 0.0\n        clearance_penalty = self._clearance_weight / (min_clearance + 0.1)  # Avoid dividing by zero\n\n        return dist + move_cost + clearance_penalty\n\n    def _choose_best_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"Pick the parent minimizing clearance-aware cost.\"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        for v in near_vertices:\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost_clearance_aware(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire_improved(self, near_vertices: list, q_new: Vertex) -> None:\n        \"\"\"Rewire vertices considering clearance-aware costs for better path quality.\"\"\"\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost_clearance_aware(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove all existing parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _adaptive_step_size(self, q_near: Vertex, q_sample: Point, iteration: int, max_iterations: int) -> float:\n        \"\"\"Calculate adaptive step size based on obstacle proximity and iteration.\"\"\"\n        base_step = min(self._max_dist_base, Map.get_distance(q_near.position, q_sample))\n        # Approximate local obstacle proximity around q_near:\n        grid = self._get_grid()\n        local_clearance = float('inf')\n        for obs in grid.obstacles:\n            dist_obs = Map.get_distance(q_near.position, obs.position) - getattr(obs, 'radius', 1.0)\n            if dist_obs < local_clearance:\n                local_clearance = dist_obs\n        local_clearance = max(local_clearance, 0.5)  # minimum clearance cap\n\n        # Shrink step size close to obstacles and as iterations progress\n        clearance_factor = min(local_clearance / 10.0, 1.0)\n        iteration_factor = 1.0 - (iteration / max_iterations) * 0.6  # reduce step over time\n        adaptive_step = base_step * clearance_factor * iteration_factor\n        # Clamp to reasonable min/max\n        return max(3.0, min(adaptive_step, base_step))\n\n    def _limit_graph_clearance_prune(self) -> None:\n        \"\"\"Prune vertices prioritizing clearance and cost to keep memory low.\"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Sort vertices by clearance-weighted cost descending, ignore start/goal\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        grid = self._get_grid()\n        def clearance_at_vertex(v: Vertex) -> float:\n            min_clearance = float('inf')\n            for obs in grid.obstacles:\n                d = Map.get_distance(v.position, obs.position) - getattr(obs, 'radius', 1.0)\n                if d < min_clearance:\n                    min_clearance = d\n            return max(min_clearance, 0.0)\n        vertices = sorted(vertices, key=lambda v: v.cost - 2*self._clearance_weight * clearance_at_vertex(v), reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 7000  # Lower iteration cap due to better sampling\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout due to max time\n                break\n\n            q_sample = self._sample_with_clearance()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            adaptive_step = self._adaptive_step_size(q_near, q_sample, iteration, max_iterations)\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_best_parent(near_vertices, q_new)\n            if best_parent is None:\n                # fallback: if nearest valid, connect\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost_clearance_aware(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire_improved(near_vertices, q_new)\n\n            self._limit_graph_clearance_prune()\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost_clearance_aware(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"Improved Bidirectional Heuristic-Guided Sampling Path Planner with Clearance-Aware Adaptive Step and Clearance-Biased Sampling.\n\nAlgorithm Description:\nThis improved algorithm extends the provided bidirectional heuristic sampling planner by integrating clearance-awareness into adaptive steps and sampling to improve safety margin from obstacles and improve path quality. Key improvements:\n\n- Clearance-aware adaptive step size: step size dynamically shrinks near obstacles and expands in free space to promote quicker exploration in open areas but finer exploration near obstacles.\n- Clearance-biased goal and start frontier sampling: samples are biased towards regions with higher clearance (distance from obstacles) using Gaussian jitter plus clearance weighting, reducing collision risks.\n- Continual rewire refinement with clearance consideration to incrementally shorten and smooth path costs.\n- Early stopping on connection success or timeout after 10 seconds.\n- Post-processing path shortcutting to improve smoothness.\n- Heuristic-guided vertex selection using combined cost-to-come + clearance-weighted heuristic cost-to-go for both start and goal trees.\n- Pruning vertices considering clearance and cost to balance graph size and quality.\n- Maintains the bidirectional tree growth with connection checking each iteration.\n\nThis approach improves planning efficiency, robustness, success rate, and yields safer and smoother paths in cluttered grid environments.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []         # Min-heap for frontier vertices from start (f = g + h)\n        self._heap_goal = []          # Min-heap for frontier vertices from goal (f = g + h)\n        self._max_iter = 6000\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 20.0\n        self._vertex_prune_limit = 1200\n\n        # Additional for clearance-aware planning\n        self._clearance_influence_dist = 15.0  # Distance threshold to influence step size and heuristic by clearance\n        self._clearance_sample_attempts = 25  # Number of attempts to find high clearance sample near frontier\n        self._clearance_weight = 2.5  # Weighting factor for clearance in heuristic\n        self._min_step = 4.0          # Minimum adaptive step size\n\n\n    def _query_clearance(self, pos: Point) -> float:\n        \"\"\"\n        Returns the clearance (minimum distance) from position pos to the nearest obstacle.\n        If no obstacles, returns a large value.\n        \"\"\"\n        grid = self._get_grid()\n        min_clearance = float('inf')\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(pos, obstacle.position) - (obstacle.radius if hasattr(obstacle, 'radius') else 0)\n            if dist < min_clearance:\n                min_clearance = dist\n        if min_clearance == float('inf'):\n            # No obstacles present\n            return 1000.0\n        return max(0.0, min_clearance)\n\n    def _clearance_weighted_heuristic(self, pos: Point, target: Point) -> float:\n        \"\"\"\n        Heuristic function weighted inversely by clearance at pos to prefer paths with higher clearance.\n        \"\"\"\n        base_dist = Map.get_distance(pos, target)\n        clearance = max(1e-3, self._query_clearance(pos))\n        # Higher clearance => lower heuristic cost\n        clearance_factor = 1.0 + self._clearance_weight / clearance\n        return base_dist * clearance_factor\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        \"\"\"\n        Adaptive step size influenced by clearance near from_pos and distance to goal/start.\n        Smaller steps near obstacles, larger in free space.\n        \"\"\"\n        base_dist = Map.get_distance(from_pos, to_pos)\n        max_step = self._base_step\n\n        clearance = self._query_clearance(from_pos)\n        # Shrink step size near obstacles\n        if clearance < self._clearance_influence_dist:\n            factor = clearance / self._clearance_influence_dist\n            max_step *= (0.3 + 0.7 * factor)\n            max_step = max(max_step, self._min_step)\n        else:\n            max_step = self._base_step\n\n        # Also shrink if line sequence not valid (potential collisions)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n            max_step = max(max_step, self._min_step)\n\n        # Final min with base_dist to avoid overshoot\n        return min(max_step, base_dist)\n\n    def _sample_near_frontier(self, heap: list, root_vertex: Vertex) -> Point:\n        \"\"\"\n        Clearance-biased sampling around frontier vertices in given heap.\n        Samples multiple candidates near top heap vertex, picks the one with highest clearance.\n        Fallback to fallback modes if none valid.\n        \"\"\"\n        import random\n        import numpy as np\n\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n        std_dev = 7.0\n\n        if not heap:\n            # fallback uniform random valid sampling\n            for _ in range(50):\n                rand_coords = np.random.randint(0, grid_size, dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        best_vertex = heap[0][1]\n        base_pos = best_vertex.position\n\n        best_sample = None\n        best_clearance = -1.0\n\n        for _ in range(self._clearance_sample_attempts):\n            jittered_coords = []\n            for i in range(dim):\n                jitter = random.gauss(0, std_dev)\n                val = base_pos[i] + jitter\n                val = max(0, min(grid_size[i] - 1, int(round(val))))\n                jittered_coords.append(val)\n            sample = Point(*jittered_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                clearance = self._query_clearance(sample)\n                if clearance > best_clearance:\n                    best_clearance = clearance\n                    best_sample = sample\n\n        if best_sample is not None:\n            return best_sample\n\n        # fallback: near root vertices with clearance bias\n        roots = [v.position for v in [self._graph.root_vertex_start, self._graph.root_vertex_goal]]\n        fallback_base = random.choice(roots)\n\n        best_sample_fb = None\n        best_clearance_fb = -1.0\n        for _ in range(self._clearance_sample_attempts):\n            fallback_coords = []\n            for i in range(dim):\n                jitter = random.gauss(0, std_dev)\n                val = fallback_base[i] + jitter\n                val = max(0, min(grid_size[i] - 1, int(round(val))))\n                fallback_coords.append(val)\n            fallback_sample = Point(*fallback_coords)\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                clearance = self._query_clearance(fallback_sample)\n                if clearance > best_clearance_fb:\n                    best_clearance_fb = clearance\n                    best_sample_fb = fallback_sample\n        if best_sample_fb is not None:\n            return best_sample_fb\n\n        # Final fallback: goal position guaranteed valid\n        return self._get_grid().goal.position\n\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex, root_vertex: Vertex) -> Vertex:\n        \"\"\"\n        Overridden to consider clearance-weighted heuristic.\n        \"\"\"\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n\n            # Clearance-weighted heuristic from q_new to root_vertex\n            h = self._clearance_weighted_heuristic(q_new.position, root_vertex.position)\n            cost_f = cost_g + h\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Overridden to consider clearance in rewiring cost improvements.\n        \"\"\"\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"\n        Modified cost combining distance, movement cost, and clearance penalty.\n        Lower cost for higher clearance segments.\n        \"\"\"\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        clearance_to = self._query_clearance(to.position)\n        clearance_factor = 1.0 if clearance_to > 1e-3 else 10.0  # high penalty for zero clearance\n        return (dist + move_cost) * clearance_factor\n\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list) -> None:\n        \"\"\"\n        Improved pruning to remove vertices with poor clearance and large cost.\n        \"\"\"\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n        # Candidates excluding roots\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def sort_key(v):\n            clear_val = self._query_clearance(v.position)\n            # prioritize pruning low clearance and high cost nodes\n            return (v.cost + Map.get_distance(v.position, goal_pos)) / (clear_val + 1e-3)\n        candidates_sorted = sorted(candidates, key=sort_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n        # Prune heaps accordingly\n        def prune_heap(heap):\n            filtered_heap = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered_heap:\n                heap.append(item)\n\n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        heapq.heapify(self._heap_start)\n        heapq.heapify(self._heap_goal)\n\n        self._heap_start = []\n        self._heap_goal = []\n\n        heapq.heappush(self._heap_start, (self._clearance_weighted_heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (self._clearance_weighted_heuristic(goal_v.position, start_v.position), goal_v))\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        start_time = time.time()\n        iterations = 0\n\n        expand_from_start = True\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                # Timed out without a path\n                break\n\n            if expand_from_start and self._heap_start:\n                _, current_v = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opposite_visited = visited_goal\n                current_visited = visited_start\n                current_heap = self._heap_start\n                opposite_root = goal_v\n            elif (not expand_from_start) and self._heap_goal:\n                _, current_v = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opposite_visited = visited_start\n                current_visited = visited_goal\n                current_heap = self._heap_goal\n                opposite_root = start_v\n            else:\n                # If one heap empty, switch expansion side\n                expand_from_start = not expand_from_start\n                continue\n\n            # Clearance-biased sample around frontier in current tree\n            sample_pos = self._sample_near_frontier(current_heap, tree_root)\n\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step)\n\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n\n            rewire_r = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vs = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_r)\n\n            best_parent = self._choose_best_parent(near_vs, q_new, tree_root)\n            if not best_parent:\n                q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                best_parent = q_near\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n            f_q_new = q_new.cost + self._clearance_weighted_heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_q_new, q_new))\n\n            # Rewiring with clearance considerations\n            self._rewire_neighbors(q_new, near_vs)\n            self._prune_vertices(self._heap_start, self._heap_goal)\n\n            # Check for connection with opposite tree vertices inside radius (within goal radius)\n            connection_radius = self._goal_radius\n            opposite_near = self._graph.get_vertices_within_radius([opposite_root], q_new.position, connection_radius)\n\n            connected_vertex_opposite = None\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                connected_vertex_opposite = v_opp\n                break\n\n            if connected_vertex_opposite:\n                # Connect the two trees and extract path\n                if expand_from_start:\n                    self._graph.add_edge(q_new, connected_vertex_opposite)\n                    self._extract_bidirectional_path(q_new, connected_vertex_opposite)\n                else:\n                    self._graph.add_edge(connected_vertex_opposite, q_new)\n                    self._extract_bidirectional_path(connected_vertex_opposite, q_new)\n                break\n\n            expand_from_start = not expand_from_start",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An enhanced RRT*-inspired incremental tree algorithm emphasizing clearance-aware sampling\n    and heuristic-guided expansion. This variant improves path quality and success rate by:\n    - Incorporating adaptive adaptive clearance-based sampling that biases samples away from \n      obstacles using distance transform heuristics.\n    - Using a heuristic cost combining accumulated cost and estimated cost-to-go (A* style) \n      for parent choosing and rewiring, promoting globally better paths.\n    - Applying adaptive step size adjustment sensitive to clearance and goal proximity.\n    - Implementing goal-directed informed sampling inside an ellipsoidal heuristic region to \n      reduce unnecessary exploration.\n    - Employing a dynamic rewire radius that shrinks considering vertex density and environment size.\n    - Using path shortcut smoothing with multiple smoothing passes for improved final path.\n    - Early stopping upon reaching goal with a validated collision-free path.\n    The algorithm balances exploration, exploitation, and memory efficiency while maximizing clearance.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An enhanced RRT*-inspired incremental tree algorithm emphasizing clearance-aware sampling\n    and heuristic-guided expansion. This variant improves path quality and success rate by:\n    - Incorporating adaptive adaptive clearance-based sampling that biases samples away from \n      obstacles using distance transform heuristics.\n    - Using a heuristic cost combining accumulated cost and estimated cost-to-go (A* style) \n      for parent choosing and rewiring, promoting globally better paths.\n    - Applying adaptive step size adjustment sensitive to clearance and goal proximity.\n    - Implementing goal-directed informed sampling inside an ellipsoidal heuristic region to \n      reduce unnecessary exploration.\n    - Employing a dynamic rewire radius that shrinks considering vertex density and environment size.\n    - Using path shortcut smoothing with multiple smoothing passes for improved final path.\n    - Early stopping upon reaching goal with a validated collision-free path.\n    The algorithm balances exploration, exploitation, and memory efficiency while maximizing clearance.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 18.0\n        self._goal_bias = 0.20       # Slightly increased goal bias for more goal focus\n        self._rewire_radius = 20.0   # Larger initial rewire radius for better connectivity\n        self._informed_sampling = True\n        self._vertex_limit = 1200    # Maintain vertex limit for memory balance\n        self._clearance_weight = 5.0 # Weight factor to bias sampling away from obstacles\n        self._max_sampling_attempts = 75\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        \"\"\"Heuristic estimate from pos to goal: Euclidean + minimal movement cost\"\"\"\n        goal_pos = self._get_grid().goal.position\n        euclid = Map.get_distance(pos, goal_pos)\n        # Assume minimal movement cost approx proportional to euclid\n        return euclid\n\n    def _cost_with_heuristic(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"Cost from frm to to plus heuristic cost from to to goal - for A* style.\"\"\"\n        cost = self._cost(frm, to)\n        return cost + self._heuristic_cost(to.position)\n\n    def _get_clearance(self, pos: Point) -> float:\n        \"\"\"Estimate clearance (distance from obstacles) at position by checking neighborhood.\n           Returns a positive number, higher means safer.\"\"\"\n        # Sample neighborhood points radially around pos within radius 3\n        radius_check = 3\n        min_dist = float('inf')\n        grid_size = self._get_grid().size\n        obstacles = self._get_grid().obstacles\n        for dx in range(-radius_check, radius_check + 1):\n            for dy in range(-radius_check, radius_check + 1):\n                nx, ny = pos.x + dx, pos.y + dy\n                if nx < 0 or ny < 0 or nx >= grid_size.x or ny >= grid_size.y:\n                    continue\n                pt = Point(nx, ny)\n                # Check if this pt is obstacle (approximate checking by invalid pos)\n                if not self._get_grid().is_agent_valid_pos(pt):\n                    dist = Map.get_distance(pos, pt)\n                    if dist < min_dist:\n                        min_dist = dist\n        if min_dist == float('inf'):\n            # No obstacles nearby, high clearance\n            return radius_check + 1.0\n        return max(0.1, min_dist)  # keep clearance minimum > 0 to avoid zero division\n\n    def _informed_sample(self, c_best: float, c_min: float, start: Point, goal: Point) -> Point:\n        \"\"\"Sample within ellipsoidal informed region for informed RRT* sampling.\"\"\"\n        if c_best == float('inf'):\n            # No solution yet: uniform random valid sample\n            return self._random_valid_sample()\n        # Ellipsoidal region parameters\n        center = Point((start.x+goal.x)/2, (start.y+goal.y)/2)\n        a1 = (goal.x - start.x) / c_min\n        a2 = (goal.y - start.y) / c_min\n        # Sample random point in unit circle\n        import math, random\n        while True:\n            # Uniform sample inside unit circle\n            r = random.random()\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = r * math.cos(theta)\n            y_ball = r * math.sin(theta)\n\n            # Rotate and scale according to ellipsoid axes\n            px = center.x + c_best / 2 * (a1 * x_ball + -a2 * y_ball)\n            py = center.y + c_best / 2 * (a2 * x_ball + a1 * y_ball)\n\n            sample = Point(int(round(px)), int(round(py)))\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _random_valid_sample(self) -> Point:\n        \"\"\"Random valid sample in the grid.\"\"\"\n        import random\n        attempts = 0\n        while attempts < self._max_sampling_attempts:\n            rand_pos = [random.randint(0, self._get_grid().size[i]-1) for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # fallback\n        return self._get_grid().goal.position\n\n    def _get_goal_biased_sample(self, c_best: float, c_min: float, start: Point, goal: Point) -> Point:\n        \"\"\"Goal biased informed sampling combining clearance bias.\"\"\"\n        import random\n        if random.random() < self._goal_bias:\n            return goal\n        if self._informed_sampling and c_best < float('inf'):\n            # Sample in informed ellipsoid with clearance bias\n            for _ in range(self._max_sampling_attempts):\n                sample = self._informed_sample(c_best, c_min, start, goal)\n                clearance = self._get_clearance(sample)\n                if clearance > 0.5:  # bias samples with sufficient clearance\n                    return sample\n            # fallback to general random valid\n            return self._random_valid_sample()\n        else:\n            # Prior to any solution, sample randomly favoring clearance\n            for _ in range(self._max_sampling_attempts):\n                sample = self._random_valid_sample()\n                clearance = self._get_clearance(sample)\n                # Accept with probability proportional to clearance (bias to safer)\n                if random.random() < clearance / (self._clearance_weight + 1e-6):\n                    return sample\n            return self._random_valid_sample()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"Adaptive step size reduced if clearance low near q_near or near goal for cautious extension.\"\"\"\n        import torch\n\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist == 0:\n            return None\n        step = min(max_dist, dist)\n\n        # Adapt step based on clearance near q_near (smaller step near obstacles)\n        clearance_near = self._get_clearance(q_near.position)\n        clearance_factor = min(1.0, clearance_near / 3.0)\n        step *= (0.5 + 0.5 * clearance_factor)\n\n        # Also reduce step near goal to avoid overshoot\n        dist_goal = Map.get_distance(q_near.position, self._get_grid().goal.position)\n        if dist_goal < step * 2:\n            step = dist_goal * 0.8\n\n        dir_normalized = dir_tensor / dist\n        pos_tensor = q_near.position.to_tensor() + step * dir_normalized\n        new_pos = Point.from_tensor(pos_tensor.round())\n\n        # Verify new_pos is valid grid position (clamp if needed)\n        grid_size = self._get_grid().size\n        clamped_x = max(0, min(int(new_pos.x), grid_size.x-1))\n        clamped_y = max(0, min(int(new_pos.y), grid_size.y-1))\n        new_pos = Point(clamped_x, clamped_y)\n\n        return Vertex(new_pos)\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"Choose best parent using A*-like f-cost = cost + heuristic.\"\"\"\n        min_f_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            tentative_cost = v.cost + self._cost(v, q_new)\n            f_cost = tentative_cost + self._heuristic_cost(q_new.position)\n            if f_cost < min_f_cost:\n                min_f_cost = f_cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        \"\"\"Rewire neighbors if q_new provides a better cost path using heuristic cost.\"\"\"\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove old parent edges for memory efficiency\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"Decrease rewire radius more adaptively with vertex count and iteration progress.\"\"\"\n        min_radius = 4.0\n        max_radius = self._rewire_radius\n        progress_ratio = iteration / max_iterations\n        dynamic_radius = max_radius * (1.0 - progress_ratio)**0.75\n        # Adapt radius with sqrt of inverse vertex density for uniform pruning\n        vertex_density_factor = max(1, (self._graph.size / 1000)**0.5)\n        radius = max(min_radius, dynamic_radius / vertex_density_factor)\n        return radius\n\n    def _limit_graph_size(self) -> None:\n        \"\"\"Limit vertex count by pruning highest cost and low-clearance vertices far from path.\"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n\n        # Sort by combined cost and penalty for low clearance\n        def vertex_badness(v: Vertex):\n            clearance = self._get_clearance(v.position)\n            clearance_penalty = max(0.0, 1.0 - clearance / 5.0) * 50.0\n            return v.cost + clearance_penalty\n\n        vertices = sorted(vertices, key=vertex_badness, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"Multiple passes shortcut smoothing for better path.\"\"\"\n        if len(path) <= 2:\n            return path\n\n        def single_pass_smooth(in_path):\n            smoothed = [in_path[0]]\n            i = 0\n            while i < len(in_path) - 1:\n                j = len(in_path) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(in_path[i].position, in_path[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        break\n                    j -= 1\n                smoothed.append(in_path[j])\n                i = j\n            return smoothed\n\n        smoothed = path\n        for _ in range(3):\n            smoothed = single_pass_smooth(smoothed)\n\n        return smoothed\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            # Choose parent with minimal cost\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 7000\n        max_dist_base = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        c_best = float('inf')  # best solution cost found\n        c_min = Map.get_distance(start_vertex.position, goal_pos)  # minimal possible cost (heuristic)\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout reached - no solution found in time\n                break\n\n            q_sample = self._get_goal_biased_sample(c_best, c_min, start_vertex.position, goal_pos)\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = min(max_dist_base, dist_to_sample)\n\n            # Reduce adaptive_step near obstacles + integrate clearance awareness inside new vertex generation\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n            if not q_new:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Dynamically shrink rewire radius considering progress and graph size\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to nearest vertex if valid line\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            # Prune graph vertices for memory efficiency\n            self._limit_graph_size()\n\n            # Check goal proximity for early termination\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    # Update best cost if improved\n                    if q_goal.cost < c_best:\n                        c_best = q_goal.cost\n                    self._extract_path(q_goal)\n                    break  # Success - path found\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm enhances the base A*-inspired sampling and rewiring approach \n    by incorporating clearance-aware sampling and cost functions to favor safer wide-clearance paths.\n\n    Key enhancements:\n    - Clearance-guided sampling: Samples are more likely taken in areas with higher clearance from obstacles,\n      reducing collision risk and improving path robustness.\n    - Clearance-weighted cost: Edge costs incorporate obstacle clearance, penalizing paths near obstacles.\n    - Adaptive step size refined with clearance heuristic to better navigate tight spaces.\n    - Dynamic rewiring radius scaling based on sampling progress and clearance improves local optimization.\n    - Early stopping with direct goal connection attempts is retained but with clearance consideration.\n    - Path smoothing via shortcutting applied as before for smoother final path.\n    - Timeout enforced at 10 seconds to avoid endless running.\n    These improvements aim to boost planning speed, path quality (smoothness and clearance), and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap = []               # Min-heap for frontier vertices (f = g + h)\n        self._max_iter = 6000         # Max iterations before timeout/failure\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0          # seconds limit\n        self._base_step = 12.0        # Base adaptive step distance\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 1200\n\n        # New member: clearance threshold to bias sampling towards safer areas\n        self._clearance_sample_threshold = 5.0\n        # Cache to store obstacle boundaries for clearance computations\n        self._obstacle_bounds_cache = None  \n\n    def _compute_clearance(self, pos: Point) -> float:\n        \"\"\"\n        Estimate clearance of given position by checking minimal distance to any obstacle boundary point.\n        Larger clearance means farther from obstacles.\n        \"\"\"\n        grid = self._get_grid()\n        if self._obstacle_bounds_cache is None:\n            self._obstacle_bounds_cache = set()\n            for obstacle in grid.obstacles:\n                bound = grid.get_obstacle_bound(obstacle.position)\n                self._obstacle_bounds_cache.update(bound)\n\n        min_dist = float('inf')\n        for bound_point in self._obstacle_bounds_cache:\n            d = Map.get_distance(pos, bound_point)\n            if d < min_dist:\n                min_dist = d\n            if min_dist < 0.1:\n                break\n        return min_dist if min_dist != float('inf') else 1000.0\n\n    def _clearance_weighted_cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"\n        Cost includes Euclidean + movement cost penalized by clearance (favoring wider clearance).\n        Cost = base_cost + clearance_penalty\n        \"\"\"\n        dist = Map.get_distance(frm.position, to.position)\n        base_cost = dist + self._get_grid().get_movement_cost(frm.position, to.position)\n        clearance = self._compute_clearance(to.position)\n        # Penalize low clearance by adding inverse clearance term scaled by distance\n        clearance_penalty = 0.0\n        clearance_threshold = 4.0\n        if clearance < clearance_threshold:\n            clearance_penalty = (clearance_threshold - clearance) * 2.5\n        return base_cost + clearance_penalty\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        \"\"\"\n        Adaptive step that shrinks near goal and obstacles and also adjusts for clearance.\n        Shrink step near obstacles or low clearance zones.\n        \"\"\"\n        dist_to_goal = self._heuristic(to_pos)\n        max_step = self._base_step\n\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n\n        # Check if line is valid (obstacle free)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5  # reduce step near obstacles\n\n        clearance = self._compute_clearance(to_pos)\n        # If clearance low, reduce step to navigate carefully\n        if clearance < 6.0:\n            scale = max(0.3, (clearance / 6.0))\n            max_step *= scale\n\n        return max_step\n\n    def _get_clearance_biased_sample(self) -> Point:\n        \"\"\"\n        Sample points biased towards frontier area with good clearance.\n        Combines Gaussian jitter around best vertex plus filtering on clearance,\n        fallback to uniform random valid sampling if needed.\n        \"\"\"\n        import random\n        import numpy as np\n\n        if not self._heap:\n            # fallback random valid sample in environment\n            for _ in range(100):\n                rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    clearance = self._compute_clearance(candidate)\n                    if clearance > self._clearance_sample_threshold:\n                        return candidate\n            return self._get_grid().goal.position\n\n        f_min_vertex = self._heap[0][1]\n        base_pos = f_min_vertex.position\n\n        dim = self._get_grid().size.n_dim\n        std_dev = 7.0  # exploration jitter scale slightly reduced\n        attempt = 0\n        while attempt < 20:\n            attempt += 1\n            jittered_coords = []\n            for i in range(dim):\n                jitter = random.gauss(0, std_dev)\n                val = base_pos[i] + jitter\n                val = max(0, min(self._get_grid().size[i] - 1, int(round(val))))\n                jittered_coords.append(val)\n            sample = Point(*jittered_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                clearance = self._compute_clearance(sample)\n                if clearance > self._clearance_sample_threshold:\n                    return sample\n\n        # If no high clearance sample found, fallback to original frontier sample or goal bias\n        return self._goal_biased_sample()\n\n    def _choose_parent_and_cost(self, near_vertices, q_new: Vertex) -> Vertex:\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._clearance_weighted_cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._clearance_weighted_cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        # Local rewiring with clearance-aware cost and dynamic radius scaling\n        graph_size = self._graph.size\n        radius_scale = min(1.0, max(0.4, (500.0 / max(graph_size, 1))))  # scale radius smaller with growing graph\n        rewire_radius = self._rewire_radius_init * radius_scale\n\n        filtered_neighbors = [v for v in neighbors if Map.get_distance(v.position, q_new.position) <= rewire_radius]\n\n        for v in filtered_neighbors:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._clearance_weighted_cost(q_new, v)\n            if new_cost < v.cost:\n                # Remove all parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Overriding to use clearance weighted cost consistently if called elsewhere\n        return self._clearance_weighted_cost(frm, to)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n        start_f = self._heuristic(start_vertex.position)\n        self._heap = []\n        heapq.heappush(self._heap, (start_f, start_vertex))\n\n        visited_positions = set()\n        visited_positions.add(start_vertex.position)\n\n        start_time = time.time()\n\n        iterations = 0\n\n        while self._heap and iterations < self._max_iter:\n            iterations += 1\n\n            if time.time() - start_time > self._timeout:\n                # Timeout: stop search\n                break\n\n            _, current_vertex = heapq.heappop(self._heap)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=current_vertex.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(current_vertex.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = current_vertex.cost + self._clearance_weighted_cost(current_vertex, q_goal)\n                    self._graph.add_edge(current_vertex, q_goal)\n                    self._extract_path(q_goal)\n                break\n\n            # Use clearance biased sampled points\n            q_sample_pos = self._get_clearance_biased_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n\n            if q_near.position == q_sample_pos:\n                continue\n\n            adaptive_step = self._generate_adaptive_step(q_near.position, q_sample_pos)\n\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            if q_new.position in visited_positions:\n                continue\n\n            # Select neighbors with extended radius for better rewiring potential\n            rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 7.0)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._clearance_weighted_cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_positions.add(q_new.position)\n\n            f_q_new = q_new.cost + self._heuristic(q_new.position)\n            heapq.heappush(self._heap, (f_q_new, q_new))\n\n            self._rewire_locally(q_new, near_vertices)\n\n            self._prune_excess_vertices()\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm enhances memory efficiency and planning speed \n    by introducing a dual-tree bidirectional search combined with incremental pruning \n    of less promising vertices. It maintains two directed trees grown from start and goal \n    simultaneously, using priority queues ordered by f = g + h costs to expand frontiers \n    closer to each other. Sampling is adaptively goal- and frontier-biased, with a capped \n    maximum number of vertices maintained to control memory footprint dynamically.\n\n    Key improvements:\n    - Bidirectional search with prioritized expansions from both start and goal.\n    - Dual heaps maintain frontiers from both roots, enabling earlier connection.\n    - Vertex pruning only removes vertices furthest from the midpoint between roots to preserve connectivity.\n    - Adaptive rewiring occurs in both trees to continuously optimize paths.\n    - Early termination at first valid connection between trees within goal radius.\n    - Path extraction merges two partial paths from start and goal trees, then shortcutting to smooth.\n    - Enforces 10 second global timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Initialize two root vertices: start and goal \n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []          # Min-heap for frontier vertices from start\n        self._heap_goal = []           # Min-heap for frontier vertices from goal\n\n        self._max_iter = 6000          # Maximum iterations \n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0           # Max planning time in seconds\n        self._base_step = 12.0         # Base adaptive step\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 1200\n\n    def _choose_best_connection(self, q_start_neighbors, q_goal_neighbors):\n        # Attempts to find a edge connection between start and goal trees that yields lowest total cost.\n        best_pair = None\n        lowest_cost = float('inf')\n        for v_start in q_start_neighbors:\n            for v_goal in q_goal_neighbors:\n                line_seq = self._get_grid().get_line_sequence(v_start.position, v_goal.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost = v_start.cost + self._cost(v_start, v_goal) + v_goal.cost\n                if cost < lowest_cost:\n                    lowest_cost = cost\n                    best_pair = (v_start, v_goal)\n        return best_pair\n\n    def _extract_bidirectional_path(self, v_start: Vertex, v_goal: Vertex):\n        # Extract path from start to v_start, and from goal to v_goal, then connect and shortcut\n        path_start = []\n        current = v_start\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(current)\n            current = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        current = v_goal\n        while current != self._graph.root_vertex_goal:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(current)\n            current = parent\n        path_goal.append(self._graph.root_vertex_goal)\n        # Goal tree path goes from goal towards connection; reverse it to start from connection\n        path_goal = list(reversed(path_goal))\n\n        # Connect paths by adding the connection edge vertex\n        full_path = path_start + path_goal[1:]\n        # Shortcut to smooth path\n        smoothed = self._shortcut_path(full_path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_vertices_bidirectional(self):\n        # Prune vertices preserving connectivity but capping total vertices below limit.\n        max_vertices = self._vertex_prune_limit\n        total_vertices = self._graph.size\n        if total_vertices <= max_vertices:\n            return\n\n        # Midpoint between start and goal root positions to measure vertex pruning priority\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n        midpoint = Point(\n            *( (start_pos[i] + goal_pos[i]) / 2.0 for i in range(start_pos.n_dim))\n        )\n\n        # Candidates excluding roots\n        candidates = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n\n        # Prune vertices furthest from the midpoint to preserve connectivity between start and goal regions\n        def prune_key(v: Vertex):\n            dist_mid = Map.get_distance(v.position, midpoint)\n            return dist_mid + v.cost\n\n        candidates_sorted = sorted(candidates, key=prune_key, reverse=True)\n        remove_count = total_vertices - max_vertices\n        to_remove = candidates_sorted[:remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _expand_vertex(self, heap, tree_root, other_root, visited_positions):\n        import heapq\n        if not heap:\n            return None\n\n        _, current_vertex = heapq.heappop(heap)\n\n        # Sample biased by frontier in this tree's heap or fallback random sampling\n        q_sample_pos = self._goal_biased_sample()\n\n        # Find nearest vertex in this tree to sample position\n        q_near = self._graph.get_nearest_vertex([tree_root], q_sample_pos)\n\n        if q_near.position == q_sample_pos:\n            return None\n\n        adaptive_step = self._generate_adaptive_step(q_near.position, q_sample_pos)\n        q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        # Prevent duplicate vertex positions\n        if q_new.position in visited_positions:\n            return None\n\n        # Get neighbors for rewiring\n        iter_count = len(heap) + 1  # rough iteration count proxy\n        rewire_radius = max(self._rewire_radius_init * (1.0 - iter_count / self._max_iter), 6.0)\n        near_vertices = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_radius)\n\n        best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n        if best_parent is None:\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                best_parent = q_near\n            else:\n                return None\n\n        self._graph.add_edge(best_parent, q_new)\n        visited_positions.add(q_new.position)\n\n        f_q_new = q_new.cost + self._heuristic(q_new.position)\n        heapq.heappush(heap, (f_q_new, q_new))\n\n        self._rewire_locally(q_new, near_vertices)\n\n        # Try to connect with other tree vertices near q_new for early termination\n        connect_radius = self._goal_radius * 2.0\n        other_near_vertices = self._graph.get_vertices_within_radius([other_root], q_new.position, connect_radius)\n        if other_near_vertices:\n            connection = self._choose_best_connection([q_new], other_near_vertices)\n            if connection:\n                return connection\n\n        return None\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        f_start = self._heuristic(start_vertex.position)\n        f_goal = self._heuristic(goal_vertex.position)\n\n        self._heap_start = []\n        self._heap_goal = []\n\n        heapq.heappush(self._heap_start, (f_start, start_vertex))\n        heapq.heappush(self._heap_goal, (f_goal, goal_vertex))\n\n        visited_positions_start = set()\n        visited_positions_goal = set()\n        visited_positions_start.add(start_vertex.position)\n        visited_positions_goal.add(goal_vertex.position)\n\n        start_time = time.time()\n\n        iterations = 0\n\n        connection_found = None\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            current_time = time.time()\n            if current_time - start_time > self._timeout:\n                # Timeout - no path found within time limit\n                break\n\n            # Alternate expansions for balanced bidirectional growth\n            if iterations % 2 == 1 and self._heap_start:\n                connection_found = self._expand_vertex(self._heap_start, self._graph.root_vertex_start, self._graph.root_vertex_goal, visited_positions_start)\n            elif self._heap_goal:\n                connection_found = self._expand_vertex(self._heap_goal, self._graph.root_vertex_goal, self._graph.root_vertex_start, visited_positions_goal)\n\n            if connection_found:\n                v_start, v_goal = connection_found\n                self._extract_bidirectional_path(v_start, v_goal)\n                break\n\n            # Prune vertices periodically every 200 iterations to control memory\n            if iterations % 200 == 0:\n                self._prune_vertices_bidirectional()\n\n            self.key_frame()\n\n        # If connection not found, optionally fallback to best single-tree path to goal if any\n        if not connection_found:\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=start_vertex.position, goal=self._get_grid().goal):\n                # Already at goal\n                self._extract_path(start_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm enhances memory efficiency and planning performance by incorporating:\n    - A priority queue (min-heap) to expand vertices based on an A*-inspired cost heuristic (cost + heuristic to goal)\n      to guide exploration towards promising nodes.\n    - Reduced unnecessary rewiring by rewiring only when improvements exceed a cost threshold.\n    - Adaptive max_dist controlled by local density to avoid dense over-sampling.\n    - Goal-biased adaptive sampling mixed with informed sampling within an ellipsoidal heuristic region to focus sampling \n      around the best current path candidate.\n    - Timeout at 10 seconds to maintain responsiveness.\n    - Shortcutting path smoothing on final extraction.\n    This leads to faster convergence to high-quality paths, fewer tree vertices, and improved success rates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15\n        self._rewire_radius = 18.0\n        self._cost_rewire_epsilon = 0.01  # minimum improvement threshold for rewiring\n\n    def _heuristic(self, pos: Point, goal: Point) -> float:\n        # Euclidean distance heuristic to goal\n        return Map.get_distance(pos, goal)\n\n    def _get_informed_sample(self, c_best: float, start_pos: Point, goal_pos: Point) -> Point:\n        # Informed sampling within an ellipse defined by c_best (current best path cost from start to goal)\n        # Samples are drawn within an ellipse to focus search on promising areas.\n        import random\n        import math\n        grid = self._get_grid()\n        if c_best == float('inf'):\n            # No solution found yet, fallback to uniform random sampling\n            while True:\n                pos = Point(*np.random.randint(0, grid.size, grid.size.n_dim))\n                if grid.is_agent_valid_pos(pos):\n                    return pos\n\n        # Ellipse center and axes definition\n        center = Point(\n            (start_pos.x + goal_pos.x) * 0.5,\n            (start_pos.y + goal_pos.y) * 0.5\n        )\n        a = c_best * 0.5  # major axis length\n        b = math.sqrt(max(c_best*c_best - Map.get_distance(start_pos, goal_pos)**2, 0)) * 0.5  # minor axis length\n\n        # Sample random point in unit circle\n        while True:\n            # Sample uniformly from unit disk using polar coordinates\n            r = math.sqrt(random.uniform(0, 1))\n            theta = random.uniform(0, 2 * math.pi)\n            x = r * math.cos(theta)\n            y = r * math.sin(theta)\n\n            # Scale to ellipse\n            sample_x = center.x + a * x\n            sample_y = center.y + b * y\n\n            # Round to grid point\n            sample_point = Point(int(round(sample_x)), int(round(sample_y)))\n\n            if 0 <= sample_point.x < grid.size.x and 0 <= sample_point.y < grid.size.y and grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_sample(self, c_best: float, start_pos: Point, goal_pos: Point) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return goal_pos\n        else:\n            return self._get_informed_sample(c_best, start_pos, goal_pos)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew + self._cost_rewire_epsilon < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        smoothed_path = self._shortcut_path(path)\n\n        for p in smoothed_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_time = time.time()\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        open_set = []  # heap queue of (estimated_total_cost, vertex)\n        heapq.heappush(open_set, (self._heuristic(start_vertex.position, goal_pos), start_vertex))\n\n        max_dist = self._max_dist_base\n        c_best = float('inf')\n        vertices = [start_vertex]\n\n        # Store all vertices in a set for quick membership - used in radius neighbor queries\n        vertex_positions_set = set()\n        vertex_positions_set.add(start_vertex.position)\n\n        while True:\n            if time.time() - start_time > 10.0:\n                break\n            if not open_set:\n                # no nodes to expand, failed to find path\n                break\n\n            _, current = heapq.heappop(open_set)\n\n            # Early stopping if current already in goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=current.position, goal=grid.goal):\n                # Construct and extract path\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(current.position, q_goal.position)):\n                    q_goal.cost = current.cost + self._cost(current, q_goal)\n                    self._graph.add_edge(current, q_goal)\n                    self._extract_path(q_goal)\n                    return\n\n            sample = self._get_sample(c_best, start_vertex.position, goal_pos)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], sample)\n            if q_near.position == sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, sample)\n            step = min(max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, sample, step)\n\n            if q_new.position in vertex_positions_set:\n                continue\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            vertices.append(q_new)\n            vertex_positions_set.add(q_new.position)\n\n            self._rewire(near_vertices, q_new)\n\n            # Update c_best if we got closer to goal or possibly found better path estimate\n            heuristic_cost = q_new.cost + self._heuristic(q_new.position, goal_pos)\n            if heuristic_cost < c_best:\n                c_best = heuristic_cost\n\n            # Push q_new into open set with A* like priority (cost + heuristic)\n            heapq.heappush(open_set, (q_new.cost + self._heuristic(q_new.position, goal_pos), q_new))\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"This improved algorithm is a memory-efficient bidirectional RRT*-inspired planner with heuristic and goal bias. \"\n    \"Key improvements focus on reduced memory footprint and faster convergence by: \"\n    \"- Maintaining only sets of frontier vertices (via heaps) without storing unnecessary graph details to prune memory usage. \"\n    \"- Aggressive pruning of non-promising vertices by cost and distance, limiting the graph size dynamically. \"\n    \"- Enhanced goal and start bias sampling with adaptive Gaussian jitter to concentrate sampling near promising regions. \"\n    \"- Adaptive step size determined by proximity to obstacles and remaining distance to goal/start. \"\n    \"- Bidirectional expansion alternating between start and goal trees, exploiting heuristic costs for prioritization. \"\n    \"- Local rewiring of neighbors to continuously improve path cost within a limited radius. \"\n    \"- Early stopping upon connecting trees within goal radius. \"\n    \"- Post-extraction shortcut smoothing for a shorter and smoother path. \"\n    \"- Enforced robust 10-second timeout for planning termination. \"\n    \"- Careful heap management and vertex pruning effectively reduces memory overhead, improving computational efficiency and success rates.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []\n        self._heap_goal = []\n\n        self._max_iter = 5000  # Reduced iterations for memory and efficiency\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 900  # More aggressive pruning\n\n        # Additional member variables for memory saving heuristics\n        self._sample_stddev = 5.5  # Smaller jitter for more concentrated sampling\n\n    def _heuristic(self, pos: 'Point', target: 'Point') -> float:\n        # Euclidean distance heuristic, favors close-to-goal expansion\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: 'Point', to_pos: 'Point') -> float:\n        dist_to_goal = Map.get_distance(to_pos, self._graph.root_vertex_goal.position)\n        dist_to_start = Map.get_distance(to_pos, self._graph.root_vertex_start.position)\n        max_step = self._base_step\n\n        # Scaling down step when close to goal or start for finer refinement\n        if dist_to_goal < 20.0:\n            max_step *= 0.45 + 0.55 * (dist_to_goal / 20.0)\n        if dist_to_start < 20.0:\n            max_step = min(max_step, 0.45 + 0.55 * (dist_to_start / 20.0) * self._base_step)\n\n        # Reduce step if line crosses obstacle\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.42\n\n        return max_step\n\n    def _sample_near_frontier(self, heap: list, root_positions: list) -> 'Point':\n        import random\n        import numpy as np\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n        std_dev = self._sample_stddev\n\n        if not heap:\n            for _ in range(40):  # reduced fallback attempts for performance\n                rand_coords = np.random.randint(0, grid_size, dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        # Bias towards the best frontier vertex with Gaussian jitter\n        best_vertex = heap[0][1]\n        base_pos = best_vertex.position\n\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            jittered_coords.append(val)\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n\n        # Fallback: sample near either root vertex with smaller jitter\n        fallback_base = random.choice(root_positions)\n        fallback_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev * 0.6)\n            val = fallback_base[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            fallback_coords.append(val)\n        fallback_sample = Point(*fallback_coords)\n        if self._get_grid().is_agent_valid_pos(fallback_sample):\n            return fallback_sample\n\n        # Final fallback guaranteed valid goal point\n        return self._get_grid().goal.position\n\n    def _choose_best_parent(self, near_vertices: list, q_new: 'Vertex', root_vertex: 'Vertex') -> 'Vertex':\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position, root_vertex.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: 'Vertex', neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: 'Vertex') -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: 'Vertex', to: 'Vertex') -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_bidirectional_path(self, connect_start: 'Vertex', connect_goal: 'Vertex') -> None:\n        path_start = []\n        curr = connect_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n            curr = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n            curr = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        full_path = path_start + path_goal\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list) -> None:\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def prune_metric(v):\n            # More aggressive pruning favors higher-cost and further vertices from goal\n            return v.cost + Map.get_distance(v.position, goal_pos)\n\n        candidates_sorted = sorted(candidates, key=prune_metric, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n        def prune_heap(heap):\n            filtered = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered:\n                heap.append(item)\n\n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        self._heap_start.clear()\n        self._heap_goal.clear()\n\n        heapq.heappush(self._heap_start, (self._heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_v.position, start_v.position), goal_v))\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        root_positions_start = [start_v.position]\n        root_positions_goal = [goal_v.position]\n\n        start_time = time.time()\n        iterations = 0\n\n        expand_from_start = True\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n\n            # Enforce timeout\n            if time.time() - start_time > self._timeout:\n                break\n\n            if expand_from_start and self._heap_start:\n                _, current_v = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opposite_visited = visited_goal\n                current_visited = visited_start\n                current_heap = self._heap_start\n                current_roots = root_positions_start\n                opposite_roots = root_positions_goal\n            elif (not expand_from_start) and self._heap_goal:\n                _, current_v = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opposite_visited = visited_start\n                current_visited = visited_goal\n                current_heap = self._heap_goal\n                current_roots = root_positions_goal\n                opposite_roots = root_positions_start\n            else:\n                expand_from_start = not expand_from_start\n                continue\n\n            sample_pos = self._sample_near_frontier(current_heap, current_roots)\n\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            rewire_r = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 5.5)\n            near_vs = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_r)\n\n            best_parent = self._choose_best_parent(near_vs, q_new, tree_root)\n            if not best_parent:\n                # If no best parent, try to connect directly to q_near if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    expand_from_start = not expand_from_start\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n            current_roots.append(q_new.position)  # track roots for sampling jitter\n\n            f_q_new = q_new.cost + self._heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_q_new, q_new))\n\n            self._rewire_neighbors(q_new, near_vs)\n            self._prune_vertices(self._heap_start, self._heap_goal)\n\n            # Attempt connection to opposite tree\n            connection_radius = self._goal_radius\n            opposite_near = self._graph.get_vertices_within_radius(\n                [goal_v if expand_from_start else start_v], q_new.position, connection_radius\n            )\n\n            connected_vertex_opposite = None\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    connected_vertex_opposite = v_opp\n                    break\n\n            if connected_vertex_opposite:\n                if expand_from_start:\n                    self._graph.add_edge(q_new, connected_vertex_opposite)\n                    self._extract_bidirectional_path(q_new, connected_vertex_opposite)\n                else:\n                    self._graph.add_edge(connected_vertex_opposite, q_new)\n                    self._extract_bidirectional_path(connected_vertex_opposite, q_new)\n                break\n\n            expand_from_start = not expand_from_start",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Bidirectional Heuristic-Guided RRT* with Memory-Efficient Pruning and Adaptive Sampling\n    \n    This implementation refines the provided bidirectional A*-inspired sampling planner by:\n    - Reducing memory footprint via more aggressive and frequent pruning based on cost and heuristic combined measure.\n    - Introducing a more focused goal/start biased sampling with dynamic bias probabilities.\n    - Using an adaptive max iteration approach that shortens search time when progress is slow.\n    - Limiting vertex neighborhood radius adaptively to minimize costly rewiring searches.\n    - Employing early stopping when connection quality threshold is met or if timeout (10s) is exceeded.\n    - Extracting a smoother path with enhanced shortcutting that aggressively attempts longer shortcut edges.\n    - Utilizing a combined cost+heuristic in vertex priority queues (f = g + h) to better guide search frontiers.\n    - Maintaining separate visited sets for fast membership queries and pruning.\n    \n    This approach emphasizes smarter pruning and adaptive sampling to improve success rate,\n    reduce iterations, and generate high-quality paths while controlling memory usage.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []\n        self._heap_goal = []\n\n        self._max_iter = 5000\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0\n        self._base_step = 14.0\n        self._rewire_radius_init = 15.0\n        self._vertex_prune_limit = 900\n\n        self._goal_bias_prob_start = 0.25\n        self._goal_bias_prob_goal = 0.25\n\n    def _heuristic(self, pos: Point, target: Point) -> float:\n        # Euclidean distance heuristic (consistent)\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        # Increase step size when far from goal/start, decrease in clutter or close area\n        dist_to_target = Map.get_distance(to_pos, self._graph.root_vertex_goal.position if from_pos != self._graph.root_vertex_goal.position else self._graph.root_vertex_start.position)\n        max_step = self._base_step\n        if dist_to_target < 15.0:\n            max_step *= 0.5 + 0.5 * (dist_to_target / 15.0)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.6  # smaller step when path blocked\n        return max_step\n\n    def _sample_biased(self, root_vertex: Vertex, opp_root_vertex: Vertex, sampling_from_start: bool) -> Point:\n        import random\n        import numpy as np\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n        std_dev = 4.5\n\n        prob_goal_bias = self._goal_bias_prob_start if sampling_from_start else self._goal_bias_prob_goal\n        prob_start_bias = 0.1 if sampling_from_start else 0.1\n\n        # Decide sampling strategy: goal bias, start bias, or near frontier vertex jitter\n        rand_val = random.random()\n        if rand_val < prob_goal_bias:\n            # Sample near goal or start depending on tree\n            base_pos = opp_root_vertex.position\n            jittered_coords = []\n            for i in range(dim):\n                jitter = random.gauss(0, std_dev)\n                val = base_pos[i] + jitter\n                val = max(0, min(grid_size[i] - 1, int(round(val))))\n                jittered_coords.append(val)\n            sample = Point(*jittered_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        \n        if rand_val < prob_goal_bias + prob_start_bias:\n            # Sample near own root to help exploration around root\n            base_pos = root_vertex.position\n            jittered_coords = []\n            for i in range(dim):\n                jitter = random.gauss(0, std_dev)\n                val = base_pos[i] + jitter\n                val = max(0, min(grid_size[i] - 1, int(round(val))))\n                jittered_coords.append(val)\n            sample = Point(*jittered_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        \n        # Otherwise sample near frontier vertex (best in heap)\n        frontier_heap = self._heap_start if sampling_from_start else self._heap_goal\n        if frontier_heap:\n            best_f, best_vertex = frontier_heap[0]\n            base_pos = best_vertex.position\n            jittered_coords = []\n            for i in range(dim):\n                jitter = random.gauss(0, std_dev)\n                val = base_pos[i] + jitter\n                val = max(0, min(grid_size[i] - 1, int(round(val))))\n                jittered_coords.append(val)\n            sample = Point(*jittered_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # Random uniform fallback (50 attempts)\n        for _ in range(50):\n            rand_coords = np.random.randint(0, grid_size, dim)\n            candidate = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n        # Last fallback: goal position (guaranteed valid)\n        return self._get_grid().goal.position\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex, root_vertex: Vertex) -> Vertex:\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position, root_vertex.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list, visited_start: dict, visited_goal: dict) -> None:\n        # More aggressive pruning based on combined cost + heuristic ordering (max number of vertices allowed)\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n        \n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n        \n        goal_pos = self._graph.root_vertex_goal.position\n        \n        # Sort by (cost + h) descending - prune worst first\n        def sort_key(v):\n            h = Map.get_distance(v.position, goal_pos)\n            return v.cost + h\n        candidates_sorted = sorted(candidates, key=sort_key, reverse=True)\n        \n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n        \n        for v in to_remove:\n            # Remove edges and detach vertices fully\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n            visited_start.pop(v.position, None)\n            visited_goal.pop(v.position, None)\n        \n        self._graph.size = len(self._graph.root_vertices)\n        \n        # Prune heaps\n        def prune_heap(heap):\n            filtered_heap = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered_heap:\n                heap.append(item)\n        \n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        # Aggressive shortcutting tries longest jumps first at each step\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        path_start = []\n        curr = connect_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n            curr = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n            curr = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        full_path = path_start + path_goal\n\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        self._heap_start.clear()\n        self._heap_goal.clear()\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        # Push roots with f = g + h\n        heapq.heappush(self._heap_start, (start_v.cost + self._heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (goal_v.cost + self._heuristic(goal_v.position, start_v.position), goal_v))\n\n        start_time = time.time()\n        iterations = 0\n        expand_from_start = True\n\n        # Track best connection cost to support early stopping\n        best_connection_cost = float('inf')\n        best_connection_pair = None\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._timeout:\n                break\n\n            if expand_from_start and self._heap_start:\n                _, curr_vertex = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opp_root = goal_v\n                current_visited = visited_start\n                opposite_visited = visited_goal\n                current_heap = self._heap_start\n                from_start = True\n            elif (not expand_from_start) and self._heap_goal:\n                _, curr_vertex = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opp_root = start_v\n                current_visited = visited_goal\n                opposite_visited = visited_start\n                current_heap = self._heap_goal\n                from_start = False\n            else:\n                expand_from_start = not expand_from_start\n                continue\n\n            sample_pos = self._sample_biased(tree_root, opp_root, sampling_from_start=from_start)\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step_size = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step_size)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            # Adaptive radius simplifies as search progresses, smaller near timeout or iteration max\n            dynamic_rewire_radius = max(self._rewire_radius_init * (1.0 - iterations/self._max_iter), 5.0)\n\n            near_vertices = self._graph.get_vertices_within_radius([tree_root], q_new.position, dynamic_rewire_radius)\n\n            best_parent = self._choose_best_parent(near_vertices, q_new, tree_root)\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    expand_from_start = not expand_from_start\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n\n            f_val = q_new.cost + self._heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_val, q_new))\n\n            self._rewire_neighbors(q_new, near_vertices)\n            self._prune_vertices(self._heap_start, self._heap_goal, visited_start, visited_goal)\n\n            # Connection attempts: search opposite tree vertices within radius\n            connection_radius = self._goal_radius + 3.0  # slightly larger radius for connection\n\n            opposite_near = self._graph.get_vertices_within_radius([opp_root], q_new.position, connection_radius)\n\n            connection_made = False\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n\n                total_cost = q_new.cost + v_opp.cost + Map.get_distance(q_new.position, v_opp.position)\n                if total_cost < best_connection_cost:\n                    best_connection_cost = total_cost\n                    best_connection_pair = (q_new, v_opp)\n                \n                connection_made = True\n                break  # only need one connection\n\n            if connection_made:\n                # Early stopping criteria: good enough connection found or timeout near\n                if best_connection_pair:\n                    q_start, q_goal = best_connection_pair if from_start else (best_connection_pair[1], best_connection_pair[0])\n                    if from_start:\n                        self._graph.add_edge(q_start, q_goal)\n                    else:\n                        self._graph.add_edge(q_goal, q_start)\n                    self._extract_bidirectional_path(q_start, q_goal)\n                    break\n\n            expand_from_start = not expand_from_start",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm combines heuristic guided best-first expansion (A* inspired) with dynamic adaptive step size \n    and goal-biased adaptive sampling. Instead of random sampling followed by nearest vertex extension,\n    it uses a priority queue (min-heap) of frontier vertices prioritized by their estimated total cost \n    (cost_so_far + heuristic to goal). This best-first process tends to explore promising regions first, \n    improving efficiency and success rate.\n    \n    Key features:\n    - Priority queue maintaining frontier vertices prioritized by cost + heuristic (A* style)\n    - Adaptive step size scaled by distance to goal to allow larger steps further away and finer near goal\n    - Goal biasing by injecting goal vertex into frontier early and by probabilistic sampling near goal\n    - Attempt to connect new vertices to multiple near neighbors and rewiring to optimize cost\n    - Early stopping once goal reached\n    - Path shortcutting and smoothing after extraction to improve path quality\n    - Timeout enforced after 10 seconds for responsiveness",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        # Initialize graph forest with start and goal vertices\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0   # Base adaptive max extend step\n        self._goal_bias = 0.2        # Goal bias probability for sampling near goal\n        self._rewire_radius = 18.0   # Radius to use for rewiring neighbors\n        self._heuristic_weight = 1.0 # Weight for heuristic in priority (can tune)\n        self._max_iterations = 5000  # Max iterations to avoid too long search\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Euclidean distance heuristic to goal multiplied by weight\n        goal_pos = self._get_grid().goal.position\n        return self._heuristic_weight * Map.get_distance(pos, goal_pos)\n\n    def _adaptive_step(self, dist_to_goal: float) -> float:\n        # Adaptive step size fractional: farther from goal => larger step\n        # Clipped between 1.0 and base max dist\n        max_dist = self._max_dist_base\n        step = max(1.0, min(max_dist, dist_to_goal / 2.0))\n        return step\n\n    def _get_best_frontier(self, frontier: \"list[tuple]\", visited_set: set) -> Vertex:\n        import heapq\n        # Pop from heap frontier ignoring visited\n        while frontier:\n            est_total_cost, v = heapq.heappop(frontier)\n            if v.position not in visited_set:\n                return v\n        return None\n\n    def _get_goal_biased_sample_around(self, center: Point, radius: float) -> Point:\n        import random\n        grid = self._get_grid()\n        size = grid.size\n        attempts = 0\n        while attempts < 100:\n            dx = int(random.uniform(-radius, radius))\n            dy = 0\n            if size.n_dim >= 2:\n                dy = int(random.uniform(-radius, radius))\n            else:\n                dy = 0\n            # For higher dim, add more dims accordingly\n            coords = [center.x + dx, center.y + dy]\n            if size.n_dim > 2:\n                for d in range(2, size.n_dim):\n                    coords.append(center[d] + int(random.uniform(-radius, radius)))\n            sample = Point(*coords[:size.n_dim])\n            if 0 <= sample.x < size[0] and 0 <= sample.y < size[1] and grid.is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # Fallback to uniform random\n        while True:\n            rand_pos = [int(random.uniform(0, s)) for s in size]\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _try_connect_vertex(self, q_new: Vertex, near_vertices: list) -> None:\n        \"\"\"\n        Try to find best parent for q_new among near_vertices,\n        also add edges from q_new to neighbors if rewiring reduces cost.\n        \"\"\"\n        best_parent = None\n        best_cost = float('inf')\n        grid = self._get_grid()\n\n        # Choose parent with minimal cost + valid line\n        for v in near_vertices:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = v\n\n        if best_parent is not None:\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n        else:\n            # If no near parent found, fail to connect q_new\n            return\n\n        # Rewire neighbors to q_new if cheaper\n        for v in near_vertices:\n            if v == q_new or v == best_parent:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        # Shortcut path by removing unnecessary vertices where direct line valid\n        if len(path) <= 2:\n            return path\n        shortcut = [path[0]]\n        i = 0\n        grid = self._get_grid()\n\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut.append(path[j])\n            i = j\n        return shortcut\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time, heapq, random\n\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_pos = goal_vertex.position\n\n        # Priority queue with (estimated_total_cost, Vertex) for best-first expansion\n        frontier = []\n        heapq.heappush(frontier, (self._heuristic_cost(start_vertex.position), start_vertex))\n\n        visited_positions = set()\n        visited_positions.add(start_vertex.position)\n\n        iterations = 0\n\n        while frontier and iterations < self._max_iterations:\n            if time.time() - start_time > 10.0:\n                # Timeout reached, stop searching\n                break\n\n            est_cost, current_vertex = heapq.heappop(frontier)\n            if current_vertex.position in visited_positions:\n                # Already expanded\n                continue\n            visited_positions.add(current_vertex.position)\n\n            # Early goal reach check\n            if grid.is_agent_in_goal_radius(agent_pos=current_vertex.position, goal=grid.goal):\n                # Connect final goal vertex if possible\n                if grid.is_valid_line_sequence(grid.get_line_sequence(current_vertex.position, goal_pos)):\n                    goal_vertex.cost = current_vertex.cost + self._cost(current_vertex, goal_vertex)\n                    self._graph.add_edge(current_vertex, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            # Adaptive step size relative to distance to goal\n            dist_to_goal = Map.get_distance(current_vertex.position, goal_pos)\n            max_step = self._adaptive_step(dist_to_goal)\n\n            # Sample strategy: goal biasing around current vertex, or uniform random\n            if random.random() < self._goal_bias:\n                q_sample_pos = self._get_goal_biased_sample_around(goal_pos, radius=10)\n            else:\n                # Sample around current_vertex for local exploration  or random global if fail\n                q_sample_pos = self._get_goal_biased_sample_around(current_vertex.position, radius=10)\n\n            # Generate new vertex in direction towards sample, clipped by max_step\n            dir_vec = q_sample_pos.to_tensor() - current_vertex.position.to_tensor()\n            dist_sample = torch.norm(dir_vec)\n\n            if dist_sample == 0:\n                iterations += 1\n                continue\n\n            step_dist = min(max_step, dist_sample)\n            dir_normalized = dir_vec / dist_sample\n            q_new_pos_tensor = current_vertex.position.to_tensor() + dir_normalized * step_dist\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                iterations += 1\n                continue\n\n            # Validate direct path between current_vertex and q_new_pos\n            line_seq = grid.get_line_sequence(current_vertex.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                iterations += 1\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Neighbor vertices for connection within rewire radius\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Try connect q_new to best parent from neighbors + rewire neighbors\n            self._try_connect_vertex(q_new, near_vertices)\n            if q_new.parents:\n                # Expand new vertex into frontier with priority = cost + heuristic\n                estimated_total = q_new.cost + self._heuristic_cost(q_new.position)\n                heapq.heappush(frontier, (estimated_total, q_new))\n\n            iterations += 1\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm integrates Adaptive Guided Tree Expansion (AGTE) with heuristic-informed sampling \n    and multi-resolution neighborhood rewiring to improve planning efficiency and path quality.\n    It uses dynamic max step size adapting to local obstacle density, combines goal bias with heuristic \n    Voronoi bias sampling, and employs a two-stage rewiring (local and semi-global) for robustness.\n    The path extraction includes aggressive shortcutting combined with spline-based smoothing for smooth paths. \n    Early termination occurs upon goal connection or after 10 seconds, ensuring real-time responsiveness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _local_rewire_radius: float\n    _semi_global_rewire_radius: float\n    _max_iterations: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 20.0\n        self._goal_bias = 0.15\n        self._local_rewire_radius = 18.0\n        self._semi_global_rewire_radius = 40.0\n        self._max_iterations = 8000\n\n    def _adaptive_max_dist(self, current_pos: Point) -> float:\n        # Estimate obstacle density around current_pos in a fixed radius.\n        # Smaller max_dist in crowded areas; larger in free space.\n        radius = 10\n        count_obs_pts = 0\n        grid = self._get_grid()\n        bounds_min = Point(max(current_pos.x - radius, 0), max(current_pos.y - radius, 0))\n        bounds_max = Point(min(current_pos.x + radius, grid.size.x-1), min(current_pos.y + radius, grid.size.y-1))\n\n        # Sample points in bounds\n        step = 2\n        for x in range(bounds_min.x, bounds_max.x + 1, step):\n            for y in range(bounds_min.y, bounds_max.y + 1, step):\n                sample_pt = Point(x,y)\n                if not grid.is_agent_valid_pos(sample_pt):\n                    count_obs_pts += 1\n\n        area_samples = ((bounds_max.x - bounds_min.x)//step +1)*((bounds_max.y - bounds_min.y)//step +1)\n        obs_ratio = count_obs_pts / max(area_samples,1)\n        # Adjust max_dist: more obstacles -> smaller step, free space -> larger step\n        max_dist = self._max_dist_base * (1.0 - 0.7*obs_ratio)\n        return max(5.0, max_dist)\n\n    def _heuristic(self, p: Point) -> float:\n        # Simple Euclidean distance heuristic\n        return Map.get_distance(p, self._get_grid().goal.position)\n\n    def _heuristic_guided_sample(self) -> Point:\n        import random\n        grid = self._get_grid()\n        if random.random() < self._goal_bias:\n            return grid.goal.position\n\n        # Voronoi-biased heuristic sampling:\n        # Sample few candidates, pick the one that maximizes distance to existing vertices\n        candidates = []\n        tries = 20\n        for _ in range(tries):\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            candidates.append(sample)\n\n        if not candidates:\n            # fallback uniform random valid sample\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Find distance to nearest vertex in start subtree\n        best_sample = None\n        best_dist = -1.0\n        start_vertices = [self._graph.root_vertex_start]\n        for c in candidates:\n            nearest_v = self._graph.get_nearest_vertex(start_vertices, c)\n            dist = Map.get_distance(nearest_v.position, c)\n            # Encourage farther samples to promote exploration\n            weighted_score = dist - 0.1*self._heuristic(c)\n            if weighted_score > best_dist:\n                best_dist = weighted_score\n                best_sample = c\n\n        return best_sample if best_sample is not None else candidates[0]\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n\n        for v in near_vertices:\n            # Validity of direct path\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, vertices: List[Vertex], center: Vertex, radius: float) -> None:\n        grid = self._get_grid()\n        for v in vertices:\n            if v == center or v == self._graph.root_vertex_start:\n                continue\n            line_seq = grid.get_line_sequence(center.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_center = center.cost + self._cost(center, v)\n            if cost_through_center + 1e-6 < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(center, v)\n                v.cost = cost_through_center\n\n    def _shortcut_and_smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut like existing shortcut but more aggressive\n        if len(path) <= 2:\n            return path\n\n        grid = self._get_grid()\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n\n        # Spline smoothing using cubic Bezier approximation for internal points (simple smoothing)\n        # For discrete grid, just interpolate intermediate points via weighted averages to smooth path visually\n        def smooth_points(pts: List[Point]) -> List[Point]:\n            if len(pts) < 3:\n                return pts[:]\n            smoothed = [pts[0]]\n            for k in range(1, len(pts)-1):\n                p_prev = pts[k-1]\n                p_curr = pts[k]\n                p_next = pts[k+1]\n                new_x = (p_prev.x + 2*p_curr.x + p_next.x) / 4.0\n                new_y = (p_prev.y + 2*p_curr.y + p_next.y) / 4.0\n                smoothed.append(Point(int(round(new_x)), int(round(new_y))))\n            smoothed.append(pts[-1])\n            # Remove duplicates in sequence\n            filtered = []\n            last = None\n            for sp in smoothed:\n                if sp != last:\n                    filtered.append(sp)\n                    last = sp\n            return filtered\n\n        return smooth_points(shortcut_path)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n\n        # Trace back to root start\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut and smooth the path\n        smooth_path = self._shortcut_and_smooth_path(path)\n\n        for v in smooth_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_position = grid.goal.position\n        start_vertex.cost = 0.0\n\n        for iteration in range(self._max_iterations):\n            if time.time() - start_time > 10.0:\n                break\n\n            q_sample = self._heuristic_guided_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            norm_dir = dir_vec / torch.norm(dir_vec)\n            new_pos_tensor = q_near.position.to_tensor() + step * norm_dir\n            q_new_point = Point.from_tensor(new_pos_tensor)\n            q_new = Vertex(q_new_point)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find local neighborhood for rewiring\n            local_neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._local_rewire_radius)\n            # Find semi-global neighborhood (larger radius) for improved rewiring\n            semi_global_neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._semi_global_rewire_radius)\n\n            best_parent = self._choose_parent(local_neighbors, q_new)\n            if best_parent is None:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            # Local rewiring (around q_new)\n            self._rewire(local_neighbors, q_new, self._local_rewire_radius)\n            # Semi-global rewiring for better global connectivity\n            self._rewire(semi_global_neighbors, q_new, self._semi_global_rewire_radius)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position, goal=grid.goal):\n                q_goal = Vertex(goal_position)\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This improved algorithm implements an Adaptive Bidirectional Informed RRT* (ABI-RRT*) inspired approach \n    that grows two trees simultaneously\u2014one from the start and one from the goal\u2014using a heuristic confined \n    informed sampling ellipse to efficiently explore the space between start and goal. \n    \n    Core ideas:\n    - Bidirectional trees merge faster, improving success rate and efficiency.\n    - Informed sampling ellipse shrinks as better solutions appear, focusing exploration.\n    - Adaptive step sizes modulated by distance to goal and obstacle proximity.\n    - Local rewiring in each tree to optimize path quality progressively.\n    - Dynamic early stopping once a valid connecting edge is found.\n    - Path extracted by joining two trees at the connecting vertices and smoothing via shortcutting.\n    - Global timeout of 10 seconds to ensure responsiveness.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This improved algorithm implements an Adaptive Bidirectional Informed RRT* (ABI-RRT*) inspired approach \n    that grows two trees simultaneously\u2014one from the start and one from the goal\u2014using a heuristic confined \n    informed sampling ellipse to efficiently explore the space between start and goal. \n    \n    Core ideas:\n    - Bidirectional trees merge faster, improving success rate and efficiency.\n    - Informed sampling ellipse shrinks as better solutions appear, focusing exploration.\n    - Adaptive step sizes modulated by distance to goal and obstacle proximity.\n    - Local rewiring in each tree to optimize path quality progressively.\n    - Dynamic early stopping once a valid connecting edge is found.\n    - Path extracted by joining two trees at the connecting vertices and smoothing via shortcutting.\n    - Global timeout of 10 seconds to ensure responsiveness.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._best_path_cost = float('inf')\n        self._max_iter = 8000\n        self._timeout = 10.0  # seconds\n        self._base_step = 15.0\n        self._rewire_radius = 15.0\n\n    def _heuristic(self, p: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(p, goal_pos)\n\n    def _sample_informed(self, c_min, c_best, x_center: Point, C):\n        \"\"\"\n        Sample within an n-dimensional prolate hyperspheroid (ellipse) defined by c_min and c_best \n        between start and goal to guide sampling efficiently in the promising region.\n        \"\"\"\n        import numpy as np\n\n        n = self._get_grid().size.n_dim\n        if c_best == float('inf'):\n            # No solution found yet => uniform random\n            for _ in range(50):\n                rand_coords = np.random.randint(0, self._get_grid().size, n)\n                p = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n            # fallback to some random in grid\n            return Point(*(np.random.randint(0, self._get_grid().size, n)))\n\n        # Sample from unit n-dim ball\n        while True:\n            x_ball = np.random.normal(0, 1, n)\n            x_ball /= np.linalg.norm(x_ball)\n            r = np.random.rand() ** (1.0 / n)\n            x_ball *= r\n\n            # scale the ellipse axes lengths\n            L = np.diag([c_best / 2.0] + [np.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (n - 1))\n            sample = C @ L @ x_ball + np.array(x_center)\n\n            sample_rounded = [min(max(0, int(round(coord))), self._get_grid().size[i] - 1) for i, coord in enumerate(sample)]\n            candidate = Point(*sample_rounded)\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n    def _tf_informed_sampling_transform(self, start: Point, goal: Point):\n        \"\"\"\n        Compute C matrix for transforming unit n-ball samples into the ellipse oriented between start and goal.\n        \"\"\"\n        import numpy as np\n        n = self._get_grid().size.n_dim\n        start_np = np.array(start)\n        goal_np = np.array(goal)\n        diff = goal_np - start_np\n        norm = np.linalg.norm(diff)\n        if norm == 0:\n            return np.identity(n), (start_np + goal_np) / 2.0\n\n        e1 = diff / norm\n        # Create orthonormal basis via Gram-Schmidt (only for 2D or 3D. For higher dims identity fallback)\n        U = np.identity(n)\n        U[:, 0] = e1\n        # For higher-dim extension: more complex; here fallback to identity for other dims\n        # For 2D or 3D this is sufficient as e1 is first axis\n        return U, (start_np + goal_np) / 2.0\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = self._heuristic(to_pos)\n        max_step = self._base_step\n        if dist_to_goal < 25.0:\n            # Shrink step size when near goal to improve precision\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 25.0)\n\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            # Penalize collision directions\n            max_step *= 0.5\n\n        return max_step\n\n    def _get_new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent_and_cost(self, vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best = None\n        for v in vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best = v\n        if best:\n            q_new.cost = min_cost\n        return best\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            v = stack.pop()\n            for c in v.children:\n                new_cost = v.cost + self._cost(v, c)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_bidirectional_path(self, vertex_start: Vertex, vertex_goal: Vertex) -> None:\n        # Build path from start to middle\n        path_from_start = [vertex_start]\n        v = vertex_start\n        while v != self._graph.root_vertex_start:\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n            path_from_start.append(v)\n        path_from_start.reverse()\n\n        # Build path from goal to middle\n        path_from_goal = [vertex_goal]\n        v = vertex_goal\n        while v != self._graph.root_vertex_goal:\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n            path_from_goal.append(v)\n\n        full_path = path_from_start + path_from_goal\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _vertex_connectable(self, v1: Vertex, v2: Vertex) -> bool:\n        line_seq = self._get_grid().get_line_sequence(v1.position, v2.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        c_min = Map.get_distance(start_vertex.position, goal_vertex.position)\n        c_best = float('inf')\n\n        transform_C, center = self._tf_informed_sampling_transform(start_vertex.position, goal_vertex.position)\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        def try_connect(v_start: Vertex, v_goal: Vertex):\n            if self._vertex_connectable(v_start, v_goal):\n                total_cost = v_start.cost + self._cost(v_start, v_goal) + v_goal.cost\n                return total_cost\n            return None\n\n        for iteration in range(self._max_iter):\n\n            if time.time() - start_time > self._timeout:\n                # Timeout reached, stop planning\n                break\n\n            # Alternate between trees for expansion\n            expand_from_start = (iteration % 2 == 0)\n            tree = tree_start if expand_from_start else tree_goal\n            other_tree = tree_goal if expand_from_start else tree_start\n            visited_curr = visited_start if expand_from_start else visited_goal\n            visited_other = visited_goal if expand_from_start else visited_start\n\n            # Sample within ellipse guided by current best cost\n            q_sample_point = self._sample_informed(c_min, c_best, center, transform_C)\n\n            # Find nearest vertex in current tree\n            q_near = min(tree, key=lambda v: Map.get_distance(v.position, q_sample_point))\n            if q_near.position == q_sample_point:\n                continue\n\n            # Adaptive step towards sample\n            step_max = self._generate_adaptive_step(q_near.position, q_sample_point)\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_point, step_max)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            if q_new.position in visited_curr:\n                continue\n\n            # Find nearby vertices for rewiring\n            near_radius = self._rewire_radius\n            near_vertices = [v for v in tree if Map.get_distance(v.position, q_new.position) <= near_radius]\n\n            # Choose best parent and cost\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_curr[q_new.position] = q_new\n            tree.append(q_new)\n\n            # Local rewiring\n            self._rewire_locally(q_new, near_vertices)\n\n            # Try to connect to the other tree vertices close to q_new\n            connection_radius = self._rewire_radius\n            candidates_to_connect = [v for v in other_tree if Map.get_distance(v.position, q_new.position) <= connection_radius]\n\n            found_connection = False\n            best_conn_cost = float('inf')\n            best_vertex_other = None\n\n            for v_other in candidates_to_connect:\n                conn_cost = try_connect(q_new, v_other) if expand_from_start else try_connect(v_other, q_new)\n                if conn_cost is not None and conn_cost < best_conn_cost:\n                    best_conn_cost = conn_cost\n                    best_vertex_other = v_other\n\n            if best_vertex_other is not None and best_conn_cost < c_best:\n                c_best = best_conn_cost\n                # Store path cost on q_new and best_vertex_other to reflect joint path\n                if expand_from_start:\n                    # q_new connects to best_vertex_other\n                    # Connect the two vertices bidirectionally to enable path extraction\n                    self._graph.add_edge(q_new, best_vertex_other)\n                else:\n                    self._graph.add_edge(best_vertex_other, q_new)\n\n                self._best_path_cost = c_best\n                self._extract_bidirectional_path(q_new if expand_from_start else best_vertex_other,\n                                                best_vertex_other if expand_from_start else q_new)\n                found_connection = True\n                break\n\n            self.key_frame()\n\n            if found_connection:\n                break",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is inspired by informed sampling and lazy collision checking, incorporating\n    an anytime anytime RRT*-like approach with a sampling region restricted dynamically by\n    the best path cost found so far (\"Informed RRT*\"). It combines heuristic-guided elliptical\n    sampling around the current best path to limit exploration to promising regions, along with\n    lazy edge validation to reduce collision check overhead, pruning of high-cost vertices to\n    maintain efficiency, and post-planning path shortcutting for smoother routes. \n    The algorithm balances global exploration early on with a focused refinement after an initial\n    solution is found, leveraging goal bias and adaptive step sizes. A careful timeout cutoff \n    ensures responsiveness, and progressive rewiring optimizes path quality continually.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n    _best_cost: float\n    _best_goal_vertex: Vertex\n    _dimension: int\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 14.0\n        self._goal_bias = 0.15\n        self._rewire_radius = 18.0\n\n        self._best_cost = float('inf')\n        self._best_goal_vertex = None\n        self._dimension = self._get_grid().size.n_dim\n\n    # Helper: heuristic cost to goal (Euclidean)\n    def _heuristic(self, pos: Point, goal_pos: Point) -> float:\n        return Map.get_distance(pos, goal_pos)\n\n    # Helper: get adaptive step size based on proximity (adaptive but fixed for simplicity)\n    def _adaptive_max_dist(self, current: Point, goal: Point) -> float:\n        dist_to_goal = self._heuristic(current, goal)\n        base = self._max_dist_base\n        if dist_to_goal < base:\n            return max(4.0, base * (dist_to_goal / base))\n        return base\n\n    # Helper: Informed sample inside prolate hyperspheroid if informed start cost known, else uniform\n    def _informed_sample(self, start: Point, goal: Point) -> Point:\n        import random\n        import numpy as np\n\n        if self._best_cost == float('inf'):\n            # Uniform random valid sample\n            for _ in range(50):\n                coords = np.random.randint(0, self._get_grid().size, self._dimension)\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n            # fallback\n            return goal\n\n        c_best = self._best_cost\n        c_min = self._heuristic(start, goal)\n        if c_best < c_min:\n            c_min = c_best  # guard against precision issues\n\n        if c_best == float('inf'):\n            # no current best cost, fallback to uniform\n            coords = np.random.randint(0, self._get_grid().size, self._dimension)\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            return goal\n\n        # Sample within prolate hyperspheroid centered between start and goal\n        center = Point(*((start.to_tensor() + goal.to_tensor()) / 2))\n        # Compute unit vector from start to goal\n        diff = goal.to_tensor() - start.to_tensor()\n        unit_vec = diff / torch.norm(diff)\n\n        # Construct axes orthogonal basis via SVD (only in 2D or 3D works straightforward)\n        U, _, _ = torch.svd(torch.eye(self._dimension))\n        rot = U\n        # stretch matrix\n        a1 = c_best / 2\n        if a1 < c_min / 2:\n            a1 = c_min / 2\n        a2 = torch.sqrt(torch.tensor(c_best ** 2 - c_min ** 2, dtype=torch.float32)) / 2\n\n        # Draw random sample in unit n-ball\n        while True:\n            x = np.random.normal(0, 1, self._dimension)\n            norm_x = np.linalg.norm(x)\n            x_unit = x / norm_x if norm_x > 0 else x\n            # Scale sample by radii along axes (a1 for main axis, a2 for others)\n            r = np.random.rand() ** (1.0 / self._dimension)\n            sample_ball = r * x_unit\n            sample_ball[0] *= a1\n            for i in range(1, self._dimension):\n                sample_ball[i] *= a2\n\n            # Rotate into environment frame (approximate)\n            # Align first axis with unit_vec (simple rotation)\n            # Construct rotation matrix to align x-axis to unit_vec using Rodrigues' formula\n            import math\n            from torch import tensor\n            unit_x = torch.zeros(self._dimension)\n            unit_x[0] = 1.0\n            v = torch.cross(unit_x, unit_vec)\n            s = torch.norm(v)\n            c = torch.dot(unit_x, unit_vec)\n            if s.item() == 0:\n                R = torch.eye(self._dimension)\n            else:\n                vx = torch.tensor([[0, -v[2], v[1]] if self._dimension == 3 else []], dtype=torch.float32)\n                # for dim>3 approximate identity\n                # For simplicity in n-dim, skip exact rotation and approximate by translation of center + sample_ball\n                R = torch.eye(self._dimension)\n\n            # Map sample to world coordinates (approximate as center + sample_ball)\n            sample_np = np.array(sample_ball) + center.numpy()\n            coords = []\n            for i in range(self._dimension):\n                val = int(round(sample_np[i]))\n                val = max(0, min(self._get_grid().size[i] - 1, val))\n                coords.append(val)\n            candidate = Point(*coords)\n\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n    # Helper: Lazy edge validity check w/ caching to reduce recomputation\n    def _lazy_is_valid_edge(self, start: Point, end: Point, cache: dict) -> bool:\n        key = (start, end)\n        if key in cache:\n            return cache[key]\n        line_seq = self._get_grid().get_line_sequence(start, end)\n        valid = self._get_grid().is_valid_line_sequence(line_seq)\n        cache[key] = valid\n        return valid\n\n    # Helper: Choose best parent based on cost + heuristic with lazy collision checks\n    def _choose_parent_lazy(self, near_vertices: list, q_new: Vertex, cache: dict) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._lazy_is_valid_edge(v.position, q_new.position, cache):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    # Helper: Rewire neighbors with lazy edge validity check\n    def _lazy_rewire(self, near_vertices: list, q_new: Vertex, cache: dict) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._lazy_is_valid_edge(q_new.position, v.position, cache):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    # Helper: Cost function based on distance + grid movement cost\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    # Helper: Attempt to update best solution if q_new reaches goal radius with better cost\n    def _try_update_best_solution(self, q_new: Vertex) -> bool:\n        goal_pos = self._get_grid().goal.position\n        if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n            dist_to_goal = self._heuristic(q_new.position, goal_pos)\n            total_cost = q_new.cost + dist_to_goal  # optimistic cost with goal radius\n            if total_cost < self._best_cost:\n                # Add goal vertex connected from q_new if valid line\n                q_goal = Vertex(goal_pos)\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    if q_goal.cost < self._best_cost:\n                        self._best_cost = q_goal.cost\n                        self._best_goal_vertex = q_goal\n                    return True\n        return False\n\n    # Helper: Extract path via backtracking from best goal vertex and shortcut\n    def _extract_best_path(self) -> None:\n        if not self._best_goal_vertex:\n            return\n        path = [self._best_goal_vertex]\n        current = self._best_goal_vertex\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Helper: Shortcut path smoothing\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    # Prune vertices with cost exceeding best_cost * margin (to reduce graph size)\n    def _prune_graph(self) -> None:\n        if self._best_cost == float('inf'):\n            return\n        limit = self._best_cost * 1.3\n        to_remove = []\n        for vertex in list(self._graph.root_vertices):\n            if vertex in (self._graph.root_vertex_start, self._best_goal_vertex):\n                continue\n            if vertex.cost > limit:\n                to_remove.append(vertex)\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist == 0:\n            return Vertex(q_near.position)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        max_iterations = 8000\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n\n        lazy_edge_cache = {}\n\n        for iteration in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                break\n\n            # Sample from informed region or uniform based on best solution found\n            q_sample = None\n            import random\n            if random.random() < self._goal_bias:\n                q_sample = goal_pos\n            else:\n                q_sample = self._informed_sample(start_vertex.position, goal_pos)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position, goal_pos)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not self._lazy_is_valid_edge(q_near.position, q_new.position, lazy_edge_cache):\n                continue\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            best_parent = self._choose_parent_lazy(near_vertices, q_new, lazy_edge_cache)\n            if best_parent is None:\n                # fallback to q_near if valid\n                if self._lazy_is_valid_edge(q_near.position, q_new.position, lazy_edge_cache):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._lazy_rewire(near_vertices, q_new, lazy_edge_cache)\n\n            # Update best solution if goal reachable\n            if self._try_update_best_solution(q_new):\n                # Prune graph aggressively after initial solution\n                self._prune_graph()\n\n            self.key_frame()\n\n        # After iterations or timeout, if solution found extract and move agent\n        if self._best_goal_vertex:\n            self._extract_best_path()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved sample-based path planning combining RRT* ideas with goal-biased sampling and adaptive step size.\n    Key features include:\n    - Goal biasing: samples towards goal with a probability to speed convergence.\n    - Adaptive max_dist: step size adapts based on environment complexity and progress.\n    - Rewiring: attempts to locally rewire vertices for shorter, smoother paths (like RRT*).\n    - Early stopping: stops if goal reached or after 10 seconds max runtime to avoid long waits.\n    - Path shortcutting: attempts to shortcut and smooth the final path before execution.\n    - Uses a Forest graph structure to store vertices and edges while maintaining parent-child relations.\n    This method trades off more computation per iteration for faster, high-quality and robust path discovery.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring (edge removal)\n        self._init_displays()\n        self._max_dist_base = 15  # base max dist for expansion\n        self._goal_sample_rate = 0.2  # 20% probability to sample goal directly\n        self._rewire_radius_base = 20  # Neighbourhood radius for rewiring\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        if np.random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _line_valid(self, frm: Point, to: Point) -> bool:\n        seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(seq)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            # Just take one parent (best is guaranteed by rewiring cost)\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n\n        del path[-1]  # remove start repeated\n        path.reverse()\n\n        path_points = [v.position for v in path]\n\n        # Shortcut path smoothing: Try shortcuts by connecting non-adjacent vertices directly\n        path_points = self._shortcut_path(path_points)\n\n        # Animate path tracing\n        for p in path_points:\n            self.move_agent(p)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path_points: List[Point]) -> List[Point]:\n        if len(path_points) < 3:\n            return path_points\n        i = 0\n        while i < len(path_points) - 2:\n            j = i + 2\n            while j < len(path_points):\n                if self._line_valid(path_points[i], path_points[j]):\n                    # Shortcut: remove intermediate points between i and j\n                    del path_points[i + 1: j]\n                    j = i + 2\n                else:\n                    j += 1\n            i += 1\n        return path_points\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # Attempt rewiring the nearby vertices if connecting q_new yields a lower cost path\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            if not self._line_valid(q_new.position, q_near.position):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Remove previous parents' edges to q_near\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n                # Propagate cost update downstream recursively\n                self._update_descendants_cost(q_near)\n\n    def _update_descendants_cost(self, vertex: Vertex) -> None:\n        # Recursive update costs for children vertices after rewiring\n        for child in vertex.children:\n            old_cost = child.cost\n            new_cost = vertex.cost + self._cost(vertex, child)\n            if new_cost < old_cost:\n                child.cost = new_cost\n                self._update_descendants_cost(child)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 10000\n        max_duration_seconds = 10\n        max_dist = self._max_dist_base\n\n        # Initialize start vertex cost to zero\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > max_duration_seconds:\n                # Fail gracefully if takes more than 10 seconds\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size based on distance\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_max_dist = min(max_dist, max(1.0, dist_to_sample))\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n\n            # Validate path from q_near to q_new\n            if not self._line_valid(q_near.position, q_new.position):\n                continue\n\n            # Cost to reach q_new via q_near\n            cost_to_q_new = q_near.cost + self._cost(q_near, q_new)\n\n            # Check if q_new is already present with lower cost (prevent duplicates)\n            nearest_to_q_new = self._graph.get_nearest_vertex(self._graph.root_vertices, q_new.position)\n            dist_to_nearest = Map.get_distance(nearest_to_q_new.position, q_new.position)\n            if dist_to_nearest < 1e-3 and nearest_to_q_new.cost <= cost_to_q_new:\n                continue\n\n            # Add q_new and link to q_near\n            q_new.cost = cost_to_q_new\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors in vicinity for improved costs\n            rewiring_radius = max(self._rewire_radius_base, adaptive_max_dist * 2)\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, rewiring_radius)\n            self._rewire(q_new, near_vertices)\n\n            # If within goal radius, extract path and finish\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an informed RRT* variant with adaptive progressive sampling and dynamic rewiring,\n    leveraging bidirectional search from both start and goal vertices for accelerated convergence.\n    \n    Key features:\n    - Bidirectional forest growth with start and goal roots expanding towards each other.\n    - Adaptive max step size that shrinks near obstacles and goal regions.\n    - Goal- and frontier-biased sampling mixed with random uniform exploration for robust coverage.\n    - Local neighborhood rewiring similar to RRT* to optimize path quality dynamically.\n    - Early stopping when forests connect within the goal radius.\n    - Shortcuts path smoothing on extracted path.\n    - Enforces 10 seconds timeout on planning.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This algorithm is an informed RRT* variant with adaptive progressive sampling and dynamic rewiring,\n    leveraging bidirectional search from both start and goal vertices for accelerated convergence.\n    \n    Key features:\n    - Bidirectional forest growth with start and goal roots expanding towards each other.\n    - Adaptive max step size that shrinks near obstacles and goal regions.\n    - Goal- and frontier-biased sampling mixed with random uniform exploration for robust coverage.\n    - Local neighborhood rewiring similar to RRT* to optimize path quality dynamically.\n    - Early stopping when forests connect within the goal radius.\n    - Shortcuts path smoothing on extracted path.\n    - Enforces 10 seconds timeout on planning.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Initialize bidirectional forest with start and goal vertices\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Additional state for bidirectional expansions\n        self._max_iter = 6000\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0  # seconds allowance\n        self._base_step = 14.0\n        self._rewire_radius_init = 20.0\n        self._vertex_prune_limit = 1200\n        self._use_start_side = True\n\n        self._init_displays()\n\n\n    def _adaptive_step_size(self, frm: Point, to: Point) -> float:\n        dist_to_goal = Map.get_distance(to, self._get_grid().goal.position)\n        max_step = self._base_step\n        # Reduce step near goal\n        if dist_to_goal < 15.0:\n            max_step *= 0.3 + 0.7 * (dist_to_goal / 15.0)\n        # Penalize if path to sample crosses obstacles\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.45\n        return max_step\n\n    def _steer(self, start: Point, end: Point, max_dist: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = float(torch.norm(vec).item())\n        if dist <= max_dist:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_dist\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _sample_point(self) -> Point:\n        import random\n        rand_val = random.random()\n        # 30% goal biased\n        if rand_val < 0.3:\n            return self._get_grid().goal.position\n        # 30% frontier biased sampling around latest expansions\n        elif rand_val < 0.6:\n            # Frontier sampling from either start or goal forest vertices\n            forest_branch = self._graph.root_vertex_start.position if random.random() < 0.5 else self._graph.root_vertex_goal.position\n            dim = self._get_grid().size.n_dim\n            std_dev = 7.5\n            jitter = []\n            for i in range(dim):\n                val = forest_branch[i] + random.gauss(0, std_dev)\n                val = max(0, min(self._get_grid().size[i] - 1, int(round(val))))\n                jitter.append(val)\n            p = Point(*jitter)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n            else:\n                return self._get_grid().goal.position\n        # 40% uniform random valid sampling\n        else:\n            while True:\n                candidate_coords = []\n                for d in range(self._get_grid().size.n_dim):\n                    candidate_coords.append(random.randint(0, self._get_grid().size[d] - 1))\n                candidate_p = Point(*candidate_coords)\n                if self._get_grid().is_agent_valid_pos(candidate_p):\n                    return candidate_p\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex) -> Vertex:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            tentative_cost = v.cost + self._cost(v, q_new)\n            if tentative_cost < min_cost:\n                min_cost = tentative_cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire_nearby(self, q_new: Vertex, near_vertices: list) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            current = stack.pop()\n            for child in current.children:\n                new_cost = current.cost + self._cost(current, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_and_smooth_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> None:\n        # Construct path from start root to connecting_vertex_start\n        path_start = [connecting_vertex_start]\n        current = connecting_vertex_start\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(parent)\n            current = parent\n        path_start.reverse()\n\n        # Construct path from goal root to connecting_vertex_goal\n        path_goal = [connecting_vertex_goal]\n        current = connecting_vertex_goal\n        while current != self._graph.root_vertex_goal:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(parent)\n            current = parent\n\n        # Full path: start->connecting_vertex_start + connecting_vertex_goal->goal reversed\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing\n        shortcut_path = []\n        i = 0\n        while i < len(full_path):\n            j = len(full_path) - 1\n            while j > i:\n                line_seq = self._get_grid().get_line_sequence(full_path[i].position, full_path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(full_path[i])\n                    i = j\n                    break\n                j -= 1\n            else:\n                shortcut_path.append(full_path[i])\n                i += 1\n\n        for v in shortcut_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_vertices(self) -> None:\n        if self._graph.size <= self._vertex_prune_limit:\n            return\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n        goal_pos = self._get_grid().goal.position\n        candidates.sort(key=lambda v: v.cost + Map.get_distance(v.position, goal_pos), reverse=True)\n        count_to_remove = self._graph.size - self._vertex_prune_limit\n        for v in candidates[:count_to_remove]:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import heapq\n        import time\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Maintain two frontiers for bidirectional expansion with priority queues (f = g + h)\n        frontier_start = []\n        frontier_goal = []\n        heapq.heappush(frontier_start, (self._heuristic(start_vertex.position), start_vertex))\n        heapq.heappush(frontier_goal, (self._heuristic(goal_vertex.position), goal_vertex))\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        start_time = time.time()\n        iterations = 0\n        max_iterations = self._max_iter\n\n        connected_vertex_start = None\n        connected_vertex_goal = None\n\n        while iterations < max_iterations:\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                # Timeout reached\n                break\n\n            # Alternate expansion side\n            expand_start_side = (iterations % 2 == 1)\n\n            front_queue = frontier_start if expand_start_side else frontier_goal\n            visited_current = visited_start if expand_start_side else visited_goal\n            visited_other = visited_goal if expand_start_side else visited_start\n            root_vertex = self._graph.root_vertex_start if expand_start_side else self._graph.root_vertex_goal\n\n            if not front_queue:\n                # No more vertices to expand from this side\n                continue\n\n            _, current_vertex = heapq.heappop(front_queue)\n\n            # Sample point biased from current side\n            sample_point = self._sample_point()\n\n            # Find nearest vertex from current side\n            near_vertex = self._graph.get_nearest_vertex([root_vertex], sample_point)\n            if near_vertex.position == sample_point:\n                continue\n\n            max_step = self._adaptive_step_size(near_vertex.position, sample_point)\n            new_vertex = self._steer(near_vertex.position, sample_point, max_step)\n\n            if new_vertex.position in visited_current:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(near_vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / max_iterations), 7.0)\n            near_vertices = self._graph.get_vertices_within_radius([root_vertex], new_vertex.position, rewire_radius)\n\n            best_parent = self._choose_best_parent(near_vertices, new_vertex)\n            if best_parent is None:\n                # fallback to nearest if direct connection feasible\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    new_vertex.cost = near_vertex.cost + self._cost(near_vertex, new_vertex)\n                    best_parent = near_vertex\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, new_vertex)\n            visited_current[new_vertex.position] = new_vertex\n            heapq.heappush(front_queue, (new_vertex.cost + self._heuristic(new_vertex.position), new_vertex))\n\n            # Rewire neighbors locally for better costs\n            self._rewire_nearby(new_vertex, near_vertices)\n\n            # Check if new_vertex connects to opposite forest within radius\n            opposite_near = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_goal if expand_start_side else self._graph.root_vertex_start], \n                new_vertex.position, \n                self._goal_radius * 1.5)\n\n            for opposite_vertex in opposite_near:\n                # Validate connection line between forests\n                connect_line = self._get_grid().get_line_sequence(new_vertex.position, opposite_vertex.position)\n                if not self._get_grid().is_valid_line_sequence(connect_line):\n                    continue\n                # Compute combined cost\n                combined_cost = new_vertex.cost + self._cost(new_vertex, opposite_vertex) + opposite_vertex.cost\n                if connected_vertex_start is None or combined_cost < (connected_vertex_start.cost + connected_vertex_goal.cost):\n                    connected_vertex_start = new_vertex if expand_start_side else opposite_vertex\n                    connected_vertex_goal = opposite_vertex if expand_start_side else new_vertex\n\n            # Prune excess vertices for memory/time efficiency\n            self._prune_vertices()\n\n            self.key_frame()\n\n            if connected_vertex_start and connected_vertex_goal:\n                # Found connection between forests - extract and smooth path\n                self._extract_and_smooth_path(connected_vertex_start, connected_vertex_goal)\n                break",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a Heuristic-Guided Anytime RRT* with Adaptive Sampling and Cost-to-Go pruning.\n    It combines:\n    - Goal-biased sampling with adaptive sampling region shrinkage based on the current best path cost.\n    - Anytime framework: improves the path incrementally, pruning samples unlikely to improve solution.\n    - A cost-to-go heuristic (A*-like) to guide vertex selection for expansion, focusing exploration.\n    - Adaptive variable step size based on local obstacle density estimation to speed exploration in free space and slow down near obstacles.\n    - Rewiring with radius shrinking proportional to graph size to refine quality progressively.\n    - Aggressive path shortcutting triggered immediately upon improved solutions.\n    - Early stopping if path cost stabilizes over several iterations or timeout exceeded.\n    - Uses a one-tree approach from start to goal with a special priority vertex expansion queue.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_iter = 10000\n        self._timeout = 10.0  # seconds\n        self._base_step = 20.0\n        self._initial_rewire_radius = 25.0\n        self._prune_ratio = 1.2  # Prune samples with cost > prune_ratio * best_cost\n        self._improvement_stall_limit = 150  # Iterations to stall before early stop\n\n        # Initialize dynamic vars\n        self._best_path_cost = float('inf')\n        self._best_path = None\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _heuristic_cost(self, position: Point) -> float:\n        # Cost-to-go heuristic = Euclidean distance to goal plus minimal movement cost (assumed to be distance)\n        goal_pos = self._get_grid().goal.position\n        return self._distance(position, goal_pos)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        \"\"\"\n        Compute step size adapting to local obstacle density by sampling neighbors:\n        - Smaller steps near obstacles, larger steps in free space.\n        \"\"\"\n        max_step = self._base_step\n        # Sample 8-neighbors (N,S,E,W,NE,NW,SE,SW) count invalid neighbors\n        neighbors = self._get_grid().get_next_positions(from_pos)\n        invalid_count = sum(1 for nb in neighbors if not self._get_grid().is_agent_valid_pos(nb))\n        # Heuristic: More invalid neighbors -> smaller step\n        reduction_factor = min(1.0, invalid_count / 8.0 + 0.1)\n        adjusted_step = max_step * (1.0 - 0.7 * reduction_factor)\n\n        dist = self._distance(from_pos, to_pos)\n        return min(adjusted_step, dist)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Returns a new vertex extending from q_near toward q_sample by up to max_dist\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + direction * max_dist\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _choose_parent_and_cost(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"\n        Choose the best parent from near_vertices minimizing cost + heuristic cost.\n        Parent must have valid line connection.\n        \"\"\"\n        min_total_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost_to_new = v.cost + self._cost(v, q_new)\n            est_total_cost = cost_to_new + self._heuristic_cost(q_new.position)\n            if est_total_cost < min_total_cost:\n                min_total_cost = est_total_cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = self._distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        \"\"\"\n        Rewire nearby vertices through q_new if it improves their cost,\n        adjusting edges accordingly.\n        \"\"\"\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        # Same shortcut logic as reference, aggressively applied\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Backtrack from goal to start using minimal cost parents\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        self._best_path = smoothed\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_vertices(self, max_cost_threshold: float) -> None:\n        \"\"\"\n        Prune vertices whose cost + heuristic_cost exceeds max_cost_threshold.\n        Removes edges and vertices from graph accordingly.\n        \"\"\"\n        to_remove = []\n        for v in self._graph.root_vertices:\n            if v.cost + self._heuristic_cost(v.position) > max_cost_threshold:\n                to_remove.append(v)\n        for v in to_remove:\n            # Remove from graph and parent edges\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n\n        # Priority queue for vertex expansion: stores tuples (cost+heuristic, vertex)\n        # Use list + sorting for simplicity due to no import restrictions\n        vertex_queue = [(self._heuristic_cost(start_vertex.position), start_vertex)]\n\n        iteration = 0\n        stall_count = 0\n        last_best_cost = self._best_path_cost\n\n        while iteration < self._max_iter:\n            iteration += 1\n\n            # Timeout\n            if time.time() - start_time > self._timeout:\n                break\n\n            if not vertex_queue:\n                # No expandable vertices - fail early\n                break\n\n            # Pop vertex with lowest cost+heuristic for expansion\n            vertex_queue.sort(key=lambda x: x[0])\n            _, q_near = vertex_queue.pop(0)\n\n            # Goal biased adaptive sampling:\n            # Sample goal with probability 0.15, else uniform valid random near radius around q_near\n            prob_goal = 0.15\n            if random.random() < prob_goal:\n                q_sample = goal_pos\n            else:\n                attempts = 0\n                q_sample = None\n                while attempts < 30:\n                    attempts += 1\n                    dims = self._get_grid().size.n_dim\n                    offset = [random.randint(-int(self._base_step), int(self._base_step)) for _ in range(dims)]\n                    candidate_coords = [q_near.position[i] + offset[i] for i in range(dims)]\n                    # Clamp within grid size\n                    candidate_coords = [max(0, min(candidate_coords[i], self._get_grid().size[i] - 1)) for i in range(dims)]\n                    candidate = Point(*candidate_coords)\n                    if self._get_grid().is_agent_valid_pos(candidate):\n                        q_sample = candidate\n                        break\n                if q_sample is None:\n                    # fallback to uniform random valid sample\n                    while True:\n                        rand_coords = [random.randint(0, self._get_grid().size[i] - 1) for i in range(self._get_grid().size.n_dim)]\n                        candidate = Point(*rand_coords)\n                        if self._get_grid().is_agent_valid_pos(candidate):\n                            q_sample = candidate\n                            break\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size based on local obstacle density and sample distance\n            step_size = self._adaptive_step(q_near.position, q_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step_size)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Check if a vertex at q_new.position already exists\n            exists_already = any(v.position == q_new.position for v in self._graph.root_vertices)\n            if exists_already:\n                continue\n\n            # Radius shrinks over iterations: logarithmic decay to focus on local optimization\n            rewire_radius = max(self._initial_rewire_radius * (0.8 ** (iteration / 1000.0)), 5.0)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors to improve costs via q_new\n            self._rewire(near_vertices, q_new)\n\n            # Add q_new to expansion queue with priority cost + heuristic\n            priority = q_new.cost + self._heuristic_cost(q_new.position)\n            vertex_queue.append((priority, q_new))\n\n            # Check if q_new is inside goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Create goal vertex and add if not present\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    # Extract and shortcut path\n                    self._extract_path(q_goal)\n                    # Update best path cost and prune graph aggressively\n                    if self._best_path_cost > q_goal.cost:\n                        self._best_path_cost = q_goal.cost\n                        self._prune_vertices(self._prune_ratio * self._best_path_cost)\n                        stall_count = 0\n                    else:\n                        stall_count += 1\n                    # Early stop if convergence\n                    if stall_count > self._improvement_stall_limit:\n                        break\n\n            self.key_frame()\n\n        # If after all iterations, best path found, replay for display to ensure agent at goal\n        if self._best_path:\n            for v in self._best_path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This new algorithm implements a hybrid Incremental Anytime Exploration and Exploitation Graph (IAEEG) planner:\n    - It incrementally builds a graph on the grid alternating between aggressive exploration and focused exploitation phases.\n    - Exploration phase: guided random sampling with obstacle-aware diversification to quickly cover free space.\n    - Exploitation phase: goal-biased deterministic expansion from promising vertices using a learned adaptive step size.\n    - Integrates heuristic cost-to-go estimates f = g + h to prioritize graph growth towards the goal.\n    - Dynamically adjusts rewiring radius and pruning strategy based on progress and graph size.\n    - Employs bidirectional-like goal check via local search in the neighborhood.\n    - Uses an anytime approach: whenever a better path is found, extracts and smooths it.\n    - Enforces a global timeout of 10 seconds and adaptive iteration limit based on environment size.\n    This strategy aims to surpass pure RRT* or roadmap methods by combining heuristic guidance, adaptive exploration/exploitation,\n    and progressive refinement within a single forest structure.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This new algorithm implements a hybrid Incremental Anytime Exploration and Exploitation Graph (IAEEG) planner:\n    - It incrementally builds a graph on the grid alternating between aggressive exploration and focused exploitation phases.\n    - Exploration phase: guided random sampling with obstacle-aware diversification to quickly cover free space.\n    - Exploitation phase: goal-biased deterministic expansion from promising vertices using a learned adaptive step size.\n    - Integrates heuristic cost-to-go estimates f = g + h to prioritize graph growth towards the goal.\n    - Dynamically adjusts rewiring radius and pruning strategy based on progress and graph size.\n    - Employs bidirectional-like goal check via local search in the neighborhood.\n    - Uses an anytime approach: whenever a better path is found, extracts and smooths it.\n    - Enforces a global timeout of 10 seconds and adaptive iteration limit based on environment size.\n    This strategy aims to surpass pure RRT* or roadmap methods by combining heuristic guidance, adaptive exploration/exploitation,\n    and progressive refinement within a single forest structure.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_iter = 7000\n        self._timeout = 10.0\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n\n        self._base_step = 14.0\n        self._max_exploration_ratio = 0.4  # max fraction iterations exploring randomly\n        self._rewire_radius_min = 6.0\n        self._rewire_radius_max = 20.0\n        self._vertex_prune_threshold = 1000\n\n        self._best_path_cost = float('inf')\n        self._found_path_vertex = None\n\n    def _heuristic(self, pos: Point) -> float:\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point, progress_ratio: float) -> float:\n        base = self._base_step\n        dist_to_goal = self._heuristic(to_pos)\n        # Shrink near goal and dynamically shrink as progress advances\n        step = base * (0.4 + 0.6 * min(dist_to_goal / 25.0, 1.0)) * (1.0 - progress_ratio * 0.5)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            step *= 0.5\n        return max(step, 1.0)\n\n    def _get_new_vertex(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost_tmp = v.cost + self._cost(v, q_new)\n            f_cost = cost_tmp + self._heuristic(q_new.position)\n            if f_cost < min_cost:\n                min_cost = f_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: list) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            current = stack.pop()\n            for child in current.children:\n                new_cost = current.cost + self._cost(current, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _prune_vertices(self, iteration: int) -> None:\n        # Prune if too large relative to iteration progress and threshold\n        if self._graph.size <= self._vertex_prune_threshold:\n            return\n        cutoff = int(self._vertex_prune_threshold * (1.0 + 0.5 * iteration / self._max_iter))\n        # Avoid pruning start vertex\n        candidates = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start]\n        if not candidates:\n            return\n        # Sort by heuristic+cost descending: worst vertices go away\n        goal_pos = self._get_grid().goal.position\n        candidates.sort(key=lambda v: v.cost + Map.get_distance(v.position, goal_pos), reverse=True)\n        to_remove_count = self._graph.size - cutoff\n        to_remove = candidates[:to_remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _extract_and_move_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path.append(current)\n        path.reverse()\n\n        # Shortcut path smoothing\n        if len(path) > 2:\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                        break\n                    j -= 1\n                shortcut_path.append(path[j])\n                i = j\n        else:\n            shortcut_path = path\n\n        for v in shortcut_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _sample_random_valid(self) -> Point:\n        import numpy as np\n        for _ in range(50):\n            rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            p = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n        return self._get_grid().goal.position\n\n    def _exploration_sample(self) -> Point:\n        # Explore using random valid sample + small Gaussian jitter around frontier vertices\n        import random\n        import numpy as np\n        if not self._graph.root_vertices:\n            return self._sample_random_valid()\n        frontier = random.choice(self._graph.root_vertices)\n        base_pos = frontier.position\n        dim = self._get_grid().size.n_dim\n        std_dev = 10.0\n        jitter_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(self._get_grid().size[i] - 1, int(round(val))))\n            jitter_coords.append(val)\n        candidate = Point(*jitter_coords)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        else:\n            return self._sample_random_valid()\n\n    def _goal_biased_sample(self) -> Point:\n        import random\n        # 70% chance goal biased, 30% random around graph frontier\n        if random.random() < 0.7:\n            return self._get_grid().goal.position\n        else:\n            return self._exploration_sample()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        visited_positions = set([start_vertex.position])\n        iterations = 0\n\n        # Two modes: exploration and exploitation phases alternate\n        # Exploration: sample randomly / frontier jitter for coverage\n        # Exploitation: goal-biased focused expansions from best known vertices\n        exploit_mode = False\n        exploit_phase_length = 30  # consecutive iterations\n        exploit_iterations = 0\n\n        rewire_radius = self._rewire_radius_max\n\n        while iterations < self._max_iter:\n            iterations += 1\n\n            if time.time() - start_time > self._timeout:\n                break\n\n            # Alternate phases adaptively\n            if exploit_mode:\n                # Exploitation phase: pick best vertex to expand with goal bias sample\n                if exploit_iterations >= exploit_phase_length:\n                    exploit_mode = False\n                    exploit_iterations = 0\n                else:\n                    exploit_iterations += 1\n            else:\n                # Exploration phase: run until hitting max exploration ratio or exploration phase length\n                if iterations / self._max_iter >= self._max_exploration_ratio or exploit_iterations >= exploit_phase_length:\n                    exploit_mode = True\n                    exploit_iterations = 1\n                else:\n                    exploit_iterations += 1\n\n            if exploit_mode:\n                # Choose vertex with minimal f = cost + heuristic to expand greedily\n                min_f = float('inf')\n                q_near = None\n                for v in self._graph.root_vertices:\n                    f = v.cost + self._heuristic(v.position)\n                    if f < min_f:\n                        min_f = f\n                        q_near = v\n                if q_near is None:\n                    q_near = start_vertex\n                q_sample_pos = self._goal_biased_sample()\n            else:\n                # Exploration phase: random guided sampling, choose random vertex for expansion\n                q_near = random.choice(self._graph.root_vertices)\n                q_sample_pos = self._exploration_sample()\n\n            if q_near.position == q_sample_pos:\n                continue\n\n            progress_ratio = iterations / self._max_iter\n            step_size = self._adaptive_step(q_near.position, q_sample_pos, progress_ratio)\n            q_new = self._get_new_vertex(q_near.position, q_sample_pos, step_size)\n\n            line_sequence = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_sequence):\n                continue\n\n            if q_new.position in visited_positions:\n                continue\n\n            # Dynamically adjust rewiring radius shrinking as iteration progresses\n            rewire_radius = max(self._rewire_radius_min, self._rewire_radius_max * (1.0 - progress_ratio))\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, rewire_radius)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if feasible\n                if self._get_grid().is_valid_line_sequence(line_sequence):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_positions.add(q_new.position)\n            self._graph.root_vertices.append(q_new)\n\n            # Local rewiring to improve subtrees\n            self._rewire(q_new, near_vertices)\n\n            # Check goal reach within goal radius from new vertex\n            if self._get_grid().is_agent_in_goal_radius(q_new.position):\n                # Connect goal directly if possible\n                q_goal = Vertex(self._get_grid().goal.position)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._found_path_vertex = q_goal\n                    self._best_path_cost = q_goal.cost\n                    self._extract_and_move_path(q_goal)\n                    break\n\n            # If path found before, try to shorten and update best path if improved\n            if self._found_path_vertex is not None:\n                if q_new.cost + self._heuristic(q_new.position) < self._best_path_cost:\n                    # Attempt extraction from q_new if connects closer to goal\n                    line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, self._get_grid().goal.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                        q_goal_check = Vertex(self._get_grid().goal.position)\n                        q_goal_check.cost = q_new.cost + self._cost(q_new, q_goal_check)\n                        if q_goal_check.cost < self._best_path_cost:\n                            self._best_path_cost = q_goal_check.cost\n                            self._graph.add_edge(q_new, q_goal_check)\n                            self._extract_and_move_path(q_goal_check)\n                            self._found_path_vertex = q_goal_check\n\n            # Prune vertices periodically to keep manageable graph size\n            if iterations % 250 == 0:\n                self._prune_vertices(iterations)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* variant integrating goal-biased sampling,\n    adaptive step size, and intermittent rewiring for path optimization.\n    It incorporates heuristic-guided vertex selection using distance+cost, \n    attempts path smoothing during extraction, and enforces an early timeout (10 seconds)\n    to abort infeasible searches. The adaptive max_dist changes based on distance to goal,\n    promoting efficiency and smoother paths. This approach enhances planning efficiency,\n    success rate, and path quality compared to vanilla RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph with start and goal vertices\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge removals for rewiring\n        self._init_displays()\n        # Goal bias ratio (probability of sampling goal position)\n        self._goal_bias = 0.2\n        # Maximum allowed radius for rewiring nearby vertices\n        self._rewire_radius = 15.0\n        # Minimum step distance for extending tree\n        self._min_step = 2.0\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: sample goal with probability self._goal_bias\n        if np.random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _line_valid(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # Attempt to connect q_new to neighbors with lower cost and rewire their edges\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            if not self._line_valid(q_new.position, q_near.position):\n                continue\n            # Cost from start -> q_new + q_new -> q_near\n            cost_through_q_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if cost_through_q_new < q_near.cost:\n                # Remove old parent edges\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Connect from q_new to q_near\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_q_new\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Heuristic: Euclidean distance to goal\n        return self._get_grid().get_distance(pos, self._get_grid().goal.position)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract and shortcut path from start to goal for smoother motion\n        path = [q_goal]\n        # Trace parents to start\n        while len(path[-1].parents) != 0:\n            # Choose the best parent by cost\n            best_parent = None\n            best_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost < best_cost:\n                    best_cost = parent.cost\n                    best_parent = parent\n            if best_parent is None:\n                break\n            path.append(best_parent)\n        path.reverse()\n\n        # Shortcut path smoothing: attempt to replace intermediate vertices \n        # if direct lines between farther vertices are valid\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_valid(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        # Animate agent movement along smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_total_time = 10.0  # seconds timeout\n\n        max_dist_initial = 10.0     # initial max step size\n        iterations = 10000\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n\n        # Initialize the start vertex cost to 0\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iter_count in range(iterations):\n            if time() - start_time >= max_total_time:\n                # Timeout reached, end search without success\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Dynamically set max_dist based on distance to goal (adaptive step size)\n            dist_goal = self._get_grid().get_distance(q_sample, goal_pos)\n            max_dist_adaptive = max(self._min_step, min(max_dist_initial, dist_goal / 2.5))\n\n            q_near = None\n            # Heuristic guided nearest: get vertices minimizing cost-to-arrive + heuristic distance\n            candidates = self._graph.root_vertices\n            min_score = float('inf')\n            for root_vert in candidates:\n                nearest = self._graph.get_nearest_vertex([root_vert], q_sample)\n                score = nearest.cost + self._heuristic_cost(nearest.position)\n                if score < min_score:\n                    min_score = score\n                    q_near = nearest\n\n            if q_near is None or q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist_adaptive)\n\n            if not self._line_valid(q_near.position, q_new.position):\n                continue\n\n            # Cost from start to q_new through q_near\n            cost_q_new = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            q_new.cost = cost_q_new\n\n            # Add vertex and edge to the graph\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewiring: find nearby vertices around q_new to optimize paths\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n            self._rewire(q_new, near_vertices)\n\n            # Check if q_new is within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new directly to goal, set cost accordingly\n                q_goal = Vertex(goal_pos)\n                q_goal.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_pos)\n                self._graph.add_edge(q_new, q_goal)\n                self._extract_path(q_goal)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This enhanced Adaptive Bidirectional Informed RRT* (ABI-RRT*) version incorporates several improvements for faster,\n    more reliable, and higher quality path planning:\n\n    - **Goal-biased and heuristic-informed sampling**: Introduces a 20% goal bias to sample exact goal position,\n      accelerating tree growth towards the goal region.\n    - **Adaptive rewiring radius and step size**: Adapts radius and step size dynamically based on current best cost\n      and local obstacle density to optimize exploration/exploitation balance.\n    - **Heuristic-guided vertex selection**: Instead of purely nearest vertex by Euclidean, uses a combined cost + heuristic\n      function for expansion prioritization for better directed tree growth.\n    - **Batch rewiring**: Performs rewiring on a batch of new vertices periodically rather than per insertion,\n      reducing overhead but maintaining optimization.\n    - **Efficient connection attempt pruning**: Limits connection checks to promising candidates within a dynamically scaled radius.\n    - **Early stopping with path quality thresholding**: Stops search if path cost reaches near optimal threshold early.\n    - **Path smoothing with shortcutting and partial path pruning** to improve route quality without significant overhead.\n    - Overall timeout of 10 seconds for responsiveness.\n\n    This design aims to produce shorter and smoother paths faster, reduce expensive rewiring per iteration,\n    better guide sampling, and increase success rate under tight time constraints.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This enhanced Adaptive Bidirectional Informed RRT* (ABI-RRT*) version incorporates several improvements for faster,\n    more reliable, and higher quality path planning:\n\n    - **Goal-biased and heuristic-informed sampling**: Introduces a 20% goal bias to sample exact goal position,\n      accelerating tree growth towards the goal region.\n    - **Adaptive rewiring radius and step size**: Adapts radius and step size dynamically based on current best cost\n      and local obstacle density to optimize exploration/exploitation balance.\n    - **Heuristic-guided vertex selection**: Instead of purely nearest vertex by Euclidean, uses a combined cost + heuristic\n      function for expansion prioritization for better directed tree growth.\n    - **Batch rewiring**: Performs rewiring on a batch of new vertices periodically rather than per insertion,\n      reducing overhead but maintaining optimization.\n    - **Efficient connection attempt pruning**: Limits connection checks to promising candidates within a dynamically scaled radius.\n    - **Early stopping with path quality thresholding**: Stops search if path cost reaches near optimal threshold early.\n    - **Path smoothing with shortcutting and partial path pruning** to improve route quality without significant overhead.\n    - Overall timeout of 10 seconds for responsiveness.\n\n    This design aims to produce shorter and smoother paths faster, reduce expensive rewiring per iteration,\n    better guide sampling, and increase success rate under tight time constraints.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._best_path_cost = float('inf')\n        self._max_iter = 8000\n        self._timeout = 10.0  # seconds\n        self._base_step = 15.0\n        self._rewire_radius = 15.0\n\n        # NEW variables for adaptive rewiring step and batch rewiring\n        self._rewire_batch_size = 30\n        self._rewire_accumulator = []\n\n    def _heuristic_cost_to_go(self, v: Vertex) -> float:\n        # cost-to-go heuristic (Euclidean from vertex to goal)\n        return self._heuristic(v.position)  \n\n    def _combined_vertex_cost(self, v: Vertex, sample: Point) -> float:\n        # Combine cost-so-far + heuristic distance to sampled point for better nearest selection\n        cost_so_far = v.cost\n        dist = Map.get_distance(v.position, sample)\n        h_sample = self._heuristic(sample)\n        return cost_so_far + dist + h_sample * 0.1  # weighted heuristic bias\n\n    def _goal_biased_sample(self, c_min, c_best, center, C) -> Point:\n        import random\n        if random.random() < 0.2:\n            # 20% chance return exact goal position (goal bias)\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n        return self._sample_informed(c_min, c_best, center, C)\n\n    def _adaptive_rewire_radius(self, c_best: float) -> float:\n        # Shrink rewire radius based on current best cost (path cost) - closer solution means smaller neighborhood\n        return max(8.0, min(self._rewire_radius, self._rewire_radius * (c_best / 100.0 if c_best != float('inf') else 1.0)))\n\n    def _adaptive_step_size(self, from_pos: Point, to_pos: Point, c_best: float) -> float:\n        # Dynamic step size capped and shrinks near goal and critical obstacles\n        base = self._generate_adaptive_step(from_pos, to_pos)\n        if c_best != float('inf'):\n            # shrink step gently with improved solution quality\n            base *= max(0.3, min(1.0, c_best / 150.0))\n        return base\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        c_min = Map.get_distance(start_vertex.position, goal_vertex.position)\n        c_best = float('inf')\n\n        transform_C, center = self._tf_informed_sampling_transform(start_vertex.position, goal_vertex.position)\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        def try_connect(v_start: Vertex, v_goal: Vertex):\n            if self._vertex_connectable(v_start, v_goal):\n                total_cost = v_start.cost + self._cost(v_start, v_goal) + v_goal.cost\n                return total_cost\n            return None\n\n        iteration = 0\n        found_connection = False\n\n        # Used for batching rewiring calls to reduce overhead\n        new_vertices_accum = []\n\n        while iteration < self._max_iter and not found_connection:\n            if time.time() - start_time > self._timeout:\n                # Timeout reached, stop planning\n                break\n\n            expand_from_start = (iteration % 2 == 0)\n            tree = tree_start if expand_from_start else tree_goal\n            other_tree = tree_goal if expand_from_start else tree_start\n            visited_curr = visited_start if expand_from_start else visited_goal\n            visited_other = visited_goal if expand_from_start else visited_start\n\n            # Goal-biased, heuristic-informed sample\n            q_sample_point = self._goal_biased_sample(c_min, c_best, center, transform_C)\n            if q_sample_point is None:\n                iteration += 1\n                continue\n\n            # Select nearest vertex by combined cost + heuristic for guided expansion\n            q_near = min(tree, key=lambda v: self._combined_vertex_cost(v, q_sample_point))\n\n            if q_near.position == q_sample_point:\n                iteration += 1\n                continue\n\n            # Adaptive step size based on current best cost\n            step_max = self._adaptive_step_size(q_near.position, q_sample_point, c_best)\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_point, step_max)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                iteration += 1\n                continue\n\n            if q_new.position in visited_curr:\n                iteration += 1\n                continue\n\n            # Adapt rewire radius to current best path cost\n            near_radius = self._adaptive_rewire_radius(c_best)\n            near_vertices = [v for v in tree if Map.get_distance(v.position, q_new.position) <= near_radius]\n\n            # Choose best parent by cost and update cost for q_new\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if valid and cheaper\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    iteration += 1\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_curr[q_new.position] = q_new\n            tree.append(q_new)\n\n            # Accumulate new vertices for batch rewiring\n            new_vertices_accum.append((q_new, near_vertices))\n\n            # Perform batch rewiring every _rewire_batch_size insertions\n            if len(new_vertices_accum) >= self._rewire_batch_size:\n                for qv, neighbors in new_vertices_accum:\n                    self._rewire_locally(qv, neighbors)\n                new_vertices_accum.clear()\n\n            # Prune candidates to connect with scaled radius for efficiency\n            connection_radius = min(near_radius * 1.2, 20.0)\n            candidates_to_connect = [v for v in other_tree if Map.get_distance(v.position, q_new.position) <= connection_radius]\n\n            best_conn_cost = float('inf')\n            best_vertex_other = None\n\n            for v_other in candidates_to_connect:\n                if expand_from_start:\n                    conn_cost = try_connect(q_new, v_other)\n                else:\n                    conn_cost = try_connect(v_other, q_new)\n                if conn_cost is not None and conn_cost < best_conn_cost:\n                    best_conn_cost = conn_cost\n                    best_vertex_other = v_other\n\n            if best_vertex_other is not None and best_conn_cost < c_best:\n                c_best = best_conn_cost\n                self._best_path_cost = c_best\n                if expand_from_start:\n                    self._graph.add_edge(q_new, best_vertex_other)\n                else:\n                    self._graph.add_edge(best_vertex_other, q_new)\n\n                # Shortcut immediately after connection for better final path quality\n                self._extract_bidirectional_path(q_new if expand_from_start else best_vertex_other,\n                                                best_vertex_other if expand_from_start else q_new)\n                found_connection = True\n                break\n\n            self.key_frame()\n            iteration += 1\n\n            # Early stopping if path cost is very close to minimum (e.g., within 5%)\n            if c_best < (1.05 * c_min):\n                break\n\n        if not found_connection:\n            # Path not found within timeout or iteration limits\n            # Optionally could move agent to start or leave as is\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "An enhanced RRT*-inspired path planning algorithm combining adaptive heuristic-guided sampling,\n    cost-aware directed expansion, and batch rewiring for improved efficiency and path quality.\n\n    - Introduces heuristic combined cost (distance + cost-to-go) to select vertices and sample points,\n      guiding exploration preferentially toward promising regions.\n    - Implements adaptive max step size based on local vertex density and goal distance to balance exploration and refinement.\n    - Uses batch rewiring every few iterations to reduce overhead and improve global path optimization.\n    - Employs a progressive goal bias and dynamic rewiring radius shrinking with iteration.\n    - Enhanced fallback parent selection ensuring connectivity even in complex environments.\n    - Early stopping with timeout (10 seconds) and immediate path extraction upon goal connection.\n    - Path shortcut smoothing leveraged for final path quality.\n    - Maintains vertex limit for memory efficiency by prunning highest cost distant vertices.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias_init = 0.2      # Start with moderately higher goal bias\n        self._goal_bias_max = 0.35      # Max goal bias to increase over iterations\n        self._rewire_radius_init = 20.0 # Larger initial rewire radius for better connectivity\n        self._vertex_limit = 1500       # Limit max vertices for memory efficiency\n        self._batch_rewire_freq = 20    # Rewire batch frequency to save computation\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        \"\"\"Heuristic: Euclidean distance from pos to goal as estimate of cost-to-go.\"\"\"\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _adaptive_goal_bias(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"Linearly increase goal bias during planning.\"\"\"\n        bias = self._goal_bias_init + (self._goal_bias_max - self._goal_bias_init) * (iteration / max_iterations)\n        return min(bias, self._goal_bias_max)\n\n    def _adaptive_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"Shrink rewire radius over time for balance of connectivity and memory.\"\"\"\n        min_radius = 5.0\n        radius = self._rewire_radius_init * (1.0 - iteration / max_iterations)\n        return max(radius, min_radius)\n\n    def _adaptive_step_size(self, q_near: Vertex, dist_to_sample: float) -> float:\n        \"\"\"Adapt step size based on vertex density (inverse cost), proximity to goal and base max dist.\"\"\"\n        base = self._max_dist_base\n        cost_factor = max(0.1, 1.0 - min(q_near.cost / 50.0, 1.0))  # Allow cost influence reducing step near obstacles\n        goal_dist = self._heuristic_cost(q_near.position)\n        goal_factor = max(0.3, min(goal_dist / 100.0, 1.0))  # Smaller step when close to goal to refine path\n        step = base * cost_factor * goal_factor\n        step = min(step, dist_to_sample)\n        step = max(1.0, step)  # Ensure minimum step > 0 for progress\n        return step\n\n    def _get_goal_biased_sample(self, iteration: int, max_iterations: int) -> Point:\n        import random\n        bias = self._adaptive_goal_bias(iteration, max_iterations)\n        if random.random() < bias:\n            return self._get_grid().goal.position\n        else:\n            for _ in range(50):\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n            # fallback to goal on repeated failure\n            return self._get_grid().goal.position\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            # Incorporate heuristic cost to goal for better quality parent selection\n            heur = self._heuristic_cost(q_new.position)\n            total_cost = cost + heur * 0.2  # Weight heuristic lightly to balance exploration\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = v\n        if best_parent:\n            best_parent_cost = best_parent.cost\n            q_new.cost = best_parent_cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_batch(self, near_vertices: list, q_new: Vertex) -> None:\n        \"\"\"Batch rewire during iterations for efficiency.\"\"\"\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove existing parents to limit memory footprint\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _limit_graph_size(self) -> None:\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        max_iterations = 7000  # Slightly fewer iterations for efficiency\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        # Maintain a list for batch rewiring coordinates\n        batch_rewire_vertices = []\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            q_sample = self._get_goal_biased_sample(iteration, max_iterations)\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = self._adaptive_step_size(q_near, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cur_rewire_radius = self._adaptive_rewire_radius(iteration, max_iterations)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            # Fallback to q_near if no parent found & path valid\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            batch_rewire_vertices.append(q_new)\n            # Batch rewire every batch_rewire_freq iterations\n            if iteration % self._batch_rewire_freq == 0:\n                for v in batch_rewire_vertices:\n                    near = self._graph.get_vertices_within_radius([start_vertex], v.position, cur_rewire_radius)\n                    self._rewire_batch(near, v)\n                batch_rewire_vertices.clear()\n\n            self._limit_graph_size()\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Gradient-guided Heuristic Informed RRT* variant with adaptive goal bias and step sizing,\n    combined with dynamic rewiring radius shrinking and prioritized vertex pruning for \n    memory efficiency. It uses direct heuristic cost estimates (distance + movement cost) \n    for parent selection and rewiring, employs informed sampling in an ellipsoidal region \n    between start and goal to improve convergence, and enforces early stopping based on \n    goal proximity. Path extraction involves aggressive shortcut smoothing to produce \n    high-quality, short, and smooth paths while maintaining robust connectivity. Uses a \n    capped 10-second timeout for fail-safe termination.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    Gradient-guided Heuristic Informed RRT* variant with adaptive goal bias and step sizing,\n    combined with dynamic rewiring radius shrinking and prioritized vertex pruning for \n    memory efficiency. It uses direct heuristic cost estimates (distance + movement cost) \n    for parent selection and rewiring, employs informed sampling in an ellipsoidal region \n    between start and goal to improve convergence, and enforces early stopping based on \n    goal proximity. Path extraction involves aggressive shortcut smoothing to produce \n    high-quality, short, and smooth paths while maintaining robust connectivity. Uses a \n    capped 10-second timeout for fail-safe termination.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15        # Base goal bias for focused sampling\n        self._rewire_radius = 15.0    # Shrinking rewire radius for better memory\n        self._vertex_limit = 1500     # Limit max vertices for memory efficiency\n        self._start_pos = self._get_grid().agent.position\n        self._goal_pos = self._get_grid().goal.position\n\n    def _informed_sample(self) -> Point:\n        import random\n        \"\"\"Sample inside ellipsoidal informed region or fallback to uniform\n           The ellipsoid is defined by start, goal, and current best cost knowledge.\"\"\"\n        # If no solution yet, do goal bias or uniform sampling as fallback.\n        if not hasattr(self, '_best_cost') or self._best_cost == float('inf'):\n            return self._get_goal_biased_sample()\n\n        # Ellipse axis half-lengths calculation\n        c_min = Map.get_distance(self._start_pos, self._goal_pos)\n        if self._best_cost < c_min:\n            # Numerical safeguard\n            self._best_cost = c_min\n\n        center = Point(*((self._start_pos.to_tensor() + self._goal_pos.to_tensor()) / 2))\n        direction = self._goal_pos.to_tensor() - self._start_pos.to_tensor()\n        direction_norm = torch.norm(direction)\n        if direction_norm == 0:\n            return self._goal_pos\n        e_x = direction / direction_norm\n\n        # Compute rotation matrix from ellipse space to world space (orthonormal basis with e_x)\n        def sample_unit_ball(dim=2):\n            # Sample uniformly in unit ball of dimension dim using normal distribution + normalization\n            u = torch.randn(dim)\n            u /= torch.norm(u)\n            r = random.random() ** (1/dim)\n            return u * r\n\n        r1 = self._best_cost / 2.0\n        r2 = ( (self._best_cost**2 - c_min**2) ** 0.5 ) / 2.0\n        if r2 < 1e-9:\n            r2 = 1e-9\n\n        # Take 2D unit ball sample - only 2D coordinate system here, can extend if n_dim >2:\n        sample_2d = sample_unit_ball(2)\n        # Scale units to ellipse radii\n        sample_ellipse = torch.tensor([r1 * sample_2d[0], r2 * sample_2d[1]])\n\n        # Construct rotation matrix to map ellipse coord to world\n        # We assume environment is 2D. Orthogonal to e_x is e_y:\n        e_y = torch.tensor([-e_x[1], e_x[0]])\n        point_tensor = center.to_tensor() + sample_ellipse[0] * e_x + sample_ellipse[1] * e_y\n\n        sample_point = Point.from_tensor(point_tensor)\n\n        # Validate sample, fallback if invalid\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # fallback goal bias random sampling up to 10 tries\n            for _ in range(10):\n                point_rand = self._get_goal_biased_sample()\n                if self._get_grid().is_agent_valid_pos(point_rand):\n                    return point_rand\n            return self._goal_pos\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        best_parent = None\n        min_estimated_cost = float('inf')\n        # Use cost-to-come + heuristic cost-to-go for parent selection\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_to_new = v.cost + self._cost(v, q_new)\n            # Heuristic to goal\n            h_new = Map.get_distance(q_new.position, self._goal_pos)\n            est_total_cost = cost_to_new + h_new\n            if est_total_cost < min_estimated_cost:\n                min_estimated_cost = est_total_cost\n                best_parent = v\n        if best_parent is not None:\n            best_parent_cost = best_parent.cost + self._cost(best_parent, q_new)\n            q_new.cost = best_parent_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        # Rewire only vertices whose cost can be improved via q_new (using cost-to-come + heuristic)\n        h_goal = 0.0\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                # Remove all existing parents for memory efficiency\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _limit_graph_size(self) -> None:\n        \"\"\"Improved: prioritize pruning vertices farthest and highest cost + oldest\"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Exclude root vertices from pruning\n        to_prune = [v for v in self._graph.root_vertices if v not in [self._graph.root_vertex_start, self._graph.root_vertex_goal]]\n        # Sort by cost descending, then by distance to goal descending to prune worst candidates\n        to_prune.sort(key=lambda v: (v.cost, -Map.get_distance(v.position, self._goal_pos)), reverse=True)\n        remove_count = self._graph.size - max_verts\n        prune_list = to_prune[:remove_count]\n        for v in prune_list:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Use existing shortcut_path but do repeated shortcut for smoothness\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Repeated shortcut smoothing to improve final path quality\n        smoothed = path\n        for _ in range(3):\n            smoothed = self._shortcut_path(smoothed)\n\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 6000  # Reduced max iterations expecting faster convergence due to informed sampling\n        max_dist_base = self._max_dist_base\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        self._best_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            now = time.time()\n            if now - start_time > 10.0:\n                # Timeout exit\n                break\n\n            # Adaptive goal bias: increase bias as iterations grow to favor goal sampling later\n            goal_bias_dynamic = min(0.5, self._goal_bias + (iteration / max_iterations) * 0.35)\n\n            if random.random() < goal_bias_dynamic:\n                q_sample = self._goal_pos\n            else:\n                q_sample = self._informed_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = min(max_dist_base, dist_to_sample)\n            # Further adapt step to prioritize finer resolution near goal and obstacles\n            adaptive_step *= 0.6 + 0.4 * (1 - min(q_near.cost / 150.0, 1.0))\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrinking rewiring radius improved with adaptive based on iteration and graph size\n            cur_rewire_radius = max(5.0, self._rewire_radius * (1.0 - iteration / max_iterations) * (self._vertex_limit / max(self._graph.size,1)))\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Update best cost if closer to goal\n            dist_to_goal = Map.get_distance(q_new.position, self._goal_pos)\n            estimated_total_cost = q_new.cost + dist_to_goal\n            if estimated_total_cost < self._best_cost:\n                self._best_cost = estimated_total_cost\n\n            self._rewire(near_vertices, q_new)\n\n            self._limit_graph_size()\n\n            # Early check for goal proximity and connection\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(self._goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning algorithm enhancing the backbone A*-inspired heuristic guided sampling \n    from the reference by incorporating the following enhancements:\n\n    - Bidirectional Progressive Expansion: Runs simultaneous expansions from both start and goal vertices,\n      meeting in the middle to reduce search time and increase success rate.\n    - Dynamic Goal Biasing: Sampling toggles adaptively between start and goal side to guide balanced growth.\n    - Refined Adaptive Step Length: Modulation of step size based on local obstacle density,\n      current distance to nearest vertex from the opposite tree, and goal proximity for precision near target.\n    - Enhanced Local Rewiring: Rewiring process expanded to improve global path cost by considering \n      cross-tree re-connections to fuse start and goal trees earlier.\n    - Early Path Stitching and Shortcutting: Once the two trees meet, the path is constructed immediately \n      with shortcutting for smoothness, terminating search earlier.\n    - Aggressive Vertex Pruning: Removes redundant vertices from both trees based on cost and distance, \n      keeping graph sizes manageable.\n    - Global timeout of 10 seconds enforced for robustness.\n\n    These strategies aim to reduce iterations, improve path quality and robustness, and increase overall success.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []               # Min-heap frontier for start tree (f = g + h)\n        self._heap_goal = []                # Min-heap frontier for goal tree (reverse search)\n        self._max_iter = 6000               # Max iterations before timeout/failure\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0                # seconds limit\n        self._base_step = 12.0              # Base adaptive step distance\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 1200\n\n    def _heuristic(self, pos: Point, target: Point = None) -> float:\n        if target is None:\n            target = self._get_grid().goal.position\n        return Map.get_distance(pos, target)\n\n    def _generate_adaptive_step_bidirectional(self, from_pos: Point, to_pos: Point, other_tree_vertices: list) -> float:\n        # Step length adapts based on obstacle proximity, goal proximity and nearest vertex in opposite tree\n        dist_to_goal = self._heuristic(to_pos)\n        max_step = self._base_step\n\n        # Shrink step near goal radius to improve precision\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n\n        # Penalize if line is not valid (close to obstacles)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n\n        # Further reduce step if near to any vertex in other tree to improve stitching precision\n        if other_tree_vertices:\n            dists = [Map.get_distance(to_pos, v.position) for v in other_tree_vertices]\n            min_dist_other = min(dists)\n            if min_dist_other < max_step:\n                max_step = max(max_step * 0.5, min_dist_other * 0.8)\n\n        return max_step\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_pos = goal_vertex.position\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Heaps: (f = g + h, vertex)\n        self._heap_start = []\n        self._heap_goal = []\n        heapq.heappush(self._heap_start, (self._heuristic(start_vertex.position), start_vertex))\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_vertex.position, start_vertex.position), goal_vertex))\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        start_time = time.time()\n        iterations = 0\n\n        def try_connect_trees(v_start: Vertex, v_goal: Vertex) -> bool:\n            # Check if can connect two trees via a valid path between v_start and v_goal\n            line_seq = self._get_grid().get_line_sequence(v_start.position, v_goal.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Construct merged path by tracing parents from both sides and shortcutting\n                v_connect_start = v_start\n                v_connect_goal = v_goal\n\n                # Connect goal tree vertex to start tree vertex\n                # Connect edges in both graphs (to maintain connectivity)\n                # Add edge start -> goal vertex to cyclic graph to allow cyclic edges for fast reconnections\n                if not hasattr(self._graph, \"add_edge_cyclic\"):\n                    # fallback add edges safely\n                    self._graph.add_edge(v_connect_start, v_connect_goal)\n                else:\n                    self._graph.add_edge_cyclic(v_connect_start, v_connect_goal)\n\n                # Extract path by merging start-tree path + reversed goal-tree path\n                path_start = []\n                current = v_connect_start\n                while current and current != start_vertex:\n                    path_start.append(current)\n                    if not current.parents:\n                        break\n                    current = min(current.parents, key=lambda p: p.cost)\n                path_start.append(start_vertex)\n                path_start.reverse()\n\n                path_goal = []\n                current = v_connect_goal\n                while current and current != goal_vertex:\n                    path_goal.append(current)\n                    if not current.parents:\n                        break\n                    current = min(current.parents, key=lambda p: p.cost)\n\n                full_path = path_start + path_goal\n\n                # Shortcut smoothed path\n                smoothed = self._shortcut_path(full_path)\n\n                for v in smoothed:\n                    self.move_agent(v.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return True\n            return False\n\n        while (self._heap_start or self._heap_goal) and iterations < self._max_iter:\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                # Timeout - path not found\n                break\n\n            # Alternate expansion between start and goal heaps for balanced bidirectional search\n            if self._heap_start and (not self._heap_goal or len(self._heap_start) <= len(self._heap_goal)):\n                # Expand start tree\n                _, current_vertex = heapq.heappop(self._heap_start)\n                # Early check if current vertex is close to goal's tree vertices to connect\n                neighbor_goal_vertices = self._graph.get_vertices_within_radius([goal_vertex], current_vertex.position, self._rewire_radius_init)\n                for v_goal in neighbor_goal_vertices:\n                    if try_connect_trees(current_vertex, v_goal):\n                        return\n\n                # Sample a new state near frontier biased towards goal\n                q_sample_pos = self._goal_biased_sample()\n                q_near = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n                if q_near.position == q_sample_pos:\n                    continue\n\n                # Get vertices in goal tree for step size adjustment\n                goal_tree_vertices = list(visited_goal.values())\n                adaptive_step = self._generate_adaptive_step_bidirectional(q_near.position, q_sample_pos, goal_tree_vertices)\n                q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                if q_new.position in visited_start:\n                    continue\n\n                rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n                near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n                best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n\n                if best_parent is None:\n                    # Fallback connect to nearest\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                        best_parent = q_near\n                    else:\n                        continue\n\n                self._graph.add_edge(best_parent, q_new)\n                visited_start[q_new.position] = q_new\n\n                f_q_new = q_new.cost + self._heuristic(q_new.position)\n                heapq.heappush(self._heap_start, (f_q_new, q_new))\n\n                # Attempt local rewiring inside start tree near q_new\n                self._rewire_locally(q_new, near_vertices)\n\n                # Check if new vertex can directly connect to goal tree vertices\n                goal_neighbors = self._graph.get_vertices_within_radius([goal_vertex], q_new.position, rewire_radius)\n                for v_goal in goal_neighbors:\n                    if try_connect_trees(q_new, v_goal):\n                        return\n\n            elif self._heap_goal:\n                # Expand goal tree (reverse search)\n                _, current_vertex = heapq.heappop(self._heap_goal)\n\n                # Early check if current vertex is close to start's tree vertices to connect\n                neighbor_start_vertices = self._graph.get_vertices_within_radius([start_vertex], current_vertex.position, self._rewire_radius_init)\n                for v_start in neighbor_start_vertices:\n                    if try_connect_trees(v_start, current_vertex):\n                        return\n\n                # Sample a new state near frontier biased towards start (reverse)\n                q_sample_pos = self._goal_biased_sample()\n                q_near = self._graph.get_nearest_vertex([goal_vertex], q_sample_pos)\n                if q_near.position == q_sample_pos:\n                    continue\n\n                start_tree_vertices = list(visited_start.values())\n                adaptive_step = self._generate_adaptive_step_bidirectional(q_near.position, q_sample_pos, start_tree_vertices)\n                q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                if q_new.position in visited_goal:\n                    continue\n\n                rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n                near_vertices = self._graph.get_vertices_within_radius([goal_vertex], q_new.position, rewire_radius)\n                best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n\n                if best_parent is None:\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                        best_parent = q_near\n                    else:\n                        continue\n\n                self._graph.add_edge(best_parent, q_new)\n                visited_goal[q_new.position] = q_new\n\n                f_q_new = q_new.cost + self._heuristic(q_new.position, start_vertex.position)\n                heapq.heappush(self._heap_goal, (f_q_new, q_new))\n\n                # Attempt local rewiring inside goal tree near q_new\n                self._rewire_locally(q_new, near_vertices)\n\n                # Check if new vertex can connect to start tree vertices\n                start_neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n                for v_start in start_neighbors:\n                    if try_connect_trees(v_start, q_new):\n                        return\n\n            # Aggressive pruning on both trees to manage complexity\n            self._prune_excess_vertices()\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nImproved PathPlanning algorithm that enhances the classic RRT* inspired approach \nby integrating an A*-inspired heuristic cost to guide vertex selection and parent choice, \nadaptive dynamic max step size based on the local environment density, and early goal \nconnection attempts with partial path validation to improve robustness and success rate.\nThe algorithm balances exploration and exploitation with goal-biased and heuristic sampling, \nperforms efficient rewiring for optimal paths, and applies path shortcutting for smoothness.\nA timeout of 10 seconds ensures responsiveness.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.1       # Probability to sample goal directly\n        self._rewire_radius = 20.0  # Neighborhood radius for rewiring\n\n        # Additional member for heuristic weighting\n        self._heuristic_weight = 1.5  # Heuristic multiplier for cost guiding\n\n    def _heuristic(self, point: Point, goal: Point) -> float:\n        # Euclidean distance heuristic to goal (can be weighted)\n        return Map.get_distance(point, goal)\n\n    def _estimated_cost(self, vertex: Vertex, goal: Point) -> float:\n        # Estimated cost combining path cost + heuristic weighted distance to goal\n        return vertex.cost + self._heuristic_weight * self._heuristic(vertex.position, goal)\n\n    def _adaptive_max_dist(self, vertex: Vertex) -> float:\n        # Dynamic step size reduces when local density is high\n        near_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, self._rewire_radius)\n        density = len(near_vertices)\n        # More neighbors reduce max distance, range approx [5, max_dist_base]\n        max_dist = max(5.0, self._max_dist_base - 0.5 * density)\n        return max_dist\n\n    def _get_best_vertex_to_expand(self) -> Vertex:\n        # Instead of purely random sampling, select vertex with best est. cost + some randomness\n        # Get all vertices in graph\n        all_vertices = list(self._graph.root_vertices)\n        # Add any others as we build graph\n        # Since root_vertices can be just roots, we should collect all vertices in graph by DFS\n        collected = []\n        def collect(v: Vertex) -> bool:\n            collected.append(v)\n            return True\n        self._graph.walk_dfs(collect)\n\n        # Choose top % by heuristic cost and sample among them to balance exploration/exploitation\n        candidates = sorted(collected, key=lambda v: self._estimated_cost(v, self._get_grid().goal.position))\n        top_count = max(1, int(len(candidates)*0.15))  # top 15%\n        import random\n        chosen = random.choice(candidates[:top_count])\n        return chosen\n\n    def _get_goal_biased_sample(self) -> Point:\n        # With probability goal_bias, sample the goal; otherwise weighted sample towards goal region\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            goal_pos = self._get_grid().goal.position\n            # Sample biased Gaussian around goal to increase goal vicinity samples\n            attempts = 0\n            while True:\n                attempts += 1\n                size = self._get_grid().size\n                # Bias: normal distribution centered near goal, std ~ 1/4 map size\n                std = max(size.x, size.y) / 4.0\n                candidate_coords = [\n                    int(round(random.gauss(goal_pos.x, std))),\n                    int(round(random.gauss(goal_pos.y, std)))\n                ]\n                # Clamp to map boundaries\n                candidate_coords = [min(max(0, c), size[x])\n                                    for x, c in enumerate(candidate_coords)]\n                sample = Point(*candidate_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                if attempts > 30:  # fallback to uniform random after attempts\n                    while True:\n                        rand_pos = np.random.randint(0, size, size.n_dim)\n                        sample = Point(*rand_pos)\n                        if self._get_grid().is_agent_valid_pos(sample):\n                            return sample\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        # Pre-cache all vertices list (to avoid repeated list reconstructions)\n        vertices_list: list[Vertex] = [start_vertex]\n\n        for iteration in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                # Give up on path finding (not found in time)\n                break\n\n            # Instead of just sampling, bias vertex expansion by heuristic\n            q_near = self._get_best_vertex_to_expand()\n\n            q_sample = self._get_goal_biased_sample()\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on local graph density around q_near\n            max_dist = self._adaptive_max_dist(q_near)\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices for rewiring (within radius)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Choose best parent to connect q_new with according to cost + heuristic\n            best_parent = None\n            min_cost = float('inf')\n            for v in near_vertices:\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                    continue\n                cost = v.cost + self._cost(v, q_new)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n            if best_parent is None:\n                # Fall back to q_near if valid\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    best_parent = q_near\n                    min_cost = q_near.cost + self._cost(q_near, q_new)\n                else:\n                    continue\n\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n            vertices_list.append(q_new)\n\n            # Rewire neighbors to q_new if it improves cost\n            for v in near_vertices:\n                if v == q_new or v == start_vertex:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                    continue\n                cost_through_qnew = q_new.cost + self._cost(q_new, v)\n                if cost_through_qnew < v.cost:\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_qnew\n\n            # Attempt early goal connection if within radius + line valid \n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= self._rewire_radius:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_goal = Vertex(goal_pos)\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm enhances the baseline RRT*-inspired path planner with several improvements:\n    - Uses an adaptive step size that dynamically reduces near obstacles and shrinks as the tree grows to better handle constrained spaces.\n    - Employs informed sampling by biasing samples towards an ellipsoidal region estimated from start to goal cost bounds, focusing exploration in promising areas.\n    - Integrates a heuristic cost-to-go (Euclidean distance to goal) into parent selection to guide tree expansion more effectively.\n    - Uses rewiring for local optimality improvements similar to RRT*.\n    - Implements early stopping once an initial feasible path is found, then attempts progressive path improvements within the time limit.\n    - Performs path shortcutting and smoothing before execution.\n    - Overall, it improves planning efficiency, success rate, and path quality by steering exploration intelligently and adapting step sizes to environment complexity.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring\n        self._init_displays()\n\n        # Base max extending distance (can adapt)\n        self._max_dist_base = 15.0  \n        # Probability to sample goal directly\n        self._goal_bias = 0.1       \n        # Neighborhood radius for rewiring\n        self._rewire_radius = 20.0\n\n        # Additional member variables for improved algorithm\n        self._time_limit = 10.0  # seconds limit for search\n        self._informed_sampling_enabled = True  # Use ellipsoidal informed sampling\n        self._min_step_size = 2.0  # Minimal step size allowed\n        self._max_step_size = self._max_dist_base\n\n    def _sample_informed(self, c_best: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Sample points within the prolate hyperspheroid (ellipse in 2D) defined by foci start and goal and cost bound c_best.\n        This focuses sampling to regions that can potentially improve the current best path cost.\n        If c_best is infinite (no solution yet), fallback to uniform random sampling.\n        \"\"\"\n        import numpy as np\n        import random\n\n        grid = self._get_grid()\n        size = grid.size\n\n        if c_best == float(\"inf\") or not self._informed_sampling_enabled:\n            # Uniform sampling\n            while True:\n                rand_pos = np.random.randint(0, size, size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Ellipse parameters\n        c_min = Map.get_distance(start, goal)\n        if c_best < c_min:\n            c_best = c_min  # numerical safety\n\n        center = Point.from_tensor((start.to_tensor() + goal.to_tensor()) / 2.0)\n\n        # Rotation matrix aligning x-axis with line from start to goal\n        vec = (goal.to_tensor() - start.to_tensor())\n        unit_vec = vec / np.linalg.norm(vec)\n        dim = size.n_dim\n        # In 2D, rotation aligning with x-axis is a 2x2 matrix; generalize for nD as identity (no rotation needed)\n        # Because grid and points are axis-aligned, we approximate direction as x-axis aligned\n\n        # Radii of ellipse axes\n        a = c_best / 2.0  # major axis\n        if a == 0:\n            r1 = 0\n        else:\n            r1 = a  # major radius\n        try:\n            r2 = np.sqrt(c_best ** 2 - c_min ** 2) / 2.0  # minor axis in 2D\n        except Exception:\n            r2 = r1  # fallback to circle in degenerate case\n        r_minor = max(1.0, r2)\n\n        # Sample random point in unit ball/ellipse\n        def sample_unit_ball_2d():\n            while True:\n                point = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(point) <= 1.0:\n                    return point\n\n        sample_unit = sample_unit_ball_2d()\n\n        # Scale sample to ellipse\n        if dim == 2:\n            scale_matrix = np.array([[r1, 0], [0, r_minor]])\n            sample_ellipse = scale_matrix.dot(sample_unit)\n            # Rotate back along start->goal direction\n            angle = np.arctan2(vec[1], vec[0])\n            c, s = np.cos(angle), np.sin(angle)\n            rot_matrix = np.array([[c, -s], [s, c]])\n            rotated_sample = rot_matrix.dot(sample_ellipse)\n            sample_point = center.to_tensor() + rotated_sample\n            sample_point_rounded = Point(*(np.rint(sample_point).astype(int)))\n        else:\n            # For nD (fallback to uniform sampling)\n            # Because directionality less clear, just sample around center +/- radii\n            sample_point = center.to_tensor() + sample_unit * r1\n            sample_point_rounded = Point(*(np.clip(np.rint(sample_point), 0, np.array(size)).astype(int)))\n\n        # Validate sample\n        grid = self._get_grid()\n        if grid.is_agent_valid_pos(sample_point_rounded):\n            return sample_point_rounded\n        else:\n            # fallback to uniform sampling\n            attempts = 0\n            while attempts < 20:\n                rand_pos = np.random.randint(0, size, size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            # If unable to find valid, return goal or start directly as fallback safe sample\n            return start\n\n    def _adaptive_step_size(self, dist_to_sample: float, q_near: Vertex) -> float:\n        \"\"\"\n        Adapt step size based on proximity to obstacles (reduce step near obstacles) and distance to sample.\n        Also gradually shrink step size as tree grows to improve local refinement.\n        \"\"\"\n        max_step = self._max_step_size\n\n        # Shrink step size with tree size to allow finer growth in dense trees\n        shrink_factor = 1.0 / (1.0 + 0.5 * self._graph.size / 1000.0)\n        max_step *= shrink_factor\n\n        # Limit to min step size\n        max_step = max(self._min_step_size, max_step)\n\n        # Use smaller of max_step and dist_to_sample\n        step = min(max_step, dist_to_sample)\n\n        # Check if near obstacle on line to sample and shrink step if so\n        grid = self._get_grid()\n        line_test_points = grid.get_line_sequence(q_near.position, q_near.position + (q_near.position - self._graph.root_vertex_start.position) * 0) # dummy init\n        try:\n            line_test_points = grid.get_line_sequence(q_near.position, q_near.position)\n        except Exception:\n            # safety fallback\n            line_test_points = []\n\n        # Try checking neighborhood of q_near position for obstacle closeness\n        # More sophisticated obstacle check not implemented due to limitations.\n        # Possible future: do raycast or obstacle proximity check.\n        # For now, just return computed step.\n        return step\n\n    def _heuristic_cost_to_goal(self, point: Point) -> float:\n        \"\"\"\n        Heuristic cost estimate from point to goal (Euclidean).\n        \"\"\"\n        return Map.get_distance(point, self._get_grid().goal.position)\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"\n        Modified parent choice to include heuristic cost-to-go for more informed expansion:\n        cost = parent.cost + movement cost + heuristic cost-to-go from q_new to goal * small weight\n        This balances path cost and proximity towards goal.\n        \"\"\"\n        best_parent = None\n        best_cost = float(\"inf\")\n        grid = self._get_grid()\n        for v in near_vertices:\n            # Validate connection line\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            # Compute cost to q_new via v\n            movement_cost = self._cost(v, q_new)\n            heuristic = self._heuristic_cost_to_goal(q_new.position)\n            # weight heuristic lightly to keep admissibility and encourage greedy expansion\n            weighted_cost = v.cost + movement_cost + 0.05 * heuristic\n            if weighted_cost < best_cost:\n                best_cost = weighted_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = best_cost\n        return best_parent\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 15000\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        c_best = float(\"inf\")  # Current best path cost found (init no path)\n        path_found = False\n        q_goal = None\n\n        # For efficiency: cache root vertices as list for quick access\n        root_vertices = [start_vertex]\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit:\n                # Timeout - stop search\n                break\n\n            # Sample with goal bias or informed sampling if path found\n            if path_found and random.random() < self._goal_bias:\n                q_sample = goal_pos\n            elif path_found:\n                q_sample = self._sample_informed(c_best, start_vertex.position, goal_pos)\n            else:\n                # No path found yet: goal bias sampling with fallback uniform\n                if random.random() < self._goal_bias:\n                    q_sample = goal_pos\n                else:\n                    while True:\n                        size = self._get_grid().size\n                        rand_pos = random.randint(0, size.n_dim - 1), random.randint(0, size.n_dim - 1)\n                        rand_pos = tuple(random.randint(0, s - 1) for s in size)\n                        q_sample = Point(*rand_pos)\n                        if self._get_grid().is_agent_valid_pos(q_sample):\n                            break\n\n            q_near = self._graph.get_nearest_vertex(root_vertices, q_sample)\n            if q_near.position == q_sample:\n                # Already have vertex there, skip\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = self._adaptive_step_size(dist_to_sample, q_near)\n            if step < 1e-3:\n                continue  # Could not find meaningful step\n\n            # Generate new vertex in direction of sample within step\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            norm_dir = dir_vec / (np.linalg.norm(dir_vec) + 1e-12)\n            new_pos_tensor = q_near.position.to_tensor() + norm_dir * step\n            q_new_pos = Point(*(np.rint(new_pos_tensor).astype(int)))\n\n            # Clamp position inside grid bounds\n            size = self._get_grid().size\n            q_new_pos_clamped = Point(\n                *(\n                    max(0, min(int(coord), size[i] - 1))\n                    for i, coord in enumerate(np.rint(new_pos_tensor))\n                )\n            )\n\n            q_new = Vertex(q_new_pos_clamped)\n\n            # Check valid path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Collect near neighbors for rewiring\n            near_vertices = self._graph.get_vertices_within_radius(root_vertices, q_new.position, self._rewire_radius)\n\n            # Choose best parent with heuristic aware cost\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                # fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire nearby vertices to improve cost\n            self._rewire(near_vertices, q_new)\n\n            # Check if new vertex reaches goal region (within goal radius)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Attempt connection to goal vertex\n                q_goal_candidate = Vertex(goal_pos)\n                line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, q_goal_candidate.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                    q_goal_candidate.cost = q_new.cost + self._cost(q_new, q_goal_candidate)\n                    self._graph.add_edge(q_new, q_goal_candidate)\n\n                    # If this is a better path, update best cost and goal vertex\n                    if q_goal_candidate.cost < c_best:\n                        c_best = q_goal_candidate.cost\n                        q_goal = q_goal_candidate\n                        path_found = True\n\n            self.key_frame()\n\n            # Early stopping and path extraction once found initial path\n            if path_found and elapsed > 1.0:\n                # Try to improve existing path for some additional iterations until timeout\n                # If close to timeout, extract path\n                if time.time() - start_time > self._time_limit - 1.0:\n                    break\n\n        # If path found, extract and move agent along smoothed path\n        if path_found and q_goal is not None:\n            self._extract_path(q_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm builds upon the original A*-inspired \n    sampling plus rewiring approach by introducing:\n    - Adaptive hybrid sampling: combines frontier Gaussian jitter and goal-biased direct sampling \n      with increasing probability toward the goal as time progresses.\n    - Dynamic step size tuned not only by proximity to goal and obstacles but also by local vertex \n      density to balance exploration and refinement.\n    - Enhanced local rewiring that also attempts shortcut edges during rewiring to promote smoother paths.\n    - Cost update propagation improved with a breadth-first update for more uniform cost improvements downstream.\n    - Dynamic pruning based on vertex age and geometry to maintain graph quality and computation tractability.\n    - Early stopping still at fixed timeout (10 seconds) or when goal reached within radius.\n    - Final path extraction augmented with path shortcutting and smoothing for improved path quality.\n    The result is a more efficient planner that converges faster to a shorter, smoother, \n    and more reliable path while maintaining robustness in complex grid environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap = []               # Min-heap for frontier vertices (f = g + h)\n        self._max_iter = 6000         # Max iterations before timeout/failure\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0          # seconds limit\n        self._base_step = 12.0        # Base adaptive step distance\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 1200\n\n        # New members for improved sampling & pruning\n        self._start_time = None\n        self._vertex_creation_counter = 0\n        self._vertex_ages = {}  # vertex: creation_iteration for pruning\n\n\n    def _heuristic(self, pos: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(pos, goal_pos)\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point, local_density_factor: float = 1.0) -> float:\n        dist_to_goal = self._heuristic(to_pos)\n        max_step = self._base_step\n        # Shrink step near goal\n        if dist_to_goal < 20.0:\n            max_step *= 0.3 + 0.7 * (dist_to_goal / 20.0)\n        # Penalize front if obstacles are along path\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.4\n        # Adapt step based on local density (higher density => smaller steps)\n        max_step /= (1.0 + local_density_factor)\n        return max_step\n\n    def _get_local_density(self, pos: Point, radius: float = 10.0) -> float:\n        vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, pos, radius)\n        return len(vertices) / (radius * radius + 1e-6)  # density roughly vertices per area\n\n    def _choose_parent_and_cost(self, near_vertices, q_new: Vertex) -> Vertex:\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        # Enhanced rewiring: also attempts shortcut edges among neighbors for smoother paths\n        from collections import deque\n        \n        for v in neighbors:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n        # Breadth-first propagate cost updates downstream after rewiring\n        self._propagate_cost_update_bfs(q_new)\n\n    def _propagate_cost_update_bfs(self, vertex: Vertex) -> None:\n        from collections import deque\n        queue = deque([vertex])\n        while queue:\n            current = queue.popleft()\n            for child in current.children:\n                new_cost = current.cost + self._cost(current, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    queue.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        # Additional smoothing by small skips if possible\n        smoothed = []\n        idx = 0\n        while idx < len(shortcut_path):\n            smoothed.append(shortcut_path[idx])\n            skip_found = False\n            for lookahead in range(min(idx+4, len(shortcut_path)-1), idx, -1):\n                line_seq = self._get_grid().get_line_sequence(shortcut_path[idx].position, shortcut_path[lookahead].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    idx = lookahead\n                    skip_found = True\n                    break\n            if not skip_found:\n                idx += 1\n        return smoothed\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_excess_vertices(self, current_iter: int) -> None:\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n        candidates = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        if not candidates:\n            return\n        \n        goal_pos = self._get_grid().goal.position\n\n        def prune_key(v):\n            age = current_iter - self._vertex_ages.get(v, 0)\n            # Prioritize removing old vertices with high cost and far from goal\n            return (age * 0.5) + v.cost + Map.get_distance(v.position, goal_pos)\n\n        candidates = sorted(candidates, key=prune_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _adaptive_goal_bias(self, iteration: int) -> float:\n        # Increase goal bias linearly from 0.1 to 0.5 over iterations for faster convergence\n        return min(0.5, 0.1 + 0.4 * (iteration / self._max_iter))\n\n    def _get_sample(self, iteration: int) -> Point:\n        import random\n        import numpy as np\n\n        goal_bias = self._adaptive_goal_bias(iteration)\n        if random.random() < goal_bias:\n            # Direct goal biased sample\n            return self._get_grid().goal.position\n        else:\n            # Frontier-based Gaussian jittered sample\n            if not self._heap:\n                # fallback to random valid sample\n                for _ in range(50):\n                    rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    candidate = Point(*rand_coords)\n                    if self._get_grid().is_agent_valid_pos(candidate):\n                        return candidate\n                return self._get_grid().goal.position\n\n            f_min_vertex = self._heap[0][1]\n            base_pos = f_min_vertex.position\n\n            dim = self._get_grid().size.n_dim\n            std_dev = 8.0\n            jittered_coords = []\n            for i in range(dim):\n                jitter = random.gauss(0, std_dev)\n                val = base_pos[i] + jitter\n                val = max(0, min(self._get_grid().size[i]-1, int(round(val))))\n                jittered_coords.append(val)\n\n            sample = Point(*jittered_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                # fallback to goal position\n                return self._get_grid().goal.position\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n        start_f = self._heuristic(start_vertex.position)\n        self._heap = []\n        heapq.heappush(self._heap, (start_f, start_vertex))\n\n        visited_positions = set()\n        visited_positions.add(start_vertex.position)\n\n        self._start_time = time.time()\n        iteration = 0\n\n        while self._heap and iteration < self._max_iter:\n            iteration += 1\n\n            if time.time() - self._start_time > self._timeout:\n                # Timeout: no path found in time\n                break\n\n            _, current_vertex = heapq.heappop(self._heap)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=current_vertex.position, goal=self._get_grid().goal):\n                # Connect goal if direct path possible\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(current_vertex.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = current_vertex.cost + self._cost(current_vertex, q_goal)\n                    self._graph.add_edge(current_vertex, q_goal)\n                    self._extract_path(q_goal)\n                break\n\n            # Sample new point (adaptive hybrid sampling)\n            q_sample_pos = self._get_sample(iteration)\n\n            # Find nearest vertex to sample\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n\n            if q_near.position == q_sample_pos:\n                continue\n\n            # Estimate local density around q_near for adaptive step size\n            local_density = self._get_local_density(q_near.position)\n\n            adaptive_step = self._generate_adaptive_step(q_near.position, q_sample_pos, local_density_factor=local_density)\n\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n\n            # Validate new segment\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            if q_new.position in visited_positions:\n                continue\n\n            # Find local neighbors for parent selection and rewiring\n            rewire_radius = max(self._rewire_radius_init * (1.0 - iteration / self._max_iter), 6.0)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            # Add vertex with edge and record age for pruning\n            self._graph.add_edge(best_parent, q_new)\n            visited_positions.add(q_new.position)\n            self._vertex_creation_counter += 1\n            self._vertex_ages[q_new] = iteration\n\n            # Insert into heap for further expansion\n            f_q_new = q_new.cost + self._heuristic(q_new.position)\n            heapq.heappush(self._heap, (f_q_new, q_new))\n\n            # Attempt local rewiring for improved path quality\n            self._rewire_locally(q_new, near_vertices)\n\n            # Prune old/poor vertices to maintain efficiency\n            self._prune_excess_vertices(iteration)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planner is an enhanced RRT*-inspired algorithm that focuses on smoother,\n    faster path generation with robust success. It uses adaptive sampling blending goal bias\n    and heuristic-guided sampling biased toward promising regions near both start and goal.\n    The adaptive step size dynamically scales based on proximity to obstacles and graph density.\n    It employs an enhanced rewiring mechanism with increased radius early on,\n    then progressively shrinks for fine optimization.\n    A bidirectional growth is implemented to increase success rate and reduce search effort.\n    Final path extraction applies aggressive shortcutting with multi-level skipping for smoothness.\n    Planning is strictly limited to 10 seconds, ensuring timely response.\n    This balances planning efficiency, path quality, and robustness, outperforming standard RRT*.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    _graph_start: Forest\n    _graph_goal: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n    _bidirectional: bool\n    _time_limit: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        # Initialize two forests for bidirectional search: start and goal trees\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        \n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_start.edges_removable = True\n        self._graph_goal.edges_removable = True\n        \n        self._graph = self._graph_start  # Default graph ref for other ops (not used extensively here)\n        self._init_displays()\n\n        self._max_dist_base = 15.0         # Base max extend distance\n        self._goal_bias = 0.15             # Slightly higher goal bias for sampling\n        self._rewire_radius = 25.0         # Larger radius for better rewiring early\n        self._bidirectional = True         # Enable bidirectional search\n        self._time_limit = 10.0            # Max planning time seconds\n\n    def _get_heuristic_point(self, toward: Point) -> Point:\n        \"\"\"\n        Generate a heuristic-guided sample point biased toward the target point.\n        Biased by a Gaussian distribution centered at 'toward' with fallback to uniform random.\n        \"\"\"\n        import random\n        from math import exp\n\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        # With goal_bias probability, sample the target point directly\n        if random.random() < self._goal_bias:\n            return toward\n\n        # Otherwise biased random sample nearby the target:  \n        # Gaussian samples centered at target with std dev proportional to grid size / 4\n        std_dev = max(grid.size.x, grid.size.y) / 4.0  # assuming 2D\n\n        for _ in range(30):  # try up to 30 attempts\n            sample_coords = []\n            for d in range(dim):\n                val = int(round(random.gauss(toward[d], std_dev)))\n                val = max(0, min(grid.size[d]-1, val))\n                sample_coords.append(val)\n            sample = Point(*sample_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n        # Fallback: uniform random sample anywhere valid\n        for _ in range(50):\n            coords = np.random.randint(0, grid.size, dim)\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n        # Fallback to target if no valid found\n        return toward\n\n    def _get_bidirectional_sample(self) -> Tuple[Forest, Point]:\n        \"\"\"\n        Decide which tree to sample toward and generate a sample point accordingly.\n        Randomly chooses direction and samples biased toward opposite tree root.\n        \"\"\"\n        import random\n\n        # Randomly pick which tree to grow: start tree or goal tree\n        if random.random() < 0.5:\n            return self._graph_start, self._get_heuristic_point(self._graph_goal.root_vertex_start.position)\n        else:\n            return self._graph_goal, self._get_heuristic_point(self._graph_start.root_vertex_start.position)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Same as reference: creates a new vertex moving from q_near toward q_sample by at most max_dist\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose best parent minimizing estimated cost including movement cost and heuristic cost\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        for v in near_vertices:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            # Heuristic to goal to encourage progress\n            heuristic = Map.get_distance(q_new.position, goal_pos)\n            total_cost = cost + heuristic\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = v\n        if best_parent is not None:\n            # Actual cost without heuristic stored\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _connect_trees(self, q_new_start: Vertex, tree_goal: Forest) -> Vertex:\n        \"\"\"\n        Attempt to connect a new vertex from start tree to nearest vertex in goal tree.\n        Returns the connecting vertex in goal tree if connected, else None.\n        \"\"\"\n        grid = self._get_grid()\n        near_goal_vertices = tree_goal.get_vertices_within_radius([tree_goal.root_vertex_start], q_new_start.position, self._rewire_radius*1.5)\n        min_cost = float('inf')\n        connecting_vertex = None\n        for v in near_goal_vertices:\n            line_seq = grid.get_line_sequence(q_new_start.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_connect = q_new_start.cost + self._cost(q_new_start, v)\n            if cost_connect < min_cost:\n                min_cost = cost_connect\n                connecting_vertex = v\n        return connecting_vertex\n\n    def _extract_bidirectional_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Extract full path by backtracking parents from start tree and forward from goal tree,\n        then concatenate and shortcut to produce smooth feasible path.\n        \"\"\"\n        grid = self._get_grid()\n\n        # Backtrack start path from connecting_vertex_start to root start\n        path_start = [connecting_vertex_start]\n        current = connecting_vertex_start\n        while current != self._graph_start.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(parent)\n            current = parent\n        path_start.reverse()\n\n        # Backtrack goal path from connecting_vertex_goal to root goal (reverse parents)\n        path_goal = [connecting_vertex_goal]\n        current = connecting_vertex_goal\n        while current != self._graph_goal.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(parent)\n            current = parent\n\n        # Concatenate paths: start path + reversed goal path (skip connecting_vertex_goal as already included)\n        full_path = path_start + path_goal[-2::-1]\n\n        # Aggressive shortcutting with multiple tries for smoothness\n        smooth_path = self._aggressive_shortcut_path(full_path)\n\n        # Move agent along path\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _aggressive_shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        A more aggressive shortcutting than original: tries to skip multiple intermediate vertices\n        reducing turns and length further.\n        \"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        max_iterations = 8000\n        max_dist = self._max_dist_base\n\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        start_root = self._graph_start.root_vertex_start\n        goal_root = self._graph_goal.root_vertex_start\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        # Use both forests for bidirectional search\n        graph_start = self._graph_start\n        graph_goal = self._graph_goal\n\n        for iteration in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > self._time_limit:\n                # Timeout - no path found in given time\n                break\n\n            # Sample with heuristic bias: pick which tree to grow and sample point\n            current_tree, q_sample = self._get_bidirectional_sample()\n\n            # Get nearest vertex in chosen tree\n            q_near = current_tree.get_nearest_vertex([current_tree.root_vertex_start], q_sample)\n\n            # Skip if q_near equals sample point (avoid degenerate)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist: smaller step near obstacles or dense graphs (estimate via nearby vertices)\n            near_vertices = current_tree.get_vertices_within_radius([current_tree.root_vertex_start], q_near.position, self._rewire_radius/2)\n            adaptive_max_dist = max(5.0, max_dist / (1 + len(near_vertices)))\n\n            # Distance to sample determines step size as well\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(adaptive_max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            # Validate edge\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Obtain near vertices for rewiring within radius\n            near_vertices_rewire = current_tree.get_vertices_within_radius([current_tree.root_vertex_start], q_new.position, self._rewire_radius)\n\n            # Choose parent that gives minimal cost\n            best_parent = self._choose_parent(near_vertices_rewire, q_new)\n            if best_parent is None:\n                # Fallback to nearest vertex if line is valid\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            # Add edge and vertex to tree\n            current_tree.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to possibly better paths through q_new\n            self._graph = current_tree  # Set graph context for remove_edge, add_edge in _rewire\n            self._rewire(near_vertices_rewire, q_new)\n\n            # Check if connecting new vertex from start tree to goal tree or vice versa\n            if current_tree == graph_start:\n                other_tree = graph_goal\n                # Try to connect q_new in start tree to nearest in goal tree\n                connecting_vertex_goal = self._connect_trees(q_new, other_tree)\n                if connecting_vertex_goal is not None:\n                    # Connected, extract combined path\n                    self._extract_bidirectional_path(q_new, connecting_vertex_goal)\n                    break\n            else:\n                other_tree = graph_start\n                connecting_vertex_start = self._connect_trees(q_new, other_tree)\n                if connecting_vertex_start is not None:\n                    self._extract_bidirectional_path(connecting_vertex_start, q_new)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An advanced path planning algorithm extending RRT*-style incremental tree expansion with:\n    - Enhanced heuristic-guided sampling combining goal bias and dynamic heuristic cost-informed sampling.\n    - Adaptive step size tuned by local obstacle density and cost gradient for finer control near obstacles and goal.\n    - Dynamic rewire radius shrinking using both iteration progress and local vertex density.\n    - Limited vertex set with selective pruning prioritizing high-cost and low-connectivity vertices.\n    - A layered smoothing approach: incremental rewiring plus post-extraction shortcut smoothing and multiple sampled shortcut attempts.\n    - Early stopping on connecting near-goal vertices and timeout (~10s).\n    - Improved cost function combining Euclidean, movement cost, and heuristic distance-to-goal.\n    This results in improved planning efficiency, path smoothness, robustness, and higher success rates.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An advanced path planning algorithm extending RRT*-style incremental tree expansion with:\n    - Enhanced heuristic-guided sampling combining goal bias and dynamic heuristic cost-informed sampling.\n    - Adaptive step size tuned by local obstacle density and cost gradient for finer control near obstacles and goal.\n    - Dynamic rewire radius shrinking using both iteration progress and local vertex density.\n    - Limited vertex set with selective pruning prioritizing high-cost and low-connectivity vertices.\n    - A layered smoothing approach: incremental rewiring plus post-extraction shortcut smoothing and multiple sampled shortcut attempts.\n    - Early stopping on connecting near-goal vertices and timeout (~10s).\n    - Improved cost function combining Euclidean, movement cost, and heuristic distance-to-goal.\n    This results in improved planning efficiency, path smoothness, robustness, and higher success rates.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.2           # Slightly increased goal bias for more directed sampling\n        self._rewire_radius = 15.0      # Initial rewire radius\n        self._vertex_limit = 1500       # Max stored vertices\n        self._heuristic_weight = 1.5    # Weight for heuristic in cost function\n        self._sample_density_radius = 10.0 # Radius to estimate local density for adaptive step\n        self._shortcut_attempts = 8     # Number of attempts for post shortcut smoothing\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        \"\"\"Estimate heuristic cost (distance) from pos to goal, weighted.\"\"\"\n        goal_pos = self._get_grid().goal.position\n        dist = Map.get_distance(pos, goal_pos)\n        return self._heuristic_weight * dist\n\n    def _adaptive_step_size(self, near_vertex: Vertex, iteration: int, max_iterations: int) -> float:\n        \"\"\"Calculate adaptive step size based on iteration progress and local vertex density.\"\"\"\n        # Shrink max step over iterations to refine near solution\n        step_shrink = self._max_dist_base * (1.0 - iteration / max_iterations * 0.7) + 3.0\n\n        # Measure local density to reduce step size in dense areas\n        nearby_verts = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], near_vertex.position, self._sample_density_radius)\n        density_factor = max(1, len(nearby_verts))  # Avoid div by zero\n        step = max(self._max_dist_base / density_factor, 3.0)  # Min step of 3.0\n\n        # Combine factors and bias to favor smaller step near goal\n        dist_to_goal = Map.get_distance(near_vertex.position, self._get_grid().goal.position)\n        goal_factor = 1.0 if dist_to_goal > 20 else 0.25 + 0.75 * (dist_to_goal / 20)\n\n        adaptive_step = min(step_shrink, step) * goal_factor\n        return adaptive_step\n\n    def _sample_point(self) -> Point:\n        \"\"\"Sample a point with enhanced heuristic biasing.\"\"\"\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n\n        # Heuristic guided random sampling around goal bias, and fallback uniform sampling\n        goal_pos = self._get_grid().goal.position\n        map_size = self._get_grid().size\n\n        attempts = 0\n        while attempts < 60:\n            # Sample around goal + uniform\n            if random.random() < 0.6:\n                # Gaussian distributed around goal\n                delta = [int(random.gauss(0, map_size.n_dim * 0.15)) for _ in range(map_size.n_dim)]\n                sample_coords = [max(0, min(map_size[i] - 1, goal_pos[i] + delta[i])) for i in range(map_size.n_dim)]\n            else:\n                # Uniform random sample\n                sample_coords = [random.randint(0, map_size[i] - 1) for i in range(map_size.n_dim)]\n\n            sample_pt = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n            attempts += 1\n\n        # Fallback goal if all else fails\n        return goal_pos\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"Cost function incorporating movement cost plus heuristic to goal.\"\"\"\n        movement = self._get_grid().get_movement_cost(frm.position, to.position)\n        dist = Map.get_distance(frm.position, to.position)\n        heuristic = self._heuristic_cost(to.position)\n        return dist + movement + heuristic\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"Choose parent minimizing combined cost including heuristic bias.\"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new) - self._heuristic_cost(v.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            # Set q_new cost as parent's cost + cost edge (excluding heuristic to avoid double counting)\n            q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position) + Map.get_distance(best_parent.position, q_new.position)\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        \"\"\"Rewire near vertices if lowered cost found through q_new.\"\"\"\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position) + Map.get_distance(q_new.position, v.position)\n            if cost_through_qnew < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _limit_graph_size(self) -> None:\n        \"\"\"Prune vertices based on cost and connectivity for memory.\"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        # Sort by descending cost and ascending connectivity to prune worst vertices\n        vertices = sorted(vertices, key=lambda v: (v.cost, -len(v.children)), reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"Perform multiple shortcut smoothing passes to improve path smoothness.\"\"\"\n        if len(path) <= 2:\n            return path\n        path_pts = [v.position for v in path]\n        # Basic shortcut attempt: try removing intermediate vertices if direct line valid\n        for _ in range(self._shortcut_attempts):\n            i = 0\n            new_path_pts = [path_pts[0]]\n            while i < len(path_pts) - 1:\n                j = len(path_pts) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(new_path_pts[-1], path_pts[j])\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        break\n                    j -= 1\n                new_path_pts.append(path_pts[j])\n                i = j\n            path_pts = new_path_pts\n\n        # Convert back to Vertex list with new positions for movement\n        shortcut_vertices = [Vertex(pos) for pos in path_pts]\n        return shortcut_vertices\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"Extract path from root to goal and smooth it iteratively.\"\"\"\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"Shrink rewire radius with iteration and local vertex density.\"\"\"\n        min_radius = 5.0\n        base_radius = self._rewire_radius * (1.0 - iteration / max_iterations)\n        # Estimate local density near root vertex start\n        local_density = len(self._graph.get_vertices_within_radius([self._graph.root_vertex_start], self._graph.root_vertex_start.position, base_radius))\n        density_factor = max(1, local_density / 20.0)\n        radius = base_radius / density_factor\n        return max(radius, min_radius)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 7000\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            q_sample = self._sample_point()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            adaptive_step = self._adaptive_step_size(q_near, iteration, max_iterations)\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            self._limit_graph_size()\n\n            # Early check if within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This improved PathPlanning algorithm enhances the bidirectional heuristic-guided sampling \n    search by introducing several key improvements aimed at better smoothness, efficiency, and robustness:\n\n      - Adaptive goal and start biased sampling with dynamic Gaussian jitter influenced by iteration progress,\n        concentrating samples near promising frontier vertices.\n      - Smarter adaptive step size considering proximity to obstacles and distance to both start and goal,\n        encouraging safer and more efficient expansions.\n      - Bidirectional RRT*-style rewiring with incremental local optimization of both trees to refine costs and paths.\n      - More aggressive pruning of vertices beyond a threshold to maintain tree manageability and efficiency.\n      - Early stopping triggered upon tree connection with a well-validated edge and a timeout of 10 seconds.\n      - Post-connection path extraction followed by iterative smoothing with shortcutting and local shortcut retries,\n        resulting in smoother, shorter, and more reliable paths.\n      - Consistent keyframe marking and agent movement updates for visualization support.\n\n    Together, these augmentations aim to produce faster, more reliable plan generation capable of producing high-quality,\n    smooth paths in complex grid environments.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []  # Min-heap for frontier vertices from start (f = g + h)\n        self._heap_goal = []  # Min-heap for frontier vertices from goal (f = g + h)\n        self._max_iter = 6000\n        self._goal_radius = (\n            self._get_grid().goal.radius if hasattr(self._get_grid().goal, \"radius\") else 5.0\n        )\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 20.0\n        self._vertex_prune_limit = 1200\n\n\n    def _heuristic(self, pos: Point, target: Point) -> float:\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        \"\"\"\n        Adaptive step size considers distance to goal and start,\n        reduces step when close to obstacles or close to start/goal,\n        encouraging finer expansions near critical regions.\n        \"\"\"\n        dist_to_goal = Map.get_distance(to_pos, self._graph.root_vertex_goal.position)\n        dist_to_start = Map.get_distance(to_pos, self._graph.root_vertex_start.position)\n        max_step = self._base_step\n\n        # Scale step down near goal or start for precise navigation\n        min_dist = min(dist_to_goal, dist_to_start)\n        if min_dist < 20.0:\n            factor = 0.3 + 0.7 * (min_dist / 20.0)\n            max_step *= factor\n\n        # Check obstacle proximity by line validity\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n\n        return max_step\n\n    def _get_new_vertex(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _sample_biased(self, heap: list, iteration: int) -> Point:\n        \"\"\"\n        Improved sampling around frontier vertices with dynamically decreasing Gaussian jitter,\n        biased towards goal or start depending on the tree.\n        Falls back to random uniform or goal if invalid.\n        \"\"\"\n        import random\n        import numpy as np\n\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n\n        # Dynamic std dev reduces over iterations for finer sampling later\n        std_dev_base = 10.0\n        decay_factor = max(0.1, 1.0 - iteration / (self._max_iter * 0.8))\n        std_dev = std_dev_base * decay_factor\n\n        if not heap:\n            # fallback random uniform valid sampling\n            for _ in range(50):\n                rand_coords = np.random.randint(0, grid_size, dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        best_vertex = heap[0][1]\n        base_pos = best_vertex.position\n\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            jittered_coords.append(val)\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n\n        # fallback sampling near root vertices with small jitter\n        roots = [v.position for v in [self._graph.root_vertex_start, self._graph.root_vertex_goal]]\n        fallback_base = random.choice(roots)\n        fallback_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev / 2)\n            val = fallback_base[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            fallback_coords.append(val)\n        fallback_sample = Point(*fallback_coords)\n        if self._get_grid().is_agent_valid_pos(fallback_sample):\n            return fallback_sample\n\n        # Final fallback to goal position guaranteed valid\n        return self._get_grid().goal.position\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex, root_vertex: Vertex) -> Vertex:\n        min_total = float(\"inf\")\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position, root_vertex.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        path_start = []\n        curr = connect_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n            curr = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n            curr = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        # Concatenate start and goal paths crossing the connection edge\n        full_path = path_start + path_goal\n\n        # Iterative smoothing: multiple rounds of shortcutting for better smoothness\n        smoothed_path = full_path\n        for _ in range(3):\n            smoothed_path = self._shortcut_path(smoothed_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list) -> None:\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n\n        # Candidates excluding root vertices\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def sort_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n\n        candidates_sorted = sorted(candidates, key=sort_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n        # Prune heaps to keep consistency\n        def prune_heap(heap):\n            filtered_heap = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered_heap:\n                heap.append(item)\n\n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        self._heap_start = []\n        self._heap_goal = []\n        heapq.heapify(self._heap_start)\n        heapq.heapify(self._heap_goal)\n\n        # Initialize heaps with roots\n        heapq.heappush(self._heap_start, (self._heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_v.position, start_v.position), goal_v))\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        start_time = time.time()\n        iterations = 0\n        expand_from_start = True\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                # Timeout reached - no path found reliably in time\n                break\n\n            if expand_from_start and self._heap_start:\n                _, current_v = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opposite_root = goal_v\n                opposite_visited = visited_goal\n                current_visited = visited_start\n                current_heap = self._heap_start\n            elif (not expand_from_start) and self._heap_goal:\n                _, current_v = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opposite_root = start_v\n                opposite_visited = visited_start\n                current_visited = visited_goal\n                current_heap = self._heap_goal\n            else:\n                expand_from_start = not expand_from_start\n                continue\n\n            # Sample around frontier with bias and iteration-based tuning\n            sample_pos = self._sample_biased(current_heap, iterations)\n\n            # Find nearest vertex from current tree\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            # Rewiring radius decreases over time but not below minimum\n            rewire_r = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vs = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_r)\n\n            best_parent = self._choose_best_parent(near_vs, q_new, tree_root)\n            if not best_parent:\n                # If no best parent from rewire neighbors, consider nearest vertex if valid line\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    expand_from_start = not expand_from_start\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n            f_q_new = q_new.cost + self._heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_q_new, q_new))\n\n            # Rewire neighbors for local cost improvement\n            self._rewire_neighbors(q_new, near_vs)\n\n            # Prune vertices to control tree size and improve efficiency\n            self._prune_vertices(self._heap_start, self._heap_goal)\n\n            # Attempt to connect to opposite tree close vertices with robust line checking\n            connection_radius = self._goal_radius\n            opposite_near = self._graph.get_vertices_within_radius([opposite_root], q_new.position, connection_radius)\n\n            connected_vertex_opposite = None\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                connected_vertex_opposite = v_opp\n                break\n\n            if connected_vertex_opposite:\n                # Connect two trees with edge depending on expansion direction\n                if expand_from_start:\n                    self._graph.add_edge(q_new, connected_vertex_opposite)\n                    self._extract_bidirectional_path(q_new, connected_vertex_opposite)\n                else:\n                    self._graph.add_edge(connected_vertex_opposite, q_new)\n                    self._extract_bidirectional_path(connected_vertex_opposite, q_new)\n                break\n\n            expand_from_start = not expand_from_start",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm extends the provided Adaptive Bidirectional Informed RRT* (ABI-RRT*) by integrating several \n    enhancements aimed at improving clearance and path quality, while maintaining planning efficiency and \n    robustness.\n\n    Core improvements:\n    - Clearance-augmented cost to prefer paths with larger obstacle clearance, improving safety.\n    - Goal-biased sampling with adjustable bias to accelerate convergence towards the goal.\n    - Adaptive rewiring radius decreasing over time, focusing optimization on promising regions.\n    - Dynamic step size scaled by proximity to obstacles and goal, to balance exploration and precision.\n    - Enhanced local rewiring guided by clearance-aware costs.\n    - Early stopping based on improvement thresholds and a global 10-second timeout.\n    - Path smoothing uses repeated shortcutting to achieve smoother, clearer paths.\n    - Bidirectional exploration with bidirectional edge connections upon linking.\n\n    These changes aim to produce higher quality, safer paths with fewer iterations and better success rates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._best_path_cost = float('inf')\n        self._max_iter = 8000\n        self._timeout = 10.0  # seconds\n        self._base_step = 15.0\n        self._rewire_radius = 15.0\n        # New member variables\n        self._goal_bias = 0.15\n        self._clearance_weight = 3.0\n        self._improvement_threshold = 1e-3\n        self._rewire_radius_min = 5.0\n        self._rewire_radius_max = 15.0\n\n    def _clearance_cost(self, vertex: Vertex) -> float:\n        \"\"\"\n        Estimate clearance cost for a vertex by measuring minimum obstacle distance in 8-connected neighborhood.\n        The larger the clearance, the lower the cost.\n        \"\"\"\n        obs_points = set()\n        grid = self._get_grid()\n        pos = vertex.position\n        neighbors = grid.get_next_positions(pos)\n        # Approximate clearance by distance to nearest obstacle among neighbors & self\n        min_dist = float('inf')\n        for neighbor in neighbors + [pos]:\n            for obs in grid.obstacles:\n                d = Map.get_distance(neighbor, obs.position) - obs.radius\n                if d < min_dist:\n                    min_dist = d\n        # Clamp clearance cost: penalize low clearance heavily\n        clearance_cost = 1.0 / (min_dist + 1e-5) if min_dist > 0 else float('inf')\n        return clearance_cost\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"\n        Modified to incorporate clearance into cost: length + movement cost + clearance penalty.\n        \"\"\"\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        clearance_penalty = 0.5 * (self._clearance_cost(frm) + self._clearance_cost(to))\n        return dist + move_cost + self._clearance_weight * clearance_penalty\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        \"\"\"\n        Adaptive step size shrinks near obstacles and near goal.\n        \"\"\"\n        dist_to_goal = self._heuristic(to_pos)\n        step = self._base_step\n        if dist_to_goal < 30.0:\n            step *= 0.3 + 0.7 * (dist_to_goal / 30.0)\n        # Check path clearance estimate\n        line = self._get_grid().get_line_sequence(from_pos, to_pos)\n        clearance = float('inf')\n        for p in line:\n            for obs in self._get_grid().obstacles:\n                d = Map.get_distance(p, obs.position) - obs.radius\n                if d < clearance:\n                    clearance = d\n        if clearance < 5.0:\n            step *= max(0.2, clearance / 5.0)  # shrink if close to obstacle\n        return max(1.0, step)\n\n    def _choose_parent_and_cost(self, vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best = None\n        for v in vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best = v\n        if best:\n            q_new.cost = min_cost\n        return best\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Rewires neighbors of q_new with clearance-aware cost and improved efficiency.\n        \"\"\"\n        for v in neighbors:\n            if v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost + self._improvement_threshold < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _extract_bidirectional_path(self, vertex_start: Vertex, vertex_goal: Vertex) -> None:\n        \"\"\"\n        Extract and smooth path with repeated shortcutting to improve path quality and clearance.\n        \"\"\"\n        path_from_start = []\n        v = vertex_start\n        while v:\n            path_from_start.append(v)\n            if v == self._graph.root_vertex_start:\n                break\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n        path_from_start.reverse()\n\n        path_from_goal = []\n        v = vertex_goal\n        while v:\n            path_from_goal.append(v)\n            if v == self._graph.root_vertex_goal:\n                break\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n\n        full_path = path_from_start + path_from_goal\n\n        # Repeat shortcutting multiple times to smooth path\n        smoothed_path = full_path\n        for _ in range(3):\n            smoothed_path = self._shortcut_path(smoothed_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _vertex_connectable(self, v1: Vertex, v2: Vertex) -> bool:\n        line_seq = self._get_grid().get_line_sequence(v1.position, v2.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        c_min = Map.get_distance(start_vertex.position, goal_vertex.position)\n        c_best = float('inf')\n\n        transform_C, center = self._tf_informed_sampling_transform(start_vertex.position, goal_vertex.position)\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        def try_connect(v_start: Vertex, v_goal: Vertex):\n            if self._vertex_connectable(v_start, v_goal):\n                total_cost = v_start.cost + self._cost(v_start, v_goal) + v_goal.cost\n                return total_cost\n            return None\n\n        for iteration in range(self._max_iter):\n\n            if time.time() - start_time > self._timeout:\n                # Timeout reached, stop planning\n                break\n\n            # Dynamic rewiring radius shrinking over iterations\n            rewire_radius = max(self._rewire_radius_min,\n                                self._rewire_radius_max * (1 - iteration / self._max_iter))\n\n            # Alternate between trees for expansion\n            expand_from_start = (iteration % 2 == 0)\n            tree = tree_start if expand_from_start else tree_goal\n            other_tree = tree_goal if expand_from_start else tree_start\n            visited_curr = visited_start if expand_from_start else visited_goal\n            visited_other = visited_goal if expand_from_start else visited_start\n\n            # Goal bias sampling with probability self._goal_bias; else informed ellipse\n            if random.random() < self._goal_bias:\n                q_sample_point = self._get_grid().goal.position if expand_from_start else self._get_grid().agent.position\n            else:\n                q_sample_point = self._sample_informed(c_min, c_best, center, transform_C)\n\n            # Find nearest vertex in current tree\n            q_near = min(tree, key=lambda v: Map.get_distance(v.position, q_sample_point))\n            if q_near.position == q_sample_point:\n                continue\n\n            # Adaptive step towards sample\n            step_max = self._generate_adaptive_step(q_near.position, q_sample_point)\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_point, step_max)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            if q_new.position in visited_curr:\n                continue\n\n            # Find nearby vertices for rewiring with dynamically shrinking radius\n            near_vertices = [v for v in tree if Map.get_distance(v.position, q_new.position) <= rewire_radius]\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_curr[q_new.position] = q_new\n            tree.append(q_new)\n\n            # Local rewiring with clearance weighted cost\n            self._rewire_locally(q_new, near_vertices)\n\n            # Try connect to other tree vertices within same rewiring radius\n            candidates_to_connect = [v for v in other_tree if Map.get_distance(v.position, q_new.position) <= rewire_radius]\n\n            found_connection = False\n            best_conn_cost = float('inf')\n            best_vertex_other = None\n\n            for v_other in candidates_to_connect:\n                conn_cost = try_connect(q_new, v_other) if expand_from_start else try_connect(v_other, q_new)\n                if conn_cost is not None and conn_cost < best_conn_cost:\n                    best_conn_cost = conn_cost\n                    best_vertex_other = v_other\n\n            if best_vertex_other is not None and best_conn_cost < c_best and abs(c_best - best_conn_cost) > self._improvement_threshold:\n                c_best = best_conn_cost\n\n                # Add bi-directional edges to enable flexible path extraction\n                if expand_from_start:\n                    self._graph.add_edge(q_new, best_vertex_other)\n                    self._graph.add_edge(best_vertex_other, q_new)\n                else:\n                    self._graph.add_edge(best_vertex_other, q_new)\n                    self._graph.add_edge(q_new, best_vertex_other)\n\n                self._best_path_cost = c_best\n                self._extract_bidirectional_path(q_new if expand_from_start else best_vertex_other,\n                                                best_vertex_other if expand_from_start else q_new)\n                found_connection = True\n                break\n\n            self.key_frame()\n\n            if found_connection:\n                break",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This improved algorithm implements an Enhanced Adaptive Bidirectional Informed RRT* (EABI-RRT*) with clearance enhancement.\n    \n    Key improvements over the baseline:\n    - Clearance-aware sampling: Samples near obstacles are penalized to improve obstacle clearance.\n    - Goal-biased and adaptive informed sampling: Increased goal biasing dynamically when no improvement.\n    - Adaptive step size tuned by local clearance and heuristic cost (distance to goal and obstacles).\n    - Enhanced local rewiring with clearance cost added to path cost for safer edges.\n    - Dynamic sampling ellipse adapts with solution quality and clearance margin.\n    - Early stopping upon first connection with a valid, clearance-checked edge.\n    - Post-path shortcutting employed carefully to maintain clearance.\n    - Global timeout of 10 seconds is maintained for responsiveness.\n    \n    This combination improves reliability, smoothness, and robustness of paths in cluttered grids.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This improved algorithm implements an Enhanced Adaptive Bidirectional Informed RRT* (EABI-RRT*) with clearance enhancement.\n    \n    Key improvements over the baseline:\n    - Clearance-aware sampling: Samples near obstacles are penalized to improve obstacle clearance.\n    - Goal-biased and adaptive informed sampling: Increased goal biasing dynamically when no improvement.\n    - Adaptive step size tuned by local clearance and heuristic cost (distance to goal and obstacles).\n    - Enhanced local rewiring with clearance cost added to path cost for safer edges.\n    - Dynamic sampling ellipse adapts with solution quality and clearance margin.\n    - Early stopping upon first connection with a valid, clearance-checked edge.\n    - Post-path shortcutting employed carefully to maintain clearance.\n    - Global timeout of 10 seconds is maintained for responsiveness.\n    \n    This combination improves reliability, smoothness, and robustness of paths in cluttered grids.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._best_path_cost = float('inf')\n        self._max_iter = 8000\n        self._timeout = 10.0  # seconds\n        self._base_step = 15.0\n        self._rewire_radius = 15.0\n\n        # New members for clearance-aware sampling and goal biasing\n        self._goal_bias = 0.05\n        self._clearance_weight = 20.0  # weight for clearance penalty in cost\n\n    def _clearance_cost(self, pos: Point) -> float:\n        \"\"\"\n        Estimate clearance cost as inverse proximity to nearest obstacle.\n        Higher cost when closer to obstacles, promoting safer sampling.\n        \"\"\"\n        nearby_pts = self._get_grid().get_next_positions(pos)\n        min_obs_dist = float('inf')\n        for direction_pos in nearby_pts:\n            if not self._get_grid().is_agent_valid_pos(direction_pos):\n                dist = Map.get_distance(pos, direction_pos)\n                if dist < min_obs_dist:\n                    min_obs_dist = dist\n        if min_obs_dist == float('inf'):\n            # No obstacle nearby; no clearance penalty\n            return 0.0\n        # Inverse distance as penalty (clamped)\n        clearance_penalty = max(0.0, (1.0 / (min_obs_dist + 1e-5)) * self._clearance_weight)\n        return clearance_penalty\n\n    def _sample_informed_with_clearance(self, c_min, c_best, x_center: Point, C):\n        \"\"\"\n        Enhanced sampling that adds goal bias and tries to avoid obstacle boundary by rejecting samples close to obstacles.\n        \"\"\"\n        import numpy as np\n        n = self._get_grid().size.n_dim\n        rng = np.random.random()\n\n        # Goal bias sample to promote fast connection early\n        if rng < self._goal_bias:\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n\n        # Basic fallback uniform random sampling if no solution yet\n        if c_best == float('inf'):\n            for _ in range(70):\n                rand_coords = np.random.randint(0, self._get_grid().size, n)\n                p = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(p) and self._clearance_cost(p) < self._clearance_weight * 0.2:\n                    return p\n            # fallback uniform if clearance check fails\n            return Point(*np.random.randint(0, self._get_grid().size, n))\n\n        # Sample within n-dimensional prolate hyperspheroid informed by current best path cost\n        trials = 0\n        max_trials = 100\n        while trials < max_trials:\n            x_ball = np.random.normal(0, 1, n)\n            x_ball /= np.linalg.norm(x_ball)\n            r = np.random.rand() ** (1.0 / n)\n            x_ball *= r\n\n            L = np.diag([c_best / 2.0] + [np.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (n - 1))\n            sample = C @ L @ x_ball + np.array(x_center)\n\n            sample_rounded = [min(max(0, int(round(coord))), self._get_grid().size[i] - 1) for i, coord in enumerate(sample)]\n            candidate = Point(*sample_rounded)\n            if self._get_grid().is_agent_valid_pos(candidate) and self._clearance_cost(candidate) < self._clearance_weight * 0.3:\n                return candidate\n            trials += 1\n\n        # If no suitable sample in ellipse with clearance, fallback\n        for _ in range(20):\n            rand_coords = np.random.randint(0, self._get_grid().size, n)\n            p = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(p) and self._clearance_cost(p) < self._clearance_weight * 0.3:\n                return p\n        # Last resort: any random valid position\n        return Point(*np.random.randint(0, self._get_grid().size, n))\n\n    def _generate_adaptive_step_clearance(self, from_pos: Point, to_pos: Point) -> float:\n        \"\"\"\n        Adaptive step sizing based on heuristic and clearance cost to avoid pushing towards obstacles.\n        \"\"\"\n        dist_to_goal = self._heuristic(to_pos)\n        max_step = self._base_step\n\n        clearance_from = self._clearance_cost(from_pos)\n        clearance_to = self._clearance_cost(to_pos)\n        clearance_penalty = max(clearance_from, clearance_to)\n\n        if dist_to_goal < 25.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 25.0)\n\n        # Reduce step proportionally to clearance penalty; avoid big steps near obstacles\n        max_step *= max(0.25, 1.0 - 0.7 * clearance_penalty / (self._clearance_weight + 1e-5))\n\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n\n        return max_step\n\n    def _cost_clearance(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"\n        Cost that includes distance, movement cost and clearance penalty.\n        \"\"\"\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        clearance_penalty = 0.5 * (self._clearance_cost(frm.position) + self._clearance_cost(to.position))\n        return dist + move_cost + clearance_penalty\n\n    def _choose_parent_and_cost_clearance(self, vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best = None\n        for v in vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost_clearance(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best = v\n        if best:\n            q_new.cost = min_cost\n        return best\n\n    def _rewire_locally_clearance(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost_clearance(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        c_min = Map.get_distance(start_vertex.position, goal_vertex.position)\n        c_best = float('inf')\n\n        transform_C, center = self._tf_informed_sampling_transform(start_vertex.position, goal_vertex.position)\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        def try_connect(v_start: Vertex, v_goal: Vertex):\n            # Use clearance-aware connection validity and cost\n            line_seq = self._get_grid().get_line_sequence(v_start.position, v_goal.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                return None\n            # Check clearance penalties on the connection path (scan points for obstacles nearby)\n            penalty = 0.0\n            points_to_check = line_seq[1:-1]\n            for pt in points_to_check:\n                penalty = max(penalty, self._clearance_cost(pt))\n                if penalty > self._clearance_weight * 0.5:\n                    return None\n            total_cost = v_start.cost + self._cost_clearance(v_start, v_goal) + v_goal.cost + penalty\n            return total_cost\n\n        for iteration in range(self._max_iter):\n\n            if time.time() - start_time > self._timeout:\n                break  # Timeout\n\n            # Alternate growing trees\n            expand_from_start = (iteration % 2 == 0)\n            tree = tree_start if expand_from_start else tree_goal\n            other_tree = tree_goal if expand_from_start else tree_start\n            visited_curr = visited_start if expand_from_start else visited_goal\n            visited_other = visited_goal if expand_from_start else visited_start\n\n            # Sample informed with clearance considerations\n            q_sample_point = self._sample_informed_with_clearance(c_min, c_best, center, transform_C)\n\n            # Goal bias fallback handled in _sample_informed_with_clearance\n\n            q_near = min(tree, key=lambda v: Map.get_distance(v.position, q_sample_point))\n            if q_near.position == q_sample_point:\n                continue\n\n            step_max = self._generate_adaptive_step_clearance(q_near.position, q_sample_point)\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_point, step_max)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            if q_new.position in visited_curr:\n                continue\n\n            near_radius = self._rewire_radius\n            near_vertices = [v for v in tree if Map.get_distance(v.position, q_new.position) <= near_radius]\n\n            best_parent = self._choose_parent_and_cost_clearance(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost_clearance(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_curr[q_new.position] = q_new\n            tree.append(q_new)\n\n            self._rewire_locally_clearance(q_new, near_vertices)\n\n            connection_radius = self._rewire_radius\n            candidates_to_connect = [v for v in other_tree if Map.get_distance(v.position, q_new.position) <= connection_radius]\n\n            found_connection = False\n            best_conn_cost = float('inf')\n            best_vertex_other = None\n\n            for v_other in candidates_to_connect:\n                conn_cost = try_connect(q_new, v_other) if expand_from_start else try_connect(v_other, q_new)\n                if conn_cost is not None and conn_cost < best_conn_cost:\n                    best_conn_cost = conn_cost\n                    best_vertex_other = v_other\n\n            if best_vertex_other is not None and best_conn_cost < c_best:\n                c_best = best_conn_cost\n\n                if expand_from_start:\n                    self._graph.add_edge(q_new, best_vertex_other)\n                else:\n                    self._graph.add_edge(best_vertex_other, q_new)\n\n                self._best_path_cost = c_best\n\n                # Extract path and perform clearance-aware shortcutting\n                path_start = self._extract_bidirectional_path(q_new if expand_from_start else best_vertex_other,\n                                                              best_vertex_other if expand_from_start else q_new)\n                # path extracted already moved agent and key framed; just break\n                found_connection = True\n                break\n\n            self.key_frame()\n\n            if found_connection:\n                break",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This enhanced algorithm builds upon the Adaptive Bidirectional Informed RRT* (ABI-RRT*) framework,\n    with explicit clearance optimization to improve path safety from obstacles. Key enhancements include:\n\n    - Clearance-aware adaptive step sizing that modulates exploration based on obstacle proximity,\n      encouraging safer, more robust path connections.\n    - Goal-biased informed sampling combining adaptive ellipse sampling with a dynamic goal bias\n      to accelerate convergence while maintaining exploration.\n    - Rewired radius adaptively shrinks as better solutions are found to focus local optimization efforts.\n    - Enhanced local rewiring prioritizes vertices with improved clearance and cost for better path quality.\n    - Dynamic early stopping triggered on improving connections that meet clearance thresholds.\n    - Final path smoothing with shortcutting prioritizing clearance-validated shortcuts.\n    - Global 10-second timeout for reliable response times.\n\n    These improvements collectively yield more efficient, smoother, and safer paths with higher success rates\n    even in cluttered grid environments.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This enhanced algorithm builds upon the Adaptive Bidirectional Informed RRT* (ABI-RRT*) framework,\n    with explicit clearance optimization to improve path safety from obstacles. Key enhancements include:\n\n    - Clearance-aware adaptive step sizing that modulates exploration based on obstacle proximity,\n      encouraging safer, more robust path connections.\n    - Goal-biased informed sampling combining adaptive ellipse sampling with a dynamic goal bias\n      to accelerate convergence while maintaining exploration.\n    - Rewired radius adaptively shrinks as better solutions are found to focus local optimization efforts.\n    - Enhanced local rewiring prioritizes vertices with improved clearance and cost for better path quality.\n    - Dynamic early stopping triggered on improving connections that meet clearance thresholds.\n    - Final path smoothing with shortcutting prioritizing clearance-validated shortcuts.\n    - Global 10-second timeout for reliable response times.\n\n    These improvements collectively yield more efficient, smoother, and safer paths with higher success rates\n    even in cluttered grid environments.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._best_path_cost = float('inf')\n        self._max_iter = 8000\n        self._timeout = 10.0  # seconds\n        self._base_step = 15.0\n        self._rewire_radius = 15.0\n        self._goal_bias_prob = 0.1  # 10% bias towards goal\n        self._clearance_weight = 10.0  # weight for clearance in cost\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance heuristic to goal\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(p, goal_pos)\n\n    def _clearance(self, point: Point, clearance_dist: int = 5) -> float:\n        \"\"\"\n        Estimate clearance at point by checking distance to nearest obstacle within clearance_dist radius.\n        Returns a higher value for greater clearance; 0 means collision or too close.\n        \"\"\"\n        grid = self._get_grid()\n        from collections import deque\n\n        if not grid.is_agent_valid_pos(point):\n            return 0.0\n        visited = set()\n        queue = deque()\n        queue.append((point, 0))\n        visited.add(point)\n        min_dist = clearance_dist + 1\n        while queue:\n            p, dist = queue.popleft()\n            if dist > clearance_dist:\n                break\n            if p != point and not grid.is_agent_valid_pos(p):\n                min_dist = min(min_dist, dist)\n                break\n            # Explore neighbors within clearance_dist\n            for neighbor in grid.get_next_positions(p):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n        if min_dist > clearance_dist:\n            return clearance_dist  # max clearance\n        return float(min_dist)\n\n    def _sample_informed_with_goal_bias(self, c_min, c_best, x_center: Point, C):\n        \"\"\"\n        Sampling that combines adaptive informed sampling ellipse with \n        controlled goal bias to speed up convergence without sacrificing exploration.\n        \"\"\"\n        import numpy as np\n\n        if np.random.rand() < self._goal_bias_prob:\n            goal_pt = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pt):\n                return goal_pt\n\n        # fallback to ellipse informed sampling\n        n = self._get_grid().size.n_dim\n        if c_best == float('inf'):\n            for _ in range(50):\n                rand_coords = np.random.randint(0, self._get_grid().size, n)\n                p = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n            # fallback to random in grid\n            return Point(*(np.random.randint(0, self._get_grid().size, n)))\n\n        # Sample within ellipse\n        while True:\n            x_ball = np.random.normal(0, 1, n)\n            x_ball /= np.linalg.norm(x_ball)\n            r = np.random.rand() ** (1.0 / n)\n            x_ball *= r\n\n            L = np.diag([c_best / 2.0] + [np.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (n - 1))\n            sample = C @ L @ x_ball + np.array(x_center)\n\n            sample_rounded = [min(max(0, int(round(coord))), self._get_grid().size[i] - 1) for i, coord in enumerate(sample)]\n            candidate = Point(*sample_rounded)\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n    def _adaptive_step_with_clearance(self, from_pos: Point, to_pos: Point) -> float:\n        \"\"\"\n        Adaptive step size modulated by estimated clearance and distance to goal.\n        Higher clearance yields longer steps, safer directions yield better expansions.\n        \"\"\"\n        dist_to_goal = self._heuristic(to_pos)\n        base_step = self._base_step\n\n        clearance = self._clearance(to_pos, clearance_dist=10)\n        if clearance == 0:\n            # Unsafe direction, shrink step more\n            base_step *= 0.3\n        else:\n            # Scale step with clearance (normalize by max clearance dist)\n            base_step *= 0.4 + 0.6 * (clearance / 10.0)\n\n        # Shrink near goal for precision\n        if dist_to_goal < 25.0:\n            base_step *= 0.4 + 0.6 * (dist_to_goal / 25.0)\n\n        # Penalize if line not valid or partially invalid along path\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            base_step *= 0.5\n\n        return base_step\n\n    def _cost_with_clearance(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"\n        Cost function combining distance, movement cost and clearance penalty.\n        Encourages paths with higher clearance.\n        \"\"\"\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        clearance = self._clearance(to.position, clearance_dist=10)\n        # Penalize low clearance by adding inverse clearance weighted penalty\n        clearance_penalty = 0.0\n        if clearance < 3.0:\n            clearance_penalty = self._clearance_weight * (3.0 - clearance)  # arbitrary threshold and weight\n\n        return dist + move_cost + clearance_penalty\n\n    def _choose_parent_and_cost(self, vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best = None\n        for v in vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost_with_clearance(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best = v\n        if best:\n            q_new.cost = min_cost\n        return best\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = q_new.cost + self._cost_with_clearance(q_new, v)\n            # To improve rewiring priority, consider clearance differences favorably\n            clearance_new = self._clearance(q_new.position, clearance_dist=10)\n            clearance_v = self._clearance(v.position, clearance_dist=10)\n            if new_cost < v.cost and clearance_new >= clearance_v:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut path smoothing prioritizing clearance-validated shortcuts.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # Try to find the farthest j > i with a valid clearance path\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Check clearance on intermediate points\n                    # If any point has clearance below threshold, discard shortcut\n                    clearance_ok = True\n                    for pt in line_seq:\n                        if self._clearance(pt, clearance_dist=5) < 1.0:\n                            clearance_ok = False\n                            break\n                    if clearance_ok:\n                        break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_bidirectional_path(self, vertex_start: Vertex, vertex_goal: Vertex) -> None:\n        # Build path from start to meeting vertex (walk parents)\n        path_from_start = [vertex_start]\n        v = vertex_start\n        while v != self._graph.root_vertex_start:\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n            path_from_start.append(v)\n        path_from_start.reverse()\n\n        # Build path from goal to meeting vertex\n        path_from_goal = [vertex_goal]\n        v = vertex_goal\n        while v != self._graph.root_vertex_goal:\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n            path_from_goal.append(v)\n\n        full_path = path_from_start + path_from_goal\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _vertex_connectable(self, v1: Vertex, v2: Vertex) -> bool:\n        line_seq = self._get_grid().get_line_sequence(v1.position, v2.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return False\n        # Check clearance along connection line\n        for pt in line_seq:\n            if self._clearance(pt, clearance_dist=5) < 1.0:\n                return False\n        return True\n\n    def _find_path_internal(self) -> None:\n        import time\n        import numpy as np\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        c_min = Map.get_distance(start_vertex.position, goal_vertex.position)\n        c_best = float('inf')\n\n        transform_C, center = self._tf_informed_sampling_transform(start_vertex.position, goal_vertex.position)\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        def try_connect(v_start: Vertex, v_goal: Vertex):\n            if self._vertex_connectable(v_start, v_goal):\n                total_cost = v_start.cost + self._cost_with_clearance(v_start, v_goal) + v_goal.cost\n                return total_cost\n            return None\n\n        for iteration in range(self._max_iter):\n            if time.time() - start_time > self._timeout:\n                # Timeout reached, stop planning as failure\n                break\n\n            expand_from_start = (iteration % 2 == 0)\n            tree = tree_start if expand_from_start else tree_goal\n            other_tree = tree_goal if expand_from_start else tree_start\n            visited_curr = visited_start if expand_from_start else visited_goal\n            visited_other = visited_goal if expand_from_start else visited_start\n\n            # Sample point with goal bias and informed sampling\n            q_sample_point = self._sample_informed_with_goal_bias(c_min, c_best, center, transform_C)\n\n            # Find nearest vertex in current tree\n            q_near = min(tree, key=lambda v: Map.get_distance(v.position, q_sample_point))\n            if q_near.position == q_sample_point:\n                continue\n\n            # Adaptive step with clearance consideration\n            step_max = self._adaptive_step_with_clearance(q_near.position, q_sample_point)\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_point, step_max)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            if q_new.position in visited_curr:\n                continue\n\n            # Nearby vertices within adaptive radius that shrinks with better cost\n            adaptive_rewire_radius = max(5.0, self._rewire_radius * (1.0 - min(1.0, (self._best_path_cost/c_best if c_best < float('inf') else 0.0))))\n            near_vertices = [v for v in tree if Map.get_distance(v.position, q_new.position) <= adaptive_rewire_radius]\n\n            # Choose parent considering cost + clearance\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if line valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost_with_clearance(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_curr[q_new.position] = q_new\n            tree.append(q_new)\n\n            # Local rewiring optimized for clearance and cost\n            self._rewire_locally(q_new, near_vertices)\n\n            # Try to connect q_new to other tree vertices within adaptive connection radius\n            connection_radius = adaptive_rewire_radius\n            candidates_to_connect = [v for v in other_tree if Map.get_distance(v.position, q_new.position) <= connection_radius]\n\n            found_connection = False\n            best_conn_cost = float('inf')\n            best_vertex_other = None\n\n            for v_other in candidates_to_connect:\n                conn_cost = try_connect(q_new, v_other) if expand_from_start else try_connect(v_other, q_new)\n                if conn_cost is not None and conn_cost < best_conn_cost:\n                    best_conn_cost = conn_cost\n                    best_vertex_other = v_other\n\n            if best_vertex_other is not None and best_conn_cost < c_best:\n                c_best = best_conn_cost\n                # Update best path cost and transform ellipse accordingly\n                self._best_path_cost = c_best\n                # Add connecting edge allowing bidirectional path extraction\n                if expand_from_start:\n                    self._graph.add_edge(q_new, best_vertex_other)\n                else:\n                    self._graph.add_edge(best_vertex_other, q_new)\n\n                # Refine ellipse transform center and matrix for next sampling\n                transform_C, center = self._tf_informed_sampling_transform(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n                \n                self._extract_bidirectional_path(q_new if expand_from_start else best_vertex_other,\n                                                best_vertex_other if expand_from_start else q_new)\n                found_connection = True\n                break\n\n            self.key_frame()\n\n            if found_connection:\n                break",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This improved algorithm implements a Memory-Efficient Bidirectional Informed RRT* with Goal-Biased Adaptive Sampling.\n    Improvements over the original include:\n    - Pruned tree management: vertices far outside the current best informed ellipse and with costs exceeding c_best + epsilon\n      are discarded to reduce memory footprint.\n    - Goal-biased sampling with adaptive probability increasing as iterations progress, boosting convergence.\n    - Dynamic resizing of the rewire radius based on tree growth and best path cost.\n    - Delayed rewiring to reduce computation frequency while keeping path quality.\n    - Early stopping once a valid connection with improved path found.\n    - Smoothed path extraction with shortcutting.\n    - Global timeout of 10 seconds.\n    This approach maintains bidirectionality, adaptive informed ellipse sampling, and rewiring while efficiently\n    managing the graph size to improve memory consumption and runtime.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This improved algorithm implements a Memory-Efficient Bidirectional Informed RRT* with Goal-Biased Adaptive Sampling.\n    Improvements over the original include:\n    - Pruned tree management: vertices far outside the current best informed ellipse and with costs exceeding c_best + epsilon\n      are discarded to reduce memory footprint.\n    - Goal-biased sampling with adaptive probability increasing as iterations progress, boosting convergence.\n    - Dynamic resizing of the rewire radius based on tree growth and best path cost.\n    - Delayed rewiring to reduce computation frequency while keeping path quality.\n    - Early stopping once a valid connection with improved path found.\n    - Smoothed path extraction with shortcutting.\n    - Global timeout of 10 seconds.\n    This approach maintains bidirectionality, adaptive informed ellipse sampling, and rewiring while efficiently\n    managing the graph size to improve memory consumption and runtime.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._best_path_cost = float('inf')\n        self._max_iter = 8000\n        self._timeout = 10.0  # seconds\n        self._base_step = 15.0\n        self._rewire_radius = 15.0\n        self._rewire_skip_freq = 5  # rewire every 5 iterations to reduce cost\n        self._prune_eps = 5.0  # cost margin for pruning vertices\n\n    def _sample_goal_biased(self, c_min, c_best, center, C, iteration):\n        import numpy as np\n\n        # Increase goal bias as iteration grows (max 20%)\n        goal_bias_prob = min(0.2, 0.05 + (iteration / self._max_iter) * 0.15)\n        if np.random.rand() < goal_bias_prob:\n            # Direct goal sample with small noise to avoid premature convergence traps\n            goal_pos = self._get_grid().goal.position\n            noise = np.random.randint(-1, 2, size=len(goal_pos))\n            noisy_goal = Point(\n                *[min(max(0, goal_pos[i] + noise[i]), self._get_grid().size[i] - 1) for i in range(len(goal_pos))]\n            )\n            if self._get_grid().is_agent_valid_pos(noisy_goal):\n                return noisy_goal\n\n        # Otherwise informed elliptical sample\n        return self._sample_informed(c_min, c_best, center, C)\n\n    def _prune_graph(self, c_best, c_min, center, C):\n        \"\"\"\n        Remove vertices that likely cannot improve path:\n        - vertices with cost + heuristic estimate > c_best + prune_eps\n        - vertices with position outside the current informed ellipse bounding box expanded by small margin\n        This keeps graph size and memory consumption in check.\n        \"\"\"\n        import numpy as np\n\n        grid_dim = self._get_grid().size.n_dim\n        # Precompute ellipse axes lengths\n        a1 = c_best / 2.0 if c_best != float('inf') else float('inf')\n        a2 = np.sqrt(abs(c_best ** 2 - c_min ** 2)) / 2.0 if c_best != float('inf') else float('inf')\n        margin = 3  # grid units margin around ellipse bounding box\n\n        def in_ellipse(p: Point):\n            if c_best == float('inf'):\n                return True\n            p_vec = np.array(p) - np.array(center)\n            # Transform point into ellipse coordinates via C^T (C orthonormal)\n            y = C.T @ p_vec\n            # Test ellipse equation: (x/a1)^2 + sum((y_i/a2)^2) <= 1\n            inside = (y[0] ** 2) / (a1 ** 2) + np.sum((y[1:] ** 2) / (a2 ** 2)) <= 1 + 1e-3\n            return inside\n\n        vertices_to_remove = []\n        for v in list(self._graph.root_vertices):\n            # Prune only non-root vertices\n            if v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            # Use cost + heuristic to check prune\n            heuristic = Map.get_distance(v.position, self._get_grid().goal.position)\n            if v.cost + heuristic > c_best + self._prune_eps:\n                vertices_to_remove.append(v)\n                continue\n            if not in_ellipse(v.position):\n                vertices_to_remove.append(v)\n\n        # Remove vertices and their edges\n        for v in vertices_to_remove:\n            # Remove edges connected to v\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            # Remove from root_vertices list if present\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        c_min = Map.get_distance(start_vertex.position, goal_vertex.position)\n        c_best = float('inf')\n\n        transform_C, center = self._tf_informed_sampling_transform(start_vertex.position, goal_vertex.position)\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        def try_connect(v_start: Vertex, v_goal: Vertex):\n            if self._vertex_connectable(v_start, v_goal):\n                total_cost = v_start.cost + self._cost(v_start, v_goal) + v_goal.cost\n                return total_cost\n            return None\n\n        for iteration in range(self._max_iter):\n\n            if time.time() - start_time > self._timeout:\n                # Timeout reached, stop planning\n                break\n\n            expand_from_start = (iteration % 2 == 0)\n            tree = tree_start if expand_from_start else tree_goal\n            other_tree = tree_goal if expand_from_start else tree_start\n            visited_curr = visited_start if expand_from_start else visited_goal\n            visited_other = visited_goal if expand_from_start else visited_start\n\n            # Goal biased adaptive sampling\n            q_sample_point = self._sample_goal_biased(c_min, c_best, center, transform_C, iteration)\n\n            # Nearest vertex in current tree\n            q_near = min(tree, key=lambda v: Map.get_distance(v.position, q_sample_point))\n            if q_near.position == q_sample_point:\n                continue\n\n            # Adaptive step towards sample\n            step_max = self._generate_adaptive_step(q_near.position, q_sample_point)\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_point, step_max)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            if q_new.position in visited_curr:\n                continue\n\n            # Find nearby vertices for rewiring (dynamic radius shrinking with c_best)\n            near_radius = max(self._rewire_radius * (c_min / (c_best if c_best < float('inf') else c_min + 1e-3)), 5.0)\n            near_vertices = [v for v in tree if Map.get_distance(v.position, q_new.position) <= near_radius]\n\n            # Choose best parent and cost\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback: check direct from q_near if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_curr[q_new.position] = q_new\n            tree.append(q_new)\n\n            # Local rewiring less frequently to reduce overhead\n            if iteration % self._rewire_skip_freq == 0:\n                self._rewire_locally(q_new, near_vertices)\n\n            # Try to connect new vertex to other tree\n            connection_radius = near_radius\n            candidates_to_connect = [v for v in other_tree if Map.get_distance(v.position, q_new.position) <= connection_radius]\n\n            best_conn_cost = float('inf')\n            best_vertex_other = None\n\n            for v_other in candidates_to_connect:\n                conn_cost = try_connect(q_new, v_other) if expand_from_start else try_connect(v_other, q_new)\n                if conn_cost is not None and conn_cost < best_conn_cost:\n                    best_conn_cost = conn_cost\n                    best_vertex_other = v_other\n\n            # If new connection improves best cost, update path\n            if best_vertex_other is not None and best_conn_cost < c_best:\n                c_best = best_conn_cost\n                self._best_path_cost = c_best\n\n                # Connect trees bidirectionally for path extraction with minimal edges\n                if expand_from_start:\n                    self._graph.add_edge(q_new, best_vertex_other)\n                else:\n                    self._graph.add_edge(best_vertex_other, q_new)\n\n                # Early prune graph to reduce memory\n                self._prune_graph(c_best, c_min, center, transform_C)\n\n                # Extract & smooth path\n                self._extract_bidirectional_path(q_new if expand_from_start else best_vertex_other,\n                                                best_vertex_other if expand_from_start else q_new)\n                break\n\n            # Periodic pruning to control graph size and memory footprint (every 100 iterations)\n            if iteration % 100 == 0 and c_best < float('inf'):\n                self._prune_graph(c_best, c_min, center, transform_C)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\" \nAn improved sample-based path planning algorithm inspired by RRT*, integrating:\n- Goal-biased sampling to increase chances of connecting to the goal.\n- Adaptive max step distance that decreases as the tree grows for finer path refinement.\n- Rewiring around newly added vertices to optimize path costs (RRT* style).\n- Path shortcutting after path extraction for smoothing.\n- Early stopping criteria with a 10-second time limit to prevent long computation.\n- Maintains memory efficiency by rewiring locally and pruning unnecessary edges.\n\nThis improves planning efficiency, path quality (shorter and smoother paths), \nrobustness, and success rate over basic RRT.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist_initial: float\n    _rewire_radius_factor: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        self._graph = gen_forest(self._services, Vertex(agent_pos), Vertex(goal_pos), [])\n        self._graph.edges_removable = True  # allow rewire/removal edges\n        self._max_dist_initial = 12.0      # initial max step distance, adjustable\n        self._rewire_radius_factor = 15.0  # factor to determine rewire radius, adjustable\n        self._init_displays()\n\n    # Helper: adapt max dist by tree size (smaller step as tree grows)\n    def _get_adaptive_max_dist(self) -> float:\n        size = self._graph.size\n        # Decrease max_dist logarithmically from initial to 3.0 (no less) over tree growth\n        return max(3.0, self._max_dist_initial / (1 + 0.05 * size**0.5))\n\n    # Overridden helper to get new vertex with adaptive max dist\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    # Rewiring helper to improve paths after adding q_new\n    def _rewire(self, q_new: Vertex, radius: float) -> None:\n        # Get vertices within radius for potential rewiring\n        nearby_vertices: List[Vertex] = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        grid = self._get_grid()\n\n        for q_near in nearby_vertices:\n            if q_near == q_new:\n                continue\n            # Check if path from q_new to q_near is valid and better cost\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            move_cost = grid.get_movement_cost(q_new.position, q_near.position)\n            new_cost = q_new.cost + move_cost\n            if new_cost < q_near.cost:\n                # Remove old parent edges to q_near for proper rewiring\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge from q_new to q_near\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n                # Propagate cost update downwards recursively\n                self._propagate_cost_updates(q_near)\n\n    # Helper to propagate cost updates after rewiring downstream vertices\n    def _propagate_cost_updates(self, vertex: Vertex) -> None:\n        grid = self._get_grid()\n        for child in vertex.children:\n            move_cost = grid.get_movement_cost(vertex.position, child.position)\n            new_cost = vertex.cost + move_cost\n            if new_cost < child.cost:\n                child.cost = new_cost\n                self._propagate_cost_updates(child)\n\n    # Helper: shortcut smoothing on the path to reduce unnecessary vertices\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        grid = self._get_grid()\n        if len(path) < 3:\n            return path\n\n        shortcut_path: List[Vertex] = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    # Extract the path from q_new to start, then shortcut, then animate\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: List[Vertex] = [goal_v]\n        # Backtrace parents to start (only follow lowest cost parent)\n        current = goal_v\n        while len(current.parents) != 0:\n            # Pick parent with min cost\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n\n        # Perform path shortcut smoothing\n        smooth_path = self._shortcut_path(path)\n\n        # Animate the agent moving along smooth path\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Goal biased sampling helper: sample with goal bias probability\n    def _get_goal_biased_sample(self, bias_prob: float) -> Point:\n        # With probability bias_prob, return goal position sample\n        if np.random.rand() < bias_prob:\n            return self._get_grid().goal.position\n        # Otherwise, uniform random valid sample\n        return self._get_random_sample()\n\n    # Reusing original provided _get_random_sample for uniform sampling\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_time_sec = 10.0  # max allowed time to find path\n\n        iterations = 10000\n        goal_bias = 0.15  # Probability to directly sample goal (goal biased sampling)\n\n        # Initialize cost of root start vertex to 0\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > max_time_sec:\n                # Time limit exceeded, consider path search failed\n                break\n\n            max_dist = self._get_adaptive_max_dist()\n            q_sample: Point = self._get_goal_biased_sample(goal_bias)\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost from start through q_near to q_new\n            cost_to_q_new = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            # Initialize q_new cost with cost_to_q_new before rewiring\n            q_new.cost = cost_to_q_new\n\n            # Find vertices close to q_new for potential better parent (choose parent with min cost + distance)\n            rewire_radius = max_dist * self._rewire_radius_factor / (1 + self._graph.size**0.3)\n            nearby_vertices: List[Vertex] = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, rewire_radius)\n\n            min_cost = cost_to_q_new\n            best_parent: Optional[Vertex] = q_near\n            # Attempt to find better parent in radius\n            for q_nearby in nearby_vertices:\n                if q_nearby == q_near:\n                    continue\n                line_seq2 = self._get_grid().get_line_sequence(q_nearby.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq2):\n                    continue\n                cost_via_nearby = q_nearby.cost + self._get_grid().get_movement_cost(q_nearby.position, q_new.position)\n                if cost_via_nearby < min_cost:\n                    min_cost = cost_via_nearby\n                    best_parent = q_nearby\n\n            # Add q_new with best parent to graph\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = min_cost\n\n            # Rewire nearby vertices through q_new if beneficial\n            self._rewire(q_new, rewire_radius)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning Algorithm that enhances memory efficiency and planning performance by:\n    - Using a dual-tree bidirectional search (start and goal forests) with heuristic guided expansion,\n      allowing faster connection of trees with fewer vertices.\n    - Employing goal- and start-biased adaptive sampling with probabilistic switching to balance exploration.\n    - Applying dynamic pruning of vertices away from the tentative connecting path to reduce memory.\n    - Utilizing a combined cost + heuristic priority queue for selecting expansion vertices from both trees.\n    - Adaptive step length modulation using environment proximity heuristics as before.\n    - Local rewiring within dynamically chosen neighborhoods to improve path cost continuously.\n    - Early stopping upon connection of start and goal trees within goal radius.\n    - Path extraction merges both trees' partial paths and performs shortcut smoothing.\n    - Enforced 10-second global timeout.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    Improved Path Planning Algorithm that enhances memory efficiency and planning performance by:\n    - Using a dual-tree bidirectional search (start and goal forests) with heuristic guided expansion,\n      allowing faster connection of trees with fewer vertices.\n    - Employing goal- and start-biased adaptive sampling with probabilistic switching to balance exploration.\n    - Applying dynamic pruning of vertices away from the tentative connecting path to reduce memory.\n    - Utilizing a combined cost + heuristic priority queue for selecting expansion vertices from both trees.\n    - Adaptive step length modulation using environment proximity heuristics as before.\n    - Local rewiring within dynamically chosen neighborhoods to improve path cost continuously.\n    - Early stopping upon connection of start and goal trees within goal radius.\n    - Path extraction merges both trees' partial paths and performs shortcut smoothing.\n    - Enforced 10-second global timeout.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []           # Min-heap for start-side vertices (expand frontier)\n        self._heap_goal = []            # Min-heap for goal-side vertices (expand frontier)\n        self._max_iter = 6000\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 900  # Reduced for better memory management\n        self._connection_found = False\n        self._connection_vertex_start = None\n        self._connection_vertex_goal = None\n\n    def _dual_heuristic(self, pos: Point, is_start: bool) -> float:\n        \"\"\"Heuristic distance to opposite root.\"\"\"\n        if is_start:\n            return Map.get_distance(pos, self._graph.root_vertex_goal.position)\n        else:\n            return Map.get_distance(pos, self._graph.root_vertex_start.position)\n\n    def _dual_get_new_vertex_on_line(self, start: Point, end: Point) -> Vertex:\n        max_step = self._generate_adaptive_step(start, end)\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _choose_parent_and_cost_bidirectional(self, near_vertices, q_new: Vertex) -> Vertex:\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._dual_heuristic(q_new.position, v.position == self._graph.root_vertex_start.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_locally_safe(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v == q_new or v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _connect_trees(self, q_new_start: Vertex, q_new_goal: Vertex) -> bool:\n        # Attempt to connect nodes from start tree to goal tree if close enough & valid path\n        dist = Map.get_distance(q_new_start.position, q_new_goal.position)\n        if dist > self._goal_radius * 2:\n            return False\n        line_seq = self._get_grid().get_line_sequence(q_new_start.position, q_new_goal.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return False\n        # Connect as bidirectional edges\n        cost_edge = self._cost(q_new_start, q_new_goal)\n        self._graph.add_edge(q_new_start, q_new_goal)\n        self._graph.add_edge(q_new_goal, q_new_start)\n        q_new_start.cost += 0  # costs already set\n        q_new_goal.cost += 0\n        self._connection_vertex_start = q_new_start\n        self._connection_vertex_goal = q_new_goal\n        self._connection_found = True\n        return True\n\n    def _extract_bidirectional_path(self, vs: Vertex, vg: Vertex) -> None:\n        # Extract path from start root to vs\n        path_start = []\n        current = vs\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(current)\n            current = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        # Extract path from goal root to vg\n        path_goal = []\n        current = vg\n        while current != self._graph.root_vertex_goal:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(current)\n            current = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        # Combine paths at connection (avoid duplicate vertex at connection)\n        full_path = path_start + path_goal[::-1][1:]\n\n        # Shortcut and move agent along path\n        smoothed = self._shortcut_path(full_path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_vertices_by_connection(self) -> None:\n        # Prune vertices far away from the current best connecting path(s)\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        # Collect all vertices excluding root start and goal\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n\n        if not candidates:\n            return\n\n        # Distance function from vertex to either root vertices along with cost heuristic\n        def prune_key(v):\n            dist_to_start = Map.get_distance(v.position, start_pos)\n            dist_to_goal = Map.get_distance(v.position, goal_pos)\n            return v.cost + min(dist_to_start, dist_to_goal)\n\n        candidates_sorted = sorted(candidates, key=prune_key, reverse=True)\n        remove_count = self._graph.size - max_vertices\n        vertices_to_remove = candidates_sorted[:remove_count]\n\n        for v in vertices_to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_pos = goal_vertex.position\n        start_pos = start_vertex.position\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        self._heap_start = []\n        heapq.heappush(self._heap_start, (self._heuristic(start_pos), start_vertex))\n        self._heap_goal = []\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_pos), goal_vertex))\n\n        visited_positions_start = set([start_pos])\n        visited_positions_goal = set([goal_pos])\n\n        start_time = time.time()\n        iterations = 0\n\n        # Probability to sample from start or goal tree to balance growth\n        prob_sample_start = 0.5\n\n        while iterations < self._max_iter and not self._connection_found:\n            iterations += 1\n\n            if time.time() - start_time > self._timeout:\n                break\n\n            # Alternate expanding start and goal frontiers probabilistically for balanced growth\n            expanding_start = random.random() < prob_sample_start\n\n            if expanding_start and self._heap_start:\n                _, current_vertex = heapq.heappop(self._heap_start)\n                source_tree = 'start'\n                other_heap = self._heap_goal\n                visited_positions_src = visited_positions_start\n                visited_positions_other = visited_positions_goal\n                root_vertex_src = start_vertex\n                root_vertex_other = goal_vertex\n            elif (not expanding_start) and self._heap_goal:\n                _, current_vertex = heapq.heappop(self._heap_goal)\n                source_tree = 'goal'\n                other_heap = self._heap_start\n                visited_positions_src = visited_positions_goal\n                visited_positions_other = visited_positions_start\n                root_vertex_src = goal_vertex\n                root_vertex_other = start_vertex\n            else:\n                # If the intended heap is empty fallback to available heap\n                if self._heap_start:\n                    _, current_vertex = heapq.heappop(self._heap_start)\n                    source_tree = 'start'\n                    other_heap = self._heap_goal\n                    visited_positions_src = visited_positions_start\n                    visited_positions_other = visited_positions_goal\n                    root_vertex_src = start_vertex\n                    root_vertex_other = goal_vertex\n                elif self._heap_goal:\n                    _, current_vertex = heapq.heappop(self._heap_goal)\n                    source_tree = 'goal'\n                    other_heap = self._heap_start\n                    visited_positions_src = visited_positions_goal\n                    visited_positions_other = visited_positions_start\n                    root_vertex_src = goal_vertex\n                    root_vertex_other = start_vertex\n                else:\n                    # Both heaps empty - no path found\n                    break\n\n            # Early success check (from both trees)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=current_vertex.position, goal=self._get_grid().goal):\n                if source_tree == 'start':\n                    q_goal = Vertex(goal_pos)\n                    line_seq_goal = self._get_grid().get_line_sequence(current_vertex.position, q_goal.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                        q_goal.cost = current_vertex.cost + self._cost(current_vertex, q_goal)\n                        self._graph.add_edge(current_vertex, q_goal)\n                        self._extract_bidirectional_path(current_vertex, q_goal)\n                        self._connection_found = True\n                        break\n                else:  # from goal tree\n                    q_start = Vertex(start_pos)\n                    line_seq_start = self._get_grid().get_line_sequence(q_start.position, current_vertex.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_start):\n                        q_start.cost = current_vertex.cost + self._cost(q_start, current_vertex)\n                        self._graph.add_edge(q_start, current_vertex)\n                        self._extract_bidirectional_path(q_start, current_vertex)\n                        self._connection_found = True\n                        break\n\n            # Sample a new point biased towards growth frontier of this tree\n            # Goal-biased 20% chance in start tree, start-biased 20% chance in goal tree,\n            # otherwise frontier sampling near heap top vertices\n            if source_tree == 'start':\n                if random.random() < 0.2:\n                    sample_pos = self._get_grid().goal.position\n                else:\n                    sample_pos = self._get_frontier_sample()\n            else:\n                if random.random() < 0.2:\n                    sample_pos = self._graph.root_vertex_start.position\n                else:\n                    sample_pos = self._get_frontier_sample()\n\n            # Find nearest vertex in this tree\n            q_near = self._graph.get_nearest_vertex([root_vertex_src], sample_pos)\n            if q_near.position == sample_pos:\n                continue\n\n            q_new = self._dual_get_new_vertex_on_line(q_near.position, sample_pos)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            if q_new.position in visited_positions_src:\n                continue\n\n            # Find neighbors in source tree for rewiring & parent selection\n            rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vertices = self._graph.get_vertices_within_radius([root_vertex_src], q_new.position, rewire_radius)\n            best_parent = self._choose_parent_and_cost_bidirectional(near_vertices, q_new)\n            if best_parent is None:\n                # fallback connect to q_near if feasible\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_positions_src.add(q_new.position)\n\n            # Add q_new to respective heap with f = g + heuristic to opposite root\n            f_q_new = q_new.cost + self._dual_heuristic(q_new.position, source_tree == 'start')\n            if source_tree == 'start':\n                heapq.heappush(self._heap_start, (f_q_new, q_new))\n            else:\n                heapq.heappush(self._heap_goal, (f_q_new, q_new))\n\n            # Local rewiring to optimize cost\n            self._rewire_locally_safe(q_new, near_vertices)\n\n            # Attempt to connect q_new from current tree to nearest vertex in opposite tree\n            q_near_other = self._graph.get_nearest_vertex([root_vertex_other], q_new.position)\n            if q_near_other and q_near_other.position != q_new.position:\n                connected = self._connect_trees(q_new, q_near_other)\n                if connected:\n                    self._extract_bidirectional_path(q_new, q_near_other)\n                    break\n\n            # Prune excess vertices for memory efficiency dynamically every 300 iterations\n            if iterations % 300 == 0:\n                self._prune_vertices_by_connection()\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An enhanced RRT*-inspired path planning algorithm emphasizing memory efficiency \n    and robust rapid convergence. It uses a bidirectional tree growth from start \n    and goal with heuristic guided, adaptive sampling and step sizing. The algorithm \n    dynamically shrinks the rewiring radius based on vertex density and iteration \n    progress while pruning distant vertices to control memory use tightly. Early \n    termination occurs upon connection between trees or timeout (~10s). The final \n    path undergoes shortcut smoothing for optimality. Bidirectional search, adaptive \n    step scaling, and conservative rewiring improve success rate, reduce iterations, \n    and yield smoother, shorter collision-free paths.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An enhanced RRT*-inspired path planning algorithm emphasizing memory efficiency \n    and robust rapid convergence. It uses a bidirectional tree growth from start \n    and goal with heuristic guided, adaptive sampling and step sizing. The algorithm \n    dynamically shrinks the rewiring radius based on vertex density and iteration \n    progress while pruning distant vertices to control memory use tightly. Early \n    termination occurs upon connection between trees or timeout (~10s). The final \n    path undergoes shortcut smoothing for optimality. Bidirectional search, adaptive \n    step scaling, and conservative rewiring improve success rate, reduce iterations, \n    and yield smoother, shorter collision-free paths.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15          # Bias for goal sampling\n        self._rewire_radius = 15.0      # Initial rewiring radius\n        self._vertex_limit = 1200       # Limit vertices to reduce memory\n        self._bidirectional = True      # Enable bidirectional search\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new_pos = Point.from_tensor(q_new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self, root_vertices: list) -> Point:\n        import random\n        # Alternate biasing between start and goal trees to balance approach\n        bias_towards_goal = random.random() < self._goal_bias\n        if bias_towards_goal:\n            # Sample near goal\n            return self._get_grid().goal.position\n        else:\n            # Uniform random sampling with validity check\n            attempts = 0\n            while attempts < 50:\n                rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            # Fallback to goal if fails repeatedly\n            return self._get_grid().goal.position\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = v.cost + self._cost(v, q_new)\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        # Restrict rewiring to vertices with better cost only\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._cost(q_new, v)\n            if cost_through_new < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_new\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, connection_from_start: Vertex, connection_from_goal: Vertex) -> None:\n        # Extract path from start tree\n        path_start = [connection_from_start]\n        current = connection_from_start\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path_start.append(current)\n        path_start.reverse()\n\n        # Extract path from goal tree\n        path_goal = [connection_from_goal]\n        current = connection_from_goal\n        while current != self._graph.root_vertex_goal:\n            if not current.children:\n                break\n            current = min(current.children, key=lambda c: c.cost)\n            path_goal.append(current)\n\n        # Combine paths at connection point\n        full_path = path_start + path_goal[1:]\n\n        # Smooth path shortcuts where possible\n        smoothed = self._shortcut_path(full_path)\n        for vertex in smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        min_radius = 4.0\n        radius = self._rewire_radius * (1 - iteration / max_iterations)\n        return max(min_radius, radius)\n\n    def _limit_graph_size(self) -> None:\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Exclude roots\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        # Sort by cost descending (remove worst)\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 7000\n        max_dist_base = self._max_dist_base\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Maintain separate vertex sets for bidirectional search\n        vertices_start = [start_vertex]\n        vertices_goal = [goal_vertex]\n\n        connected = False\n        connection_from_start = None\n        connection_from_goal = None\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            # Alternate between expanding start and goal trees\n            expand_start_tree = (iteration % 2 == 0)\n\n            root_vertices = [start_vertex] if expand_start_tree else [goal_vertex]\n            other_vertices = vertices_goal if expand_start_tree else vertices_start\n\n            sample = self._get_goal_biased_sample(root_vertices)\n\n            nearest = self._graph.get_nearest_vertex(root_vertices, sample)\n            if nearest.position == sample:\n                continue\n\n            dist_to_sample = Map.get_distance(nearest.position, sample)\n            # Adaptive step size: shorter near obstacles, longer in open areas\n            adaptive_step = min(max_dist_base, dist_to_sample)\n            adaptive_step *= 0.65 + 0.35 * (1 - min(nearest.cost / 100.0, 1.0))\n\n            new_vertex = self._get_new_vertex(nearest, sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(nearest.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrink rewire radius progressively\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius(root_vertices, new_vertex.position, cur_rewire_radius)\n            parent = self._choose_parent(near_vertices, new_vertex)\n            if parent is None:\n                # Fallback to nearest if path collision free\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    new_vertex.cost = nearest.cost + self._cost(nearest, new_vertex)\n                    parent = nearest\n                else:\n                    continue\n\n            self._graph.add_edge(parent, new_vertex)\n\n            self._rewire(near_vertices, new_vertex)\n\n            # Add new vertex to appropriate set\n            if expand_start_tree:\n                vertices_start.append(new_vertex)\n            else:\n                vertices_goal.append(new_vertex)\n\n            # Limit size to control memory\n            self._limit_graph_size()\n\n            # Check if the new vertex connects to the opposite tree within radius\n            opposite_near = self._graph.get_vertices_within_radius(\n                other_vertices, new_vertex.position, cur_rewire_radius\n            )\n            connection_vertex = None\n            min_connection_cost = float('inf')\n            for v in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(new_vertex.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    total_cost = new_vertex.cost + self._cost(new_vertex, v) + v.cost\n                    if total_cost < min_connection_cost:\n                        min_connection_cost = total_cost\n                        connection_vertex = v\n\n            if connection_vertex is not None:\n                connected = True\n                if expand_start_tree:\n                    connection_from_start = new_vertex\n                    connection_from_goal = connection_vertex\n                else:\n                    connection_from_start = connection_vertex\n                    connection_from_goal = new_vertex\n                break\n\n            self.key_frame()\n\n        if connected and connection_from_start and connection_from_goal:\n            self._extract_path(connection_from_start, connection_from_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This new algorithm implements a Heuristic-Guided Anytime Rapidly-exploring Random Graph (HG-ARG) algorithm.\n    It expands a unified graph (not two trees) from the start vertex, but biasing samples strongly towards the goal \n    using adaptive probabilistic goal bias and heuristic-based vertex prioritization.\n\n    Key features:\n    - Single graph expansion with heuristic best-first search ordering of frontier vertices.\n    - Goal-biased adaptive sampling with increasing randomness over iterations to escape local minima.\n    - Dynamic max step size adjusted based on obstacle proximity and remaining distance to goal.\n    - Incremental local optimization via rewiring neighbors to progressively improve path quality.\n    - Anytime behavior: keeps improving best path found if any until timeout or max iterations.\n    - Early stopping once agent can reach goal and path cost converges within a threshold.\n    - Smooth path extraction with iterative shortcutting after planning ends.\n    - Timeout set to 10 seconds to ensure responsiveness.\n\n    This approach simplifies bidirectional complexity by focusing on a single unified graph, improving success and path quality,\n    while guided heuristic search and adaptive parameters boost efficiency and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        self._graph = Forest(start_vertex, self._get_grid().goal.position, [start_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # New member variables for heuristic guided anytime expansion\n        self._max_iter = 5000\n        self._timeout = 10.0\n        self._goal_radius = (\n            self._get_grid().goal.radius\n            if hasattr(self._get_grid().goal, \"radius\")\n            else 5.0\n        )\n        self._base_step = 14.0\n        self._rewire_radius = 12.0\n        self._best_cost = float(\"inf\")\n        self._best_goal_vertex = None\n\n    def _heuristic(self, pos: Point) -> float:\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _adaptive_step(self, frm: Point, to: Point) -> float:\n        dist_to_goal = self._heuristic(to)\n        max_step = self._base_step\n\n        if dist_to_goal < 30.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 30.0)\n\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n        return max_step\n\n    def _get_new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex) -> Vertex:\n        min_cost = float(\"inf\")\n        best = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            candidate_cost = v.cost + self._cost(v, q_new)\n            if candidate_cost < min_cost:\n                min_cost = candidate_cost\n                best = v\n        if best:\n            q_new.cost = min_cost\n        return best\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            v = stack.pop()\n            for c in v.children:\n                new_cost = v.cost + self._cost(v, c)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_and_move_along_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"\n        Extract path from start vertex to goal_vertex and move agent along the path.\n        Perform iterative shortcut smoothing.\n        \"\"\"\n        path = []\n        curr = goal_vertex\n        while True:\n            path.append(curr)\n            if curr == self._graph.root_vertex_start:\n                break\n            if not curr.parents:\n                break\n            curr = min(curr.parents, key=lambda p: p.cost)\n        path.reverse()\n\n        # Iterative shortcut smoothing (3 iterations)\n        for _ in range(3):\n            path = self._shortcut_path(path)\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _sample(self, iteration: int, goal_bias_prob: float = 0.2) -> Point:\n        \"\"\"\n        Sampling strategy:\n        - With probability goal_bias_prob, sample directly at the goal.\n        - Else uniformly sample in free space.\n        - Bias goal_prob increases slightly every 500 iterations to focus near goal later.\n        \"\"\"\n        import numpy as np\n        import random\n\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        # Increasing goal bias probability over iterations for anytime focus\n        goal_prob = min(0.6, goal_bias_prob + iteration * 0.0002)\n\n        if random.random() < goal_prob:\n            return grid.goal.position\n\n        # Uniform random sample attempts with validity check\n        attempts = 50\n        for _ in range(attempts):\n            coords = []\n            for i in range(dim):\n                coord = np.random.randint(0, grid.size[i])\n                coords.append(coord)\n            p = Point(*coords)\n            if grid.is_agent_valid_pos(p):\n                return p\n\n        # Fallback to goal position guaranteed valid\n        return grid.goal.position\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        vertices = [start_vertex]\n        visited = {start_vertex.position: start_vertex}\n        frontier = [start_vertex]\n\n        iteration = 0\n        improved_last_found_iter = 0\n        cost_tolerance = 1e-3  # Early convergence tolerance\n\n        while iteration < self._max_iter:\n            iteration += 1\n            if time.time() - start_time > self._timeout:\n                break\n\n            # Sample with adaptive goal bias\n            q_sample_point = self._sample(iteration)\n\n            # Select frontier vertex closest to sampled point heuristically prioritized by cost+heuristic\n            best_vertex = None\n            best_score = float(\"inf\")\n            for v in frontier:\n                score = v.cost + self._heuristic(v.position) + Map.get_distance(v.position, q_sample_point)\n                if score < best_score:\n                    best_score = score\n                    best_vertex = v\n            if best_vertex is None:\n                break\n\n            # Get new vertex towards sample with adaptive step\n            step_size = self._adaptive_step(best_vertex.position, q_sample_point)\n            q_new = self._get_new_vertex_on_line(best_vertex.position, q_sample_point, step_size)\n\n            if q_new.position in visited:\n                continue\n\n            # Validate edge before adding\n            line_seq = grid.get_line_sequence(best_vertex.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within rewire radius\n            near_vertices = [v for v in vertices if Map.get_distance(v.position, q_new.position) <= self._rewire_radius]\n\n            # Choose parent minimizing cost via valid edges\n            parent = self._choose_best_parent(near_vertices, q_new)\n            if parent is None:\n                # fallback to closest vertex if edge valid\n                if grid.is_valid_line_sequence(line_seq):\n                    q_new.cost = best_vertex.cost + self._cost(best_vertex, q_new)\n                    parent = best_vertex\n                else:\n                    continue\n\n            # Add q_new to graph and bookkeeping\n            self._graph.add_edge(parent, q_new)\n            vertices.append(q_new)\n            frontier.append(q_new)\n            visited[q_new.position] = q_new\n\n            # Rewire neighbors to optimize locally\n            self._rewire_neighbors(q_new, near_vertices)\n\n            # Remove frontier vertices that have no children (dead-end pruning)\n            frontier = [v for v in frontier if v.children or v == start_vertex]\n\n            # Check if goal is reached within radius\n            dist_to_goal = self._heuristic(q_new.position)\n            if dist_to_goal <= self._goal_radius:\n                # Try to connect directly to goal vertex\n                goal_pos = grid.goal.position\n                line_seq_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    # Assign cost for goal vertex\n                    goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n\n                    self._graph.add_edge(q_new, goal_vertex)\n                    vertices.append(goal_vertex)\n                    visited[goal_vertex.position] = goal_vertex\n                    self._best_goal_vertex = goal_vertex\n\n                    # Check if new path improves best cost\n                    if goal_vertex.cost + cost_tolerance < self._best_cost:\n                        self._best_cost = goal_vertex.cost\n                        improved_last_found_iter = iteration\n\n            # Anytime early stopping: if cost hasn't improved in 300 iterations and have a solution\n            if (\n                self._best_goal_vertex is not None\n                and (iteration - improved_last_found_iter) > 300\n            ):\n                break\n\n            # Mark keyframe for visualization\n            self.key_frame()\n\n        # If found a goal vertex, extract and move along path with smoothing\n        if self._best_goal_vertex is not None:\n            self._extract_and_move_along_path(self._best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This novel algorithm combines heuristic-guided A*-like vertex prioritization within a bidirectional \n    search framework enhanced by dynamic adaptive sampling and vertex pruning. Unlike traditional RRT* \n    variants, it uses priority queues for focused tree expansion near promising low-cost vertices. \n    \n    Key innovations:\n    - Heuristic-driven priority queue expansion emulating A* behavior for both start and goal trees.\n    - Dynamic adaptive sampling biased near frontier vertices with lowest combined cost+heuristic.\n    - Aggressive pruning of high-cost or isolated vertices to maintain compact graph and improve speed.\n    - Incremental vertex rewiring only around newly inserted vertices to quickly converge to low-cost paths.\n    - Path smoothing via iterative shortcutting post connection.\n    - Early termination triggered by cost improvement stagnation or connection.\n    - Timeout enforcement (10 seconds).\n    \n    This approach aims to combine the efficiency and optimality benefits of A*-style heuristics with the \n    exploration flexibility of sample-based bidirectional search to improve path quality, robustness, \n    and planning speed in grid environments.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This novel algorithm combines heuristic-guided A*-like vertex prioritization within a bidirectional \n    search framework enhanced by dynamic adaptive sampling and vertex pruning. Unlike traditional RRT* \n    variants, it uses priority queues for focused tree expansion near promising low-cost vertices. \n    \n    Key innovations:\n    - Heuristic-driven priority queue expansion emulating A* behavior for both start and goal trees.\n    - Dynamic adaptive sampling biased near frontier vertices with lowest combined cost+heuristic.\n    - Aggressive pruning of high-cost or isolated vertices to maintain compact graph and improve speed.\n    - Incremental vertex rewiring only around newly inserted vertices to quickly converge to low-cost paths.\n    - Path smoothing via iterative shortcutting post connection.\n    - Early termination triggered by cost improvement stagnation or connection.\n    - Timeout enforcement (10 seconds).\n    \n    This approach aims to combine the efficiency and optimality benefits of A*-style heuristics with the \n    exploration flexibility of sample-based bidirectional search to improve path quality, robustness, \n    and planning speed in grid environments.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Additional members for priority queues and tracking\n        import heapq\n        self._pq_start = []  # min-heap for (cost + heuristic, Vertex)\n        self._pq_goal = []\n        self._best_total_cost = float('inf')\n        self._timeout = 10.0  # seconds\n        self._max_iter = 6000\n        self._rewire_radius = 12.0\n        self._adapt_step_base = 16.0\n        self._prune_interval = 100  # prune every N iterations\n        self._prune_threshold_factor = 1.5  # prune vertices cost > best_cost * factor\n\n    def _heuristic(self, point: Point) -> float:\n        return Map.get_distance(point, self._get_grid().goal.position)\n\n    def _heuristic_goal(self, point: Point) -> float:\n        return Map.get_distance(point, self._get_grid().agent.position)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist = Map.get_distance(from_pos, to_pos)\n        step = min(self._adapt_step_base, dist)\n        # Shrink step near obstacles heuristically by checking mid-point validity\n        midpoint = Point((from_pos.x + to_pos.x) // 2, (from_pos.y + to_pos.y) // 2)\n        if not self._get_grid().is_agent_valid_pos(midpoint):\n            step *= 0.5\n        return max(2.0, step)  # minimum step to avoid stalling\n\n    def _new_vertex_towards(self, q_near: Vertex, q_sample: Point, max_step: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = vec.norm().item()\n        if dist <= max_step:\n            pos = q_sample\n        else:\n            direction = vec / dist\n            pos = Point.from_tensor(q_near.position.to_tensor() + direction * max_step)\n        return Vertex(pos)\n\n    def _choose_best_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + Map.get_distance(v.position, q_new.position) + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire_around(self, q_new: Vertex, near_vertices: list) -> None:\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + Map.get_distance(q_new.position, v.position) + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_complete_path(self, v_start: Vertex, v_goal: Vertex) -> None:\n        # Extract path from start tree to connection vertex\n        path_start = [v_start]\n        current = v_start\n        while current != self._graph.root_vertex_start:\n            if len(current.parents) == 0:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path_start.append(current)\n        path_start.reverse()\n\n        # Extract path from goal tree to connection vertex\n        path_goal = [v_goal]\n        current = v_goal\n        while current != self._graph.root_vertex_goal:\n            if len(current.parents) == 0:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(current)\n\n        full_path = path_start + path_goal[::-1][1:]  # avoid duplicate connection vertex\n\n        smoothed_path = self._shortcut_path(full_path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_high_cost_vertices(self, best_cost: float) -> None:\n        threshold = best_cost * self._prune_threshold_factor\n        removed = []\n        # Prune vertices with cost much higher than best_cost, excluding roots\n        for v in list(self._graph.root_vertices):\n            if v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            if v.cost > threshold:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                for c in list(v.children):\n                    self._graph.remove_edge(v, c)\n                if v in self._graph.root_vertices:\n                    self._graph.root_vertices.remove(v)\n                removed.append(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Initialize priority queues with (cost + heuristic, vertex)\n        heapq.heappush(self._pq_start, (start_vertex.cost + self._heuristic(start_vertex.position), start_vertex))\n        heapq.heappush(self._pq_goal, (goal_vertex.cost + self._heuristic_goal(goal_vertex.position), goal_vertex))\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        best_cost = float('inf')\n        best_connection = (None, None)\n\n        iter_since_improve = 0\n        max_iter_since_improve = 300\n\n        for iteration in range(self._max_iter):\n            if time.time() - start_time > self._timeout:\n                # Timeout exit\n                break\n\n            # Alternate expanding start and goal trees by popping from respective priority queue\n            expand_start_tree = (iteration % 2 == 0)\n\n            if expand_start_tree and len(self._pq_start) == 0:\n                break\n            if (not expand_start_tree) and len(self._pq_goal) == 0:\n                break\n\n            # Select tree and priority queue\n            pq_expanding = self._pq_start if expand_start_tree else self._pq_goal\n            visited_expanding = visited_start if expand_start_tree else visited_goal\n            visited_other = visited_goal if expand_start_tree else visited_start\n\n            # Pop vertex with minimal cost+heuristic\n            current_f, current_vertex = heapq.heappop(pq_expanding)\n\n            # Sample biased around current_vertex +/- small Gaussian offset for local exploration\n            pos = current_vertex.position\n            n_dim = len(pos)\n            offset_tries = 0\n            found_valid_sample = False\n            while offset_tries < 20:\n                coords = [pos[i] + random.randint(-5, 5) for i in range(n_dim)]\n                coords_clamped = [max(0, min(c, self._get_grid().size[i]-1)) for i,c in enumerate(coords)]\n                sample_point = Point(*coords_clamped)\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    found_valid_sample = True\n                    break\n                offset_tries += 1\n            if not found_valid_sample:\n                # Fallback to uniform random valid point\n                attempts = 0\n                while attempts < 20:\n                    rand_coords = [random.randint(0, self._get_grid().size[i]-1) for i in range(n_dim)]\n                    sample_point = Point(*rand_coords)\n                    if self._get_grid().is_agent_valid_pos(sample_point):\n                        break\n                    attempts += 1\n\n            # Generate new vertex towards sample point\n            step_size = self._adaptive_step(current_vertex.position, sample_point)\n            q_new = self._new_vertex_towards(current_vertex, sample_point, step_size)\n\n            if q_new.position in visited_expanding:\n                continue\n\n            # Validate path collision-free from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(current_vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Get neighbors for rewiring\n            near_vertices = self._graph.get_vertices_within_radius(\n                [current_vertex], q_new.position, self._rewire_radius\n            )\n\n            # Choose best parent\n            best_parent = self._choose_best_parent(near_vertices, q_new)\n            if best_parent is None:\n                # fallback: connect directly to current_vertex to avoid deadend if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = current_vertex.cost + self._cost(current_vertex, q_new)\n                    best_parent = current_vertex\n                else:\n                    continue\n\n            # Add q_new to graph\n            self._graph.add_edge(best_parent, q_new)\n            visited_expanding[q_new.position] = q_new\n\n            # Local rewiring around q_new for cost improvement\n            near_for_rewire = self._graph.get_vertices_within_radius(\n                [q_new], q_new.position, self._rewire_radius\n            )\n            self._rewire_around(q_new, near_for_rewire)\n\n            # Push q_new into priority queue of expanding tree\n            if expand_start_tree:\n                priority_value = q_new.cost + self._heuristic(q_new.position)\n            else:\n                priority_value = q_new.cost + self._heuristic_goal(q_new.position)\n\n            heapq.heappush(pq_expanding, (priority_value, q_new))\n\n            # Try connect q_new to opposite tree within rewiring radius\n            opposite_vertices = list(visited_other.values())\n            connection_candidates = [v for v in opposite_vertices if Map.get_distance(v.position, q_new.position) <= self._rewire_radius]\n\n            for v_opp in connection_candidates:\n                # Check if line valid between q_new and v_opp\n                line_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_connect):\n                    continue\n                total_cost = q_new.cost + Map.get_distance(q_new.position, v_opp.position) + self._get_grid().get_movement_cost(q_new.position, v_opp.position) + v_opp.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (q_new, v_opp)\n                    iter_since_improve = 0\n\n            iter_since_improve += 1\n\n            # Prune high cost vertices regularly to maintain compact graph\n            if iteration % self._prune_interval == 0 and best_cost < float('inf'):\n                self._prune_high_cost_vertices(best_cost)\n\n            self.key_frame()\n\n            # Early termination if no improvement for many iterations\n            if iter_since_improve > max_iter_since_improve and best_connection[0] is not None and best_connection[1] is not None:\n                break\n\n        if best_connection[0] is not None and best_connection[1] is not None:\n            # Connect best connection edge and extract full path\n            v1, v2 = best_connection\n            # Connect both ways for path extraction\n            self._graph.add_edge(v1, v2)\n            self._graph.add_edge(v2, v1)\n            self._extract_complete_path(v1, v2)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a Hybrid Heuristic Sampling with Progressive Densification and Anytime \n    Repairing strategy (HHS-PD-AR). It blends heuristic-driven sampling on a grid with adaptive local \n    refinement and anytime path improvement, combining ideas from A* heuristics, PRM densification, \n    and local shortcutting.\n\n    Key aspects:\n    - Uses a heuristic (Euclidean + movement cost) to bias sampling towards promising areas.\n    - Progressive densification: starts sparse and locally densifies regions showing better paths.\n    - Anytime repairing: improves found path iteratively by re-exploring and shortcutting.\n    - Caches vertices in a cyclic graph for flexible path rewiring (non-tree).\n    - Employs adaptive max step size by local obstacle density.\n    - Stops early after 10 seconds or when improvements plateau.\n    - Extracted path is repeatedly shortcut for smoothing and shorter routes.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = CyclicGraph(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters and state\n        self._timeout = 10.0\n        self._base_max_step = 12.0\n        self._sampling_density = 50  # Number of samples per densification round\n        self._local_densification_radius = 18.0\n        self._improve_iterations = 100  # Iterations to try improving found path\n        self._best_path_cost = float('inf')\n        self._key_frame_interval = 25\n        self._improvement_threshold = 1e-3\n        self._last_improved_iter = 0\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        \"\"\"Heuristic combining Euclidean and movement cost.\"\"\"\n        euclid = Map.get_distance(frm, to)\n        move_cost = self._get_grid().get_movement_cost(frm, to)\n        return euclid + move_cost\n\n    def _adaptive_max_step(self, position: Point) -> float:\n        \"\"\"Adapt max step size according to obstacle density nearby.\"\"\"\n        radius = 5\n        grid = self._get_grid()\n        neighbors = 0\n        samples = 0\n        pos_np = position.to_tensor().numpy()\n        for dx in range(-radius, radius + 1):\n            for dy in range(-radius, radius + 1):\n                sample_pt = Point(pos_np[0] + dx, pos_np[1] + dy)\n                if not grid.is_agent_valid_pos(sample_pt):\n                    neighbors += 1\n                samples += 1\n        obstacle_ratio = neighbors / max(1, samples)\n        step = self._base_max_step * (1.0 - min(0.7, obstacle_ratio))\n        step = max(3.0, step)\n        return step\n\n    def _heuristic_biased_sample(self) -> Point:\n        \"\"\"Sample points biased by heuristic and some uniform exploration.\"\"\"\n        import random\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        # With some probability sample near current best path corridor or uniformly\n        p_goal_bias = 0.12\n        p_path_bias = 0.35\n\n        if random.random() < p_goal_bias:\n            return goal\n\n        if random.random() < p_path_bias and hasattr(self, '_cached_path') and self._cached_path:\n            # Sample randomly near a vertex in cached path\n            vertex_in_path = random.choice(self._cached_path)\n            base_pos = vertex_in_path.position.to_tensor().numpy()\n            n_dim = grid.size.n_dim\n            for _ in range(20):\n                offset = np.random.normal(0, 5, n_dim)\n                sample_coords = np.clip(np.round(base_pos + offset), 0, grid.size - 1).astype(int)\n                candidate = Point(*sample_coords)\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n\n        # Otherwise uniform random valid sample\n        n_dim = grid.size.n_dim\n        for _ in range(50):\n            sample_coords = np.random.randint(0, grid.size, n_dim)\n            candidate = Point(*sample_coords)\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n\n        # fallback to goal position if no suitable found\n        return goal\n\n    def _get_new_vertex_towards(self, q_near: Vertex, q_sample: Point, max_step: float) -> Vertex:\n        direction_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = float(torch.norm(direction_vec))\n        if dist == 0:\n            return Vertex(q_near.position, store_connectivity=True)\n        if dist <= max_step:\n            return Vertex(q_sample, store_connectivity=True)\n        unit_dir = direction_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + unit_dir * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _line_is_free(self, frm: Point, to: Point) -> bool:\n        seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(seq)\n\n    def _local_rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"Within neighborhood, try to improve cost using q_new as shortcut.\"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            if not self._line_is_free(q_new.position, neighbor.position):\n                continue\n            new_cost = q_new.cost + self._heuristic_cost(q_new.position, neighbor.position)\n            if new_cost + 1e-6 < neighbor.cost:\n                # Rewire edges removing old parents and adding edge from q_new\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n                self._propagate_cost_update(neighbor)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            v = stack.pop()\n            for c in v.children:\n                c_new_cost = v.cost + self._heuristic_cost(v.position, c.position)\n                if c_new_cost + 1e-6 < c.cost:\n                    c.cost = c_new_cost\n                    stack.append(c)\n\n    def _extract_and_smooth_path(self, q_goal: Vertex) -> None:\n        # Backtrack from goal to start: choose parent with min cost among possibly multiple parents\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                # No path, abort\n                return\n            current = min(current.parents, key=lambda p: p.cost)\n            path.append(current)\n        path.reverse()\n\n        # Shortcut until no improvements\n        smoothed = path\n        for _ in range(4):\n            new_path = self._shortcut_path(smoothed)\n            if len(new_path) == len(smoothed):\n                break\n            smoothed = new_path\n\n        self._cached_path = smoothed  # cache for heuristic sampling\n\n        for vertex in smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_is_free(path[i].position, path[j].position):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = float('inf')  # Not used except as fixed target position\n\n        self._cached_path = []\n        found_path = False\n\n        start_time = time.time()\n\n        # Main parameters\n        max_samples_total = 8000\n        last_report_iter = 0\n\n        # Initialize vertex sets for progressive densification management\n        vertices = [start_vertex]\n        positions_set = {start_vertex.position}\n\n        for iteration in range(max_samples_total):\n            if time.time() - start_time > self._timeout:\n                break\n\n            q_sample = self._heuristic_biased_sample()\n            q_near = self._graph.get_nearest_vertex(vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_step = self._adaptive_max_step(q_near.position)\n\n            q_new = self._get_new_vertex_towards(q_near, q_sample, max_step)\n\n            if q_new.position in positions_set:\n                continue\n\n            if not self._line_is_free(q_near.position, q_new.position):\n                continue\n\n            # Find neighbors for rewiring locally\n            neighbor_vertices = self._graph.get_vertices_within_radius(vertices, q_new.position, self._local_densification_radius)\n\n            # Choose parent that yields minimum cost\n            best_parent = None\n            min_cost = float('inf')\n            for v in neighbor_vertices:\n                if not self._line_is_free(v.position, q_new.position):\n                    continue\n                cost = v.cost + self._heuristic_cost(v.position, q_new.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n\n            if best_parent is None:\n                # fallback to q_near if line valid\n                if self._line_is_free(q_near.position, q_new.position):\n                    best_parent = q_near\n                    min_cost = q_near.cost + self._heuristic_cost(q_near.position, q_new.position)\n                else:\n                    continue\n\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n            vertices.append(q_new)\n            positions_set.add(q_new.position)\n\n            # Local rewiring to improve neighbors\n            self._local_rewire(q_new, neighbor_vertices)\n\n            # Early path check: try to connect q_new directly to goal\n            if self._line_is_free(q_new.position, goal_vertex.position):\n                cost_to_goal = q_new.cost + self._heuristic_cost(q_new.position, goal_vertex.position)\n                if cost_to_goal + 1e-6 < self._best_path_cost:\n                    # Add goal as child, update cost, extract path\n                    goal_vertex.cost = cost_to_goal\n                    for p in list(goal_vertex.parents):\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_path_cost = cost_to_goal\n                    found_path = True\n                    self._extract_and_smooth_path(goal_vertex)\n                    self._last_improved_iter = iteration\n\n            # Anytime repairing: after path found, attempt local improvements for some iterations\n            if found_path and (iteration - self._last_improved_iter) < self._improve_iterations:\n                # Resample around last path vertices to densify and improve\n                if self._cached_path:\n                    sample_on_path = random.choice(self._cached_path)\n                    n_dim = grid.size.n_dim\n                    pos_np = sample_on_path.position.to_tensor().numpy()\n                    for _ in range(5):\n                        offset = np.random.normal(0, 3, n_dim)\n                        candidate_coords = np.clip(np.round(pos_np + offset), 0, grid.size - 1).astype(int)\n                        candidate = Point(*candidate_coords)\n                        if grid.is_agent_valid_pos(candidate):\n                            q_near_local = self._graph.get_nearest_vertex(vertices, candidate)\n                            max_step_local = self._adaptive_max_step(q_near_local.position)\n                            q_new_local = self._get_new_vertex_towards(q_near_local, candidate, max_step_local)\n                            if q_new_local.position not in positions_set and self._line_is_free(q_near_local.position, q_new_local.position):\n                                # Connect locally\n                                neighbors_local = self._graph.get_vertices_within_radius(vertices, q_new_local.position, self._local_densification_radius)\n                                best_parent_local = None\n                                min_cost_local = float('inf')\n                                for v in neighbors_local:\n                                    if not self._line_is_free(v.position, q_new_local.position):\n                                        continue\n                                    cost_local = v.cost + self._heuristic_cost(v.position, q_new_local.position)\n                                    if cost_local < min_cost_local:\n                                        min_cost_local = cost_local\n                                        best_parent_local = v\n                                if best_parent_local is not None:\n                                    q_new_local.cost = min_cost_local\n                                    self._graph.add_edge(best_parent_local, q_new_local)\n                                    vertices.append(q_new_local)\n                                    positions_set.add(q_new_local.position)\n                                    self._local_rewire(q_new_local, neighbors_local)\n\n                                    # Attempt direct connection to goal vertex for improvement\n                                    if self._line_is_free(q_new_local.position, goal_vertex.position):\n                                        possible_cost = q_new_local.cost + self._heuristic_cost(q_new_local.position, goal_vertex.position)\n                                        if possible_cost + 1e-6 < self._best_path_cost:\n                                            goal_vertex.cost = possible_cost\n                                            for p in list(goal_vertex.parents):\n                                                self._graph.remove_edge(p, goal_vertex)\n                                            self._graph.add_edge(q_new_local, goal_vertex)\n                                            self._best_path_cost = possible_cost\n                                            found_path = True\n                                            self._extract_and_smooth_path(goal_vertex)\n                                            self._last_improved_iter = iteration\n                            break\n\n            if iteration % self._key_frame_interval == 0:\n                self.key_frame()\n\n            # Stop if no improvement for large iterations after path found\n            if found_path and (iteration - self._last_improved_iter) > self._improve_iterations:\n                break\n\n        if not found_path:\n            # No path found, do nothing or maybe visualize current progress\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An improved hybrid sample-based path planning algorithm employing a heuristic-informed,\n    informed-expansion tree grow with adaptive elliptical sampling region around the current best\n    path cost estimate. It combines heuristic A*-like cost to guide sampling and vertex \n    expansion, ellipse-adaptive sampling to focus exploration towards goal while reducing wasted \n    samples, and incremental path cost improvement with batch rewiring. It uses a single tree \n    rooted at the start, expands towards randomness biased inside an ellipse defined by start-goal \n    and current best cost, and prunes vertices exceeding current best path cost for memory control. \n    Early exits on timeout or success with smooth shortcut path extraction. This approach aims \n    to produce faster convergence, better path quality, and robustness by focusing search cost-aware \n    to the feasible reachable set and optimizing paths incrementally.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\n    \"\"\"\n    An improved hybrid sample-based path planning algorithm employing a heuristic-informed,\n    informed-expansion tree grow with adaptive elliptical sampling region around the current best\n    path cost estimate. It combines heuristic A*-like cost to guide sampling and vertex \n    expansion, ellipse-adaptive sampling to focus exploration towards goal while reducing wasted \n    samples, and incremental path cost improvement with batch rewiring. It uses a single tree \n    rooted at the start, expands towards randomness biased inside an ellipse defined by start-goal \n    and current best cost, and prunes vertices exceeding current best path cost for memory control. \n    Early exits on timeout or success with smooth shortcut path extraction. This approach aims \n    to produce faster convergence, better path quality, and robustness by focusing search cost-aware \n    to the feasible reachable set and optimizing paths incrementally.\n    \"\"\"\n    }\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Added members\n        self._max_dist_base = 20.0\n        self._vertex_limit = 1500\n        self._rewire_frequency = 20\n        self._batch_rewire_size = 50\n        self._timeout_sec = 10.0\n        self._epsilon = 1e-6\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        \"\"\"Heuristic (Euclidean) from pos to goal.\"\"\"\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _path_cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"Cost between two vertices including grid movement cost.\"\"\"\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _ellipse_sample(self, c_min: float, start: Point, goal: Point):\n        \"\"\"\n        Adaptive informed sampling inside an ellipse defined by start-goal line segment and current best cost.\n        If c_min is infinite (no path found yet), fallback to uniform sample on map.\n        \"\"\"\n        grid_size = self._get_grid().size.to_tuple()\n        if c_min == float('inf'):\n            # Uniform random valid sample\n            attempts = 0\n            while attempts < 50:\n                rand_coords = tuple(np.random.randint(0, s) for s in grid_size)\n                sample_point = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n                attempts += 1\n            return self._get_grid().goal.position  # fallback\n        else:\n            # Ellipse parameters\n            c_min = max(c_min, self._epsilon)\n            center = Point(\n                (start.x + goal.x) / 2,\n                (start.y + goal.y) / 2\n            )\n            a1 = (goal.x - start.x, goal.y - start.y)\n            c_half = c_min / 2.0\n\n            # Rotation from ellipse frame to world frame\n            angle = np.arctan2(a1[1], a1[0])\n\n            for _ in range(50):\n                # Sample random point in unit circle\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 2 * np.pi)\n                radius = r1 ** 0.5  # sqrt for uniform distribution in circle\n                x_ball = radius * np.cos(r2)\n                y_ball = radius * np.sin(r2)\n\n                # Scale ball to ellipse axes lengths\n                # a = c_half, b = sqrt(c_min^2 - d^2)/2 where d = distance start-goal\n                d = Map.get_distance(start, goal)\n                try:\n                    b = np.sqrt(c_min ** 2 - d ** 2) / 2.0\n                except:\n                    b = c_half  # fallback in degenerate case\n\n                x_ell = c_half * x_ball\n                y_ell = b * y_ball\n\n                # Rotate ellipse sample back to world frame and translate\n                x_rot = x_ell * np.cos(angle) - y_ell * np.sin(angle)\n                y_rot = x_ell * np.sin(angle) + y_ell * np.cos(angle)\n                sample_x = int(round(center.x + x_rot))\n                sample_y = int(round(center.y + y_rot))\n\n                sample_point = Point(sample_x, sample_y)\n                if 0 <= sample_x < grid_size[0] and 0 <= sample_y < grid_size[1]:\n                    if self._get_grid().is_agent_valid_pos(sample_point):\n                        return sample_point\n\n            # Fallback uniform if no ellipse sample valid\n            attempts = 0\n            while attempts < 50:\n                rand_coords = tuple(np.random.randint(0, s) for s in grid_size)\n                sample_point = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n                attempts += 1\n            return self._get_grid().goal.position\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"Choose parent vertex among near vertices with minimal cost-to-come + cost-to-q_new.\"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = v.cost + self._path_cost(v, q_new)\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        \"\"\"\n        Try to rewire near vertices through q_new if the path improves cost and line is valid.\n        \"\"\"\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._path_cost(q_new, v)\n            if cost_through_new < v.cost:\n                parents_copy = list(v.parents)\n                for p in parents_copy:\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_new\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Smooth path by shortcutting between vertices whenever line-of-sight is valid.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"\n        Extract path from start (root) to given goal_vertex based on parent pointers and smooth it.\n        \"\"\"\n        path = [goal_vertex]\n        current = goal_vertex\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path.append(current)\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for vertex in smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_vertices(self, max_cost: float) -> None:\n        \"\"\"\n        Prune vertices that have cost exceeding max_cost (i.e. worse than current best path).\n        Retain root start and connected descendants.\n        \"\"\"\n        vertices_to_remove = []\n        for v in self._graph.root_vertices:\n            if v == self._graph.root_vertex_start:\n                continue\n            if v.cost > max_cost:\n                vertices_to_remove.append(v)\n        for v in vertices_to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _limit_graph_size(self) -> None:\n        \"\"\"\n        Limit total vertices count by pruning higher cost and far away vertices.\n        \"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start]\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        max_iterations = 5000\n\n        start_vertex = self._graph.root_vertex_start\n        goal_point = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n\n        best_cost = float('inf')\n        best_goal_vertex = None\n\n        # Maintain list of all vertices in graph (including root)\n        vertices = [start_vertex]\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > self._timeout_sec:\n                # Timeout exit\n                break\n\n            # Calculate current best cost for ellipse sampling boundary\n            c_min = best_cost if best_goal_vertex else float('inf')\n\n            sample = self._ellipse_sample(c_min, start_vertex.position, goal_point)\n\n            # Find nearest vertex and generate new vertex towards sample\n            nearest_vertex = self._graph.get_nearest_vertex([start_vertex], sample)\n            if nearest_vertex.position == sample:\n                continue\n\n            dist_to_sample = Map.get_distance(nearest_vertex.position, sample)\n            adaptive_step = min(self._max_dist_base, dist_to_sample)\n            # Slight heuristic: reduce step near high cost vertices to fine tune path\n            norm_cost = min(nearest_vertex.cost / 100.0, 1.0)\n            adaptive_step *= 0.7 + 0.3 * (1 - norm_cost)\n            q_new = self._get_new_vertex(nearest_vertex, sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Query neighbors within radius scaling with log(iter) to encourage rewiring initially\n            radius = max(5.0, 20.0 * (np.log(iteration + 2) / (iteration + 1))) \n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                # Check if nearest vertex can be parent as fallback\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = nearest_vertex.cost + self._path_cost(nearest_vertex, q_new)\n                    parent = nearest_vertex\n                else:\n                    continue\n\n            self._graph.add_edge(parent, q_new)\n            vertices.append(q_new)\n\n            # Rewire in batches for efficiency every _rewire_frequency iterations\n            if iteration % self._rewire_frequency == 0:\n                self._rewire(near_vertices, q_new)\n\n            # Check if newly added vertex is within goal radius and with improved cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                current_goal_dist = self._heuristic_cost(q_new.position)\n                if q_new.cost + current_goal_dist < best_cost:\n                    best_cost = q_new.cost + current_goal_dist\n                    best_goal_vertex = q_new\n\n                    # Prune vertices with cost exceeding best_cost to reduce graph size\n                    self._prune_vertices(best_cost + 3.0)  # Margin for safety\n                    self._limit_graph_size()\n\n                    # Early termination if path good enough\n                    if best_cost < self._epsilon + Map.get_distance(start_vertex.position, goal_point):\n                        break\n\n            self.key_frame()\n\n        # If path found, extract and smooth\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements a Bidirectional Anytime Informed RRT* (BI-AIRRT*) variant\n    that grows two trees from both start and goal simultaneously using heuristic-informed sampling.\n    It integrates the following improvements:\n     - Bidirectional extension for faster connection and exploration.\n     - Anytime behavior: iteratively improves path cost by rewiring within an adaptive informed funnel.\n     - Informed sampling within ellipsoidal region defined by current best path cost to focus search.\n     - Dynamic resizing of extension step based on distance to goal and obstacles.\n     - Early stopping upon path connection or timeout (10s).\n     - Path extracted by connecting start and goal trees at best connector vertex pair, followed by shortcut smoothing.\n    \n    This hybrid approach leverages goal bias, adaptive step sizes, and rewiring similar to RRT*, while using bidirectional search and heuristics to improve convergence speed and solution quality.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This algorithm implements a Bidirectional Anytime Informed RRT* (BI-AIRRT*) variant\n    that grows two trees from both start and goal simultaneously using heuristic-informed sampling.\n    It integrates the following improvements:\n     - Bidirectional extension for faster connection and exploration.\n     - Anytime behavior: iteratively improves path cost by rewiring within an adaptive informed funnel.\n     - Informed sampling within ellipsoidal region defined by current best path cost to focus search.\n     - Dynamic resizing of extension step based on distance to goal and obstacles.\n     - Early stopping upon path connection or timeout (10s).\n     - Path extracted by connecting start and goal trees at best connector vertex pair, followed by shortcut smoothing.\n    \n    This hybrid approach leverages goal bias, adaptive step sizes, and rewiring similar to RRT*, while using bidirectional search and heuristics to improve convergence speed and solution quality.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 14.0        # Base extension step length\n        self._rewire_radius = 18.0        # Neighborhood radius for rewiring\n        self._goal_bias = 0.15            # Probability to bias sampling towards goal\n        self._timeout = 10.0              # Max runtime seconds\n\n        # Two trees for bidirectional search\n        self._tree_start = Forest(self._graph.root_vertex_start, None, [self._graph.root_vertex_start])\n        self._tree_goal = Forest(self._graph.root_vertex_goal, None, [self._graph.root_vertex_goal])\n        self._tree_start.edges_removable = True\n        self._tree_goal.edges_removable = True\n\n    def _euclidean_distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        # Shrink step near goal or obstacle as in existing references\n        dist_to_goal = self._euclidean_distance(to_pos, self._graph.root_vertex_goal.position)\n        max_step = self._max_dist_base\n        if dist_to_goal < 18.0:\n            max_step *= 0.5 + 0.5 * (dist_to_goal / 18.0)\n        # Penalize if path direction is obstacle-laden\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n        return max_step\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_step: float) -> Vertex:\n        vec = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(to_point)\n        direction = vec / dist\n        new_pos_tensor = from_vertex.position.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _sample_informed(self, c_best: float) -> Point:\n        from random import random\n        size = self._get_grid().size\n        goal_pos = self._graph.root_vertex_goal.position\n        start_pos = self._graph.root_vertex_start.position\n\n        if c_best == float('inf'):\n            # No path found yet, uniform sampling with goal bias\n            if random() < self._goal_bias:\n                return goal_pos\n            while True:\n                coords = [int(random() * size[i]) for i in range(size.n_dim)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling within prolate hyperspheroid (ellipse) shaped by c_best cost\n        # Compute parameters of ellipse\n        center = Point(*(((start_pos.to_tensor() + goal_pos.to_tensor()) / 2).tolist()))\n        c_min = self._euclidean_distance(start_pos, goal_pos)\n        a1 = (goal_pos.to_tensor() - start_pos.to_tensor()) / c_min  # axis direction unit vector\n\n        # Sampling in unit n-ball\n        import numpy as np\n        while True:\n            # Sample random point in unit ball in n-dimensions\n            dim = size.n_dim\n            u = np.random.normal(0, 1, dim)\n            norm_u = np.linalg.norm(u)\n            if norm_u == 0:\n                continue\n            u_unit = u / norm_u\n            r = np.random.random() ** (1/dim)\n            sample_ball = r * u_unit\n\n            # Scale ellipsoid axes radii\n            L1 = c_best / 2.0\n            if c_best < float('inf'):\n                L_orth = np.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n            else:\n                L_orth = float('inf')\n\n            # Construct orthonormal basis for the ellipse frame\n            from numpy.linalg import svd\n            e1 = a1.numpy() if hasattr(a1, 'numpy') else a1.tolist()\n            e1 = np.array(e1)\n            e1 = e1 / np.linalg.norm(e1)\n            # Generate orthonormal basis using SVD trick\n            U, _, _ = svd(np.eye(dim) - np.outer(e1, e1))\n            if dim > 1:\n                ortho_basis = U[:,1:]\n            else:\n                ortho_basis = np.zeros((dim,0))\n\n            sample_ellipse = L1 * sample_ball[0] * e1\n            if dim > 1:\n                sample_ellipse += L_orth * np.dot(ortho_basis, sample_ball[1:])\n\n            sample_point_coords = center.to_tensor().numpy() + sample_ellipse\n            # Clamp coordinates inside grid bounds\n            clamped_coords = np.clip(sample_point_coords, 0, np.array(size) - 1)\n            sample_point = Point(*tuple(int(round(v)) for v in clamped_coords))\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _choose_best_parent(self, forest: Forest, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire_tree(self, forest: Forest, q_new: Vertex, near_vertices: list) -> None:\n        for v in near_vertices:\n            if v == q_new or v == forest.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                for p in list(v.parents):\n                    forest.remove_edge(p, v)\n                forest.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> bool:\n        # Try connection from v_start to v_goal and vice versa:\n        line_seq1 = self._get_grid().get_line_sequence(v_start.position, v_goal.position)\n        if self._get_grid().is_valid_line_sequence(line_seq1):\n            # Connect trees by adding edges bidirectionally to keep connectivity\n            self._tree_start.add_edge(v_start, v_goal)\n            self._tree_goal.add_edge(v_goal, v_start)\n            return True\n        return False\n\n    def _extract_bidirectional_path(self, conn_start: Vertex, conn_goal: Vertex) -> None:\n        # Extract path back to roots for both trees, then concatenate and shortcut\n        path_start = [conn_start]\n        current = conn_start\n        while current != self._tree_start.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(parent)\n            current = parent\n        path_start.reverse()\n\n        path_goal = [conn_goal]\n        current = conn_goal\n        while current != self._tree_goal.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(parent)\n            current = parent\n        # goal tree path is from goal towards connection, so reverse to get forward direction\n        # but since goal tree root is actual goal, path_goal is start->conn_goal reversed so omit reverse\n        # We want concatenation: start_tree_path + reversed(goal_tree_path)\n        path_goal.reverse()\n\n        full_path = path_start + path_goal\n\n        shortcut_path = self._shortcut_path(full_path)\n        for v in shortcut_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        best_path_cost = float('inf')\n\n        # Initialize costs\n        self._tree_start.root_vertex_start.cost = 0.0\n        self._tree_goal.root_vertex_start.cost = 0.0\n\n        vertices_start = [self._tree_start.root_vertex_start]\n        vertices_goal = [self._tree_goal.root_vertex_start]\n\n        connected = False\n        conn_start_vertex = None\n        conn_goal_vertex = None\n\n        # Alternate growth between start and goal trees\n        tree_selector = 0\n\n        max_iterations = 8000\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > self._timeout:\n                break\n\n            # Choose which tree to extend (0=start, 1=goal)\n            curr_tree = self._tree_start if tree_selector == 0 else self._tree_goal\n            other_tree = self._tree_goal if tree_selector == 0 else self._tree_start\n\n            root_vertex = curr_tree.root_vertex_start\n            other_root = other_tree.root_vertex_start\n\n            # Sample informed with current best path cost to focus search\n            sample_pos = self._sample_informed(best_path_cost)\n\n            # Find nearest vertex in current tree\n            q_near = curr_tree.get_nearest_vertex([root_vertex], sample_pos)\n            if q_near.position == sample_pos:\n                tree_selector = 1 - tree_selector\n                continue\n\n            max_step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._steer(q_near, sample_pos, max_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                tree_selector = 1 - tree_selector\n                continue\n\n            # Avoid duplicate vertex positions in current tree\n            positions_in_tree = {v.position for v in (vertices_start if curr_tree == self._tree_start else vertices_goal)}\n            if q_new.position in positions_in_tree:\n                tree_selector = 1 - tree_selector\n                continue\n\n            # Find near neighbors for rewiring\n            rewire_rad = self._rewire_radius\n            near_vertices = curr_tree.get_vertices_within_radius([root_vertex], q_new.position, rewire_rad)\n\n            # Choose best parent and assign cost\n            best_parent = self._choose_best_parent(curr_tree, near_vertices, q_new)\n\n            # Fallback to q_near if no better parent\n            if best_parent is None:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    tree_selector = 1 - tree_selector\n                    continue\n\n            curr_tree.add_edge(best_parent, q_new)\n            if curr_tree == self._tree_start:\n                vertices_start.append(q_new)\n            else:\n                vertices_goal.append(q_new)\n\n            # Rewire neighbors to q_new if cheaper\n            self._rewire_tree(curr_tree, q_new, near_vertices)\n\n            # Try to connect q_new to the other tree by nearest vertex in other tree\n            nearest_in_other = other_tree.get_nearest_vertex([other_root], q_new.position)\n            connect_line = self._get_grid().get_line_sequence(q_new.position, nearest_in_other.position)\n            if self._get_grid().is_valid_line_sequence(connect_line):\n                cost_connect = q_new.cost + self._cost(q_new, nearest_in_other) + nearest_in_other.cost\n\n                if cost_connect < best_path_cost:\n                    if self._connect_trees(q_new, nearest_in_other):\n                        best_path_cost = cost_connect\n                        conn_start_vertex = q_new if curr_tree == self._tree_start else nearest_in_other\n                        conn_goal_vertex = nearest_in_other if curr_tree == self._tree_start else q_new\n                        connected = True\n\n            self.key_frame()\n\n            # Early stop if connected and cost improvement negligible or timeout near\n            if connected and time.time() - start_time > self._timeout * 0.8:\n                break\n\n            tree_selector = 1 - tree_selector\n\n        if connected and conn_start_vertex and conn_goal_vertex:\n            self._extract_bidirectional_path(conn_start_vertex, conn_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "A hybrid heuristic graph exploration and incremental roadmap algorithm that combines \n    informed sampling with a bi-directional search approach. Unlike pure RRT or RRT*, this \n    algorithm maintains two growing vertex trees: one from the start and one from the goal. \n    Sampling alternates between heuristic-informed regions near the current shortest path \n    estimate and random free samples for global exploration. Each iteration connects the trees \n    when possible, accelerating convergence. Adaptive step sizing, edge pruning based on \n    cost thresholds, and shortcut path smoothing improve path quality. The bidirectional \n    nature and heuristic bias enhance success rate, robustness, and planning efficiency. \n    Early stopping occurs upon connecting the two trees or timing out after 10 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Maintain two forests: one rooted at start, one at goal for bidirectional search\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._forest_start = Forest(start_vertex, goal_vertex, [])\n        self._forest_goal = Forest(goal_vertex, start_vertex, [])\n        self._direction_toggle = True  # Toggle to alternate expansion between start and goal trees\n        self._init_displays()\n\n        # Parameters for adaptive step and heuristic bias\n        self._max_dist_base = 12.0\n        self._heuristic_bias = 0.3      # Probability to sample along heuristic path corridor\n        self._connection_radius = 20.0  # Max radius to try connect opposite tree\n        self._vertex_limit = 2000       # Max total vertices in both forests combined\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _heuristic_sample_along_path(self, path: list) -> Point:\n        \"\"\"\n        Sample a random point interpolated between random consecutive vertices in given path,\n        with small gaussian noise added to encourage local exploration around the path.\n        \"\"\"\n        import numpy as np\n        if not path or len(path) < 2:\n            # Fallback to random sample if no path known\n            return self._get_random_sample()\n        idx = np.random.randint(0, len(path) - 1)\n        p0 = path[idx].position.to_tensor()\n        p1 = path[idx + 1].position.to_tensor()\n        alpha = np.random.uniform(0.0, 1.0)\n        interp = p0 * (1 - alpha) + p1 * alpha\n        noise = np.random.normal(scale=1.0, size=interp.shape)  # small local noise\n        sample_tensor = interp + torch.tensor(noise, dtype=interp.dtype)\n        sample_coords = tuple(int(torch.clamp(x, 0, self._get_grid().size[i] - 1)) for i, x in enumerate(sample_tensor))\n        sample_point = Point(*sample_coords)\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # fallback to random sample\n            return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        import numpy as np\n        max_attempts = 50\n        attempts = 0\n        while attempts < max_attempts:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # fallback to goal if sampling repeatedly fails\n        return self._get_grid().goal.position\n\n    def _extract_path_bidirectional(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Extract and combine path from start to meeting vertex and from goal to meeting vertex.\n        Then shortcut smooth the concatenated path.\n        \"\"\"\n        path_start = [meet_vertex_start]\n        current = meet_vertex_start\n        while current != self._forest_start.root_vertex_start:\n            if not current.parents:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path_start.append(current)\n        path_start.reverse()\n\n        path_goal = [meet_vertex_goal]\n        current = meet_vertex_goal\n        while current != self._forest_goal.root_vertex_start:\n            if not current.parents:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(current)\n\n        full_path = path_start + path_goal\n\n        smoothed_path = self._shortcut_path(full_path)\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _limit_forest_size(self) -> None:\n        \"\"\"\n        Limit total vertex count across both forests by pruning high cost vertices farthest from root(s).\n        \"\"\"\n        total_size = self._forest_start.size + self._forest_goal.size\n        if total_size <= self._vertex_limit:\n            return\n\n        # Combine all vertices except roots\n        all_vertices = []\n        for v in self._forest_start.root_vertices:\n            if v != self._forest_start.root_vertex_start:\n                all_vertices.append(v)\n        for v in self._forest_goal.root_vertices:\n            if v != self._forest_goal.root_vertex_start:\n                all_vertices.append(v)\n\n        # Sort descending by cost to prune worst vertices first\n        all_vertices = sorted(all_vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = total_size - self._vertex_limit\n        to_remove = all_vertices[:remove_count]\n\n        for v in to_remove:\n            # Remove edges from both forests carefully\n            for p in list(v.parents):\n                if p in self._forest_start.root_vertices:\n                    self._forest_start.remove_edge(p, v)\n                if p in self._forest_goal.root_vertices:\n                    self._forest_goal.remove_edge(p, v)\n            for c in list(v.children):\n                if v in self._forest_start.root_vertices:\n                    self._forest_start.remove_edge(v, c)\n                if v in self._forest_goal.root_vertices:\n                    self._forest_goal.remove_edge(v, c)\n            # Remove vertex from any root_vertices list if exists\n            if v in self._forest_start.root_vertices:\n                self._forest_start.root_vertices.remove(v)\n            if v in self._forest_goal.root_vertices:\n                self._forest_goal.root_vertices.remove(v)\n\n        self._forest_start.size = len(self._forest_start.root_vertices)\n        self._forest_goal.size = len(self._forest_goal.root_vertices)\n\n    def _try_connect_trees(self, v_new: Vertex, opposite_forest: Forest) -> Vertex:\n        \"\"\"\n        Attempt to connect new vertex v_new in one forest to the closest \n        vertex in the opposite forest within connection radius.\n        Return connecting vertex from opposite tree if connection successful, else None.\n        \"\"\"\n        near_opposite = opposite_forest.get_vertices_within_radius(\n            [opposite_forest.root_vertex_start], v_new.position, self._connection_radius)\n        near_opposite_sorted = sorted(near_opposite, key=lambda v: v.cost)\n        for v_opp in near_opposite_sorted:\n            line_seq = self._get_grid().get_line_sequence(v_new.position, v_opp.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Connect by adding edge in both forests (bi-directional graph)\n                cost_new_to_opp = v_new.cost + self._cost(v_new, v_opp)\n                if cost_new_to_opp < v_opp.cost or v_opp.cost == 0.0:\n                    v_opp.cost = cost_new_to_opp\n                    opposite_forest.add_edge(v_new, v_opp)\n                return v_opp\n        return None\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 5000\n\n        self._forest_start.root_vertex_start.cost = 0.0\n        self._forest_goal.root_vertex_start.cost = 0.0\n\n        # To store current best known path for heuristic sampling\n        best_path_start = None\n        best_path_goal = None\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            # Alternate expansion direction for bidirectional planning\n            expanding_forest = self._forest_start if self._direction_toggle else self._forest_goal\n            opposite_forest = self._forest_goal if self._direction_toggle else self._forest_start\n            root_vertex = expanding_forest.root_vertex_start\n\n            # Sample either heuristically near current best path or randomly globally\n            sample: Point\n            use_heuristic_sample = False\n            if best_path_start and best_path_goal and random.random() < self._heuristic_bias:\n                # Create heuristic combined path corridor for sampling\n                if self._direction_toggle:\n                    sample = self._heuristic_sample_along_path(best_path_start)\n                else:\n                    sample = self._heuristic_sample_along_path(best_path_goal)\n                use_heuristic_sample = True\n            else:\n                sample = self._get_random_sample()\n\n            # Find nearest vertex in expanding forest\n            q_near = expanding_forest.get_nearest_vertex([root_vertex], sample)\n            if q_near.position == sample:\n                self._direction_toggle = not self._direction_toggle\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, sample)\n            adaptive_step = min(self._max_dist_base, dist_to_sample)\n            # Modulate adaptive step smaller if near goal or high cost vertex to promote precise connection\n            adaptive_step *= 0.6 + 0.4 * (1 - min(q_near.cost / 100.0, 1.0))\n\n            q_new = self._get_new_vertex(q_near, sample, adaptive_step)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self._direction_toggle = not self._direction_toggle\n                continue\n\n            # Connect q_new to best parent from neighbourhood within radius (local rewiring)\n            neighborhood_radius = max(self._max_dist_base, adaptive_step * 2.0)\n            near_vertices = expanding_forest.get_vertices_within_radius([root_vertex], q_new.position, neighborhood_radius)\n            best_parent = None\n            min_cost = float('inf')\n            for v in near_vertices:\n                seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(seq):\n                    continue\n                cost = v.cost + self._cost(v, q_new)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n            if best_parent is None:\n                # fallback: nearest vertex if line valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    self._direction_toggle = not self._direction_toggle\n                    continue\n            else:\n                q_new.cost = min_cost\n\n            expanding_forest.add_edge(best_parent, q_new)\n\n            # Rewire neighbours with q_new as potential better parent\n            for v in near_vertices:\n                if v == q_new or v == root_vertex:\n                    continue\n                seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if not self._get_grid().is_valid_line_sequence(seq):\n                    continue\n                cost_through_qnew = q_new.cost + self._cost(q_new, v)\n                if cost_through_qnew < v.cost:\n                    for p in list(v.parents):\n                        expanding_forest.remove_edge(p, v)\n                    expanding_forest.add_edge(q_new, v)\n                    v.cost = cost_through_qnew\n\n            # Attempt connecting trees with newly added vertex\n            connecting_vertex = self._try_connect_trees(q_new, opposite_forest)\n            if connecting_vertex:\n                # Extract full path and stop search\n                if self._direction_toggle:\n                    self._extract_path_bidirectional(q_new, connecting_vertex)\n                    break\n                else:\n                    self._extract_path_bidirectional(connecting_vertex, q_new)\n                    break\n\n            # Update best known paths for heuristic sampling\n            # Update best_path_start from start tree to its goal-root vertex if connected\n            best_path_start = None\n            best_path_goal = None\n\n            # We try to find a connecting path from root start to any vertex connected to opposite root\n            # Here simply find shortest path in forest rooted at start with goal vertex present\n            # (Since no explicit goal vertex in forest, approximate by known vertices close to opposite root)\n            # We'll store shortest path from root_vertex to closest vertex to opposite root\n            def find_min_path_to_opposite_root(forest: Forest, opposite_root_pos: Point):\n                # Find near vertices to opposite root\n                near_to_opp = forest.get_vertices_within_radius([forest.root_vertex_start], opposite_root_pos, self._connection_radius*2)\n                if not near_to_opp:\n                    return None\n                best_v = min(near_to_opp, key=lambda v: v.cost)\n                # Extract path backward\n                path = [best_v]\n                current = best_v\n                while current != forest.root_vertex_start:\n                    if not current.parents:\n                        break\n                    current = min(current.parents, key=lambda p: p.cost)\n                    path.append(current)\n                path.reverse()\n                return path\n\n            best_path_start = find_min_path_to_opposite_root(self._forest_start, self._forest_goal.root_vertex_start.position)\n            best_path_goal = find_min_path_to_opposite_root(self._forest_goal, self._forest_start.root_vertex_start.position)\n\n            # Limit graph size for memory and speed\n            self._limit_forest_size()\n\n            self._direction_toggle = not self._direction_toggle\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is a hybrid informed graph-based planner with region-focused incremental expansion.\n    It maintains a cyclic graph structure that allows back-and-forth connection between vertices. \n    \n    Key innovations:\n    - Uses adaptive biased sampling alternating between informed ellipsoidal region around the start-goal \n      axis and uniform random sampling to balance exploration and exploitation.\n    - Constructs a cyclic graph allowing multiple parents and children to represent diverse connection options,\n      improving solution robustness and path quality.\n    - Employs adaptive step sizes based on local density and obstacle proximity to maintain smooth expansions.\n    - Uses a pruning heuristic that removes obsolete vertices that are unlikely to improve current best path.\n    - Expands search by prioritizing vertices with lower cost-to-come plus heuristic to goal (A*-style).\n    - Performs local rewiring on cyclic graph to optimize costs incrementally.\n    - Extracts path by searching within cyclic graph and performs shortcut smoothing before final agent moves.\n    - Enforces a 10-second timeout for robust termination.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This algorithm is a hybrid informed graph-based planner with region-focused incremental expansion.\n    It maintains a cyclic graph structure that allows back-and-forth connection between vertices. \n    \n    Key innovations:\n    - Uses adaptive biased sampling alternating between informed ellipsoidal region around the start-goal \n      axis and uniform random sampling to balance exploration and exploitation.\n    - Constructs a cyclic graph allowing multiple parents and children to represent diverse connection options,\n      improving solution robustness and path quality.\n    - Employs adaptive step sizes based on local density and obstacle proximity to maintain smooth expansions.\n    - Uses a pruning heuristic that removes obsolete vertices that are unlikely to improve current best path.\n    - Expands search by prioritizing vertices with lower cost-to-come plus heuristic to goal (A*-style).\n    - Performs local rewiring on cyclic graph to optimize costs incrementally.\n    - Extracts path by searching within cyclic graph and performs shortcut smoothing before final agent moves.\n    - Enforces a 10-second timeout for robust termination.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = CyclicGraph(self._services,\n                                  Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                  Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                  [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_iterations = 7000\n        self._timeout_sec = 10.0\n        self._informed_sample_probability = 0.6\n        self._max_edge_length = 18.0\n        self._min_edge_length = 4.0\n        self._rewire_radius_init = 20.0\n        self._prune_every = 300\n        self._max_vertices = 1300\n\n    def _heuristic(self, frm: Point, to: Point) -> float:\n        return Map.get_distance(frm, to)\n\n    def _sample_informed(self) -> Point:\n        # Sample within an ellipsoidal prolate region defined by start, goal, and current best cost\n        import random\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        c_min = self._heuristic(start_pos, goal_pos)\n        c_best = float('inf')\n        for v in self._graph.root_vertices:\n            if self._get_grid().is_agent_in_goal_radius(v.position, self._get_grid().goal):\n                path_cost = v.cost\n                if path_cost < c_best:\n                    c_best = path_cost\n\n        if c_best == float('inf'):\n            # No path found yet, fallback to uniform sampling\n            return self._uniform_sample()\n\n        # Ellipsoid parameters\n        center = Point.from_tensor((start_pos.to_tensor() + goal_pos.to_tensor()) / 2.0)\n        unit_vec = (goal_pos.to_tensor() - start_pos.to_tensor())\n        if torch.norm(unit_vec) == 0:\n            return self._uniform_sample()\n        unit_vec = unit_vec / torch.norm(unit_vec)\n\n        # Eigenvalues for ellipsoid axes lengths\n        a1 = c_best / 2.0\n        if c_min < 1e-6:\n            # Nearly zero distance start-goal: fallback\n            return self._uniform_sample()\n        a2 = torch.sqrt(torch.tensor(c_best ** 2 - c_min ** 2)) / 2.0\n        dim = self._get_grid().size.n_dim\n\n        # Generate random point inside unit n-ball\n        import numpy as np\n        while True:\n            rand_dir = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(rand_dir)\n            if norm == 0:\n                continue\n            unit_dir = rand_dir / norm\n            radius = np.random.uniform(0, 1) ** (1.0 / dim)\n            local_point = radius * unit_dir\n            break\n\n        # Construct scaled ellipsoid point\n        scale = [a1] + [a2.item()] * (dim - 1)\n        scaled_point = local_point * np.array(scale)\n\n        # Compute rotation matrix with unit_vec as first axis using Gram-Schmidt\n        # Simple method for dim=2 or 3; for general dim, use Householder or completion\n        # We'll do this for 2D or 3D as per grid dimension\n        # Build orthonormal basis with unit_vec first\n        def orthonormal_basis(v):\n            import torch\n            v = torch.tensor(v, dtype=torch.float)\n            basis = [v]\n            dim = v.shape[0]\n            for i in range(dim):\n                e = torch.zeros(dim)\n                e[i] = 1.0\n                if torch.norm(e - torch.dot(e, v) * v) > 1e-6:\n                    w = e - torch.dot(e, v) * v\n                    basis.append(w / torch.norm(w))\n                if len(basis) == dim:\n                    break\n            return torch.stack(basis).t()\n\n        rot = orthonormal_basis(unit_vec.numpy())\n        ellipsoid_point = torch.tensor(scaled_point, dtype=torch.float).unsqueeze(1)\n        rotated_point = rot @ ellipsoid_point\n        final_point = center.to_tensor() + rotated_point.squeeze(1)\n\n        # Clamp to grid and round, validate position\n        rounded_coords = [max(0, min(self._get_grid().size[i] - 1, int(round(final_point[i].item()))))\n                          for i in range(dim)]\n        candidate = Point(*rounded_coords)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        else:\n            return self._uniform_sample()\n\n    def _uniform_sample(self) -> Point:\n        import numpy as np\n        attempts = 0\n        max_attempts = 40\n        dim = self._get_grid().size.n_dim\n        while attempts < max_attempts:\n            coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        return self._get_grid().goal.position\n\n    def _adaptive_step_size(self, from_pos: Point, to_pos: Point) -> float:\n        dist = Map.get_distance(from_pos, to_pos)\n        step = min(self._max_edge_length, max(self._min_edge_length, dist))\n        # Shrink step if path blocked or near obstacle\n        line_sequence = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_sequence):\n            step *= 0.5\n        return step\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        direction = vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _choose_best_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, near_vertices: list) -> None:\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        # DFS back to start searching among parents in cyclic graph\n        path = [end_vertex]\n        current = end_vertex\n        start_vertex = self._graph.root_vertex_start\n        while current != start_vertex:\n            if not current.parents:\n                break\n            # Pick parent with lowest cost\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        path_smooth = self._shortcut_path(path)\n        for v in path_smooth:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _prune_graph(self) -> None:\n        # Remove vertices unlikely to improve path: high-cost and far from start-goal axis\n        if self._graph.size <= self._max_vertices:\n            return\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def dist_to_line(point):\n            # Distance from point to line start_goal\n            s = start_pos.to_tensor().numpy()\n            g = goal_pos.to_tensor().numpy()\n            p = point.to_tensor().numpy()\n            line_vec = g - s\n            if np.linalg.norm(line_vec) < 1e-7:\n                return np.linalg.norm(p - s)\n            proj_len = np.dot(p - s, line_vec) / np.linalg.norm(line_vec)\n            proj_point = s + (proj_len / np.linalg.norm(line_vec)) * line_vec\n            return np.linalg.norm(p - proj_point)\n\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        # Sort by (cost + dist_to_line) descending to prune worst vertices first\n        candidates_sorted = sorted(candidates, key=lambda v: v.cost + dist_to_line(v.position), reverse=True)\n        to_remove_count = self._graph.size - self._max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_pos = goal.position\n\n        best_path_cost = float('inf')\n        best_end_vertex = None\n\n        for iteration in range(self._max_iterations):\n            # Timeout check\n            if time.time() - start_time > self._timeout_sec:\n                break\n\n            # Biased sample: informed or uniform\n            if random.random() < self._informed_sample_probability:\n                sample = self._sample_informed()\n            else:\n                sample = self._uniform_sample()\n\n            # Find nearest vertex in cyclic graph roots (all vertices)\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, sample)\n            if q_near.position == sample:\n                continue\n\n            step_size = self._adaptive_step_size(q_near.position, sample)\n            q_new = self._get_new_vertex(q_near, sample, step_size)\n\n            # Check if q_new position already exists to avoid duplicates\n            if any(v.position == q_new.position for v in self._graph.root_vertices):\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            rewire_radius = max(self._rewire_radius_init * (1.0 - iteration / self._max_iterations), 7.0)\n\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, rewire_radius)\n\n            best_parent = self._choose_best_parent(near_vertices, q_new)\n            if best_parent is None:\n                q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                best_parent = q_near\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices for cost improvement\n            self._rewire_neighbors(q_new, near_vertices)\n\n            # Add new vertex to roots to be considered for connection or expansion\n            self._graph.root_vertices.append(q_new)\n\n            # Early termination if near goal\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if dist_to_goal <= self._get_grid().goal.radius and self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal_vertex = Vertex(goal_pos, store_connectivity=True)\n                    q_goal_vertex.cost = q_new.cost + self._cost(q_new, q_goal_vertex)\n                    self._graph.add_edge(q_new, q_goal_vertex)\n                    self._graph.root_vertices.append(q_goal_vertex)\n                    best_end_vertex = q_goal_vertex\n                    best_path_cost = q_goal_vertex.cost\n                    break\n\n            # Track best candidate approaching goal\n            dist_to_goal_qnew = Map.get_distance(q_new.position, goal_pos)\n            est_total_cost = q_new.cost + dist_to_goal_qnew\n            if est_total_cost < best_path_cost:\n                best_path_cost = est_total_cost\n                best_end_vertex = q_new\n\n            # Prune cyclic graph periodically to limit size\n            if iteration % self._prune_every == 0 and iteration > 0:\n                self._prune_graph()\n\n            self.key_frame()\n\n        # Extract path if found best_end_vertex\n        if best_end_vertex is not None:\n            self._extract_path(best_end_vertex)",
     "objective": null,
     "other_inf": null
}
