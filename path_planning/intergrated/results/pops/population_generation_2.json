[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "\"\"\"\n    This algorithm combines systematic grid-aware A*-inspired heuristic guided sampling \n    with progressive subtree rewiring for fast convergence and robust connectivity. \n    \n    Key features:\n    - Uses a priority queue (min-heap) over vertices based on f = g + h costs for expansion.\n    - Samples new nodes biased towards frontier areas near current best paths (heuristic frontier sampling).\n    - Adaptive step length modulated by distance-to-goal and obstacle proximity.\n    - Incremental local rewiring within dynamically chosen neighborhoods to optimize paths.\n    - Early termination upon reaching goal within defined radius.\n    - Incorporates path smoothing via shortcutting on final extracted path.\n    - Enforces a global timeout of 10 seconds.\n    \"\"\"",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This algorithm combines systematic grid-aware A*-inspired heuristic guided sampling \n    with progressive subtree rewiring for fast convergence and robust connectivity. \n    \n    Key features:\n    - Uses a priority queue (min-heap) over vertices based on f = g + h costs for expansion.\n    - Samples new nodes biased towards frontier areas near current best paths (heuristic frontier sampling).\n    - Adaptive step length modulated by distance-to-goal and obstacle proximity.\n    - Incremental local rewiring within dynamically chosen neighborhoods to optimize paths.\n    - Early termination upon reaching goal within defined radius.\n    - Incorporates path smoothing via shortcutting on final extracted path.\n    - Enforces a global timeout of 10 seconds.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap = []               # Min-heap for frontier vertices (f = g + h)\n        self._max_iter = 6000         # Max iterations before timeout/failure\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0          # seconds limit\n        self._base_step = 12.0        # Base adaptive step distance\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 1200\n\n    def _heuristic(self, pos: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(pos, goal_pos)\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = self._heuristic(to_pos)\n        # Step shrinks near goal and obstacles to improve precision\n        max_step = self._base_step\n        # Reduce step near goal radius\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n        # Check obstacle proximity along direction, reduce step if near\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5  # Penalize invalid/obstacle-filled directions with smaller step\n        return max_step\n\n    def _get_new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _get_frontier_sample(self) -> Point:\n        # Sample near frontier vertices in the heap using Gaussian jitter to guide exploration\n        import random\n        import numpy as np\n        if not self._heap:\n            # fallback random valid sample in environment\n            for _ in range(50):\n                rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        f_min_vertex = self._heap[0][1]\n        base_pos = f_min_vertex.position\n\n        dim = self._get_grid().size.n_dim\n        std_dev = 8.0  # exploration jitter scale\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(self._get_grid().size[i]-1, int(round(val))))\n            jittered_coords.append(val)\n\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n        else:\n            # fallback to goal biased sampling for valid position\n            return self._get_goal_biased_sample()\n\n    def _goal_biased_sample(self) -> Point:\n        import random\n        # Slight goal bias for direct attraction but mostly frontier sampling is used\n        if random.random() < 0.2:\n            return self._get_grid().goal.position\n        else:\n            return self._get_frontier_sample()\n\n    def _choose_parent_and_cost(self, near_vertices, q_new: Vertex) -> Vertex:\n        # Choose best parent minimizing cost + heuristic\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        # Attempt local rewiring in neighbors to reduce path cost\n        for v in neighbors:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                # Remove all parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                # Additionally update costs downstream in DFS fashion to propagate gains\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            current = stack.pop()\n            for child in current.children:\n                new_cost = current.cost + self._cost(current, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_excess_vertices(self) -> None:\n        # Prune vertices with highest cost or furthest from goal when size exceeds limit\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n        # Ignore start and goal vertices\n        candidates = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        if not candidates:\n            return\n\n        # Sort primarily by distance to goal + cost descending to prune worst vertices\n        goal_pos = self._get_grid().goal.position\n        def prune_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n        candidates = sorted(candidates, key=prune_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n        start_f = self._heuristic(start_vertex.position)\n        self._heap = []\n        heapq.heappush(self._heap, (start_f, start_vertex))\n\n        visited_positions = set()\n        visited_positions.add(start_vertex.position)\n\n        start_time = time.time()\n\n        iterations = 0\n\n        while self._heap and iterations < self._max_iter:\n            iterations += 1\n\n            if time.time() - start_time > self._timeout:\n                # Timeout condition: no path found within time limit\n                break\n\n            _, current_vertex = heapq.heappop(self._heap)\n\n            # Early success check\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=current_vertex.position, goal=self._get_grid().goal):\n                # Connect to goal directly if possible\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(current_vertex.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = current_vertex.cost + self._cost(current_vertex, q_goal)\n                    self._graph.add_edge(current_vertex, q_goal)\n                    self._extract_path(q_goal)\n                break\n\n            # Generate new sample biased by current frontiers\n            q_sample_pos = self._goal_biased_sample()\n\n            # Find nearest vertex to sample in graph\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n\n            if q_near.position == q_sample_pos:\n                continue\n\n            adaptive_step = self._generate_adaptive_step(q_near.position, q_sample_pos)\n\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n\n            # Validate path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Prevent duplicating vertices in same position\n            if q_new.position in visited_positions:\n                continue\n\n            # Find local neighbors for cost computation and rewiring\n            rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback: connect to nearest if feasible\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_positions.add(q_new.position)\n\n            # Insert new vertex into the heap with f = g + h for future expansions\n            f_q_new = q_new.cost + self._heuristic(q_new.position)\n            heapq.heappush(self._heap, (f_q_new, q_new))\n\n            # Attempt local rewiring to optimize paths close to q_new\n            self._rewire_locally(q_new, near_vertices)\n\n            # Prune excess vertices for memory and speed\n            self._prune_excess_vertices()\n\n            self.key_frame()",
          "objective": 924.485,
          "other_inf": null,
          "results": {
               "goal_found_perc": 20.0,
               "average_steps": 6.47,
               "average_distance": 6.46,
               "average_smoothness": 0.23,
               "average_clearance": 3.42,
               "average_time": 0.01,
               "average_distance_from_goal": 7.22,
               "average_original_distance_from_goal": 8.42,
               "average memory": 21.12,
               "goal_found_perc_improvement": -79.45,
               "average_steps_improvement": -2.7,
               "average_distance_improvement": -1.89,
               "average_smoothness_improvement": -15.0,
               "average_clearance_improvement": -0.58,
               "average_time_improvement": -132.56,
               "average_distance_from_goal_improvement": -3510.0,
               "average_path_deviation": 0.1200000000000001,
               "average_memory_improvement": 43.27
          }
     },
     {
          "algorithm": "This improved algorithm extends the A*-inspired heuristic guided sampling path planner\n    by integrating a dual-tree bidirectional search that grows trees from both start and goal,\n    enabling faster connection and increased success rates. \n\n    Key improvements:\n    - Bidirectional tree growth (start and goal) with inter-tree connection attempts each iteration.\n    - Dynamic adaptive step size based on obstacle proximity and distance to goal/start.\n    - Enhanced goal and start biased sampling with Gaussian jitter around frontier vertices.\n    - Local rewiring in both trees to incrementally refine paths and reduce costs.\n    - Early stopping once connection between trees is established inside radius.\n    - Post path extraction smoothing via shortcutting to improve path quality and smoothness.\n    - Timeout of 10 seconds enforces robust termination.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []         # Min-heap for frontier vertices from start (f = g + h)\n        self._heap_goal = []          # Min-heap for frontier vertices from goal (f = g + h)\n        self._max_iter = 6000\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 20.0\n        self._vertex_prune_limit = 1200\n\n    def _heuristic(self, pos: Point, target: Point) -> float:\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = Map.get_distance(to_pos, self._graph.root_vertex_goal.position)\n        max_step = self._base_step\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n        return max_step\n\n    def _get_new_vertex(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _sample_near_frontier(self, heap: list) -> Point:\n        import random\n        import numpy as np\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n        std_dev = 7.0  # slightly smaller jitter for tighter sampling\n\n        if not heap:\n            # fallback random uniform valid sampling\n            for _ in range(50):\n                rand_coords = np.random.randint(0, grid_size, dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        best_vertex = heap[0][1]\n        base_pos = best_vertex.position\n\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            jittered_coords.append(val)\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n\n        # fallback: random near root vertices if frontier sample invalid\n        # pick random root vertex position plus small gaussian\n        roots = [v.position for v in [self._graph.root_vertex_start, self._graph.root_vertex_goal]]\n        fallback_base = random.choice(roots)\n        fallback_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = fallback_base[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            fallback_coords.append(val)\n        fallback_sample = Point(*fallback_coords)\n        if self._get_grid().is_agent_valid_pos(fallback_sample):\n            return fallback_sample\n\n        # Final fallback: goal position, guaranteed valid\n        return self._get_grid().goal.position\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex, root_vertex: Vertex) -> Vertex:\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position, root_vertex.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        path_start = []\n        curr = connect_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n            curr = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n            curr = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        # Concatenate start and goal paths crossing the connection edge\n        full_path = path_start + path_goal\n\n        # Shortcut and smooth the path\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list) -> None:\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n\n        # Candidates excluding roots\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def sort_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n        candidates_sorted = sorted(candidates, key=sort_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n        # Also prune heaps accordingly\n        def prune_heap(heap):\n            filtered_heap = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered_heap:\n                heap.append(item)\n\n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        heapq.heapify(self._heap_start)\n        heapq.heapify(self._heap_goal)\n\n        self._heap_start = []\n        self._heap_goal = []\n\n        heapq.heappush(self._heap_start, (self._heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_v.position, start_v.position), goal_v))\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        start_time = time.time()\n        iterations = 0\n\n        # Alternate expansions from start and goal trees\n        expand_from_start = True\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                break\n\n            if expand_from_start and self._heap_start:\n                _, current_v = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opposite_visited = visited_goal\n                current_visited = visited_start\n                current_heap = self._heap_start\n            elif (not expand_from_start) and self._heap_goal:\n                _, current_v = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opposite_visited = visited_start\n                current_visited = visited_goal\n                current_heap = self._heap_goal\n            else:\n                # if one heap is empty, switch\n                expand_from_start = not expand_from_start\n                continue\n\n            # Sample around frontier in current tree\n            sample_pos = self._sample_near_frontier(current_heap)\n\n            # Find nearest vertex in current tree\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            rewire_r = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vs = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_r)\n\n            best_parent = self._choose_best_parent(near_vs, q_new, tree_root)\n            if not best_parent:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    expand_from_start = not expand_from_start\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n            f_q_new = q_new.cost + self._heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_q_new, q_new))\n\n            self._rewire_neighbors(q_new, near_vs)\n            self._prune_vertices(self._heap_start, self._heap_goal)\n\n            # Check connection to opposite tree vertices within small radius\n            connection_radius = self._goal_radius\n            opposite_near = self._graph.get_vertices_within_radius([goal_v if expand_from_start else start_v], q_new.position, connection_radius)\n\n            connected_vertex_opposite = None\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                connected_vertex_opposite = v_opp\n                break\n\n            if connected_vertex_opposite:\n                # Connect the two trees\n                if expand_from_start:\n                    self._graph.add_edge(q_new, connected_vertex_opposite)\n                    self._extract_bidirectional_path(q_new, connected_vertex_opposite)\n                else:\n                    self._graph.add_edge(connected_vertex_opposite, q_new)\n                    self._extract_bidirectional_path(connected_vertex_opposite, q_new)\n                break\n\n            expand_from_start = not expand_from_start",
          "objective": 2446.2,
          "other_inf": null,
          "results": {
               "goal_found_perc": 5.33,
               "average_steps": 9.75,
               "average_distance": 10.87,
               "average_smoothness": 0.37,
               "average_clearance": 4.17,
               "average_time": 0.0659,
               "average_distance_from_goal": 7.89,
               "average_original_distance_from_goal": 8.42,
               "average memory": 31.46,
               "goal_found_perc_improvement": -94.52,
               "average_steps_improvement": -13.11,
               "average_distance_improvement": -18.41,
               "average_smoothness_improvement": -85.0,
               "average_clearance_improvement": 10.9,
               "average_time_improvement": -980.33,
               "average_distance_from_goal_improvement": -3845.0,
               "average_path_deviation": 1.6899999999999995,
               "average_memory_improvement": 15.5
          }
     },
     {
          "algorithm": "\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15        # Slightly higher goal bias for focused sampling\n        self._rewire_radius = 15.0    # Shrinking rewire radius for better memory\n        self._vertex_limit = 1500     # Limit max vertices for memory efficiency\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            attempts = 0\n            while attempts < 50:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            # fallback to goal if sampling fails repeatedly\n            return self._get_grid().goal.position\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove all existing parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"Shrink rewire radius over time for efficiency and memory.\"\"\"\n        min_radius = 5.0\n        radius = self._rewire_radius * (1.0 - iteration / max_iterations)\n        return max(radius, min_radius)\n\n    def _limit_graph_size(self) -> None:\n        \"\"\"Limit max vertex count in graph for memory efficiency by pruning farthest or high cost vertices.\"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Sort vertices by cost descending, skip root start and goal\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            # Remove all edges to/from vertex to prune it\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            # Remove vertex from roots if present\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        # Rebuild size count\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 8000\n        max_dist_base = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = min(max_dist_base, dist_to_sample)\n\n            # Further adapt step based on costs to encourage finer exploration near obstacles or goal\n            adaptive_step *= 0.7 + 0.3 * (1 - min(q_near.cost / 100.0, 1.0))\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrinking rewire radius to save memory and speed later on\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # Fallback to nearest vertex if viable\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            # Prune to keep memory low if vertices grow large\n            self._limit_graph_size()\n\n            # Check goal proximity with radius for early success\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
          "objective": 3730.24,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 10.32,
               "average_distance": 10.94,
               "average_smoothness": 0.35,
               "average_clearance": 2.1,
               "average_time": 0.1889,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 60.63,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -12.91,
               "average_distance_improvement": -13.25,
               "average_smoothness_improvement": -34.62,
               "average_clearance_improvement": 5.0,
               "average_time_improvement": -2385.53,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 1.2799999999999994,
               "average_memory_improvement": -62.85
          }
     },
     {
          "algorithm": "This algorithm is an improved path planner inspired by RRT* and heuristic-guided sampling.\n    It uses adaptive step size and goal-biased sampling to speed up exploration.\n    The algorithm incrementally builds a tree with rewiring to optimize path cost (like RRT*),\n    reuses a radius-based neighborhood search to improve connectivity and smoothness,\n    and employs a heuristic based on Euclidean distance to goal to guide sampling.\n    During path extraction, it attempts path shortcutting to smoothen it.\n    To ensure responsiveness, search is limited to 10 seconds.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.1       # Probability to sample goal directly\n        self._rewire_radius = 20.0  # Neighborhood radius for rewiring\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        # With probability goal_bias, sample the goal; otherwise random valid sample\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        # Return all vertices within radius of point in given list\n        near_vert = []\n        radius_sq = radius * radius\n        for v in vertices:\n            if Map.get_distance(v.position, point) <= radius:\n                near_vert.append(v)\n        return near_vert\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost equivalently distance plus movement cost from grid (might consider obstacles implicitly)\n        dist = Map.get_distance(frm.position, to.position)\n        # Movement cost from grid between positions (may differ if terrain)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose best parent vertex minimizing cost to q_new + movement cost, only if line valid\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire the tree to use q_new as intermediate for near vertices if it reduces cost\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove old parent edges, add new edge from q_new\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by skipping intermediate vertices if direct line is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Decrease j until direct connection is valid\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        # Backtrack to root start by best parent chain (assume single parent tree)\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break  # no path\n            # Choose the parent with minimal cost (should be single due to rewiring but safe check)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut smoothing\n        smoothed_path = self._shortcut_path(path)\n\n        for p in smoothed_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        max_dist = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                # Give up on path finding (not found in time)\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on distance to sample\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices for rewiring (within radius)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Choose best parent to connect q_new with\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # No suitable parent found, try q_near as fallback\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to q_new if it improves cost\n            self._rewire(near_vertices, q_new)\n\n            # Check goal reached\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Connect final goal vertex\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
          "objective": 4120.16,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 10.27,
               "average_distance": 10.93,
               "average_smoothness": 0.33,
               "average_clearance": 2.09,
               "average_time": 0.2083,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 63.1,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -12.36,
               "average_distance_improvement": -13.15,
               "average_smoothness_improvement": -26.92,
               "average_clearance_improvement": 4.5,
               "average_time_improvement": -2640.79,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 1.2699999999999996,
               "average_memory_improvement": -69.49
          }
     }
]