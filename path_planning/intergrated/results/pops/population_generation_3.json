[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "\"\"\"\n    This improved algorithm implements an Adaptive Bidirectional Informed RRT* (ABI-RRT*) inspired approach \n    that grows two trees simultaneously\u2014one from the start and one from the goal\u2014using a heuristic confined \n    informed sampling ellipse to efficiently explore the space between start and goal. \n    \n    Core ideas:\n    - Bidirectional trees merge faster, improving success rate and efficiency.\n    - Informed sampling ellipse shrinks as better solutions appear, focusing exploration.\n    - Adaptive step sizes modulated by distance to goal and obstacle proximity.\n    - Local rewiring in each tree to optimize path quality progressively.\n    - Dynamic early stopping once a valid connecting edge is found.\n    - Path extracted by joining two trees at the connecting vertices and smoothing via shortcutting.\n    - Global timeout of 10 seconds to ensure responsiveness.\n    \"\"\"",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This improved algorithm implements an Adaptive Bidirectional Informed RRT* (ABI-RRT*) inspired approach \n    that grows two trees simultaneously\u2014one from the start and one from the goal\u2014using a heuristic confined \n    informed sampling ellipse to efficiently explore the space between start and goal. \n    \n    Core ideas:\n    - Bidirectional trees merge faster, improving success rate and efficiency.\n    - Informed sampling ellipse shrinks as better solutions appear, focusing exploration.\n    - Adaptive step sizes modulated by distance to goal and obstacle proximity.\n    - Local rewiring in each tree to optimize path quality progressively.\n    - Dynamic early stopping once a valid connecting edge is found.\n    - Path extracted by joining two trees at the connecting vertices and smoothing via shortcutting.\n    - Global timeout of 10 seconds to ensure responsiveness.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._best_path_cost = float('inf')\n        self._max_iter = 8000\n        self._timeout = 10.0  # seconds\n        self._base_step = 15.0\n        self._rewire_radius = 15.0\n\n    def _heuristic(self, p: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(p, goal_pos)\n\n    def _sample_informed(self, c_min, c_best, x_center: Point, C):\n        \"\"\"\n        Sample within an n-dimensional prolate hyperspheroid (ellipse) defined by c_min and c_best \n        between start and goal to guide sampling efficiently in the promising region.\n        \"\"\"\n        import numpy as np\n\n        n = self._get_grid().size.n_dim\n        if c_best == float('inf'):\n            # No solution found yet => uniform random\n            for _ in range(50):\n                rand_coords = np.random.randint(0, self._get_grid().size, n)\n                p = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n            # fallback to some random in grid\n            return Point(*(np.random.randint(0, self._get_grid().size, n)))\n\n        # Sample from unit n-dim ball\n        while True:\n            x_ball = np.random.normal(0, 1, n)\n            x_ball /= np.linalg.norm(x_ball)\n            r = np.random.rand() ** (1.0 / n)\n            x_ball *= r\n\n            # scale the ellipse axes lengths\n            L = np.diag([c_best / 2.0] + [np.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (n - 1))\n            sample = C @ L @ x_ball + np.array(x_center)\n\n            sample_rounded = [min(max(0, int(round(coord))), self._get_grid().size[i] - 1) for i, coord in enumerate(sample)]\n            candidate = Point(*sample_rounded)\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n    def _tf_informed_sampling_transform(self, start: Point, goal: Point):\n        \"\"\"\n        Compute C matrix for transforming unit n-ball samples into the ellipse oriented between start and goal.\n        \"\"\"\n        import numpy as np\n        n = self._get_grid().size.n_dim\n        start_np = np.array(start)\n        goal_np = np.array(goal)\n        diff = goal_np - start_np\n        norm = np.linalg.norm(diff)\n        if norm == 0:\n            return np.identity(n), (start_np + goal_np) / 2.0\n\n        e1 = diff / norm\n        # Create orthonormal basis via Gram-Schmidt (only for 2D or 3D. For higher dims identity fallback)\n        U = np.identity(n)\n        U[:, 0] = e1\n        # For higher-dim extension: more complex; here fallback to identity for other dims\n        # For 2D or 3D this is sufficient as e1 is first axis\n        return U, (start_np + goal_np) / 2.0\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = self._heuristic(to_pos)\n        max_step = self._base_step\n        if dist_to_goal < 25.0:\n            # Shrink step size when near goal to improve precision\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 25.0)\n\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            # Penalize collision directions\n            max_step *= 0.5\n\n        return max_step\n\n    def _get_new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent_and_cost(self, vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best = None\n        for v in vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best = v\n        if best:\n            q_new.cost = min_cost\n        return best\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            v = stack.pop()\n            for c in v.children:\n                new_cost = v.cost + self._cost(v, c)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_bidirectional_path(self, vertex_start: Vertex, vertex_goal: Vertex) -> None:\n        # Build path from start to middle\n        path_from_start = [vertex_start]\n        v = vertex_start\n        while v != self._graph.root_vertex_start:\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n            path_from_start.append(v)\n        path_from_start.reverse()\n\n        # Build path from goal to middle\n        path_from_goal = [vertex_goal]\n        v = vertex_goal\n        while v != self._graph.root_vertex_goal:\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n            path_from_goal.append(v)\n\n        full_path = path_from_start + path_from_goal\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _vertex_connectable(self, v1: Vertex, v2: Vertex) -> bool:\n        line_seq = self._get_grid().get_line_sequence(v1.position, v2.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        c_min = Map.get_distance(start_vertex.position, goal_vertex.position)\n        c_best = float('inf')\n\n        transform_C, center = self._tf_informed_sampling_transform(start_vertex.position, goal_vertex.position)\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        def try_connect(v_start: Vertex, v_goal: Vertex):\n            if self._vertex_connectable(v_start, v_goal):\n                total_cost = v_start.cost + self._cost(v_start, v_goal) + v_goal.cost\n                return total_cost\n            return None\n\n        for iteration in range(self._max_iter):\n\n            if time.time() - start_time > self._timeout:\n                # Timeout reached, stop planning\n                break\n\n            # Alternate between trees for expansion\n            expand_from_start = (iteration % 2 == 0)\n            tree = tree_start if expand_from_start else tree_goal\n            other_tree = tree_goal if expand_from_start else tree_start\n            visited_curr = visited_start if expand_from_start else visited_goal\n            visited_other = visited_goal if expand_from_start else visited_start\n\n            # Sample within ellipse guided by current best cost\n            q_sample_point = self._sample_informed(c_min, c_best, center, transform_C)\n\n            # Find nearest vertex in current tree\n            q_near = min(tree, key=lambda v: Map.get_distance(v.position, q_sample_point))\n            if q_near.position == q_sample_point:\n                continue\n\n            # Adaptive step towards sample\n            step_max = self._generate_adaptive_step(q_near.position, q_sample_point)\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_point, step_max)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            if q_new.position in visited_curr:\n                continue\n\n            # Find nearby vertices for rewiring\n            near_radius = self._rewire_radius\n            near_vertices = [v for v in tree if Map.get_distance(v.position, q_new.position) <= near_radius]\n\n            # Choose best parent and cost\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_curr[q_new.position] = q_new\n            tree.append(q_new)\n\n            # Local rewiring\n            self._rewire_locally(q_new, near_vertices)\n\n            # Try to connect to the other tree vertices close to q_new\n            connection_radius = self._rewire_radius\n            candidates_to_connect = [v for v in other_tree if Map.get_distance(v.position, q_new.position) <= connection_radius]\n\n            found_connection = False\n            best_conn_cost = float('inf')\n            best_vertex_other = None\n\n            for v_other in candidates_to_connect:\n                conn_cost = try_connect(q_new, v_other) if expand_from_start else try_connect(v_other, q_new)\n                if conn_cost is not None and conn_cost < best_conn_cost:\n                    best_conn_cost = conn_cost\n                    best_vertex_other = v_other\n\n            if best_vertex_other is not None and best_conn_cost < c_best:\n                c_best = best_conn_cost\n                # Store path cost on q_new and best_vertex_other to reflect joint path\n                if expand_from_start:\n                    # q_new connects to best_vertex_other\n                    # Connect the two vertices bidirectionally to enable path extraction\n                    self._graph.add_edge(q_new, best_vertex_other)\n                else:\n                    self._graph.add_edge(best_vertex_other, q_new)\n\n                self._best_path_cost = c_best\n                self._extract_bidirectional_path(q_new if expand_from_start else best_vertex_other,\n                                                best_vertex_other if expand_from_start else q_new)\n                found_connection = True\n                break\n\n            self.key_frame()\n\n            if found_connection:\n                break",
          "objective": 539.565,
          "other_inf": null,
          "results": {
               "goal_found_perc": 46.0,
               "average_steps": 8.8,
               "average_distance": 9.18,
               "average_smoothness": 0.31,
               "average_clearance": 2.56,
               "average_time": 0.0047,
               "average_distance_from_goal": 5.03,
               "average_original_distance_from_goal": 8.42,
               "average memory": 39.94,
               "goal_found_perc_improvement": -52.74,
               "average_steps_improvement": -16.56,
               "average_distance_improvement": -16.06,
               "average_smoothness_improvement": -24.0,
               "average_clearance_improvement": 1.99,
               "average_time_improvement": 18.97,
               "average_distance_from_goal_improvement": -2415.0,
               "average_path_deviation": 1.2699999999999996,
               "average_memory_improvement": -7.28
          }
     },
     {
          "algorithm": "\"\"\"\n    An enhanced RRT*-inspired path planning algorithm emphasizing memory efficiency \n    and robust rapid convergence. It uses a bidirectional tree growth from start \n    and goal with heuristic guided, adaptive sampling and step sizing. The algorithm \n    dynamically shrinks the rewiring radius based on vertex density and iteration \n    progress while pruning distant vertices to control memory use tightly. Early \n    termination occurs upon connection between trees or timeout (~10s). The final \n    path undergoes shortcut smoothing for optimality. Bidirectional search, adaptive \n    step scaling, and conservative rewiring improve success rate, reduce iterations, \n    and yield smoother, shorter collision-free paths.\n    \"\"\"",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An enhanced RRT*-inspired path planning algorithm emphasizing memory efficiency \n    and robust rapid convergence. It uses a bidirectional tree growth from start \n    and goal with heuristic guided, adaptive sampling and step sizing. The algorithm \n    dynamically shrinks the rewiring radius based on vertex density and iteration \n    progress while pruning distant vertices to control memory use tightly. Early \n    termination occurs upon connection between trees or timeout (~10s). The final \n    path undergoes shortcut smoothing for optimality. Bidirectional search, adaptive \n    step scaling, and conservative rewiring improve success rate, reduce iterations, \n    and yield smoother, shorter collision-free paths.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15          # Bias for goal sampling\n        self._rewire_radius = 15.0      # Initial rewiring radius\n        self._vertex_limit = 1200       # Limit vertices to reduce memory\n        self._bidirectional = True      # Enable bidirectional search\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new_pos = Point.from_tensor(q_new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self, root_vertices: list) -> Point:\n        import random\n        # Alternate biasing between start and goal trees to balance approach\n        bias_towards_goal = random.random() < self._goal_bias\n        if bias_towards_goal:\n            # Sample near goal\n            return self._get_grid().goal.position\n        else:\n            # Uniform random sampling with validity check\n            attempts = 0\n            while attempts < 50:\n                rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            # Fallback to goal if fails repeatedly\n            return self._get_grid().goal.position\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = v.cost + self._cost(v, q_new)\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        # Restrict rewiring to vertices with better cost only\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._cost(q_new, v)\n            if cost_through_new < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_new\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, connection_from_start: Vertex, connection_from_goal: Vertex) -> None:\n        # Extract path from start tree\n        path_start = [connection_from_start]\n        current = connection_from_start\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path_start.append(current)\n        path_start.reverse()\n\n        # Extract path from goal tree\n        path_goal = [connection_from_goal]\n        current = connection_from_goal\n        while current != self._graph.root_vertex_goal:\n            if not current.children:\n                break\n            current = min(current.children, key=lambda c: c.cost)\n            path_goal.append(current)\n\n        # Combine paths at connection point\n        full_path = path_start + path_goal[1:]\n\n        # Smooth path shortcuts where possible\n        smoothed = self._shortcut_path(full_path)\n        for vertex in smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        min_radius = 4.0\n        radius = self._rewire_radius * (1 - iteration / max_iterations)\n        return max(min_radius, radius)\n\n    def _limit_graph_size(self) -> None:\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Exclude roots\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        # Sort by cost descending (remove worst)\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 7000\n        max_dist_base = self._max_dist_base\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Maintain separate vertex sets for bidirectional search\n        vertices_start = [start_vertex]\n        vertices_goal = [goal_vertex]\n\n        connected = False\n        connection_from_start = None\n        connection_from_goal = None\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            # Alternate between expanding start and goal trees\n            expand_start_tree = (iteration % 2 == 0)\n\n            root_vertices = [start_vertex] if expand_start_tree else [goal_vertex]\n            other_vertices = vertices_goal if expand_start_tree else vertices_start\n\n            sample = self._get_goal_biased_sample(root_vertices)\n\n            nearest = self._graph.get_nearest_vertex(root_vertices, sample)\n            if nearest.position == sample:\n                continue\n\n            dist_to_sample = Map.get_distance(nearest.position, sample)\n            # Adaptive step size: shorter near obstacles, longer in open areas\n            adaptive_step = min(max_dist_base, dist_to_sample)\n            adaptive_step *= 0.65 + 0.35 * (1 - min(nearest.cost / 100.0, 1.0))\n\n            new_vertex = self._get_new_vertex(nearest, sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(nearest.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrink rewire radius progressively\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius(root_vertices, new_vertex.position, cur_rewire_radius)\n            parent = self._choose_parent(near_vertices, new_vertex)\n            if parent is None:\n                # Fallback to nearest if path collision free\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    new_vertex.cost = nearest.cost + self._cost(nearest, new_vertex)\n                    parent = nearest\n                else:\n                    continue\n\n            self._graph.add_edge(parent, new_vertex)\n\n            self._rewire(near_vertices, new_vertex)\n\n            # Add new vertex to appropriate set\n            if expand_start_tree:\n                vertices_start.append(new_vertex)\n            else:\n                vertices_goal.append(new_vertex)\n\n            # Limit size to control memory\n            self._limit_graph_size()\n\n            # Check if the new vertex connects to the opposite tree within radius\n            opposite_near = self._graph.get_vertices_within_radius(\n                other_vertices, new_vertex.position, cur_rewire_radius\n            )\n            connection_vertex = None\n            min_connection_cost = float('inf')\n            for v in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(new_vertex.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    total_cost = new_vertex.cost + self._cost(new_vertex, v) + v.cost\n                    if total_cost < min_connection_cost:\n                        min_connection_cost = total_cost\n                        connection_vertex = v\n\n            if connection_vertex is not None:\n                connected = True\n                if expand_start_tree:\n                    connection_from_start = new_vertex\n                    connection_from_goal = connection_vertex\n                else:\n                    connection_from_start = connection_vertex\n                    connection_from_goal = new_vertex\n                break\n\n            self.key_frame()\n\n        if connected and connection_from_start and connection_from_goal:\n            self._extract_path(connection_from_start, connection_from_goal)",
          "objective": 908.81,
          "other_inf": null,
          "results": {
               "goal_found_perc": 9.33,
               "average_steps": 5.43,
               "average_distance": 5.35,
               "average_smoothness": 0.23,
               "average_clearance": 2.35,
               "average_time": 0.0019,
               "average_distance_from_goal": 7.55,
               "average_original_distance_from_goal": 8.42,
               "average memory": 41.63,
               "goal_found_perc_improvement": -90.41,
               "average_steps_improvement": -0.0,
               "average_distance_improvement": -0.0,
               "average_smoothness_improvement": -27.78,
               "average_clearance_improvement": -1.67,
               "average_time_improvement": 34.48,
               "average_distance_from_goal_improvement": -3675.0,
               "average_path_deviation": 0.0,
               "average_memory_improvement": -11.82
          }
     },
     {
          "algorithm": "\"\"\"\n    This algorithm combines systematic grid-aware A*-inspired heuristic guided sampling \n    with progressive subtree rewiring for fast convergence and robust connectivity. \n    \n    Key features:\n    - Uses a priority queue (min-heap) over vertices based on f = g + h costs for expansion.\n    - Samples new nodes biased towards frontier areas near current best paths (heuristic frontier sampling).\n    - Adaptive step length modulated by distance-to-goal and obstacle proximity.\n    - Incremental local rewiring within dynamically chosen neighborhoods to optimize paths.\n    - Early termination upon reaching goal within defined radius.\n    - Incorporates path smoothing via shortcutting on final extracted path.\n    - Enforces a global timeout of 10 seconds.\n    \"\"\"",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This algorithm combines systematic grid-aware A*-inspired heuristic guided sampling \n    with progressive subtree rewiring for fast convergence and robust connectivity. \n    \n    Key features:\n    - Uses a priority queue (min-heap) over vertices based on f = g + h costs for expansion.\n    - Samples new nodes biased towards frontier areas near current best paths (heuristic frontier sampling).\n    - Adaptive step length modulated by distance-to-goal and obstacle proximity.\n    - Incremental local rewiring within dynamically chosen neighborhoods to optimize paths.\n    - Early termination upon reaching goal within defined radius.\n    - Incorporates path smoothing via shortcutting on final extracted path.\n    - Enforces a global timeout of 10 seconds.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap = []               # Min-heap for frontier vertices (f = g + h)\n        self._max_iter = 6000         # Max iterations before timeout/failure\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0          # seconds limit\n        self._base_step = 12.0        # Base adaptive step distance\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 1200\n\n    def _heuristic(self, pos: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(pos, goal_pos)\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = self._heuristic(to_pos)\n        # Step shrinks near goal and obstacles to improve precision\n        max_step = self._base_step\n        # Reduce step near goal radius\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n        # Check obstacle proximity along direction, reduce step if near\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5  # Penalize invalid/obstacle-filled directions with smaller step\n        return max_step\n\n    def _get_new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _get_frontier_sample(self) -> Point:\n        # Sample near frontier vertices in the heap using Gaussian jitter to guide exploration\n        import random\n        import numpy as np\n        if not self._heap:\n            # fallback random valid sample in environment\n            for _ in range(50):\n                rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        f_min_vertex = self._heap[0][1]\n        base_pos = f_min_vertex.position\n\n        dim = self._get_grid().size.n_dim\n        std_dev = 8.0  # exploration jitter scale\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(self._get_grid().size[i]-1, int(round(val))))\n            jittered_coords.append(val)\n\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n        else:\n            # fallback to goal biased sampling for valid position\n            return self._get_goal_biased_sample()\n\n    def _goal_biased_sample(self) -> Point:\n        import random\n        # Slight goal bias for direct attraction but mostly frontier sampling is used\n        if random.random() < 0.2:\n            return self._get_grid().goal.position\n        else:\n            return self._get_frontier_sample()\n\n    def _choose_parent_and_cost(self, near_vertices, q_new: Vertex) -> Vertex:\n        # Choose best parent minimizing cost + heuristic\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        # Attempt local rewiring in neighbors to reduce path cost\n        for v in neighbors:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                # Remove all parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                # Additionally update costs downstream in DFS fashion to propagate gains\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            current = stack.pop()\n            for child in current.children:\n                new_cost = current.cost + self._cost(current, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_excess_vertices(self) -> None:\n        # Prune vertices with highest cost or furthest from goal when size exceeds limit\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n        # Ignore start and goal vertices\n        candidates = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        if not candidates:\n            return\n\n        # Sort primarily by distance to goal + cost descending to prune worst vertices\n        goal_pos = self._get_grid().goal.position\n        def prune_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n        candidates = sorted(candidates, key=prune_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n        start_f = self._heuristic(start_vertex.position)\n        self._heap = []\n        heapq.heappush(self._heap, (start_f, start_vertex))\n\n        visited_positions = set()\n        visited_positions.add(start_vertex.position)\n\n        start_time = time.time()\n\n        iterations = 0\n\n        while self._heap and iterations < self._max_iter:\n            iterations += 1\n\n            if time.time() - start_time > self._timeout:\n                # Timeout condition: no path found within time limit\n                break\n\n            _, current_vertex = heapq.heappop(self._heap)\n\n            # Early success check\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=current_vertex.position, goal=self._get_grid().goal):\n                # Connect to goal directly if possible\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(current_vertex.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = current_vertex.cost + self._cost(current_vertex, q_goal)\n                    self._graph.add_edge(current_vertex, q_goal)\n                    self._extract_path(q_goal)\n                break\n\n            # Generate new sample biased by current frontiers\n            q_sample_pos = self._goal_biased_sample()\n\n            # Find nearest vertex to sample in graph\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n\n            if q_near.position == q_sample_pos:\n                continue\n\n            adaptive_step = self._generate_adaptive_step(q_near.position, q_sample_pos)\n\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n\n            # Validate path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Prevent duplicating vertices in same position\n            if q_new.position in visited_positions:\n                continue\n\n            # Find local neighbors for cost computation and rewiring\n            rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback: connect to nearest if feasible\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_positions.add(q_new.position)\n\n            # Insert new vertex into the heap with f = g + h for future expansions\n            f_q_new = q_new.cost + self._heuristic(q_new.position)\n            heapq.heappush(self._heap, (f_q_new, q_new))\n\n            # Attempt local rewiring to optimize paths close to q_new\n            self._rewire_locally(q_new, near_vertices)\n\n            # Prune excess vertices for memory and speed\n            self._prune_excess_vertices()\n\n            self.key_frame()",
          "objective": 924.485,
          "other_inf": null,
          "results": {
               "goal_found_perc": 20.0,
               "average_steps": 6.47,
               "average_distance": 6.46,
               "average_smoothness": 0.23,
               "average_clearance": 3.42,
               "average_time": 0.01,
               "average_distance_from_goal": 7.22,
               "average_original_distance_from_goal": 8.42,
               "average memory": 21.12,
               "goal_found_perc_improvement": -79.45,
               "average_steps_improvement": -2.7,
               "average_distance_improvement": -1.89,
               "average_smoothness_improvement": -15.0,
               "average_clearance_improvement": -0.58,
               "average_time_improvement": -132.56,
               "average_distance_from_goal_improvement": -3510.0,
               "average_path_deviation": 0.1200000000000001,
               "average_memory_improvement": 43.27
          }
     },
     {
          "algorithm": "This improved algorithm extends the A*-inspired heuristic guided sampling path planner\n    by integrating a dual-tree bidirectional search that grows trees from both start and goal,\n    enabling faster connection and increased success rates. \n\n    Key improvements:\n    - Bidirectional tree growth (start and goal) with inter-tree connection attempts each iteration.\n    - Dynamic adaptive step size based on obstacle proximity and distance to goal/start.\n    - Enhanced goal and start biased sampling with Gaussian jitter around frontier vertices.\n    - Local rewiring in both trees to incrementally refine paths and reduce costs.\n    - Early stopping once connection between trees is established inside radius.\n    - Post path extraction smoothing via shortcutting to improve path quality and smoothness.\n    - Timeout of 10 seconds enforces robust termination.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []         # Min-heap for frontier vertices from start (f = g + h)\n        self._heap_goal = []          # Min-heap for frontier vertices from goal (f = g + h)\n        self._max_iter = 6000\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 20.0\n        self._vertex_prune_limit = 1200\n\n    def _heuristic(self, pos: Point, target: Point) -> float:\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = Map.get_distance(to_pos, self._graph.root_vertex_goal.position)\n        max_step = self._base_step\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n        return max_step\n\n    def _get_new_vertex(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _sample_near_frontier(self, heap: list) -> Point:\n        import random\n        import numpy as np\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n        std_dev = 7.0  # slightly smaller jitter for tighter sampling\n\n        if not heap:\n            # fallback random uniform valid sampling\n            for _ in range(50):\n                rand_coords = np.random.randint(0, grid_size, dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        best_vertex = heap[0][1]\n        base_pos = best_vertex.position\n\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            jittered_coords.append(val)\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n\n        # fallback: random near root vertices if frontier sample invalid\n        # pick random root vertex position plus small gaussian\n        roots = [v.position for v in [self._graph.root_vertex_start, self._graph.root_vertex_goal]]\n        fallback_base = random.choice(roots)\n        fallback_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = fallback_base[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            fallback_coords.append(val)\n        fallback_sample = Point(*fallback_coords)\n        if self._get_grid().is_agent_valid_pos(fallback_sample):\n            return fallback_sample\n\n        # Final fallback: goal position, guaranteed valid\n        return self._get_grid().goal.position\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex, root_vertex: Vertex) -> Vertex:\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position, root_vertex.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        path_start = []\n        curr = connect_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n            curr = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n            curr = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        # Concatenate start and goal paths crossing the connection edge\n        full_path = path_start + path_goal\n\n        # Shortcut and smooth the path\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list) -> None:\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n\n        # Candidates excluding roots\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def sort_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n        candidates_sorted = sorted(candidates, key=sort_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n        # Also prune heaps accordingly\n        def prune_heap(heap):\n            filtered_heap = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered_heap:\n                heap.append(item)\n\n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        heapq.heapify(self._heap_start)\n        heapq.heapify(self._heap_goal)\n\n        self._heap_start = []\n        self._heap_goal = []\n\n        heapq.heappush(self._heap_start, (self._heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_v.position, start_v.position), goal_v))\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        start_time = time.time()\n        iterations = 0\n\n        # Alternate expansions from start and goal trees\n        expand_from_start = True\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                break\n\n            if expand_from_start and self._heap_start:\n                _, current_v = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opposite_visited = visited_goal\n                current_visited = visited_start\n                current_heap = self._heap_start\n            elif (not expand_from_start) and self._heap_goal:\n                _, current_v = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opposite_visited = visited_start\n                current_visited = visited_goal\n                current_heap = self._heap_goal\n            else:\n                # if one heap is empty, switch\n                expand_from_start = not expand_from_start\n                continue\n\n            # Sample around frontier in current tree\n            sample_pos = self._sample_near_frontier(current_heap)\n\n            # Find nearest vertex in current tree\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            rewire_r = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vs = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_r)\n\n            best_parent = self._choose_best_parent(near_vs, q_new, tree_root)\n            if not best_parent:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    expand_from_start = not expand_from_start\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n            f_q_new = q_new.cost + self._heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_q_new, q_new))\n\n            self._rewire_neighbors(q_new, near_vs)\n            self._prune_vertices(self._heap_start, self._heap_goal)\n\n            # Check connection to opposite tree vertices within small radius\n            connection_radius = self._goal_radius\n            opposite_near = self._graph.get_vertices_within_radius([goal_v if expand_from_start else start_v], q_new.position, connection_radius)\n\n            connected_vertex_opposite = None\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                connected_vertex_opposite = v_opp\n                break\n\n            if connected_vertex_opposite:\n                # Connect the two trees\n                if expand_from_start:\n                    self._graph.add_edge(q_new, connected_vertex_opposite)\n                    self._extract_bidirectional_path(q_new, connected_vertex_opposite)\n                else:\n                    self._graph.add_edge(connected_vertex_opposite, q_new)\n                    self._extract_bidirectional_path(connected_vertex_opposite, q_new)\n                break\n\n            expand_from_start = not expand_from_start",
          "objective": 2446.2,
          "other_inf": null,
          "results": {
               "goal_found_perc": 5.33,
               "average_steps": 9.75,
               "average_distance": 10.87,
               "average_smoothness": 0.37,
               "average_clearance": 4.17,
               "average_time": 0.0659,
               "average_distance_from_goal": 7.89,
               "average_original_distance_from_goal": 8.42,
               "average memory": 31.46,
               "goal_found_perc_improvement": -94.52,
               "average_steps_improvement": -13.11,
               "average_distance_improvement": -18.41,
               "average_smoothness_improvement": -85.0,
               "average_clearance_improvement": 10.9,
               "average_time_improvement": -980.33,
               "average_distance_from_goal_improvement": -3845.0,
               "average_path_deviation": 1.6899999999999995,
               "average_memory_improvement": 15.5
          }
     },
     {
          "algorithm": "\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15        # Slightly higher goal bias for focused sampling\n        self._rewire_radius = 15.0    # Shrinking rewire radius for better memory\n        self._vertex_limit = 1500     # Limit max vertices for memory efficiency\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            attempts = 0\n            while attempts < 50:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            # fallback to goal if sampling fails repeatedly\n            return self._get_grid().goal.position\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove all existing parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"Shrink rewire radius over time for efficiency and memory.\"\"\"\n        min_radius = 5.0\n        radius = self._rewire_radius * (1.0 - iteration / max_iterations)\n        return max(radius, min_radius)\n\n    def _limit_graph_size(self) -> None:\n        \"\"\"Limit max vertex count in graph for memory efficiency by pruning farthest or high cost vertices.\"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Sort vertices by cost descending, skip root start and goal\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            # Remove all edges to/from vertex to prune it\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            # Remove vertex from roots if present\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        # Rebuild size count\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 8000\n        max_dist_base = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = min(max_dist_base, dist_to_sample)\n\n            # Further adapt step based on costs to encourage finer exploration near obstacles or goal\n            adaptive_step *= 0.7 + 0.3 * (1 - min(q_near.cost / 100.0, 1.0))\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrinking rewire radius to save memory and speed later on\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # Fallback to nearest vertex if viable\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            # Prune to keep memory low if vertices grow large\n            self._limit_graph_size()\n\n            # Check goal proximity with radius for early success\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
          "objective": 3730.24,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 10.32,
               "average_distance": 10.94,
               "average_smoothness": 0.35,
               "average_clearance": 2.1,
               "average_time": 0.1889,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 60.63,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -12.91,
               "average_distance_improvement": -13.25,
               "average_smoothness_improvement": -34.62,
               "average_clearance_improvement": 5.0,
               "average_time_improvement": -2385.53,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 1.2799999999999994,
               "average_memory_improvement": -62.85
          }
     },
     {
          "algorithm": "\"\"\"\n    This improved PathPlanning algorithm enhances the bidirectional heuristic-guided sampling \n    search by introducing several key improvements aimed at better smoothness, efficiency, and robustness:\n\n      - Adaptive goal and start biased sampling with dynamic Gaussian jitter influenced by iteration progress,\n        concentrating samples near promising frontier vertices.\n      - Smarter adaptive step size considering proximity to obstacles and distance to both start and goal,\n        encouraging safer and more efficient expansions.\n      - Bidirectional RRT*-style rewiring with incremental local optimization of both trees to refine costs and paths.\n      - More aggressive pruning of vertices beyond a threshold to maintain tree manageability and efficiency.\n      - Early stopping triggered upon tree connection with a well-validated edge and a timeout of 10 seconds.\n      - Post-connection path extraction followed by iterative smoothing with shortcutting and local shortcut retries,\n        resulting in smoother, shorter, and more reliable paths.\n      - Consistent keyframe marking and agent movement updates for visualization support.\n\n    Together, these augmentations aim to produce faster, more reliable plan generation capable of producing high-quality,\n    smooth paths in complex grid environments.\n    \"\"\"",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []  # Min-heap for frontier vertices from start (f = g + h)\n        self._heap_goal = []  # Min-heap for frontier vertices from goal (f = g + h)\n        self._max_iter = 6000\n        self._goal_radius = (\n            self._get_grid().goal.radius if hasattr(self._get_grid().goal, \"radius\") else 5.0\n        )\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 20.0\n        self._vertex_prune_limit = 1200\n\n\n    def _heuristic(self, pos: Point, target: Point) -> float:\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        \"\"\"\n        Adaptive step size considers distance to goal and start,\n        reduces step when close to obstacles or close to start/goal,\n        encouraging finer expansions near critical regions.\n        \"\"\"\n        dist_to_goal = Map.get_distance(to_pos, self._graph.root_vertex_goal.position)\n        dist_to_start = Map.get_distance(to_pos, self._graph.root_vertex_start.position)\n        max_step = self._base_step\n\n        # Scale step down near goal or start for precise navigation\n        min_dist = min(dist_to_goal, dist_to_start)\n        if min_dist < 20.0:\n            factor = 0.3 + 0.7 * (min_dist / 20.0)\n            max_step *= factor\n\n        # Check obstacle proximity by line validity\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n\n        return max_step\n\n    def _get_new_vertex(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _sample_biased(self, heap: list, iteration: int) -> Point:\n        \"\"\"\n        Improved sampling around frontier vertices with dynamically decreasing Gaussian jitter,\n        biased towards goal or start depending on the tree.\n        Falls back to random uniform or goal if invalid.\n        \"\"\"\n        import random\n        import numpy as np\n\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n\n        # Dynamic std dev reduces over iterations for finer sampling later\n        std_dev_base = 10.0\n        decay_factor = max(0.1, 1.0 - iteration / (self._max_iter * 0.8))\n        std_dev = std_dev_base * decay_factor\n\n        if not heap:\n            # fallback random uniform valid sampling\n            for _ in range(50):\n                rand_coords = np.random.randint(0, grid_size, dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        best_vertex = heap[0][1]\n        base_pos = best_vertex.position\n\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            jittered_coords.append(val)\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n\n        # fallback sampling near root vertices with small jitter\n        roots = [v.position for v in [self._graph.root_vertex_start, self._graph.root_vertex_goal]]\n        fallback_base = random.choice(roots)\n        fallback_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev / 2)\n            val = fallback_base[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            fallback_coords.append(val)\n        fallback_sample = Point(*fallback_coords)\n        if self._get_grid().is_agent_valid_pos(fallback_sample):\n            return fallback_sample\n\n        # Final fallback to goal position guaranteed valid\n        return self._get_grid().goal.position\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex, root_vertex: Vertex) -> Vertex:\n        min_total = float(\"inf\")\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position, root_vertex.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        path_start = []\n        curr = connect_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n            curr = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n            curr = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        # Concatenate start and goal paths crossing the connection edge\n        full_path = path_start + path_goal\n\n        # Iterative smoothing: multiple rounds of shortcutting for better smoothness\n        smoothed_path = full_path\n        for _ in range(3):\n            smoothed_path = self._shortcut_path(smoothed_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list) -> None:\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n\n        # Candidates excluding root vertices\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def sort_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n\n        candidates_sorted = sorted(candidates, key=sort_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n        # Prune heaps to keep consistency\n        def prune_heap(heap):\n            filtered_heap = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered_heap:\n                heap.append(item)\n\n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        self._heap_start = []\n        self._heap_goal = []\n        heapq.heapify(self._heap_start)\n        heapq.heapify(self._heap_goal)\n\n        # Initialize heaps with roots\n        heapq.heappush(self._heap_start, (self._heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_v.position, start_v.position), goal_v))\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        start_time = time.time()\n        iterations = 0\n        expand_from_start = True\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                # Timeout reached - no path found reliably in time\n                break\n\n            if expand_from_start and self._heap_start:\n                _, current_v = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opposite_root = goal_v\n                opposite_visited = visited_goal\n                current_visited = visited_start\n                current_heap = self._heap_start\n            elif (not expand_from_start) and self._heap_goal:\n                _, current_v = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opposite_root = start_v\n                opposite_visited = visited_start\n                current_visited = visited_goal\n                current_heap = self._heap_goal\n            else:\n                expand_from_start = not expand_from_start\n                continue\n\n            # Sample around frontier with bias and iteration-based tuning\n            sample_pos = self._sample_biased(current_heap, iterations)\n\n            # Find nearest vertex from current tree\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            # Rewiring radius decreases over time but not below minimum\n            rewire_r = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vs = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_r)\n\n            best_parent = self._choose_best_parent(near_vs, q_new, tree_root)\n            if not best_parent:\n                # If no best parent from rewire neighbors, consider nearest vertex if valid line\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    expand_from_start = not expand_from_start\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n            f_q_new = q_new.cost + self._heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_q_new, q_new))\n\n            # Rewire neighbors for local cost improvement\n            self._rewire_neighbors(q_new, near_vs)\n\n            # Prune vertices to control tree size and improve efficiency\n            self._prune_vertices(self._heap_start, self._heap_goal)\n\n            # Attempt to connect to opposite tree close vertices with robust line checking\n            connection_radius = self._goal_radius\n            opposite_near = self._graph.get_vertices_within_radius([opposite_root], q_new.position, connection_radius)\n\n            connected_vertex_opposite = None\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                connected_vertex_opposite = v_opp\n                break\n\n            if connected_vertex_opposite:\n                # Connect two trees with edge depending on expansion direction\n                if expand_from_start:\n                    self._graph.add_edge(q_new, connected_vertex_opposite)\n                    self._extract_bidirectional_path(q_new, connected_vertex_opposite)\n                else:\n                    self._graph.add_edge(connected_vertex_opposite, q_new)\n                    self._extract_bidirectional_path(connected_vertex_opposite, q_new)\n                break\n\n            expand_from_start = not expand_from_start",
          "objective": 3962.045,
          "other_inf": null,
          "results": {
               "goal_found_perc": 8.0,
               "average_steps": 7.92,
               "average_distance": 7.99,
               "average_smoothness": 0.32,
               "average_clearance": 4.23,
               "average_time": 0.1156,
               "average_distance_from_goal": 7.85,
               "average_original_distance_from_goal": 8.42,
               "average memory": 32.22,
               "goal_found_perc_improvement": -91.78,
               "average_steps_improvement": -8.05,
               "average_distance_improvement": -9.45,
               "average_smoothness_improvement": -3.23,
               "average_clearance_improvement": -0.7,
               "average_time_improvement": -2040.74,
               "average_distance_from_goal_improvement": -3825.0,
               "average_path_deviation": 0.6900000000000004,
               "average_memory_improvement": 13.46
          }
     },
     {
          "algorithm": "This algorithm is an improved path planner inspired by RRT* and heuristic-guided sampling.\n    It uses adaptive step size and goal-biased sampling to speed up exploration.\n    The algorithm incrementally builds a tree with rewiring to optimize path cost (like RRT*),\n    reuses a radius-based neighborhood search to improve connectivity and smoothness,\n    and employs a heuristic based on Euclidean distance to goal to guide sampling.\n    During path extraction, it attempts path shortcutting to smoothen it.\n    To ensure responsiveness, search is limited to 10 seconds.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.1       # Probability to sample goal directly\n        self._rewire_radius = 20.0  # Neighborhood radius for rewiring\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        # With probability goal_bias, sample the goal; otherwise random valid sample\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        # Return all vertices within radius of point in given list\n        near_vert = []\n        radius_sq = radius * radius\n        for v in vertices:\n            if Map.get_distance(v.position, point) <= radius:\n                near_vert.append(v)\n        return near_vert\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost equivalently distance plus movement cost from grid (might consider obstacles implicitly)\n        dist = Map.get_distance(frm.position, to.position)\n        # Movement cost from grid between positions (may differ if terrain)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose best parent vertex minimizing cost to q_new + movement cost, only if line valid\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire the tree to use q_new as intermediate for near vertices if it reduces cost\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove old parent edges, add new edge from q_new\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by skipping intermediate vertices if direct line is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Decrease j until direct connection is valid\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        # Backtrack to root start by best parent chain (assume single parent tree)\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break  # no path\n            # Choose the parent with minimal cost (should be single due to rewiring but safe check)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut smoothing\n        smoothed_path = self._shortcut_path(path)\n\n        for p in smoothed_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        max_dist = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                # Give up on path finding (not found in time)\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on distance to sample\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices for rewiring (within radius)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Choose best parent to connect q_new with\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # No suitable parent found, try q_near as fallback\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to q_new if it improves cost\n            self._rewire(near_vertices, q_new)\n\n            # Check goal reached\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Connect final goal vertex\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
          "objective": 4120.16,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 10.27,
               "average_distance": 10.93,
               "average_smoothness": 0.33,
               "average_clearance": 2.09,
               "average_time": 0.2083,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 63.1,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -12.36,
               "average_distance_improvement": -13.15,
               "average_smoothness_improvement": -26.92,
               "average_clearance_improvement": 4.5,
               "average_time_improvement": -2640.79,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 1.2699999999999996,
               "average_memory_improvement": -69.49
          }
     }
]