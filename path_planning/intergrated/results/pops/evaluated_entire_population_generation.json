{
     "algorithm": "This algorithm is an improved RRT* inspired method that incorporates goal-biased sampling,\n    heuristic guided vertex selection, adaptive step length, and rewiring for continuous path cost optimization.\n    It uses a Forest graph structure rooted at start with incremental vertex insertion.\n    Key improvements:\n    - Goal-bias in sampling guides exploration towards goal.\n    - Adaptive max step size based on distance to nearest vertex and goal.\n    - Heuristic (cost + distance-to-goal) to select parents for new vertex, improving path quality.\n    - Rewiring nearby vertices around new vertex to reduce path cost (like RRT*).\n    - Shortcut smoothing applied after path found for smoother routes.\n    - Early termination if path cost no longer improves or if 30s timeout reached.\n    This balances exploration, path quality, and computational efficiency for improved planning performance.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _iterations: int\n    _goal_sample_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n\n        self._max_dist_base = 12.0  # base adaptive max step length\n        self._iterations = 8000\n        self._goal_sample_rate = 0.2  # probability of sampling goal to bias towards it\n        self._rewire_radius = 20.0\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        from random import random\n        if random() < self._goal_sample_rate:\n            # With some probability sample goal directly\n            return self._graph.root_vertex_goal.position\n        else:\n            while True:\n                sample = Point(*[\n                    torch.randint(0, self._get_grid().size[i], (1,)).item()\n                    for i in range(self._get_grid().size.n_dim)\n                ])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, point)\n\n    def _get_dist(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _get_adaptive_max_dist(self, q_near: Vertex, q_rand: Point) -> float:\n        d_to_goal = self._get_dist(q_near.position, self._graph.root_vertex_goal.position)\n        d_to_rand = self._get_dist(q_near.position, q_rand)\n        max_dist = min(self._max_dist_base, max(d_to_rand * 0.75, 5.0), d_to_goal * 0.75)\n        if max_dist < 1.0:\n            max_dist = 1.0\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / norm\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos)\n\n    def _line_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose parent to minimize cost + heuristic-to-goal\n        best_parent = None\n        best_cost = float('inf')\n        for v in near_vertices:\n            if v.position == q_new.position:\n                continue\n            if self._line_valid(v.position, q_new.position):\n                cost_v = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n                heuristic = self._get_dist(q_new.position, self._graph.root_vertex_goal.position)\n                total_cost = cost_v + heuristic\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire near vertices for lower cost paths through q_new\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if self._line_valid(q_new.position, v.position):\n                cost_through_qnew = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n                if cost_through_qnew < v.cost:\n                    # Change parent edge\n                    # Remove old parent edges:\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    # Add new edge\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_qnew\n\n    def _extract_path(self) -> None:\n        path: List[Vertex] = []\n        current = self._graph.root_vertex_goal\n\n        # Trace back to start by choosing minimum cost parent\n        while current != self._graph.root_vertex_start:\n            path.append(current)\n            # Choose parent with minimal cost\n            if not current.parents:\n                # Fail-safe if no parent (break infinite)\n                break\n            current = min(current.parents, key=lambda p: p.cost + self._get_dist(p.position, current.position))\n        path.append(self._graph.root_vertex_start)\n        path.reverse()\n\n        # Shortcut smoothing - try to remove unnecessary intermediate nodes\n        path = self._smooth_path(path)\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut by skipping intermediate vertices if direct connection is collision free\n        if len(path) < 3:\n            return path\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1  # try to connect as far as possible\n            while next_idx > idx + 1:\n                if self._line_valid(path[idx].position, path[next_idx].position):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for i in range(self._iterations):\n            if time.time() - start_time > 30.0:\n                # timeout reached, stop planning without path\n                return\n\n            q_rand: Point = self._get_random_sample()\n            q_near: Vertex = self._get_nearest_vertex(self._graph.root_vertices, q_rand)\n\n            max_dist: float = self._get_adaptive_max_dist(q_near, q_rand)\n            q_new: Vertex = self._get_new_vertex(q_near, q_rand, max_dist)\n\n            if not self._line_valid(q_near.position, q_new.position):\n                continue\n\n            # Find near vertices within radius for rewiring and parent choosing\n            near_vertices: List[Vertex] = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n\n            # Choose best parent based on cost+heuristic\n            parent_vertex = self._choose_parent(near_vertices + [q_near], q_new)\n            if parent_vertex is None:\n                parent_vertex = q_near\n\n            # Set cost and add vertex and edge\n            q_new.cost = parent_vertex.cost + self._get_grid().get_movement_cost(parent_vertex.position, q_new.position)\n            self._graph.root_vertices.append(q_new)\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire neighbors to improve path cost\n            self._rewire(near_vertices, q_new)\n\n            # Early check if new vertex reached goal or close enough\n            if self._get_dist(q_new.position, self._graph.root_vertex_goal.position) < self._max_dist_base:\n                if self._line_valid(q_new.position, self._graph.root_vertex_goal.position):\n                    # Connect goal directly if possible\n                    if self._graph.root_vertex_goal.cost > q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position):\n                        # Remove old parent edges of goal\n                        for p in list(self._graph.root_vertex_goal.parents):\n                            self._graph.remove_edge(p, self._graph.root_vertex_goal)\n                        self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                        self._graph.root_vertex_goal.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n\n            # Terminate early if goal is connected and path cost is finite\n            if self._graph.root_vertex_goal.cost < float('inf'):\n                self._extract_path()\n                return\n\n            self.key_frame() ",
     "objective": 2635.905,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 10.73,
          "average_distance": 11.53,
          "average_smoothness": 0.35,
          "average_clearance": 2.11,
          "average_time": 0.1375,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "steps_alldata": [
               11,
               17,
               14,
               4,
               10,
               18,
               18,
               15,
               10,
               3,
               12,
               12,
               4,
               20,
               4,
               9,
               19,
               19,
               16,
               17,
               12,
               6,
               6,
               13,
               8,
               18,
               13,
               15,
               6,
               9,
               20,
               8,
               4,
               13,
               7,
               20,
               13,
               7,
               13,
               12,
               16,
               10,
               10,
               12,
               6,
               25,
               12,
               11,
               8,
               7,
               19,
               13,
               5,
               9,
               6,
               5,
               11,
               15,
               4,
               14,
               10,
               11,
               7,
               6,
               7,
               15,
               4,
               10,
               3,
               10,
               12,
               10,
               5,
               10,
               23,
               15,
               5,
               14,
               15,
               13,
               11,
               15,
               2,
               12,
               9,
               14,
               10,
               10,
               18,
               16,
               10,
               12,
               10,
               19,
               2,
               4,
               7,
               28,
               11,
               15,
               3,
               11,
               5,
               10,
               11,
               13,
               15,
               7,
               5,
               14,
               7,
               22,
               5,
               11,
               6,
               10,
               9,
               3,
               3,
               10,
               9,
               9,
               10,
               18,
               6,
               15,
               10,
               4,
               9,
               10,
               3,
               14,
               10,
               2,
               16,
               3,
               6,
               2,
               16,
               9,
               6,
               19,
               17,
               23,
               4,
               3
          ],
          "distance_alldata": [
               11.242640614509583,
               18.899494767189026,
               17.55634891986847,
               3.414213538169861,
               11.899494767189026,
               20.727921843528748,
               19.485281229019165,
               17.727921843528748,
               12.313708305358887,
               2.8284270763397217,
               11.828427076339722,
               13.071067690849304,
               3.8284270763397217,
               23.97056245803833,
               4.2426406145095825,
               10.485281229019165,
               20.899494767189026,
               22.14213538169861,
               16.242640614509583,
               18.899494767189026,
               13.899494767189026,
               7.071067690849304,
               5.828427076339722,
               13.242640614509583,
               7.828427076339722,
               19.485281229019165,
               13.656854152679443,
               17.313708305358887,
               6.2426406145095825,
               9.656854152679443,
               22.727921843528748,
               8.656854152679443,
               3.0,
               15.313708305358887,
               7.2426406145095825,
               21.071067690849304,
               13.656854152679443,
               7.2426406145095825,
               13.242640614509583,
               14.313708305358887,
               19.14213538169861,
               10.656854152679443,
               9.828427076339722,
               12.656854152679443,
               5.828427076339722,
               25.242640614509583,
               12.242640614509583,
               12.071067690849304,
               8.656854152679443,
               6.828427076339722,
               20.071067690849304,
               14.899494767189026,
               4.0,
               10.899494767189026,
               5.414213538169861,
               5.2426406145095825,
               11.242640614509583,
               16.071067690849304,
               3.414213538169861,
               13.828427076339722,
               11.485281229019165,
               12.899494767189026,
               6.0,
               6.656854152679443,
               6.414213538169861,
               15.242640614509583,
               4.2426406145095825,
               11.071067690849304,
               2.414213538169861,
               9.41421353816986,
               13.485281229019165,
               11.071067690849304,
               5.2426406145095825,
               10.242640614509583,
               24.899494767189026,
               16.899494767189026,
               5.2426406145095825,
               14.656854152679443,
               17.313708305358887,
               12.41421353816986,
               10.41421353816986,
               17.727921843528748,
               1.4142135381698608,
               13.071067690849304,
               9.242640614509583,
               14.656854152679443,
               11.899494767189026,
               11.071067690849304,
               19.071067690849304,
               16.656854152679443,
               11.071067690849304,
               11.0,
               9.41421353816986,
               22.97056245803833,
               1.4142135381698608,
               3.8284270763397217,
               7.2426406145095825,
               28.656854152679443,
               13.313708305358887,
               18.97056245803833,
               2.0,
               12.899494767189026,
               5.2426406145095825,
               9.828427076339722,
               10.41421353816986,
               14.485281229019165,
               16.899494767189026,
               7.656854152679443,
               4.414213538169861,
               14.656854152679443,
               8.485281229019165,
               23.485281229019165,
               5.2426406145095825,
               12.899494767189026,
               7.071067690849304,
               12.313708305358887,
               10.071067690849304,
               2.414213538169861,
               2.8284270763397217,
               10.242640614509583,
               10.899494767189026,
               8.828427076339722,
               11.899494767189026,
               20.313708305358887,
               5.0,
               17.727921843528748,
               10.242640614509583,
               3.414213538169861,
               9.656854152679443,
               9.828427076339722,
               2.8284270763397217,
               14.656854152679443,
               11.071067690849304,
               1.0,
               17.485281229019165,
               2.414213538169861,
               5.414213538169861,
               1.0,
               15.41421353816986,
               9.656854152679443,
               7.071067690849304,
               22.55634891986847,
               19.727921843528748,
               24.071067690849304,
               4.2426406145095825,
               2.0
          ],
          "smoothness_alldata": [
               0.5711986611773677,
               0.6929983764481712,
               0.28049934529296516,
               0.3926990902558596,
               0.39269908341015125,
               0.5235987794014701,
               0.4363323129985824,
               0.31415926307707653,
               0.07853981462831774,
               0.0,
               0.3926990874034811,
               0.4581489215175653,
               0.3926990731415887,
               0.5497787212239222,
               0.0,
               0.26179938209439246,
               0.5373776844403647,
               0.49604094890665595,
               0.39269907528087256,
               0.5543987035746694,
               0.4581489215175653,
               0.0,
               0.5235987641887849,
               0.18124573133127814,
               0.3926990731415887,
               0.6981317046009033,
               0.362491454763662,
               0.4712389037432259,
               0.6544984609407382,
               0.6108652515091149,
               0.1963495434165027,
               0.6872233779977802,
               0.0,
               0.4833219414401925,
               0.33659920554993317,
               0.5105088019297737,
               0.4229067020513744,
               0.5609986856961386,
               0.3624914521306973,
               0.327249236175126,
               0.44178647653784203,
               0.5497787126667867,
               0.39269908341015125,
               0.5235987641887849,
               0.5235987641887849,
               0.3769911170616335,
               0.3926990731415887,
               0.3569991729598723,
               0.49087384142698587,
               0.44879896029241095,
               0.3306939599327633,
               0.5437371887279049,
               0.0,
               0.3490658427925233,
               0.13089969104719623,
               0.314159258513271,
               0.3569991729598723,
               0.7330382881195213,
               0.3926990731415887,
               0.4487989505128276,
               0.4712389083070315,
               0.42839900755184684,
               0.0,
               0.26179938209439246,
               0.22439948014620548,
               0.47123890146132313,
               0.0,
               0.628318517026542,
               0.2617993935039064,
               0.3141592687818335,
               0.4581489186651868,
               0.5497787263582035,
               0.314159258513271,
               0.4712389083070315,
               0.3756252063490921,
               0.47123890146132313,
               0.314159258513271,
               0.16829960277496658,
               0.5235987755982988,
               0.24166097598602576,
               0.1427996629605777,
               0.6806784048549344,
               0.0,
               0.4581489386318362,
               0.6981316969945605,
               0.16829960277496658,
               0.3141592653589793,
               0.2356194438849532,
               0.5235987774998845,
               0.4908738564019729,
               0.5497787229353492,
               0.0,
               0.15707963610234382,
               0.5787144271800826,
               0.0,
               0.3926990731415887,
               0.33659921532951653,
               0.2804993489603089,
               0.3569991667365011,
               0.3141592676408821,
               0.0,
               0.28559933214452665,
               0.31415927220468765,
               0.314159258513271,
               0.2141994975525522,
               0.4229067073173039,
               0.26179939122200363,
               0.4487989407332442,
               0.31415927220468765,
               0.5609986783614511,
               0.2243994703666221,
               0.2855993352562123,
               0.31415927220468765,
               0.42839900755184684,
               0.0,
               0.1570796292566355,
               0.6981317084040745,
               0.26179938209439246,
               0.0,
               0.6283185204493961,
               0.17453292900260425,
               0.5235987832046415,
               0.314159258513271,
               0.6544984761534235,
               0.0,
               0.628318517026542,
               0.4712388877699064,
               0.3926990731415887,
               0.7853981576926913,
               0.314159258513271,
               0.0,
               0.39269907558648454,
               0.23561945415351576,
               0.0,
               0.49087384356626973,
               0.2617993935039064,
               0.26179938209439246,
               0.0,
               0.09817476828539717,
               0.6108652515091149,
               0.0,
               0.2893572153915434,
               0.46199892568588874,
               0.4780684487736008,
               0.0,
               0.0
          ],
          "clearance_alldata": [
               3.1347823252501117,
               1.1319200404187817,
               1.4377850146065685,
               7.5,
               1.2242640687119286,
               1.3992729220621358,
               3.33573003487159,
               1.5852847829576562,
               1.4650281539872885,
               6.0,
               1.3101124459781968,
               1.3880711874576985,
               2.1625703849682214,
               1.2207106781186547,
               1.8941228056353687,
               1.4444444444444444,
               1.6225487960392733,
               1.4928977990521974,
               1.8266732976508975,
               2.0066542517521784,
               1.4767791126448637,
               2.235702260395516,
               1.0690355937288492,
               1.1593129086050367,
               2.095978616954046,
               1.419432026471364,
               1.362675126316836,
               2.257425606053391,
               1.235702260395516,
               2.101409673869917,
               1.6357388321059432,
               1.4348385830773844,
               1.8090169943749475,
               1.4846586984419825,
               1.807183077124698,
               2.0707106781186546,
               1.9780597417014514,
               1.4040610178208843,
               5.580320215973272,
               1.2845177968644246,
               2.1920151387207314,
               2.6414213562373097,
               1.1656854249492379,
               1.4368867239266072,
               6.270562119350991,
               1.4617281506746018,
               1.5107491837076632,
               5.695211758697052,
               1.2285533905932737,
               4.037328167680166,
               1.3409846665588987,
               1.991557417731141,
               5.543652090601087,
               1.1571348402636774,
               1.0690355937288492,
               3.7438723371992437,
               1.3753627458629056,
               1.580985109474591,
               2.5,
               1.450509699240376,
               2.1186912597118446,
               4.20863234630617,
               1.4132746038560242,
               1.0690355937288492,
               5.3173174227521125,
               1.974726066488575,
               1.1035533905932737,
               3.8226772762414356,
               1.0,
               1.7128990204491963,
               3.339877940759473,
               1.2656854249492382,
               1.448528137423857,
               1.8886349517372676,
               1.548160820396132,
               1.6124608398078963,
               7.092501174215641,
               1.3790811278118047,
               1.3143184428079242,
               2.918128063512225,
               1.1129673351926623,
               1.082842712474619,
               2.5,
               1.6380711874576985,
               1.8791874516476947,
               3.504158716580708,
               1.2414213562373095,
               1.2064495102245982,
               3.955776096424465,
               1.364276695296637,
               1.4064495102245982,
               1.4125703849682214,
               1.2242640687119286,
               1.1921200810459414,
               5.5,
               1.0,
               1.2357545056961265,
               2.1377485348153007,
               1.5727784617950702,
               1.3143184428079244,
               5.393952027490282,
               1.4980644240562797,
               1.3300563079745769,
               2.449847350245616,
               1.5039276151695504,
               1.5483838618839971,
               3.6501240323145256,
               1.4040610178208843,
               1.894427190999916,
               2.3740887417975722,
               1.3448876517675852,
               1.3834602724480558,
               3.0,
               1.4610061647150432,
               6.546465554663977,
               1.2414213562373095,
               1.1111111111111112,
               4.2235160309735145,
               1.0,
               1.530056307974577,
               5.350331382786994,
               1.4253807916384658,
               1.789292222699217,
               1.9805711966596047,
               1.2071067811865475,
               1.192861481799478,
               3.5,
               2.5995864094170424,
               1.1840949166102646,
               2.5010469622751654,
               1.0,
               1.2953973510079613,
               1.7414213562373095,
               1.4142135623730951,
               1.2691959868353293,
               0,
               1.5107491837076632,
               1.0,
               3.2977142362982557,
               1.4516105669162203,
               2.235702260395516,
               1.3845860941771193,
               1.229382055094804,
               2.0158720948692066,
               1.6035533905932737,
               1.1380711874576983
          ],
          "time_alldata": [
               0.006631,
               0.629903,
               0.005001,
               0.003034,
               0.016808,
               0.332083,
               0.010503,
               0.12319,
               0.010507,
               0.0025,
               0.06878,
               0.007139,
               0.002108,
               3.128466,
               0.001998,
               0.003152,
               0.696902,
               0.024141,
               0.006,
               0.235893,
               0.006503,
               0.00251,
               0.002998,
               0.042924,
               0.003006,
               0.010785,
               0.00508,
               0.04671,
               0.002394,
               0.002075,
               0.102844,
               0.226035,
               0.000999,
               0.124715,
               0.002002,
               0.325061,
               1.115761,
               0.009721,
               0.004128,
               0.061531,
               0.003119,
               0.001721,
               0.257284,
               0.003512,
               0.003,
               0.386875,
               0.010153,
               0.002998,
               0.732267,
               0.002,
               0.840303,
               0.028524,
               0.002814,
               0.218314,
               0.009512,
               0.001508,
               0.004503,
               0.061788,
               0.001005,
               0.290534,
               0.003,
               0.0,
               0.002001,
               0.001002,
               0.002002,
               0.814831,
               0.008541,
               0.005,
               0.003504,
               0.003502,
               0.003039,
               0.008022,
               0.002001,
               0.006504,
               1.380746,
               0.044571,
               0.002004,
               0.240805,
               0.00926,
               0.003002,
               0.004998,
               0.135176,
               0.002001,
               0.003182,
               0.086297,
               0.288799,
               0.126109,
               0.11889,
               0.01602,
               0.078339,
               0.012031,
               0.002446,
               0.003,
               0.069975,
               0.002003,
               0.002,
               0.002998,
               0.469479,
               0.025818,
               0.047488,
               0.001999,
               0.01908,
               0.002551,
               0.003219,
               0.176691,
               0.004509,
               0.005998,
               0.060963,
               0.003,
               0.063926,
               0.079469,
               0.014869,
               0.001998,
               0.001999,
               0.001001,
               0.013022,
               0.006343,
               0.002,
               0.001,
               0.010514,
               0.002543,
               0.025386,
               0.003865,
               0.23238,
               0.002,
               0.208954,
               0.002617,
               0.000998,
               0.002999,
               0.003506,
               0.002507,
               0.305654,
               0.172892,
               0.002426,
               0.074396,
               0.0,
               0.001999,
               0.001881,
               0.007271,
               0.003,
               0.003179,
               0.481805,
               0.153301,
               3.591848,
               0.002002,
               0.000998
          ],
          "distance_from_goal_alldata": [
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               11.180339813232422,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               3.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               2.2360680103302,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               14.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0
          ],
          "original_distance_from_goal_alldata": [
               8.062257766723633,
               6.7082037925720215,
               8.602325439453125,
               3.1622776985168457,
               8.602325439453125,
               9.05538558959961,
               16.401220321655273,
               8.062257766723633,
               10.630146026611328,
               2.8284270763397217,
               8.062257766723633,
               10.770329475402832,
               3.605551242828369,
               8.062257766723633,
               4.242640495300293,
               10.0,
               8.062257766723633,
               14.142135620117188,
               11.045360565185547,
               11.180339813232422,
               12.806248664855957,
               5.830951690673828,
               5.385164737701416,
               9.0,
               7.280109882354736,
               13.892443656921387,
               8.0,
               10.0,
               11.180339813232422,
               4.4721360206604,
               8.246211051940918,
               11.401754379272461,
               7.280109882354736,
               3.0,
               4.4721360206604,
               6.7082037925720215,
               8.246211051940918,
               10.0,
               6.4031243324279785,
               12.369317054748535,
               12.206555366516113,
               18.027755737304688,
               7.8102498054504395,
               6.7082037925720215,
               11.704699516296387,
               5.385164737701416,
               8.062257766723633,
               11.401754379272461,
               11.180339813232422,
               3.0,
               8.062257766723633,
               6.324555397033691,
               17.0,
               13.45362377166748,
               4.0,
               8.5440034866333,
               3.1622776985168457,
               5.0,
               10.440306663513184,
               12.041594505310059,
               3.1622776985168457,
               9.848857879638672,
               10.816654205322266,
               12.206555366516113,
               6.0,
               6.4031243324279785,
               6.082762718200684,
               12.041594505310059,
               3.1622776985168457,
               10.29563045501709,
               2.2360680103302,
               8.0,
               7.8102498054504395,
               9.486832618713379,
               5.0,
               9.486832618713379,
               14.03566837310791,
               13.45362377166748,
               5.0,
               8.062257766723633,
               11.045360565185547,
               11.0,
               10.049875259399414,
               11.180339813232422,
               1.4142135381698608,
               12.083045959472656,
               7.8102498054504395,
               13.152946472167969,
               11.313708305358887,
               10.29563045501709,
               13.34166431427002,
               14.317821502685547,
               10.0,
               11.0,
               9.05538558959961,
               9.486832618713379,
               1.4142135381698608,
               3.605551242828369,
               4.123105525970459,
               16.6433162689209,
               8.246211051940918,
               12.649110794067383,
               2.0,
               12.041594505310059,
               5.0,
               9.219544410705566,
               9.219544410705566,
               11.401754379272461,
               9.219544410705566,
               4.0,
               4.123105525970459,
               12.206555366516113,
               6.0,
               4.123105525970459,
               5.0,
               2.2360680103302,
               10.049875259399414,
               7.071067810058594,
               8.062257766723633,
               7.8102498054504395,
               2.2360680103302,
               2.8284270763397217,
               7.071067810058594,
               10.630146026611328,
               5.099019527435303,
               11.401754379272461,
               12.206555366516113,
               5.0,
               14.317821502685547,
               9.486832618713379,
               3.1622776985168457,
               6.0,
               9.219544410705566,
               2.8284270763397217,
               12.206555366516113,
               10.29563045501709,
               1.0,
               15.264337539672852,
               2.2360680103302,
               5.099019527435303,
               1.0,
               15.033296585083008,
               14.0,
               8.9442720413208,
               7.071067810058594,
               11.180339813232422,
               15.524174690246582,
               11.180339813232422,
               4.242640495300293,
               2.0
          ],
          "path_deviation_alldata": [
               -2.585786461830139,
               -4.828427076339722,
               -8.485281229019165,
               0.0,
               -1.4142135381698608,
               -9.656854152679443,
               -1.1715729236602783,
               -8.485281229019165,
               -1.4142135381698608,
               0.0,
               -1.1715729236602783,
               -1.4142135381698608,
               0.0,
               -3.6568541526794434,
               0.0,
               0.0,
               -6.0,
               -7.313708305358887,
               -3.414213538169861,
               -4.828427076339722,
               -0.5857864618301392,
               -0.8284270763397217,
               0.0,
               -2.585786461830139,
               0.0,
               -4.585786461830139,
               -4.0,
               -5.071067690849304,
               -1.4142135381698608,
               -0.24264061450958252,
               -9.071067690849304,
               -0.8284270763397217,
               0.0,
               -5.656854152679443,
               0.0,
               -8.0,
               -1.1715729236602783,
               -0.5857864618301392,
               0.0,
               -1.4142135381698608,
               0.0,
               -2.585786461830139,
               -0.5857864618301392,
               0.0,
               0.0,
               -8.343145847320557,
               0.0,
               0.0,
               0.0,
               0.0,
               -1.1715729236602783,
               -0.5857864618301392,
               0.0,
               0.0,
               -2.0,
               0.0,
               0.0,
               -3.7573593854904175,
               0.0,
               -1.7573593854904175,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               -1.7573593854904175,
               -0.8284270763397217,
               0.0,
               0.0,
               -0.5857864618301392,
               -5.414213538169861,
               -0.8284270763397217,
               0.0,
               0.0,
               -5.171572923660278,
               -2.585786461830139,
               0.0,
               -6.0,
               -5.071067690849304,
               -0.5857864618301392,
               0.0,
               -5.071067690849304,
               0.0,
               0.0,
               -1.1715729236602783,
               -0.8284270763397217,
               0.0,
               0.0,
               -4.828427076339722,
               -0.5857864618301392,
               -0.5857864618301392,
               0.0,
               0.0,
               -12.727921843528748,
               0.0,
               0.0,
               -2.8284270763397217,
               -2.585786461830139,
               -4.485281229019165,
               -5.313708305358887,
               0.0,
               0.0,
               0.0,
               0.0,
               -0.5857864618301392,
               -2.2426406145095825,
               -7.071067690849304,
               -2.0,
               0.0,
               -1.1715729236602783,
               -0.8284270763397217,
               -19.071067690849304,
               0.0,
               -2.485281229019165,
               0.0,
               -2.2426406145095825,
               -2.0,
               0.0,
               0.0,
               -2.0,
               0.0,
               -0.5857864618301392,
               0.0,
               -3.6568541526794434,
               0.0,
               -2.485281229019165,
               0.0,
               0.0,
               -2.8284270763397217,
               0.0,
               0.0,
               -1.7573593854904175,
               0.0,
               0.0,
               -1.1715729236602783,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               -9.899494767189026,
               -3.071067690849304,
               -2.3431458473205566,
               0.0,
               0.0
          ],
          "memory_alldata": [
               625.646,
               85.383,
               15.287,
               9.159,
               21.527,
               37.343,
               17.847,
               30.255,
               15.463,
               10.239,
               25.591,
               15.467,
               8.943,
               82.815,
               10.119,
               13.903,
               56.071,
               20.431,
               15.863,
               32.135,
               16.039,
               10.463,
               20.607,
               126.847,
               18.447,
               39.063,
               27.263,
               22.943,
               10.887,
               11.537,
               38.927,
               30.999,
               9.711,
               27.295,
               10.687,
               38.967,
               55.755,
               15.183,
               14.111,
               23.719,
               14.719,
               14.431,
               33.903,
               14.055,
               11.303,
               48.107,
               15.495,
               13.479,
               41.139,
               11.383,
               60.091,
               20.991,
               9.167,
               29.791,
               11.791,
               10.799,
               16.375,
               25.463,
               9.214,
               52.007,
               11.975,
               14.879,
               12.87,
               11.071,
               10.759,
               50.695,
               13.847,
               14.295,
               12.015,
               13.055,
               14.239,
               15.839,
               10.895,
               13.703,
               57.639,
               25.079,
               9.783,
               34.435,
               18.383,
               13.527,
               15.847,
               30.414,
               8.279,
               14.239,
               27.863,
               30.359,
               31.927,
               29.023,
               18.159,
               25.256,
               15.887,
               26.311,
               28.767,
               133.903,
               10.519,
               16.335,
               13.303,
               39.143,
               17.351,
               25.174,
               10.239,
               20.495,
               11.031,
               13.359,
               27.015,
               15.575,
               15.375,
               21.895,
               8.847,
               24.871,
               24.111,
               20.543,
               12.135,
               13.383,
               9.151,
               17.127,
               15.215,
               9.543,
               10.503,
               17.263,
               11.543,
               23.287,
               12.807,
               38.183,
               10.783,
               33.183,
               13.239,
               9.135,
               12.575,
               12.799,
               10.815,
               34.167,
               31.103,
               9.703,
               29.175,
               7.011,
               12.831,
               10.567,
               15.859,
               11.319,
               10.175,
               36.427,
               27.351,
               83.42,
               10.983,
               10.079
          ],
          "average memory": 31.82,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -17.4,
          "average_distance_improvement": -19.36,
          "average_smoothness_improvement": -34.62,
          "average_clearance_improvement": 5.5,
          "average_time_improvement": -1758.11,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 1.8699999999999992,
          "average_memory_improvement": 14.53
     }
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning Algorithm inspired by RRT* with goal biasing and rewiring for smoother, shorter paths.\n    Key Improvements:\n    - Goal-biased sampling to direct growth towards the goal (20% chance).\n    - Adaptive max_dist step size decreasing as tree grows to allow finer expansions near goal.\n    - Near vertices rewiring to implement RRT* style path cost improvement.\n    - Path shortcutting during extraction to reduce unnecessary detours.\n    - Early stopping if path found or 10 seconds elapsed.\n    This yields better path quality, higher success rate, and efficient planning.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services, \n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_near_vertices(self, root_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        # Reuse Forest's get_vertices_within_radius for radius neighborhood search\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        # Choose the best parent, minimizing cost + move cost from parent to new\n        if not near_vertices:\n            return None\n        best_parent = None\n        best_cost = float('inf')\n        for vertex in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = vertex.cost + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        # Try to improve costs of near vertices by connecting them with new vertex\n        for vertex in near_vertices:\n            if vertex == new_vertex:\n                continue\n            line_seq = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if cost_through_new < vertex.cost:\n                # Remove old parent edges to vertex\n                for parent in list(vertex.parents):\n                    self._graph.remove_edge(parent, vertex)\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = cost_through_new\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut smoother path by skipping intermediate vertices if direct path is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_final: Vertex) -> None:\n        # Extract path to start, store in list\n        path: List[Vertex] = [q_final]\n        while len(path[-1].parents) != 0:\n            # Select parent with minimal cost to trace back\n            parents_list = list(path[-1].parents)\n            min_cost_parent = min(parents_list, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.reverse()\n\n        # Shortcut path to smooth it\n        path = self._shortcut_path(path)\n\n        # Animate path traversal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        # Implement goal biasing: 20% chance of sampling goal directly\n        if np.random.rand() < 0.2:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _find_path_internal(self) -> None:\n        from time import time\n        start_time = time()\n\n        max_iterations = 8000\n        max_dist_initial = 15.0\n        goal_radius = 5.0  # Use goal radius for pruning in rewiring\n\n        # Initialize start and goal vertices' cost\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for iteration in range(max_iterations):\n\n            # Time check to stop if >10s\n            elapsed = time() - start_time\n            if elapsed > 10.0:\n                # Stop attempt if too long\n                break\n\n            # Adaptive step size decreasing over time for finer expansions\n            max_dist = max(1.0, max_dist_initial * (1 - iteration / max_iterations))\n\n            q_sample_point = self._get_random_sample()\n            q_near_vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample_point)\n            if q_near_vertex.position == q_sample_point:\n                continue\n\n            q_new_vertex = self._get_new_vertex(q_near_vertex, q_sample_point, max_dist)\n\n            # Check line sequence validity\n            line_seq = self._get_grid().get_line_sequence(q_near_vertex.position, q_new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Get vertices near to q_new_vertex within radius r for rewiring\n            # Radius for near vertices adapts with log and density theory (standard RRT* radius)\n            r = min(goal_radius, max_dist * 5)\n            near_vertices = self._get_near_vertices([self._graph.root_vertex_start], q_new_vertex.position, r)\n\n            # Choose best parent for q_new_vertex from near_vertices\n            best_parent = self._choose_parent(near_vertices, q_new_vertex) or q_near_vertex\n\n            # Assign cost to q_new_vertex from best_parent\n            cost_to_new = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new_vertex.position)\n            q_new_vertex.cost = cost_to_new\n\n            # Add edge from best parent to new vertex\n            self._graph.add_edge(best_parent, q_new_vertex)\n\n            # Rewire nearby vertices to potentially improve cost\n            self._rewire(near_vertices, q_new_vertex)\n\n            # Check if new vertex is in goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new_vertex.position):\n                # Add direct edge to goal if valid\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_to_goal = self._get_grid().get_line_sequence(q_new_vertex.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                    cost_to_goal = q_new_vertex.cost + self._get_grid().get_movement_cost(q_new_vertex.position, goal_vertex.position)\n                    if cost_to_goal < goal_vertex.cost:\n                        self._graph.add_edge(q_new_vertex, goal_vertex)\n                        goal_vertex.cost = cost_to_goal\n                        self._extract_path(goal_vertex)\n                        break\n\n            self.key_frame() ",
     "objective": 2543.935,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 10.81,
          "average_distance": 11.57,
          "average_smoothness": 0.35,
          "average_clearance": 2.11,
          "average_time": 0.1064,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "steps_alldata": [
               13,
               14,
               16,
               4,
               11,
               19,
               19,
               10,
               19,
               3,
               13,
               11,
               4,
               18,
               4,
               9,
               13,
               16,
               16,
               24,
               14,
               7,
               6,
               19,
               8,
               15,
               10,
               15,
               7,
               9,
               14,
               8,
               4,
               9,
               7,
               15,
               20,
               15,
               13,
               11,
               17,
               10,
               10,
               12,
               6,
               19,
               12,
               11,
               8,
               7,
               17,
               18,
               5,
               10,
               4,
               5,
               11,
               14,
               4,
               12,
               10,
               11,
               7,
               6,
               7,
               12,
               7,
               10,
               3,
               11,
               10,
               11,
               5,
               10,
               22,
               16,
               5,
               17,
               13,
               12,
               11,
               12,
               2,
               12,
               10,
               14,
               19,
               14,
               14,
               15,
               9,
               12,
               10,
               11,
               2,
               4,
               9,
               29,
               10,
               21,
               3,
               12,
               5,
               10,
               12,
               14,
               10,
               7,
               5,
               13,
               7,
               5,
               5,
               12,
               6,
               11,
               13,
               3,
               3,
               8,
               9,
               12,
               10,
               22,
               6,
               19,
               10,
               4,
               7,
               10,
               3,
               14,
               24,
               2,
               16,
               3,
               6,
               2,
               16,
               9,
               6,
               19,
               16,
               23,
               4,
               3
          ],
          "distance_alldata": [
               12.41421353816986,
               14.656854152679443,
               17.071067690849304,
               3.414213538169861,
               12.485281229019165,
               22.14213538169861,
               20.071067690849304,
               12.313708305358887,
               19.242640614509583,
               2.8284270763397217,
               14.071067690849304,
               11.656854152679443,
               3.8284270763397217,
               20.313708305358887,
               4.2426406145095825,
               10.485281229019165,
               15.727921843528748,
               20.38477599620819,
               17.071067690849304,
               26.313708305358887,
               15.071067690849304,
               7.656854152679443,
               5.828427076339722,
               21.727921843528748,
               7.828427076339722,
               16.071067690849304,
               10.242640614509583,
               14.0,
               7.656854152679443,
               10.485281229019165,
               14.242640614509583,
               8.656854152679443,
               3.0,
               9.656854152679443,
               7.2426406145095825,
               16.485281229019165,
               22.727921843528748,
               16.899494767189026,
               13.242640614509583,
               12.899494767189026,
               21.38477599620819,
               9.828427076339722,
               9.828427076339722,
               12.656854152679443,
               5.828427076339722,
               20.071067690849304,
               12.242640614509583,
               12.071067690849304,
               8.656854152679443,
               6.828427076339722,
               19.727921843528748,
               19.485281229019165,
               4.0,
               12.313708305358887,
               3.414213538169861,
               5.2426406145095825,
               11.242640614509583,
               17.14213538169861,
               3.414213538169861,
               12.656854152679443,
               11.485281229019165,
               12.899494767189026,
               6.0,
               6.656854152679443,
               6.414213538169861,
               13.485281229019165,
               6.828427076339722,
               11.071067690849304,
               2.414213538169861,
               10.828427076339722,
               9.828427076339722,
               11.656854152679443,
               5.2426406145095825,
               10.242640614509583,
               23.485281229019165,
               16.656854152679443,
               5.2426406145095825,
               19.727921843528748,
               15.313708305358887,
               11.828427076339722,
               10.41421353816986,
               14.313708305358887,
               1.4142135381698608,
               13.071067690849304,
               9.828427076339722,
               14.656854152679443,
               19.656854152679443,
               14.242640614509583,
               16.727921843528748,
               16.071067690849304,
               10.485281229019165,
               11.0,
               9.41421353816986,
               12.485281229019165,
               1.4142135381698608,
               3.8284270763397217,
               10.071067690849304,
               28.41421353816986,
               10.242640614509583,
               24.14213538169861,
               2.0,
               13.485281229019165,
               5.2426406145095825,
               9.828427076339722,
               11.0,
               15.071067690849304,
               9.828427076339722,
               6.828427076339722,
               4.414213538169861,
               14.899494767189026,
               7.656854152679443,
               4.414213538169861,
               5.2426406145095825,
               14.313708305358887,
               7.071067690849304,
               12.899494767189026,
               14.899494767189026,
               2.414213538169861,
               2.8284270763397217,
               9.071067690849304,
               10.899494767189026,
               13.071067690849304,
               11.899494767189026,
               25.14213538169861,
               5.0,
               21.727921843528748,
               10.242640614509583,
               3.414213538169861,
               7.656854152679443,
               9.828427076339722,
               2.8284270763397217,
               14.656854152679443,
               26.727921843528748,
               1.0,
               19.97056245803833,
               2.414213538169861,
               5.414213538169861,
               1.0,
               15.41421353816986,
               9.656854152679443,
               7.071067690849304,
               20.071067690849304,
               18.313708305358887,
               26.55634891986847,
               4.2426406145095825,
               2.0
          ],
          "smoothness_alldata": [
               0.24166097072009626,
               0.5048988229942748,
               0.4417864572842873,
               0.3926990902558596,
               0.571198658065682,
               0.7027246752157597,
               0.49604094350214933,
               0.1570796292566355,
               0.3306939689402743,
               0.0,
               0.5437371939938344,
               0.3569991574014443,
               0.3926990731415887,
               0.21816615745008403,
               0.0,
               0.26179938209439246,
               0.3624914521306973,
               0.19634954084936207,
               0.5890486161302346,
               0.4581489300747008,
               0.39269907558648454,
               0.33659921043972485,
               0.5235987641887849,
               0.3720307008709788,
               0.3926990731415887,
               0.5759586611447884,
               0.5497787092439326,
               0.10471975511965977,
               0.6731984110998663,
               0.3490658580052085,
               0.33659921532951653,
               0.49087384142698587,
               0.0,
               0.43633231490016805,
               0.33659920554993317,
               0.3665191440597606,
               0.47123890317275025,
               0.5235987687525905,
               0.3624914521306973,
               0.28559933836789786,
               0.23099946082950074,
               0.4712389048841773,
               0.39269908341015125,
               0.5235987641887849,
               0.5235987641887849,
               0.4133674526182074,
               0.3926990731415887,
               0.3569991729598723,
               0.2945243048561915,
               0.44879896029241095,
               0.369599131689559,
               0.6981316931913892,
               0.0,
               0.3141592653589793,
               0.19634953657079435,
               0.314159258513271,
               0.3569991729598723,
               0.33659920554993317,
               0.3926990731415887,
               0.5235987784506774,
               0.4712389083070315,
               0.42839900755184684,
               0.0,
               0.26179938209439246,
               0.22439948014620548,
               0.45814893007470076,
               1.009797641098758,
               0.628318517026542,
               0.2617993935039064,
               0.2855993352562123,
               0.4712389048841773,
               0.2855993352562123,
               0.314159258513271,
               0.4712389083070315,
               0.6425985004368706,
               0.4908738606805406,
               0.314159258513271,
               0.4157990327146111,
               0.4833219519720515,
               0.1963495451279298,
               0.1427996629605777,
               0.3926990731415887,
               0.0,
               0.5890486353837894,
               0.47123889803846897,
               0.3926990731415887,
               0.4133674544197096,
               0.44879895295772343,
               0.3365992202193082,
               0.41887902732434745,
               0.2617993935039064,
               0.0,
               0.15707963610234382,
               0.571198658065682,
               0.0,
               0.3926990731415887,
               0.5235987717951276,
               0.16249617291769763,
               0.39269907998729703,
               0.5609986971056526,
               0.0,
               0.5235987755982988,
               0.31415927220468765,
               0.314159258513271,
               0.1308996938995747,
               0.504898820549379,
               0.15707963610234382,
               0.6731984306590331,
               0.31415927220468765,
               0.4229066941524801,
               0.4487989407332442,
               0.1570796292566355,
               0.31415927220468765,
               0.3272492390275045,
               0.0,
               0.4283989951051044,
               0.6645676859362943,
               0.26179938209439246,
               0.0,
               0.589048609712383,
               0.17453292900260425,
               0.6544984752026305,
               0.314159258513271,
               0.46409891706862005,
               0.0,
               0.37203070807698757,
               0.4712388877699064,
               0.3926990731415887,
               0.4487989407332442,
               0.314159258513271,
               0.0,
               0.5609986979206179,
               0.3272492390275045,
               0.0,
               0.39269908169872414,
               0.2617993935039064,
               0.26179938209439246,
               0.0,
               0.09817476828539717,
               0.43633232250651066,
               0.0,
               0.6613879252700332,
               0.3926990902558596,
               0.6146594322240901,
               0.0,
               0.0
          ],
          "clearance_alldata": [
               3.6744406468786783,
               1.1306019374818708,
               1.1294417382415922,
               7.5,
               1.262992929726561,
               1.3011236500914927,
               3.550387062634827,
               1.4242640687119288,
               1.7089164973438762,
               6.0,
               1.331318137643482,
               1.3324412954083984,
               2.1625703849682214,
               1.1571348402636774,
               1.8941228056353687,
               1.4444444444444444,
               1.6923076923076923,
               1.5853161363744843,
               2.239276695296637,
               1.7536003139054215,
               1.5683869520884397,
               2.3531622792856544,
               1.0690355937288492,
               1.1830899297167936,
               2.095978616954046,
               1.204737854124365,
               1.0828427124746192,
               2.2804451623303685,
               1.2020305089104422,
               1.949244862985006,
               1.50921358603514,
               1.5893470802648584,
               1.8090169943749475,
               1.2031585694162432,
               1.807183077124698,
               2.120837280002751,
               1.4946461113496086,
               1.5419326802994642,
               5.580320215973272,
               1.3694995547496347,
               2.0464581221232407,
               3.1,
               1.1656854249492379,
               1.4368867239266072,
               6.270562119350991,
               1.371815531697157,
               1.5107491837076632,
               5.695211758697052,
               1.125,
               4.037328167680166,
               1.3462558539630987,
               1.9974856407083788,
               5.543652090601087,
               1.2828427124746191,
               1.0,
               3.7438723371992437,
               1.3753627458629056,
               1.5219382706689475,
               2.5,
               1.3535533905932737,
               2.1186912597118446,
               4.20863234630617,
               1.4132746038560242,
               1.0690355937288492,
               5.3173174227521125,
               1.6785151943924623,
               1.1183467321065985,
               3.8226772762414356,
               1.0,
               1.6480900185901783,
               1.9654178453005045,
               1.3162462422380978,
               1.448528137423857,
               1.8886349517372676,
               1.4499770425732577,
               2.21701849268153,
               7.092501174215641,
               1.3949868613011096,
               1.534680355355281,
               2.85223106353453,
               1.1129673351926623,
               1.0345177968644246,
               2.5,
               1.603553390593274,
               1.5307135789365265,
               3.3453818702034077,
               1.6876050053813676,
               1.354101237802725,
               3.68765106909581,
               1.2828427124746191,
               1.2293883446939977,
               1.4125703849682214,
               1.2242640687119286,
               1.3162462422380978,
               5.5,
               1.0,
               1.5166979488747652,
               2.2865873345688765,
               1.482842712474619,
               1.588682651263134,
               5.393952027490282,
               1.4714045207910316,
               1.3300563079745769,
               2.449847350245616,
               1.4619336472387545,
               1.2484791903299342,
               2.1064495102245977,
               1.487744794624728,
               1.894427190999916,
               2.4217388905962487,
               1.1428571428571428,
               1.1656854249492379,
               3.0,
               1.2898923887182565,
               6.546465554663977,
               1.3162462422380978,
               1.1725108220860991,
               4.2235160309735145,
               1.0,
               1.5598385830773844,
               5.350331382786994,
               1.471404520791032,
               1.789292222699217,
               3.4733733437442313,
               1.2071067811865475,
               1.3319545152297507,
               3.5,
               2.5995864094170424,
               1.3795506070703403,
               2.5010469622751654,
               1.0,
               1.2612038749637413,
               1.5443539625935827,
               1.4142135623730951,
               1.3353161363744845,
               0,
               1.5107491837076632,
               1.0,
               3.2977142362982557,
               1.4778403421939745,
               2.235702260395516,
               1.72217628167044,
               1.1294417382415922,
               3.0748412761625366,
               1.6035533905932737,
               1.1380711874576983
          ],
          "time_alldata": [
               0.007195,
               3.399759,
               0.031838,
               0.004,
               0.049291,
               0.01822,
               0.004506,
               0.012539,
               0.006006,
               0.001,
               0.010569,
               0.434557,
               0.002,
               1.161494,
               0.007938,
               0.050117,
               0.015074,
               0.0151,
               0.014414,
               0.06369,
               0.011504,
               0.018778,
               0.002138,
               0.042894,
               0.008207,
               0.028998,
               0.029761,
               0.004219,
               0.006095,
               0.029527,
               0.205871,
               0.004004,
               0.003454,
               0.013503,
               0.006001,
               0.006015,
               0.115494,
               0.081152,
               0.003001,
               2.640571,
               0.004999,
               0.007504,
               0.30321,
               0.003505,
               0.0,
               0.036942,
               0.006006,
               0.006898,
               0.135989,
               0.007508,
               0.059295,
               0.008026,
               0.002001,
               0.014013,
               0.043482,
               0.002998,
               0.006044,
               0.084108,
               0.003998,
               0.307303,
               0.001005,
               0.019015,
               0.003418,
               0.002002,
               0.001502,
               0.949197,
               0.325687,
               0.005507,
               0.004,
               0.031587,
               0.003003,
               0.630993,
               0.003003,
               0.001505,
               0.018014,
               0.007512,
               0.002999,
               0.01776,
               0.007004,
               0.127003,
               0.003002,
               0.015223,
               0.003,
               0.006501,
               0.008143,
               0.005998,
               0.016748,
               0.00106,
               0.033911,
               2.514795,
               0.019201,
               0.003,
               0.003,
               0.028852,
               0.013515,
               0.001091,
               0.037018,
               0.040555,
               0.011868,
               0.046838,
               0.002001,
               0.005501,
               0.087398,
               0.002,
               0.017103,
               0.007,
               0.015799,
               0.213981,
               0.001006,
               0.061586,
               0.031093,
               0.021015,
               0.000999,
               0.00511,
               0.00666,
               0.01001,
               0.010512,
               0.001004,
               0.001,
               0.012906,
               0.001613,
               0.012681,
               0.074958,
               0.103099,
               0.002005,
               0.012468,
               0.007999,
               0.012009,
               0.005503,
               0.013797,
               0.001239,
               0.003504,
               0.065514,
               0.001,
               0.003011,
               0.004,
               0.00751,
               0.0,
               0.014013,
               0.01401,
               0.006512,
               0.019792,
               0.013079,
               0.019049,
               0.006177,
               0.003
          ],
          "distance_from_goal_alldata": [
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               11.180339813232422,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               3.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               2.2360680103302,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               14.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0
          ],
          "original_distance_from_goal_alldata": [
               8.062257766723633,
               6.7082037925720215,
               8.602325439453125,
               3.1622776985168457,
               8.602325439453125,
               9.05538558959961,
               16.401220321655273,
               8.062257766723633,
               10.630146026611328,
               2.8284270763397217,
               8.062257766723633,
               10.770329475402832,
               3.605551242828369,
               8.062257766723633,
               4.242640495300293,
               10.0,
               8.062257766723633,
               14.142135620117188,
               11.045360565185547,
               11.180339813232422,
               12.806248664855957,
               5.830951690673828,
               5.385164737701416,
               9.0,
               7.280109882354736,
               13.892443656921387,
               8.0,
               10.0,
               11.180339813232422,
               4.4721360206604,
               8.246211051940918,
               11.401754379272461,
               7.280109882354736,
               3.0,
               4.4721360206604,
               6.7082037925720215,
               8.246211051940918,
               10.0,
               6.4031243324279785,
               12.369317054748535,
               12.206555366516113,
               18.027755737304688,
               7.8102498054504395,
               6.7082037925720215,
               11.704699516296387,
               5.385164737701416,
               8.062257766723633,
               11.401754379272461,
               11.180339813232422,
               3.0,
               8.062257766723633,
               6.324555397033691,
               17.0,
               13.45362377166748,
               4.0,
               8.5440034866333,
               3.1622776985168457,
               5.0,
               10.440306663513184,
               12.041594505310059,
               3.1622776985168457,
               9.848857879638672,
               10.816654205322266,
               12.206555366516113,
               6.0,
               6.4031243324279785,
               6.082762718200684,
               12.041594505310059,
               3.1622776985168457,
               10.29563045501709,
               2.2360680103302,
               8.0,
               7.8102498054504395,
               9.486832618713379,
               5.0,
               9.486832618713379,
               14.03566837310791,
               13.45362377166748,
               5.0,
               8.062257766723633,
               11.045360565185547,
               11.0,
               10.049875259399414,
               11.180339813232422,
               1.4142135381698608,
               12.083045959472656,
               7.8102498054504395,
               13.152946472167969,
               11.313708305358887,
               10.29563045501709,
               13.34166431427002,
               14.317821502685547,
               10.0,
               11.0,
               9.05538558959961,
               9.486832618713379,
               1.4142135381698608,
               3.605551242828369,
               4.123105525970459,
               16.6433162689209,
               8.246211051940918,
               12.649110794067383,
               2.0,
               12.041594505310059,
               5.0,
               9.219544410705566,
               9.219544410705566,
               11.401754379272461,
               9.219544410705566,
               4.0,
               4.123105525970459,
               12.206555366516113,
               6.0,
               4.123105525970459,
               5.0,
               2.2360680103302,
               10.049875259399414,
               7.071067810058594,
               8.062257766723633,
               7.8102498054504395,
               2.2360680103302,
               2.8284270763397217,
               7.071067810058594,
               10.630146026611328,
               5.099019527435303,
               11.401754379272461,
               12.206555366516113,
               5.0,
               14.317821502685547,
               9.486832618713379,
               3.1622776985168457,
               6.0,
               9.219544410705566,
               2.8284270763397217,
               12.206555366516113,
               10.29563045501709,
               1.0,
               15.264337539672852,
               2.2360680103302,
               5.099019527435303,
               1.0,
               15.033296585083008,
               14.0,
               8.9442720413208,
               7.071067810058594,
               11.180339813232422,
               15.524174690246582,
               11.180339813232422,
               4.242640495300293,
               2.0
          ],
          "path_deviation_alldata": [
               -3.7573593854904175,
               -0.5857864618301392,
               -8.0,
               0.0,
               -2.0,
               -11.071067690849304,
               -1.7573593854904175,
               -3.071067690849304,
               -8.343145847320557,
               0.0,
               -3.414213538169861,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               -0.8284270763397217,
               -5.556348919868469,
               -4.2426406145095825,
               -12.242640614509583,
               -1.7573593854904175,
               -1.4142135381698608,
               0.0,
               -11.071067690849304,
               0.0,
               -1.1715729236602783,
               -0.5857864618301392,
               -1.7573593854904175,
               -2.8284270763397217,
               -1.0710676908493042,
               -0.5857864618301392,
               -0.8284270763397217,
               0.0,
               0.0,
               0.0,
               -3.414213538169861,
               -10.242640614509583,
               -10.242640614509583,
               0.0,
               0.0,
               -2.2426406145095825,
               -1.7573593854904175,
               -0.5857864618301392,
               0.0,
               0.0,
               -3.1715729236602783,
               0.0,
               0.0,
               0.0,
               0.0,
               -0.8284270763397217,
               -5.171572923660278,
               0.0,
               -1.4142135381698608,
               0.0,
               0.0,
               0.0,
               -4.828427076339722,
               0.0,
               -0.5857864618301392,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               -3.414213538169861,
               0.0,
               0.0,
               -2.0,
               -1.7573593854904175,
               -1.4142135381698608,
               0.0,
               0.0,
               -3.7573593854904175,
               -2.3431458473205566,
               0.0,
               -11.071067690849304,
               -3.071067690849304,
               0.0,
               0.0,
               -1.6568541526794434,
               0.0,
               0.0,
               -1.7573593854904175,
               -0.8284270763397217,
               -7.7573593854904175,
               -3.1715729236602783,
               -2.485281229019165,
               0.0,
               0.0,
               0.0,
               0.0,
               -2.2426406145095825,
               0.0,
               0.0,
               -5.656854152679443,
               -2.3431458473205566,
               -1.4142135381698608,
               -10.485281229019165,
               0.0,
               -0.5857864618301392,
               0.0,
               0.0,
               -1.1715729236602783,
               -2.8284270763397217,
               0.0,
               -1.1715729236602783,
               0.0,
               -1.4142135381698608,
               0.0,
               0.0,
               0.0,
               -3.899494767189026,
               0.0,
               -2.8284270763397217,
               -6.828427076339722,
               0.0,
               0.0,
               -0.8284270763397217,
               0.0,
               -4.828427076339722,
               0.0,
               -8.485281229019165,
               0.0,
               -6.485281229019165,
               0.0,
               0.0,
               -0.8284270763397217,
               0.0,
               0.0,
               -1.7573593854904175,
               -15.656854152679443,
               0.0,
               -3.6568541526794434,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               0.0,
               -7.414213538169861,
               -1.6568541526794434,
               -4.828427076339722,
               0.0,
               0.0
          ],
          "memory_alldata": [
               1313.814,
               954.035,
               41.139,
               11.803,
               55.419,
               32.979,
               18.443,
               27.152,
               24.051,
               11.147,
               23.364,
               270.052,
               9.239,
               659.253,
               20.298,
               63.71,
               25.843,
               31.411,
               32.127,
               78.483,
               30.787,
               35.635,
               15.979,
               52.355,
               20.69,
               51.931,
               37.523,
               21.827,
               18.522,
               42.059,
               168.539,
               13.267,
               13.978,
               31.466,
               20.134,
               21.275,
               126.963,
               85.859,
               15.787,
               908.362,
               19.019,
               22.707,
               205.692,
               16.643,
               15.099,
               54.379,
               24.075,
               18.675,
               108.931,
               19.283,
               75.899,
               25.155,
               8.831,
               25.33,
               44.826,
               12.287,
               19.467,
               83.059,
               16.922,
               207.851,
               11.511,
               33.499,
               16.226,
               16.658,
               10.655,
               616.722,
               228.595,
               18.611,
               16.482,
               45.747,
               14.707,
               540.854,
               14.642,
               11.511,
               32.219,
               22.643,
               13.882,
               35.195,
               21.123,
               111.043,
               17.755,
               32.666,
               12.506,
               21.738,
               21.763,
               23.147,
               32.995,
               16.139,
               43.219,
               936.779,
               31.315,
               12.839,
               16.035,
               41.987,
               26.683,
               10.463,
               90.195,
               109.499,
               35.171,
               80.946,
               11.107,
               20.435,
               79.395,
               11.959,
               31.499,
               21.235,
               32.291,
               170.811,
               8.735,
               102.671,
               33.682,
               36.843,
               10.847,
               15.899,
               21.194,
               22.046,
               25.522,
               9.775,
               10.735,
               21.58,
               11.439,
               29.779,
               77.395,
               96.627,
               12.811,
               27.467,
               20.203,
               32.019,
               19.651,
               21.523,
               10.255,
               16.779,
               72.867,
               9.031,
               27.287,
               15.722,
               22.227,
               8.935,
               34.747,
               30.963,
               20.994,
               32.195,
               28.374,
               40.723,
               16.426,
               13.21
          ],
          "average memory": 120.86,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -18.27,
          "average_distance_improvement": -19.77,
          "average_smoothness_improvement": -34.62,
          "average_clearance_improvement": 5.5,
          "average_time_improvement": -1377.78,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 1.9100000000000001,
          "average_memory_improvement": -224.63
     }
}

Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0076,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.23
}
{
     "algorithm": "This algorithm is an improved path planner inspired by RRT* and heuristic-guided sampling.\n    It uses adaptive step size and goal-biased sampling to speed up exploration.\n    The algorithm incrementally builds a tree with rewiring to optimize path cost (like RRT*),\n    reuses a radius-based neighborhood search to improve connectivity and smoothness,\n    and employs a heuristic based on Euclidean distance to goal to guide sampling.\n    During path extraction, it attempts path shortcutting to smoothen it.\n    To ensure responsiveness, search is limited to 10 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.1       # Probability to sample goal directly\n        self._rewire_radius = 20.0  # Neighborhood radius for rewiring\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        # With probability goal_bias, sample the goal; otherwise random valid sample\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        # Return all vertices within radius of point in given list\n        near_vert = []\n        radius_sq = radius * radius\n        for v in vertices:\n            if Map.get_distance(v.position, point) <= radius:\n                near_vert.append(v)\n        return near_vert\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost equivalently distance plus movement cost from grid (might consider obstacles implicitly)\n        dist = Map.get_distance(frm.position, to.position)\n        # Movement cost from grid between positions (may differ if terrain)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose best parent vertex minimizing cost to q_new + movement cost, only if line valid\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire the tree to use q_new as intermediate for near vertices if it reduces cost\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove old parent edges, add new edge from q_new\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by skipping intermediate vertices if direct line is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Decrease j until direct connection is valid\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        # Backtrack to root start by best parent chain (assume single parent tree)\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break  # no path\n            # Choose the parent with minimal cost (should be single due to rewiring but safe check)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut smoothing\n        smoothed_path = self._shortcut_path(path)\n\n        for p in smoothed_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        max_dist = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                # Give up on path finding (not found in time)\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on distance to sample\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices for rewiring (within radius)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Choose best parent to connect q_new with\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # No suitable parent found, try q_near as fallback\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to q_new if it improves cost\n            self._rewire(near_vertices, q_new)\n\n            # Check goal reached\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Connect final goal vertex\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": 4120.16,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 10.27,
          "average_distance": 10.93,
          "average_smoothness": 0.33,
          "average_clearance": 2.09,
          "average_time": 0.2083,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 63.1,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -12.36,
          "average_distance_improvement": -13.15,
          "average_smoothness_improvement": -26.92,
          "average_clearance_improvement": 4.5,
          "average_time_improvement": -2640.79,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 1.2699999999999996,
          "average_memory_improvement": -69.49
     }
}
{
     "algorithm": "\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15        # Slightly higher goal bias for focused sampling\n        self._rewire_radius = 15.0    # Shrinking rewire radius for better memory\n        self._vertex_limit = 1500     # Limit max vertices for memory efficiency\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            attempts = 0\n            while attempts < 50:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            # fallback to goal if sampling fails repeatedly\n            return self._get_grid().goal.position\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove all existing parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"Shrink rewire radius over time for efficiency and memory.\"\"\"\n        min_radius = 5.0\n        radius = self._rewire_radius * (1.0 - iteration / max_iterations)\n        return max(radius, min_radius)\n\n    def _limit_graph_size(self) -> None:\n        \"\"\"Limit max vertex count in graph for memory efficiency by pruning farthest or high cost vertices.\"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Sort vertices by cost descending, skip root start and goal\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            # Remove all edges to/from vertex to prune it\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            # Remove vertex from roots if present\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        # Rebuild size count\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 8000\n        max_dist_base = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = min(max_dist_base, dist_to_sample)\n\n            # Further adapt step based on costs to encourage finer exploration near obstacles or goal\n            adaptive_step *= 0.7 + 0.3 * (1 - min(q_near.cost / 100.0, 1.0))\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrinking rewire radius to save memory and speed later on\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # Fallback to nearest vertex if viable\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            # Prune to keep memory low if vertices grow large\n            self._limit_graph_size()\n\n            # Check goal proximity with radius for early success\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
     "objective": 3730.24,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 10.32,
          "average_distance": 10.94,
          "average_smoothness": 0.35,
          "average_clearance": 2.1,
          "average_time": 0.1889,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 60.63,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -12.91,
          "average_distance_improvement": -13.25,
          "average_smoothness_improvement": -34.62,
          "average_clearance_improvement": 5.0,
          "average_time_improvement": -2385.53,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 1.2799999999999994,
          "average_memory_improvement": -62.85
     }
}
{
     "algorithm": "\"\"\"\n    This algorithm combines systematic grid-aware A*-inspired heuristic guided sampling \n    with progressive subtree rewiring for fast convergence and robust connectivity. \n    \n    Key features:\n    - Uses a priority queue (min-heap) over vertices based on f = g + h costs for expansion.\n    - Samples new nodes biased towards frontier areas near current best paths (heuristic frontier sampling).\n    - Adaptive step length modulated by distance-to-goal and obstacle proximity.\n    - Incremental local rewiring within dynamically chosen neighborhoods to optimize paths.\n    - Early termination upon reaching goal within defined radius.\n    - Incorporates path smoothing via shortcutting on final extracted path.\n    - Enforces a global timeout of 10 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This algorithm combines systematic grid-aware A*-inspired heuristic guided sampling \n    with progressive subtree rewiring for fast convergence and robust connectivity. \n    \n    Key features:\n    - Uses a priority queue (min-heap) over vertices based on f = g + h costs for expansion.\n    - Samples new nodes biased towards frontier areas near current best paths (heuristic frontier sampling).\n    - Adaptive step length modulated by distance-to-goal and obstacle proximity.\n    - Incremental local rewiring within dynamically chosen neighborhoods to optimize paths.\n    - Early termination upon reaching goal within defined radius.\n    - Incorporates path smoothing via shortcutting on final extracted path.\n    - Enforces a global timeout of 10 seconds.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap = []               # Min-heap for frontier vertices (f = g + h)\n        self._max_iter = 6000         # Max iterations before timeout/failure\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0          # seconds limit\n        self._base_step = 12.0        # Base adaptive step distance\n        self._rewire_radius_init = 18.0\n        self._vertex_prune_limit = 1200\n\n    def _heuristic(self, pos: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(pos, goal_pos)\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = self._heuristic(to_pos)\n        # Step shrinks near goal and obstacles to improve precision\n        max_step = self._base_step\n        # Reduce step near goal radius\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n        # Check obstacle proximity along direction, reduce step if near\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5  # Penalize invalid/obstacle-filled directions with smaller step\n        return max_step\n\n    def _get_new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _get_frontier_sample(self) -> Point:\n        # Sample near frontier vertices in the heap using Gaussian jitter to guide exploration\n        import random\n        import numpy as np\n        if not self._heap:\n            # fallback random valid sample in environment\n            for _ in range(50):\n                rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        f_min_vertex = self._heap[0][1]\n        base_pos = f_min_vertex.position\n\n        dim = self._get_grid().size.n_dim\n        std_dev = 8.0  # exploration jitter scale\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(self._get_grid().size[i]-1, int(round(val))))\n            jittered_coords.append(val)\n\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n        else:\n            # fallback to goal biased sampling for valid position\n            return self._get_goal_biased_sample()\n\n    def _goal_biased_sample(self) -> Point:\n        import random\n        # Slight goal bias for direct attraction but mostly frontier sampling is used\n        if random.random() < 0.2:\n            return self._get_grid().goal.position\n        else:\n            return self._get_frontier_sample()\n\n    def _choose_parent_and_cost(self, near_vertices, q_new: Vertex) -> Vertex:\n        # Choose best parent minimizing cost + heuristic\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        # Attempt local rewiring in neighbors to reduce path cost\n        for v in neighbors:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                # Remove all parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                # Additionally update costs downstream in DFS fashion to propagate gains\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            current = stack.pop()\n            for child in current.children:\n                new_cost = current.cost + self._cost(current, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_excess_vertices(self) -> None:\n        # Prune vertices with highest cost or furthest from goal when size exceeds limit\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n        # Ignore start and goal vertices\n        candidates = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        if not candidates:\n            return\n\n        # Sort primarily by distance to goal + cost descending to prune worst vertices\n        goal_pos = self._get_grid().goal.position\n        def prune_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n        candidates = sorted(candidates, key=prune_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_vertex.cost = 0.0\n        start_f = self._heuristic(start_vertex.position)\n        self._heap = []\n        heapq.heappush(self._heap, (start_f, start_vertex))\n\n        visited_positions = set()\n        visited_positions.add(start_vertex.position)\n\n        start_time = time.time()\n\n        iterations = 0\n\n        while self._heap and iterations < self._max_iter:\n            iterations += 1\n\n            if time.time() - start_time > self._timeout:\n                # Timeout condition: no path found within time limit\n                break\n\n            _, current_vertex = heapq.heappop(self._heap)\n\n            # Early success check\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=current_vertex.position, goal=self._get_grid().goal):\n                # Connect to goal directly if possible\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(current_vertex.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = current_vertex.cost + self._cost(current_vertex, q_goal)\n                    self._graph.add_edge(current_vertex, q_goal)\n                    self._extract_path(q_goal)\n                break\n\n            # Generate new sample biased by current frontiers\n            q_sample_pos = self._goal_biased_sample()\n\n            # Find nearest vertex to sample in graph\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample_pos)\n\n            if q_near.position == q_sample_pos:\n                continue\n\n            adaptive_step = self._generate_adaptive_step(q_near.position, q_sample_pos)\n\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_pos, adaptive_step)\n\n            # Validate path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Prevent duplicating vertices in same position\n            if q_new.position in visited_positions:\n                continue\n\n            # Find local neighbors for cost computation and rewiring\n            rewire_radius = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback: connect to nearest if feasible\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_positions.add(q_new.position)\n\n            # Insert new vertex into the heap with f = g + h for future expansions\n            f_q_new = q_new.cost + self._heuristic(q_new.position)\n            heapq.heappush(self._heap, (f_q_new, q_new))\n\n            # Attempt local rewiring to optimize paths close to q_new\n            self._rewire_locally(q_new, near_vertices)\n\n            # Prune excess vertices for memory and speed\n            self._prune_excess_vertices()\n\n            self.key_frame()",
     "objective": 924.485,
     "other_inf": null,
     "results": {
          "goal_found_perc": 20.0,
          "average_steps": 6.47,
          "average_distance": 6.46,
          "average_smoothness": 0.23,
          "average_clearance": 3.42,
          "average_time": 0.01,
          "average_distance_from_goal": 7.22,
          "average_original_distance_from_goal": 8.42,
          "average memory": 21.12,
          "goal_found_perc_improvement": -79.45,
          "average_steps_improvement": -2.7,
          "average_distance_improvement": -1.89,
          "average_smoothness_improvement": -15.0,
          "average_clearance_improvement": -0.58,
          "average_time_improvement": -132.56,
          "average_distance_from_goal_improvement": -3510.0,
          "average_path_deviation": 0.1200000000000001,
          "average_memory_improvement": 43.27
     }
}
{
     "algorithm": "This improved algorithm extends the A*-inspired heuristic guided sampling path planner\n    by integrating a dual-tree bidirectional search that grows trees from both start and goal,\n    enabling faster connection and increased success rates. \n\n    Key improvements:\n    - Bidirectional tree growth (start and goal) with inter-tree connection attempts each iteration.\n    - Dynamic adaptive step size based on obstacle proximity and distance to goal/start.\n    - Enhanced goal and start biased sampling with Gaussian jitter around frontier vertices.\n    - Local rewiring in both trees to incrementally refine paths and reduce costs.\n    - Early stopping once connection between trees is established inside radius.\n    - Post path extraction smoothing via shortcutting to improve path quality and smoothness.\n    - Timeout of 10 seconds enforces robust termination.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []         # Min-heap for frontier vertices from start (f = g + h)\n        self._heap_goal = []          # Min-heap for frontier vertices from goal (f = g + h)\n        self._max_iter = 6000\n        self._goal_radius = self._get_grid().goal.radius if hasattr(self._get_grid().goal, 'radius') else 5.0\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 20.0\n        self._vertex_prune_limit = 1200\n\n    def _heuristic(self, pos: Point, target: Point) -> float:\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = Map.get_distance(to_pos, self._graph.root_vertex_goal.position)\n        max_step = self._base_step\n        if dist_to_goal < 20.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 20.0)\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n        return max_step\n\n    def _get_new_vertex(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _sample_near_frontier(self, heap: list) -> Point:\n        import random\n        import numpy as np\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n        std_dev = 7.0  # slightly smaller jitter for tighter sampling\n\n        if not heap:\n            # fallback random uniform valid sampling\n            for _ in range(50):\n                rand_coords = np.random.randint(0, grid_size, dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        best_vertex = heap[0][1]\n        base_pos = best_vertex.position\n\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            jittered_coords.append(val)\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n\n        # fallback: random near root vertices if frontier sample invalid\n        # pick random root vertex position plus small gaussian\n        roots = [v.position for v in [self._graph.root_vertex_start, self._graph.root_vertex_goal]]\n        fallback_base = random.choice(roots)\n        fallback_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = fallback_base[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            fallback_coords.append(val)\n        fallback_sample = Point(*fallback_coords)\n        if self._get_grid().is_agent_valid_pos(fallback_sample):\n            return fallback_sample\n\n        # Final fallback: goal position, guaranteed valid\n        return self._get_grid().goal.position\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex, root_vertex: Vertex) -> Vertex:\n        min_total = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position, root_vertex.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        path_start = []\n        curr = connect_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n            curr = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n            curr = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        # Concatenate start and goal paths crossing the connection edge\n        full_path = path_start + path_goal\n\n        # Shortcut and smooth the path\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list) -> None:\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n\n        # Candidates excluding roots\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def sort_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n        candidates_sorted = sorted(candidates, key=sort_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n        # Also prune heaps accordingly\n        def prune_heap(heap):\n            filtered_heap = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered_heap:\n                heap.append(item)\n\n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import random\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        heapq.heapify(self._heap_start)\n        heapq.heapify(self._heap_goal)\n\n        self._heap_start = []\n        self._heap_goal = []\n\n        heapq.heappush(self._heap_start, (self._heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_v.position, start_v.position), goal_v))\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        start_time = time.time()\n        iterations = 0\n\n        # Alternate expansions from start and goal trees\n        expand_from_start = True\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                break\n\n            if expand_from_start and self._heap_start:\n                _, current_v = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opposite_visited = visited_goal\n                current_visited = visited_start\n                current_heap = self._heap_start\n            elif (not expand_from_start) and self._heap_goal:\n                _, current_v = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opposite_visited = visited_start\n                current_visited = visited_goal\n                current_heap = self._heap_goal\n            else:\n                # if one heap is empty, switch\n                expand_from_start = not expand_from_start\n                continue\n\n            # Sample around frontier in current tree\n            sample_pos = self._sample_near_frontier(current_heap)\n\n            # Find nearest vertex in current tree\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            rewire_r = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vs = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_r)\n\n            best_parent = self._choose_best_parent(near_vs, q_new, tree_root)\n            if not best_parent:\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    expand_from_start = not expand_from_start\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n            f_q_new = q_new.cost + self._heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_q_new, q_new))\n\n            self._rewire_neighbors(q_new, near_vs)\n            self._prune_vertices(self._heap_start, self._heap_goal)\n\n            # Check connection to opposite tree vertices within small radius\n            connection_radius = self._goal_radius\n            opposite_near = self._graph.get_vertices_within_radius([goal_v if expand_from_start else start_v], q_new.position, connection_radius)\n\n            connected_vertex_opposite = None\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                connected_vertex_opposite = v_opp\n                break\n\n            if connected_vertex_opposite:\n                # Connect the two trees\n                if expand_from_start:\n                    self._graph.add_edge(q_new, connected_vertex_opposite)\n                    self._extract_bidirectional_path(q_new, connected_vertex_opposite)\n                else:\n                    self._graph.add_edge(connected_vertex_opposite, q_new)\n                    self._extract_bidirectional_path(connected_vertex_opposite, q_new)\n                break\n\n            expand_from_start = not expand_from_start",
     "objective": 2446.2,
     "other_inf": null,
     "results": {
          "goal_found_perc": 5.33,
          "average_steps": 9.75,
          "average_distance": 10.87,
          "average_smoothness": 0.37,
          "average_clearance": 4.17,
          "average_time": 0.0659,
          "average_distance_from_goal": 7.89,
          "average_original_distance_from_goal": 8.42,
          "average memory": 31.46,
          "goal_found_perc_improvement": -94.52,
          "average_steps_improvement": -13.11,
          "average_distance_improvement": -18.41,
          "average_smoothness_improvement": -85.0,
          "average_clearance_improvement": 10.9,
          "average_time_improvement": -980.33,
          "average_distance_from_goal_improvement": -3845.0,
          "average_path_deviation": 1.6899999999999995,
          "average_memory_improvement": 15.5
     }
}
{
     "algorithm": "\"\"\"\n    This improved algorithm implements an Adaptive Bidirectional Informed RRT* (ABI-RRT*) inspired approach \n    that grows two trees simultaneously\u2014one from the start and one from the goal\u2014using a heuristic confined \n    informed sampling ellipse to efficiently explore the space between start and goal. \n    \n    Core ideas:\n    - Bidirectional trees merge faster, improving success rate and efficiency.\n    - Informed sampling ellipse shrinks as better solutions appear, focusing exploration.\n    - Adaptive step sizes modulated by distance to goal and obstacle proximity.\n    - Local rewiring in each tree to optimize path quality progressively.\n    - Dynamic early stopping once a valid connecting edge is found.\n    - Path extracted by joining two trees at the connecting vertices and smoothing via shortcutting.\n    - Global timeout of 10 seconds to ensure responsiveness.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    This improved algorithm implements an Adaptive Bidirectional Informed RRT* (ABI-RRT*) inspired approach \n    that grows two trees simultaneously\u2014one from the start and one from the goal\u2014using a heuristic confined \n    informed sampling ellipse to efficiently explore the space between start and goal. \n    \n    Core ideas:\n    - Bidirectional trees merge faster, improving success rate and efficiency.\n    - Informed sampling ellipse shrinks as better solutions appear, focusing exploration.\n    - Adaptive step sizes modulated by distance to goal and obstacle proximity.\n    - Local rewiring in each tree to optimize path quality progressively.\n    - Dynamic early stopping once a valid connecting edge is found.\n    - Path extracted by joining two trees at the connecting vertices and smoothing via shortcutting.\n    - Global timeout of 10 seconds to ensure responsiveness.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._best_path_cost = float('inf')\n        self._max_iter = 8000\n        self._timeout = 10.0  # seconds\n        self._base_step = 15.0\n        self._rewire_radius = 15.0\n\n    def _heuristic(self, p: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(p, goal_pos)\n\n    def _sample_informed(self, c_min, c_best, x_center: Point, C):\n        \"\"\"\n        Sample within an n-dimensional prolate hyperspheroid (ellipse) defined by c_min and c_best \n        between start and goal to guide sampling efficiently in the promising region.\n        \"\"\"\n        import numpy as np\n\n        n = self._get_grid().size.n_dim\n        if c_best == float('inf'):\n            # No solution found yet => uniform random\n            for _ in range(50):\n                rand_coords = np.random.randint(0, self._get_grid().size, n)\n                p = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n            # fallback to some random in grid\n            return Point(*(np.random.randint(0, self._get_grid().size, n)))\n\n        # Sample from unit n-dim ball\n        while True:\n            x_ball = np.random.normal(0, 1, n)\n            x_ball /= np.linalg.norm(x_ball)\n            r = np.random.rand() ** (1.0 / n)\n            x_ball *= r\n\n            # scale the ellipse axes lengths\n            L = np.diag([c_best / 2.0] + [np.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (n - 1))\n            sample = C @ L @ x_ball + np.array(x_center)\n\n            sample_rounded = [min(max(0, int(round(coord))), self._get_grid().size[i] - 1) for i, coord in enumerate(sample)]\n            candidate = Point(*sample_rounded)\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n    def _tf_informed_sampling_transform(self, start: Point, goal: Point):\n        \"\"\"\n        Compute C matrix for transforming unit n-ball samples into the ellipse oriented between start and goal.\n        \"\"\"\n        import numpy as np\n        n = self._get_grid().size.n_dim\n        start_np = np.array(start)\n        goal_np = np.array(goal)\n        diff = goal_np - start_np\n        norm = np.linalg.norm(diff)\n        if norm == 0:\n            return np.identity(n), (start_np + goal_np) / 2.0\n\n        e1 = diff / norm\n        # Create orthonormal basis via Gram-Schmidt (only for 2D or 3D. For higher dims identity fallback)\n        U = np.identity(n)\n        U[:, 0] = e1\n        # For higher-dim extension: more complex; here fallback to identity for other dims\n        # For 2D or 3D this is sufficient as e1 is first axis\n        return U, (start_np + goal_np) / 2.0\n\n    def _generate_adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        dist_to_goal = self._heuristic(to_pos)\n        max_step = self._base_step\n        if dist_to_goal < 25.0:\n            # Shrink step size when near goal to improve precision\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 25.0)\n\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            # Penalize collision directions\n            max_step *= 0.5\n\n        return max_step\n\n    def _get_new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent_and_cost(self, vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best = None\n        for v in vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best = v\n        if best:\n            q_new.cost = min_cost\n        return best\n\n    def _rewire_locally(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            v = stack.pop()\n            for c in v.children:\n                new_cost = v.cost + self._cost(v, c)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_bidirectional_path(self, vertex_start: Vertex, vertex_goal: Vertex) -> None:\n        # Build path from start to middle\n        path_from_start = [vertex_start]\n        v = vertex_start\n        while v != self._graph.root_vertex_start:\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n            path_from_start.append(v)\n        path_from_start.reverse()\n\n        # Build path from goal to middle\n        path_from_goal = [vertex_goal]\n        v = vertex_goal\n        while v != self._graph.root_vertex_goal:\n            if not v.parents:\n                break\n            v = min(v.parents, key=lambda p: p.cost)\n            path_from_goal.append(v)\n\n        full_path = path_from_start + path_from_goal\n        smoothed_path = self._shortcut_path(full_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _vertex_connectable(self, v1: Vertex, v2: Vertex) -> bool:\n        line_seq = self._get_grid().get_line_sequence(v1.position, v2.position)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        c_min = Map.get_distance(start_vertex.position, goal_vertex.position)\n        c_best = float('inf')\n\n        transform_C, center = self._tf_informed_sampling_transform(start_vertex.position, goal_vertex.position)\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        visited_start = {start_vertex.position: start_vertex}\n        visited_goal = {goal_vertex.position: goal_vertex}\n\n        def try_connect(v_start: Vertex, v_goal: Vertex):\n            if self._vertex_connectable(v_start, v_goal):\n                total_cost = v_start.cost + self._cost(v_start, v_goal) + v_goal.cost\n                return total_cost\n            return None\n\n        for iteration in range(self._max_iter):\n\n            if time.time() - start_time > self._timeout:\n                # Timeout reached, stop planning\n                break\n\n            # Alternate between trees for expansion\n            expand_from_start = (iteration % 2 == 0)\n            tree = tree_start if expand_from_start else tree_goal\n            other_tree = tree_goal if expand_from_start else tree_start\n            visited_curr = visited_start if expand_from_start else visited_goal\n            visited_other = visited_goal if expand_from_start else visited_start\n\n            # Sample within ellipse guided by current best cost\n            q_sample_point = self._sample_informed(c_min, c_best, center, transform_C)\n\n            # Find nearest vertex in current tree\n            q_near = min(tree, key=lambda v: Map.get_distance(v.position, q_sample_point))\n            if q_near.position == q_sample_point:\n                continue\n\n            # Adaptive step towards sample\n            step_max = self._generate_adaptive_step(q_near.position, q_sample_point)\n            q_new = self._get_new_vertex_on_line(q_near.position, q_sample_point, step_max)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            if q_new.position in visited_curr:\n                continue\n\n            # Find nearby vertices for rewiring\n            near_radius = self._rewire_radius\n            near_vertices = [v for v in tree if Map.get_distance(v.position, q_new.position) <= near_radius]\n\n            # Choose best parent and cost\n            best_parent = self._choose_parent_and_cost(near_vertices, q_new)\n            if best_parent is None:\n                # fallback to q_near if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            visited_curr[q_new.position] = q_new\n            tree.append(q_new)\n\n            # Local rewiring\n            self._rewire_locally(q_new, near_vertices)\n\n            # Try to connect to the other tree vertices close to q_new\n            connection_radius = self._rewire_radius\n            candidates_to_connect = [v for v in other_tree if Map.get_distance(v.position, q_new.position) <= connection_radius]\n\n            found_connection = False\n            best_conn_cost = float('inf')\n            best_vertex_other = None\n\n            for v_other in candidates_to_connect:\n                conn_cost = try_connect(q_new, v_other) if expand_from_start else try_connect(v_other, q_new)\n                if conn_cost is not None and conn_cost < best_conn_cost:\n                    best_conn_cost = conn_cost\n                    best_vertex_other = v_other\n\n            if best_vertex_other is not None and best_conn_cost < c_best:\n                c_best = best_conn_cost\n                # Store path cost on q_new and best_vertex_other to reflect joint path\n                if expand_from_start:\n                    # q_new connects to best_vertex_other\n                    # Connect the two vertices bidirectionally to enable path extraction\n                    self._graph.add_edge(q_new, best_vertex_other)\n                else:\n                    self._graph.add_edge(best_vertex_other, q_new)\n\n                self._best_path_cost = c_best\n                self._extract_bidirectional_path(q_new if expand_from_start else best_vertex_other,\n                                                best_vertex_other if expand_from_start else q_new)\n                found_connection = True\n                break\n\n            self.key_frame()\n\n            if found_connection:\n                break",
     "objective": 539.565,
     "other_inf": null,
     "results": {
          "goal_found_perc": 46.0,
          "average_steps": 8.8,
          "average_distance": 9.18,
          "average_smoothness": 0.31,
          "average_clearance": 2.56,
          "average_time": 0.0047,
          "average_distance_from_goal": 5.03,
          "average_original_distance_from_goal": 8.42,
          "average memory": 39.94,
          "goal_found_perc_improvement": -52.74,
          "average_steps_improvement": -16.56,
          "average_distance_improvement": -16.06,
          "average_smoothness_improvement": -24.0,
          "average_clearance_improvement": 1.99,
          "average_time_improvement": 18.97,
          "average_distance_from_goal_improvement": -2415.0,
          "average_path_deviation": 1.2699999999999996,
          "average_memory_improvement": -7.28
     }
}
{
     "algorithm": "\"\"\"\n    This improved PathPlanning algorithm enhances the bidirectional heuristic-guided sampling \n    search by introducing several key improvements aimed at better smoothness, efficiency, and robustness:\n\n      - Adaptive goal and start biased sampling with dynamic Gaussian jitter influenced by iteration progress,\n        concentrating samples near promising frontier vertices.\n      - Smarter adaptive step size considering proximity to obstacles and distance to both start and goal,\n        encouraging safer and more efficient expansions.\n      - Bidirectional RRT*-style rewiring with incremental local optimization of both trees to refine costs and paths.\n      - More aggressive pruning of vertices beyond a threshold to maintain tree manageability and efficiency.\n      - Early stopping triggered upon tree connection with a well-validated edge and a timeout of 10 seconds.\n      - Post-connection path extraction followed by iterative smoothing with shortcutting and local shortcut retries,\n        resulting in smoother, shorter, and more reliable paths.\n      - Consistent keyframe marking and agent movement updates for visualization support.\n\n    Together, these augmentations aim to produce faster, more reliable plan generation capable of producing high-quality,\n    smooth paths in complex grid environments.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._heap_start = []  # Min-heap for frontier vertices from start (f = g + h)\n        self._heap_goal = []  # Min-heap for frontier vertices from goal (f = g + h)\n        self._max_iter = 6000\n        self._goal_radius = (\n            self._get_grid().goal.radius if hasattr(self._get_grid().goal, \"radius\") else 5.0\n        )\n        self._timeout = 10.0\n        self._base_step = 12.0\n        self._rewire_radius_init = 20.0\n        self._vertex_prune_limit = 1200\n\n\n    def _heuristic(self, pos: Point, target: Point) -> float:\n        return Map.get_distance(pos, target)\n\n    def _adaptive_step(self, from_pos: Point, to_pos: Point) -> float:\n        \"\"\"\n        Adaptive step size considers distance to goal and start,\n        reduces step when close to obstacles or close to start/goal,\n        encouraging finer expansions near critical regions.\n        \"\"\"\n        dist_to_goal = Map.get_distance(to_pos, self._graph.root_vertex_goal.position)\n        dist_to_start = Map.get_distance(to_pos, self._graph.root_vertex_start.position)\n        max_step = self._base_step\n\n        # Scale step down near goal or start for precise navigation\n        min_dist = min(dist_to_goal, dist_to_start)\n        if min_dist < 20.0:\n            factor = 0.3 + 0.7 * (min_dist / 20.0)\n            max_step *= factor\n\n        # Check obstacle proximity by line validity\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n\n        return max_step\n\n    def _get_new_vertex(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _sample_biased(self, heap: list, iteration: int) -> Point:\n        \"\"\"\n        Improved sampling around frontier vertices with dynamically decreasing Gaussian jitter,\n        biased towards goal or start depending on the tree.\n        Falls back to random uniform or goal if invalid.\n        \"\"\"\n        import random\n        import numpy as np\n\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n\n        # Dynamic std dev reduces over iterations for finer sampling later\n        std_dev_base = 10.0\n        decay_factor = max(0.1, 1.0 - iteration / (self._max_iter * 0.8))\n        std_dev = std_dev_base * decay_factor\n\n        if not heap:\n            # fallback random uniform valid sampling\n            for _ in range(50):\n                rand_coords = np.random.randint(0, grid_size, dim)\n                candidate = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            return self._get_grid().goal.position\n\n        best_vertex = heap[0][1]\n        base_pos = best_vertex.position\n\n        jittered_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev)\n            val = base_pos[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            jittered_coords.append(val)\n        sample = Point(*jittered_coords)\n        if self._get_grid().is_agent_valid_pos(sample):\n            return sample\n\n        # fallback sampling near root vertices with small jitter\n        roots = [v.position for v in [self._graph.root_vertex_start, self._graph.root_vertex_goal]]\n        fallback_base = random.choice(roots)\n        fallback_coords = []\n        for i in range(dim):\n            jitter = random.gauss(0, std_dev / 2)\n            val = fallback_base[i] + jitter\n            val = max(0, min(grid_size[i] - 1, int(round(val))))\n            fallback_coords.append(val)\n        fallback_sample = Point(*fallback_coords)\n        if self._get_grid().is_agent_valid_pos(fallback_sample):\n            return fallback_sample\n\n        # Final fallback to goal position guaranteed valid\n        return self._get_grid().goal.position\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex, root_vertex: Vertex) -> Vertex:\n        min_total = float(\"inf\")\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_g = v.cost + self._cost(v, q_new)\n            cost_f = cost_g + self._heuristic(q_new.position, root_vertex.position)\n            if cost_f < min_total:\n                min_total = cost_f\n                best_parent = v\n        if best_parent:\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n        return best_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            curr = stack.pop()\n            for child in curr.children:\n                new_cost = curr.cost + self._cost(curr, child)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        path_start = []\n        curr = connect_start\n        while curr != self._graph.root_vertex_start:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n            curr = parent\n        path_start.append(self._graph.root_vertex_start)\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_goal\n        while curr != self._graph.root_vertex_goal:\n            if not curr.parents:\n                break\n            parent = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n            curr = parent\n        path_goal.append(self._graph.root_vertex_goal)\n\n        # Concatenate start and goal paths crossing the connection edge\n        full_path = path_start + path_goal\n\n        # Iterative smoothing: multiple rounds of shortcutting for better smoothness\n        smoothed_path = full_path\n        for _ in range(3):\n            smoothed_path = self._shortcut_path(smoothed_path)\n\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _prune_vertices(self, heap_start: list, heap_goal: list) -> None:\n        max_vertices = self._vertex_prune_limit\n        if self._graph.size <= max_vertices:\n            return\n\n        # Candidates excluding root vertices\n        candidates = [v for v in self._graph.root_vertices if v not in (self._graph.root_vertex_start, self._graph.root_vertex_goal)]\n        if not candidates:\n            return\n\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def sort_key(v):\n            return v.cost + Map.get_distance(v.position, goal_pos)\n\n        candidates_sorted = sorted(candidates, key=sort_key, reverse=True)\n        to_remove_count = self._graph.size - max_vertices\n        to_remove = candidates_sorted[:to_remove_count]\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n        self._graph.size = len(self._graph.root_vertices)\n\n        # Prune heaps to keep consistency\n        def prune_heap(heap):\n            filtered_heap = [(f, v) for (f, v) in heap if v in self._graph.root_vertices]\n            heap.clear()\n            for item in filtered_heap:\n                heap.append(item)\n\n        prune_heap(heap_start)\n        prune_heap(heap_goal)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        self._heap_start = []\n        self._heap_goal = []\n        heapq.heapify(self._heap_start)\n        heapq.heapify(self._heap_goal)\n\n        # Initialize heaps with roots\n        heapq.heappush(self._heap_start, (self._heuristic(start_v.position, goal_v.position), start_v))\n        heapq.heappush(self._heap_goal, (self._heuristic(goal_v.position, start_v.position), goal_v))\n\n        visited_start = {start_v.position: start_v}\n        visited_goal = {goal_v.position: goal_v}\n\n        start_time = time.time()\n        iterations = 0\n        expand_from_start = True\n\n        while iterations < self._max_iter and (self._heap_start or self._heap_goal):\n            iterations += 1\n            if time.time() - start_time > self._timeout:\n                # Timeout reached - no path found reliably in time\n                break\n\n            if expand_from_start and self._heap_start:\n                _, current_v = heapq.heappop(self._heap_start)\n                tree_root = start_v\n                opposite_root = goal_v\n                opposite_visited = visited_goal\n                current_visited = visited_start\n                current_heap = self._heap_start\n            elif (not expand_from_start) and self._heap_goal:\n                _, current_v = heapq.heappop(self._heap_goal)\n                tree_root = goal_v\n                opposite_root = start_v\n                opposite_visited = visited_start\n                current_visited = visited_goal\n                current_heap = self._heap_goal\n            else:\n                expand_from_start = not expand_from_start\n                continue\n\n            # Sample around frontier with bias and iteration-based tuning\n            sample_pos = self._sample_biased(current_heap, iterations)\n\n            # Find nearest vertex from current tree\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_pos)\n            if q_near.position == sample_pos:\n                expand_from_start = not expand_from_start\n                continue\n\n            step = self._adaptive_step(q_near.position, sample_pos)\n            q_new = self._get_new_vertex(q_near.position, sample_pos, step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                expand_from_start = not expand_from_start\n                continue\n\n            if q_new.position in current_visited:\n                expand_from_start = not expand_from_start\n                continue\n\n            # Rewiring radius decreases over time but not below minimum\n            rewire_r = max(self._rewire_radius_init * (1.0 - iterations / self._max_iter), 6.0)\n            near_vs = self._graph.get_vertices_within_radius([tree_root], q_new.position, rewire_r)\n\n            best_parent = self._choose_best_parent(near_vs, q_new, tree_root)\n            if not best_parent:\n                # If no best parent from rewire neighbors, consider nearest vertex if valid line\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    expand_from_start = not expand_from_start\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            current_visited[q_new.position] = q_new\n            f_q_new = q_new.cost + self._heuristic(q_new.position, tree_root.position)\n            heapq.heappush(current_heap, (f_q_new, q_new))\n\n            # Rewire neighbors for local cost improvement\n            self._rewire_neighbors(q_new, near_vs)\n\n            # Prune vertices to control tree size and improve efficiency\n            self._prune_vertices(self._heap_start, self._heap_goal)\n\n            # Attempt to connect to opposite tree close vertices with robust line checking\n            connection_radius = self._goal_radius\n            opposite_near = self._graph.get_vertices_within_radius([opposite_root], q_new.position, connection_radius)\n\n            connected_vertex_opposite = None\n            for v_opp in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(q_new.position, v_opp.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    continue\n                connected_vertex_opposite = v_opp\n                break\n\n            if connected_vertex_opposite:\n                # Connect two trees with edge depending on expansion direction\n                if expand_from_start:\n                    self._graph.add_edge(q_new, connected_vertex_opposite)\n                    self._extract_bidirectional_path(q_new, connected_vertex_opposite)\n                else:\n                    self._graph.add_edge(connected_vertex_opposite, q_new)\n                    self._extract_bidirectional_path(connected_vertex_opposite, q_new)\n                break\n\n            expand_from_start = not expand_from_start",
     "objective": 3962.045,
     "other_inf": null,
     "results": {
          "goal_found_perc": 8.0,
          "average_steps": 7.92,
          "average_distance": 7.99,
          "average_smoothness": 0.32,
          "average_clearance": 4.23,
          "average_time": 0.1156,
          "average_distance_from_goal": 7.85,
          "average_original_distance_from_goal": 8.42,
          "average memory": 32.22,
          "goal_found_perc_improvement": -91.78,
          "average_steps_improvement": -8.05,
          "average_distance_improvement": -9.45,
          "average_smoothness_improvement": -3.23,
          "average_clearance_improvement": -0.7,
          "average_time_improvement": -2040.74,
          "average_distance_from_goal_improvement": -3825.0,
          "average_path_deviation": 0.6900000000000004,
          "average_memory_improvement": 13.46
     }
}
{
     "algorithm": "\"\"\"\n    An enhanced RRT*-inspired path planning algorithm emphasizing memory efficiency \n    and robust rapid convergence. It uses a bidirectional tree growth from start \n    and goal with heuristic guided, adaptive sampling and step sizing. The algorithm \n    dynamically shrinks the rewiring radius based on vertex density and iteration \n    progress while pruning distant vertices to control memory use tightly. Early \n    termination occurs upon connection between trees or timeout (~10s). The final \n    path undergoes shortcut smoothing for optimality. Bidirectional search, adaptive \n    step scaling, and conservative rewiring improve success rate, reduce iterations, \n    and yield smoother, shorter collision-free paths.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An enhanced RRT*-inspired path planning algorithm emphasizing memory efficiency \n    and robust rapid convergence. It uses a bidirectional tree growth from start \n    and goal with heuristic guided, adaptive sampling and step sizing. The algorithm \n    dynamically shrinks the rewiring radius based on vertex density and iteration \n    progress while pruning distant vertices to control memory use tightly. Early \n    termination occurs upon connection between trees or timeout (~10s). The final \n    path undergoes shortcut smoothing for optimality. Bidirectional search, adaptive \n    step scaling, and conservative rewiring improve success rate, reduce iterations, \n    and yield smoother, shorter collision-free paths.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15          # Bias for goal sampling\n        self._rewire_radius = 15.0      # Initial rewiring radius\n        self._vertex_limit = 1200       # Limit vertices to reduce memory\n        self._bidirectional = True      # Enable bidirectional search\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new_pos = Point.from_tensor(q_new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self, root_vertices: list) -> Point:\n        import random\n        # Alternate biasing between start and goal trees to balance approach\n        bias_towards_goal = random.random() < self._goal_bias\n        if bias_towards_goal:\n            # Sample near goal\n            return self._get_grid().goal.position\n        else:\n            # Uniform random sampling with validity check\n            attempts = 0\n            while attempts < 50:\n                rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            # Fallback to goal if fails repeatedly\n            return self._get_grid().goal.position\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = v.cost + self._cost(v, q_new)\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        # Restrict rewiring to vertices with better cost only\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._cost(q_new, v)\n            if cost_through_new < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_new\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, connection_from_start: Vertex, connection_from_goal: Vertex) -> None:\n        # Extract path from start tree\n        path_start = [connection_from_start]\n        current = connection_from_start\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n            path_start.append(current)\n        path_start.reverse()\n\n        # Extract path from goal tree\n        path_goal = [connection_from_goal]\n        current = connection_from_goal\n        while current != self._graph.root_vertex_goal:\n            if not current.children:\n                break\n            current = min(current.children, key=lambda c: c.cost)\n            path_goal.append(current)\n\n        # Combine paths at connection point\n        full_path = path_start + path_goal[1:]\n\n        # Smooth path shortcuts where possible\n        smoothed = self._shortcut_path(full_path)\n        for vertex in smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        min_radius = 4.0\n        radius = self._rewire_radius * (1 - iteration / max_iterations)\n        return max(min_radius, radius)\n\n    def _limit_graph_size(self) -> None:\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Exclude roots\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        # Sort by cost descending (remove worst)\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 7000\n        max_dist_base = self._max_dist_base\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Maintain separate vertex sets for bidirectional search\n        vertices_start = [start_vertex]\n        vertices_goal = [goal_vertex]\n\n        connected = False\n        connection_from_start = None\n        connection_from_goal = None\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            # Alternate between expanding start and goal trees\n            expand_start_tree = (iteration % 2 == 0)\n\n            root_vertices = [start_vertex] if expand_start_tree else [goal_vertex]\n            other_vertices = vertices_goal if expand_start_tree else vertices_start\n\n            sample = self._get_goal_biased_sample(root_vertices)\n\n            nearest = self._graph.get_nearest_vertex(root_vertices, sample)\n            if nearest.position == sample:\n                continue\n\n            dist_to_sample = Map.get_distance(nearest.position, sample)\n            # Adaptive step size: shorter near obstacles, longer in open areas\n            adaptive_step = min(max_dist_base, dist_to_sample)\n            adaptive_step *= 0.65 + 0.35 * (1 - min(nearest.cost / 100.0, 1.0))\n\n            new_vertex = self._get_new_vertex(nearest, sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(nearest.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrink rewire radius progressively\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius(root_vertices, new_vertex.position, cur_rewire_radius)\n            parent = self._choose_parent(near_vertices, new_vertex)\n            if parent is None:\n                # Fallback to nearest if path collision free\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    new_vertex.cost = nearest.cost + self._cost(nearest, new_vertex)\n                    parent = nearest\n                else:\n                    continue\n\n            self._graph.add_edge(parent, new_vertex)\n\n            self._rewire(near_vertices, new_vertex)\n\n            # Add new vertex to appropriate set\n            if expand_start_tree:\n                vertices_start.append(new_vertex)\n            else:\n                vertices_goal.append(new_vertex)\n\n            # Limit size to control memory\n            self._limit_graph_size()\n\n            # Check if the new vertex connects to the opposite tree within radius\n            opposite_near = self._graph.get_vertices_within_radius(\n                other_vertices, new_vertex.position, cur_rewire_radius\n            )\n            connection_vertex = None\n            min_connection_cost = float('inf')\n            for v in opposite_near:\n                line_seq_connect = self._get_grid().get_line_sequence(new_vertex.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_connect):\n                    total_cost = new_vertex.cost + self._cost(new_vertex, v) + v.cost\n                    if total_cost < min_connection_cost:\n                        min_connection_cost = total_cost\n                        connection_vertex = v\n\n            if connection_vertex is not None:\n                connected = True\n                if expand_start_tree:\n                    connection_from_start = new_vertex\n                    connection_from_goal = connection_vertex\n                else:\n                    connection_from_start = connection_vertex\n                    connection_from_goal = new_vertex\n                break\n\n            self.key_frame()\n\n        if connected and connection_from_start and connection_from_goal:\n            self._extract_path(connection_from_start, connection_from_goal)",
     "objective": 908.81,
     "other_inf": null,
     "results": {
          "goal_found_perc": 9.33,
          "average_steps": 5.43,
          "average_distance": 5.35,
          "average_smoothness": 0.23,
          "average_clearance": 2.35,
          "average_time": 0.0019,
          "average_distance_from_goal": 7.55,
          "average_original_distance_from_goal": 8.42,
          "average memory": 41.63,
          "goal_found_perc_improvement": -90.41,
          "average_steps_improvement": -0.0,
          "average_distance_improvement": -0.0,
          "average_smoothness_improvement": -27.78,
          "average_clearance_improvement": -1.67,
          "average_time_improvement": 34.48,
          "average_distance_from_goal_improvement": -3675.0,
          "average_path_deviation": 0.0,
          "average_memory_improvement": -11.82
     }
}
{
     "algorithm": "This new algorithm implements a Heuristic-Guided Anytime Rapidly-exploring Random Graph (HG-ARG) algorithm.\n    It expands a unified graph (not two trees) from the start vertex, but biasing samples strongly towards the goal \n    using adaptive probabilistic goal bias and heuristic-based vertex prioritization.\n\n    Key features:\n    - Single graph expansion with heuristic best-first search ordering of frontier vertices.\n    - Goal-biased adaptive sampling with increasing randomness over iterations to escape local minima.\n    - Dynamic max step size adjusted based on obstacle proximity and remaining distance to goal.\n    - Incremental local optimization via rewiring neighbors to progressively improve path quality.\n    - Anytime behavior: keeps improving best path found if any until timeout or max iterations.\n    - Early stopping once agent can reach goal and path cost converges within a threshold.\n    - Smooth path extraction with iterative shortcutting after planning ends.\n    - Timeout set to 10 seconds to ensure responsiveness.\n\n    This approach simplifies bidirectional complexity by focusing on a single unified graph, improving success and path quality,\n    while guided heuristic search and adaptive parameters boost efficiency and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        self._graph = Forest(start_vertex, self._get_grid().goal.position, [start_vertex])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # New member variables for heuristic guided anytime expansion\n        self._max_iter = 5000\n        self._timeout = 10.0\n        self._goal_radius = (\n            self._get_grid().goal.radius\n            if hasattr(self._get_grid().goal, \"radius\")\n            else 5.0\n        )\n        self._base_step = 14.0\n        self._rewire_radius = 12.0\n        self._best_cost = float(\"inf\")\n        self._best_goal_vertex = None\n\n    def _heuristic(self, pos: Point) -> float:\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _adaptive_step(self, frm: Point, to: Point) -> float:\n        dist_to_goal = self._heuristic(to)\n        max_step = self._base_step\n\n        if dist_to_goal < 30.0:\n            max_step *= 0.4 + 0.6 * (dist_to_goal / 30.0)\n\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            max_step *= 0.5\n        return max_step\n\n    def _get_new_vertex_on_line(self, start: Point, end: Point, max_step: float) -> Vertex:\n        vec = end.to_tensor() - start.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_step:\n            return Vertex(end)\n        direction = vec / dist\n        new_pos_tensor = start.to_tensor() + direction * max_step\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _choose_best_parent(self, near_vertices, q_new: Vertex) -> Vertex:\n        min_cost = float(\"inf\")\n        best = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            candidate_cost = v.cost + self._cost(v, q_new)\n            if candidate_cost < min_cost:\n                min_cost = candidate_cost\n                best = v\n        if best:\n            q_new.cost = min_cost\n        return best\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        for v in neighbors:\n            if v is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, v)\n            if new_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n                self._propagate_cost_update(v)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        stack = [vertex]\n        while stack:\n            v = stack.pop()\n            for c in v.children:\n                new_cost = v.cost + self._cost(v, c)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _extract_and_move_along_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"\n        Extract path from start vertex to goal_vertex and move agent along the path.\n        Perform iterative shortcut smoothing.\n        \"\"\"\n        path = []\n        curr = goal_vertex\n        while True:\n            path.append(curr)\n            if curr == self._graph.root_vertex_start:\n                break\n            if not curr.parents:\n                break\n            curr = min(curr.parents, key=lambda p: p.cost)\n        path.reverse()\n\n        # Iterative shortcut smoothing (3 iterations)\n        for _ in range(3):\n            path = self._shortcut_path(path)\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _sample(self, iteration: int, goal_bias_prob: float = 0.2) -> Point:\n        \"\"\"\n        Sampling strategy:\n        - With probability goal_bias_prob, sample directly at the goal.\n        - Else uniformly sample in free space.\n        - Bias goal_prob increases slightly every 500 iterations to focus near goal later.\n        \"\"\"\n        import numpy as np\n        import random\n\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        # Increasing goal bias probability over iterations for anytime focus\n        goal_prob = min(0.6, goal_bias_prob + iteration * 0.0002)\n\n        if random.random() < goal_prob:\n            return grid.goal.position\n\n        # Uniform random sample attempts with validity check\n        attempts = 50\n        for _ in range(attempts):\n            coords = []\n            for i in range(dim):\n                coord = np.random.randint(0, grid.size[i])\n                coords.append(coord)\n            p = Point(*coords)\n            if grid.is_agent_valid_pos(p):\n                return p\n\n        # Fallback to goal position guaranteed valid\n        return grid.goal.position\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        vertices = [start_vertex]\n        visited = {start_vertex.position: start_vertex}\n        frontier = [start_vertex]\n\n        iteration = 0\n        improved_last_found_iter = 0\n        cost_tolerance = 1e-3  # Early convergence tolerance\n\n        while iteration < self._max_iter:\n            iteration += 1\n            if time.time() - start_time > self._timeout:\n                break\n\n            # Sample with adaptive goal bias\n            q_sample_point = self._sample(iteration)\n\n            # Select frontier vertex closest to sampled point heuristically prioritized by cost+heuristic\n            best_vertex = None\n            best_score = float(\"inf\")\n            for v in frontier:\n                score = v.cost + self._heuristic(v.position) + Map.get_distance(v.position, q_sample_point)\n                if score < best_score:\n                    best_score = score\n                    best_vertex = v\n            if best_vertex is None:\n                break\n\n            # Get new vertex towards sample with adaptive step\n            step_size = self._adaptive_step(best_vertex.position, q_sample_point)\n            q_new = self._get_new_vertex_on_line(best_vertex.position, q_sample_point, step_size)\n\n            if q_new.position in visited:\n                continue\n\n            # Validate edge before adding\n            line_seq = grid.get_line_sequence(best_vertex.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within rewire radius\n            near_vertices = [v for v in vertices if Map.get_distance(v.position, q_new.position) <= self._rewire_radius]\n\n            # Choose parent minimizing cost via valid edges\n            parent = self._choose_best_parent(near_vertices, q_new)\n            if parent is None:\n                # fallback to closest vertex if edge valid\n                if grid.is_valid_line_sequence(line_seq):\n                    q_new.cost = best_vertex.cost + self._cost(best_vertex, q_new)\n                    parent = best_vertex\n                else:\n                    continue\n\n            # Add q_new to graph and bookkeeping\n            self._graph.add_edge(parent, q_new)\n            vertices.append(q_new)\n            frontier.append(q_new)\n            visited[q_new.position] = q_new\n\n            # Rewire neighbors to optimize locally\n            self._rewire_neighbors(q_new, near_vertices)\n\n            # Remove frontier vertices that have no children (dead-end pruning)\n            frontier = [v for v in frontier if v.children or v == start_vertex]\n\n            # Check if goal is reached within radius\n            dist_to_goal = self._heuristic(q_new.position)\n            if dist_to_goal <= self._goal_radius:\n                # Try to connect directly to goal vertex\n                goal_pos = grid.goal.position\n                line_seq_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    # Assign cost for goal vertex\n                    goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n\n                    self._graph.add_edge(q_new, goal_vertex)\n                    vertices.append(goal_vertex)\n                    visited[goal_vertex.position] = goal_vertex\n                    self._best_goal_vertex = goal_vertex\n\n                    # Check if new path improves best cost\n                    if goal_vertex.cost + cost_tolerance < self._best_cost:\n                        self._best_cost = goal_vertex.cost\n                        improved_last_found_iter = iteration\n\n            # Anytime early stopping: if cost hasn't improved in 300 iterations and have a solution\n            if (\n                self._best_goal_vertex is not None\n                and (iteration - improved_last_found_iter) > 300\n            ):\n                break\n\n            # Mark keyframe for visualization\n            self.key_frame()\n\n        # If found a goal vertex, extract and move along path with smoothing\n        if self._best_goal_vertex is not None:\n            self._extract_and_move_along_path(self._best_goal_vertex)",
     "objective": 2192150.72,
     "other_inf": null,
     "results": {
          "goal_found_perc": 23.33,
          "average_steps": 4.26,
          "average_distance": 3.91,
          "average_smoothness": 0.18,
          "average_clearance": 2.73,
          "average_time": 10.2678,
          "average_distance_from_goal": 7.54,
          "average_original_distance_from_goal": 8.42,
          "average memory": 288529.12,
          "goal_found_perc_improvement": -76.03,
          "average_steps_improvement": -0.0,
          "average_distance_improvement": -0.0,
          "average_smoothness_improvement": -20.0,
          "average_clearance_improvement": -0.36,
          "average_time_improvement": -427725.0,
          "average_distance_from_goal_improvement": -3670.0,
          "average_path_deviation": 0.0,
          "average_memory_improvement": -774890.92
     }
}
