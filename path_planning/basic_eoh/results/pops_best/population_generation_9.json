{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the rapid exploration and bidirectional growth of dual-tree RRT with the optimization and rewiring capabilities of RRT*. It uses goal-biased sampling with adaptive neighborhood radius and incorporates incremental rewiring when adding nodes to improve path quality progressively. The planner grows two trees simultaneously from start and goal, attempts frequent connections, and applies rewiring locally to shorten paths, ensuring collision-free nodes and edges at all steps. Such integration enhances planning efficiency, success rate, and path smoothness while reducing overall search time.",
     "planning_mechanism": "The planner alternates expansions between start and goal trees. Each iteration samples (with goal bias), extends the nearest node towards the sample by a fixed step size, checks collisions on node and edge, then connects the new node to the best parent in its neighborhood to minimize cost. Afterwards, neighbors are rewired if lower-cost paths through the new node exist without collision. It attempts direct connections between the two trees after each expansion, terminating early once a connection is found. The final path is extracted bidirectionally and returned.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from start node\n        self.children = []\n        self.valid = True               # Validity flag for collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, max_radius: float=20.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            curr = connect_node\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                if distance(new_pos, node_a.position) < self.step_size:\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        # Adaptive radius function decreases with iterations, but not below a minimum radius\n        def adaptive_radius(iter_num):\n            gamma = self.max_radius *  (math.log(iter_num + 1 + 1) / (iter_num + 1))**0.5\n            return max(min(gamma, self.max_radius), self.step_size)\n\n        for iter_num in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal bias sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                radius = adaptive_radius(iter_num)\n                neighbors = find_near(tree_a, new_node, radius)\n\n                # Choose best parent minimizing cost for the new node\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors to possibly improve their path costs\n                rewire(tree_a, new_node, neighbors)\n\n                # Try connecting the two trees\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": -7.79662,
     "time_improvement": 21.0,
     "length_improvement": 8.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.008672499656677246,
               "num_nodes_avg": 171.6,
               "path_length_avg": 178.58706890783012,
               "smoothness_avg": 0.01287433619980249,
               "success_improvement": 0.0,
               "time_improvement": 12.254857027070063,
               "length_improvement": 10.743899448907847,
               "smoothness_improvement": 23.706492344377313,
               "objective_score": 5.943769459624475
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.01442580223083496,
               "num_nodes_avg": 417.4,
               "path_length_avg": 285.20214147412014,
               "smoothness_avg": 0.006810454997463837,
               "success_improvement": 0.0,
               "time_improvement": 4.938302639145074,
               "length_improvement": 5.360280641017321,
               "smoothness_improvement": -4.592070180053407,
               "objective_score": 2.5305865690467195
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.015455484390258789,
               "num_nodes_avg": 416.6,
               "path_length_avg": 150.10711452935692,
               "smoothness_avg": 0.014126727627698357,
               "success_improvement": 0.0,
               "time_improvement": 44.346621176700864,
               "length_improvement": 7.825189074258418,
               "smoothness_improvement": 9.298433618285387,
               "objective_score": 14.91551633595337
          }
     ],
     "success_rate": 1.0
}