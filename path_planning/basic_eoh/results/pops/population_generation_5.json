[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.47449114023227,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012044763565063477,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": -21.86446156592386,
                    "length_improvement": 12.401486536989607,
                    "smoothness_improvement": 60.71897053377777,
                    "objective_score": -3.7754463097103477
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017744064331054688,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": -16.928046454483464,
                    "length_improvement": 14.190408824541839,
                    "smoothness_improvement": 52.81399740357816,
                    "objective_score": -1.9762621844187802
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009687995910644532,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.11466785256512,
                    "length_improvement": 11.655572158065754,
                    "smoothness_improvement": 61.933425488650386,
                    "objective_score": 22.175181914825938
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -1.486610468143649,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008508419990539551,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 13.914954384712244,
                    "length_improvement": 5.9265718433081265,
                    "smoothness_improvement": 7.497776338222911,
                    "objective_score": 5.397289565766413
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017635869979858398,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": -16.21507822540353,
                    "length_improvement": 0.3867603104208941,
                    "smoothness_improvement": 0.5583282013809732,
                    "objective_score": -4.784379764529976
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024777650833129883,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 10.77859785250502,
                    "length_improvement": 2.8534839845313615,
                    "smoothness_improvement": 8.529090107346295,
                    "objective_score": 3.84692160319451
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm combines bidirectional growth of two trees with asymptotic optimality via rewiring, incorporating goal biasing and adaptive neighborhood sampling to efficiently find smooth, short, and collision-free paths in 2D or 3D environments containing obstacles. It balances exploration and exploitation to improve success rate, path quality, and planning speed.",
          "planning_mechanism": "The planner grows two trees\u2014one from start and one from goal\u2014by sampling free space with a bias towards the goal. Each extension considers a neighborhood for rewiring to optimize costs. After each new node insertion, the planner attempts to connect the two trees with collision-checked edges, extracting the best path upon success. Adaptive radius and collision checks ensure robustness and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision and validity checks\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        success = False\n        path: list[tuple] = []\n\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            while node_start:\n                path_s.append(node_start.position)\n                node_start = node_start.parent\n            while node_goal:\n                path_g.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_s[::-1] + path_g\n\n        def adaptive_radius(n_nodes):\n            # Radius adaptively shrinks with number of nodes, capped by base_radius\n            gamma = self.base_radius\n            return min(gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        for i in range(self.max_iter):\n            # Goal biasing sampling alternating between trees\n            sample_from_start = (i % 2 == 0)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    # Rewire\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt connection from new_node in tree_a to nearest in tree_b\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d):\n                    # Connect both trees with minimal cost\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # No connection found\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1.22143,
          "time_improvement": -7.0,
          "length_improvement": 4.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008090043067932129,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 185.6649117391287,
                    "smoothness_avg": 0.010914094873855713,
                    "success_improvement": 0.0,
                    "time_improvement": 18.14793730129248,
                    "length_improvement": 7.2064616304885325,
                    "smoothness_improvement": 4.870990861583404,
                    "objective_score": 6.9100284707933675
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014984416961669921,
                    "num_nodes_avg": 248.6,
                    "path_length_avg": 303.9601784431043,
                    "smoothness_avg": 0.006630449936174837,
                    "success_improvement": 0.0,
                    "time_improvement": 1.2571995965398015,
                    "length_improvement": -0.8642706379259195,
                    "smoothness_improvement": -7.113768107885172,
                    "objective_score": 0.16873691083733064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.038583230972290036,
                    "num_nodes_avg": 419.1,
                    "path_length_avg": 155.2327737852811,
                    "smoothness_avg": 0.01296368234295665,
                    "success_improvement": 0.0,
                    "time_improvement": -38.93367010102172,
                    "length_improvement": 4.6777255162124165,
                    "smoothness_improvement": 0.2999570284091653,
                    "objective_score": -10.743056141921985
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT planner optimized for enhanced efficiency, path quality, and robustness. It alternates growth of two trees from start and goal, samples points with goal bias, and ensures strict collision checking for newly added nodes and connecting edges. Upon connection, it reconstructs the path and applies shortcut smoothing to reduce unnecessary detours and improve smoothness. The design balances exploration depth and computational effort for improved success rates and faster convergence.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal by sampling free configurations biased toward the goal. It extends each tree by steering towards sampled points within step size, validating new nodes and edges via collision-free checks. When the two trees connect, the planner reconstructs the full path and performs iterative shortcut smoothing to optimize path quality before returning the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 3.0, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                         \n        start_position = map.start                 \n        goal_position = map.goal                   \n        obstacles = map.obstacles                  \n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, target_node):\n            current = _nearest(tree, target_node.position)\n            while True:\n                next_pos = _steer(current.position, target_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, target_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(40):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if not new_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.98769,
          "time_improvement": -24.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01088719367980957,
                    "num_nodes_avg": 134.1,
                    "path_length_avg": 175.03233523134534,
                    "smoothness_avg": 0.013335379012390985,
                    "success_improvement": 0.0,
                    "time_improvement": -10.152597731537979,
                    "length_improvement": 12.52052117410358,
                    "smoothness_improvement": 28.136545147160557,
                    "objective_score": -0.4009923589048745
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023423933982849122,
                    "num_nodes_avg": 412.5,
                    "path_length_avg": 250.35117199926208,
                    "smoothness_avg": 0.021827263057035733,
                    "success_improvement": 0.0,
                    "time_improvement": -54.356678931773125,
                    "length_improvement": 16.925011373547015,
                    "smoothness_improvement": 205.77897991876952,
                    "objective_score": -11.893106505228687
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029634523391723632,
                    "num_nodes_avg": 463.6,
                    "path_length_avg": 126.67064640606554,
                    "smoothness_avg": 0.03621107325015106,
                    "success_improvement": 0.0,
                    "time_improvement": -6.710428151123073,
                    "length_improvement": 22.216592338552495,
                    "smoothness_improvement": 180.16492496948817,
                    "objective_score": 3.3310146472210187
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planning algorithm combines bidirectional search from the dual-tree RRT with asymptotically optimal rewiring from RRT*. It grows two trees from start and goal, alternately extending towards random samples and attempting connections. Each extension uses rewiring within a neighborhood radius to optimize paths locally. The goal biasing accelerates convergence. Collision and edge checks ensure validity. The hybrid approach improves planning efficiency, path quality, robustness, success rate, and smoothness by leveraging complementary strengths of both methods.",
          "planning_mechanism": "The planner maintains start and goal trees, grows them bidirectionally by sampling points and steering towards them. For each new node added, it finds neighbors within a radius to rewire and minimize cost. After each extension, it attempts to connect the two trees directly. If a connection is found without collision, the path is extracted. Goal biasing increases attempts towards the goal to speed up convergence. The algorithm terminates early upon a successful path or after max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, search_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-assign parent\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            # Try building connection backward from connect_node towards node_a\n            curr = connect_node\n            connection_chain = []\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                connection_chain.append(new_node)\n                if distance(new_pos, node_a.position) < self.step_size:\n                    # Final connect node\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_from_start, node_from_goal):\n            path_start = []\n            node = node_from_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_from_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree selection for expanding\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing on sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                # Boundary check\n                out_of_bounds = any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds)))\n                if out_of_bounds:\n                    continue\n\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Find neighbors for rewiring\n                neighbors = find_near(tree_a, new_node, self.search_radius)\n                # Choose best parent\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = cost\n                            min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors through new_node if better\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt to connect the other tree directly\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.2445,
          "time_improvement": -28.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013188529014587402,
                    "num_nodes_avg": 194.0,
                    "path_length_avg": 173.0342779839435,
                    "smoothness_avg": 0.021996203295678553,
                    "success_improvement": 0.0,
                    "time_improvement": -33.436657226802765,
                    "length_improvement": 13.519130982034183,
                    "smoothness_improvement": 111.35638469997163,
                    "objective_score": -6.770389048134134
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024630069732666016,
                    "num_nodes_avg": 484.0,
                    "path_length_avg": 244.14905520536445,
                    "smoothness_avg": 0.015383195714505082,
                    "success_improvement": 0.0,
                    "time_improvement": -62.30475071249689,
                    "length_improvement": 18.9830835527118,
                    "smoothness_improvement": 115.50378905411706,
                    "objective_score": -14.317289557936123
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024231910705566406,
                    "num_nodes_avg": 405.4,
                    "path_length_avg": 130.81419641767454,
                    "smoothness_avg": 0.028347178181784644,
                    "success_improvement": 0.0,
                    "time_improvement": 12.743743770384414,
                    "length_improvement": 19.672203019772287,
                    "smoothness_improvement": 119.32200113298974,
                    "objective_score": 8.354173740734732
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner with optimized parameters to improve efficiency, path quality, and success rate. It features reduced step size for finer expansions, increased maximum iterations for deeper search, and a goal bias sampling probability to accelerate convergence. Collision checking is precise with a refined resolution, and post-planning path smoothing via shortcutting reduces unnecessary detours and improves smoothness.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions, alternately expanding each towards sampled points biased towards the goal. Each new node and edge is strictly checked for collision-free feasibility. When the trees connect, the planner reconstructs the path, smooths it by iteratively shortcutting, and returns the optimized trajectory along with explored graph data.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.6782,
          "time_improvement": -33.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010827350616455077,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 163.9683475002103,
                    "smoothness_avg": 0.014173695614508616,
                    "success_improvement": 0.0,
                    "time_improvement": -9.547127756576938,
                    "length_improvement": 18.050195900642194,
                    "smoothness_improvement": 36.19173375747664,
                    "objective_score": 0.9268595219427409
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03178107738494873,
                    "num_nodes_avg": 498.6,
                    "path_length_avg": 249.62854531281232,
                    "smoothness_avg": 0.0401662199932736,
                    "success_improvement": 0.0,
                    "time_improvement": -109.42774008867326,
                    "length_improvement": 17.164803355659895,
                    "smoothness_improvement": 462.6901432691145,
                    "objective_score": -27.081910639124423
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02228260040283203,
                    "num_nodes_avg": 378.2,
                    "path_length_avg": 125.71203140928696,
                    "smoothness_avg": 0.05507350730124254,
                    "success_improvement": 0.0,
                    "time_improvement": 19.762980565745675,
                    "length_improvement": 22.805239694513528,
                    "smoothness_improvement": 326.10349972973546,
                    "objective_score": 12.120459607275086
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional search strategy from the enhanced bidirectional RRT with the incremental rewiring and local path optimization of RRT*. It grows two trees from start and goal, alternately expanding toward sampled points with goal bias. New nodes choose parents through cost minimization within a neighbor radius, and rewire nearby nodes to reduce path costs. Upon connecting the two trees, the solution path is reconstructed and smoothed via iterative shortcutting to improve path quality and smoothness, balancing exploration, optimality, and efficiency.",
          "planning_mechanism": "The planner alternates growing two trees towards random samples biased to the goal. Each new node chooses the best parent within a neighborhood to minimize cost, rewires neighbors for better paths, and checks collision at nodes and edges. When the two trees connect, the path is extracted and smoothed by shortcutting to yield a high-quality trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start/goal root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=8.0, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # list of obstacle boxes\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        # Helper functions\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _near_nodes(tree, point):\n            return [node for node in tree if math.dist(node.position, point) <= self.neighbor_radius]\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def _can_connect(parent_node, new_pos, tree):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            import math\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        edges.remove((node.parent, node))\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # node_b path from root is from goal to connecting point, reverse it excluding connecting node to avoid duplication\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n\n        # Main loop - alternate between tree expansions\n        for i in range(self.max_iter):\n            # Sample point (goal bias applied inside _sample_free)\n            sample = _sample_free()\n\n            # Extend tree_a towards sample\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample)\n            if not _can_connect(nearest_node_a, new_pos_a, tree_a):\n                tree_a, tree_b = tree_b, tree_a  # swap trees if extension fails\n                continue\n\n            # Determine neighbors and best parent for new node in tree_a\n            near_nodes_a = _near_nodes(tree_a, new_pos_a)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.parent = None\n            new_node_a.cost = 0\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            # Rewire neighbors in tree_a via new_node_a\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            # Try connecting tree_b to new_node_a\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n            if dist <= self.step_size:\n                if (not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(new_node_a.position, obstacles, is_3d)):\n                    # Connected, create connecting node in tree_b if needed\n                    connecting_node_b = None\n                    if nearest_node_b.position != new_node_a.position:\n                        connecting_node_b = Node(new_node_a.position)\n                        connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                        tree_b.append(connecting_node_b)\n                        nodes.append(connecting_node_b)\n                        edges.append((nearest_node_b, connecting_node_b))\n                    else:\n                        connecting_node_b = nearest_node_b\n\n                    # Rewire tree_b neighbors around connecting_node_b\n                    near_nodes_b = _near_nodes(tree_b, connecting_node_b.position)\n                    _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                    # Reconstruct full path from start_root to goal_root\n                    success_state = True\n                    extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                    extracted_path = _smooth_path(extracted_path)\n                    break\n            else:\n                # If not connected yet, try to extend tree_b toward new_node_a\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position)\n                if _can_connect(nearest_node_b, new_pos_b, tree_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.parent = None\n                    new_node_b.cost = 0\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a  # swap trees for next iteration\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 13.19292,
          "time_improvement": -68.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01825902462005615,
                    "num_nodes_avg": 139.7,
                    "path_length_avg": 170.53916823025477,
                    "smoothness_avg": 0.03657085421153936,
                    "success_improvement": 0.0,
                    "time_improvement": -84.73805583832261,
                    "length_improvement": 14.766162855188394,
                    "smoothness_improvement": 251.40080438605742,
                    "objective_score": -21.21118015852882
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03545658588409424,
                    "num_nodes_avg": 388.8,
                    "path_length_avg": 234.62398934310326,
                    "smoothness_avg": 0.07992438153248214,
                    "success_improvement": 0.0,
                    "time_improvement": -133.64823549004393,
                    "length_improvement": 22.143822653129895,
                    "smoothness_improvement": 1019.6637797318008,
                    "objective_score": -30.567387217728196
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02384152412414551,
                    "num_nodes_avg": 283.0,
                    "path_length_avg": 121.90768417505406,
                    "smoothness_avg": 0.08857985352242485,
                    "success_improvement": 0.0,
                    "time_improvement": 14.14947986734191,
                    "length_improvement": 25.14133807406572,
                    "smoothness_improvement": 585.3419627879955,
                    "objective_score": 12.199821388955696
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner merges bidirectional tree growth, goal biasing, and asymptotically optimal rewiring from RRT* principles combined with adaptive sampling and dynamic neighborhood radius scaling. It grows two trees simultaneously from start and goal, extends alternately towards biased random samples or via informed sampling near the current best paths, locally rewires nodes to optimize path cost, and attempts timely direct tree connections. It leverages adaptive radius for efficient rewiring, early stopping upon connection, and path smoothing via short-cutting to improve smoothness and path length while respecting collision and boundary constraints.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling points either randomly biased towards the goal or informed around the best path area to accelerate convergence. Each extension includes rewiring neighbors within a dynamically scaled radius to locally optimize paths. After extension, it tries to directly connect the two trees, checking collision validity. When a connection is found, the path is extracted and refined by shortcutting to improve smoothness and path quality. The planning terminates early upon success or after reaching max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 min_search_radius: float = 10.0, max_search_radius: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_search_radius = min_search_radius\n        self.max_search_radius = max_search_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-assign parent\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b):\n            nearest_b = find_nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n            # Attempt to connect with small incremental steps\n            curr = nearest_b\n            while True:\n                new_pos = steer(curr.position, node_from_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                if distance(new_pos, node_from_a.position) < self.step_size * 1.01:\n                    # Final connect node to node_from_a\n                    final_node = Node(node_from_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_from_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Attempt to shortcut the path by removing unnecessary intermediate nodes\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        # Shortcut is possible; remove intermediate nodes between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        # Initialize trees\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: list = []\n\n        best_path_cost = float(\"inf\")\n        best_path = []\n\n        # For adaptive radius based on iteration count\n        def adaptive_radius(iteration):\n            scale = min(1.0, iteration / (self.max_iter/2))\n            r = self.max_search_radius - (self.max_search_radius - self.min_search_radius) * scale\n            return r if r > self.min_search_radius else self.min_search_radius\n\n        # Informed sampling around the current best path cost ellipsoid if any, else uniform\n        def informed_sample():\n            if best_path_cost == float(\"inf\"):\n                # Uniform sampling\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                return sample\n            else:\n                # Informed sampling ellipsoid around start-goal with best cost\n                # Simplified: sample around the line segment start-goal with Gaussian noise proportional to cost\n                import numpy as np\n                dim = len(bounds)\n                start = np.array(start_position)\n                goal = np.array(goal_position)\n                center = (start + goal) / 2\n                c_best = best_path_cost\n                c_min = distance(start_position, goal_position)\n                if c_best < c_min:\n                    c_best = c_min + 1e-3  # Avoid degenerate case\n\n                # Sampling in prolate hyperspheroid\n                while True:\n                    # Sample unit ball\n                    direction = np.random.normal(0,1,dim)\n                    norm = np.linalg.norm(direction)\n                    if norm == 0:\n                        continue\n                    direction /= norm\n                    radius = random.uniform(0,1) ** (1/dim)\n                    point_ball = radius * direction\n\n                    # Stretch and translate the sample to ellipsoid\n                    a1 = (goal - start) / c_min\n                    I = np.eye(dim)\n                    M = np.outer(a1, a1)\n                    U, _, _ = np.linalg.svd(M)\n                    L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n                    sample = U @ L @ point_ball + center\n                    sample = np.clip(sample, [0]*dim, bounds)\n                    sample_tuple = tuple(float(v) for v in sample)\n\n                    if not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                        return sample_tuple\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree growth: start_tree first on even, goal_tree first on odd to balance\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_count % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]:\n                # Goal biasing and sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    # With probability, use informed sampling around best path\n                    if best_path_cost < float(\"inf\") and random.random() < 0.6:\n                        sample = informed_sample()\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                # Boundary check\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n\n                # Collision checks for new node and edge\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node with tentative cost\n                tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                # Adaptive neighborhood radius for rewiring\n                curr_radius = adaptive_radius(iter_count)\n\n                neighbors = find_near(tree_a, new_node, curr_radius)\n\n                # Choose best parent from neighbors for minimal cost path\n                min_cost = tentative_cost\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_node.position)\n                    cost = node.cost + edge_cost\n                    if cost + 1e-7 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost\n                            min_node = node\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors with new_node as better parent candidate\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt connecting the other tree\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n\n                    # Save best path cost found so far\n                    path_cost = 0.0\n                    for i in range(len(extracted_path) - 1):\n                        path_cost += distance(extracted_path[i], extracted_path[i+1])\n                    if path_cost < best_path_cost:\n                        best_path_cost = path_cost\n                        best_path = extracted_path\n\n                    # Perform path shortcutting to smooth path\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n        # If no path found, but best path may have been updated by heuristic sampling and rewiring (unlikely)\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 27.10239,
          "time_improvement": -120.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020557212829589843,
                    "num_nodes_avg": 84.2,
                    "path_length_avg": 163.18597505252896,
                    "smoothness_avg": 0.04818481693406371,
                    "success_improvement": 0.0,
                    "time_improvement": -107.99027388470499,
                    "length_improvement": 18.441218130223056,
                    "smoothness_improvement": 362.9966620927936,
                    "objective_score": -26.89385522890292
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04085087776184082,
                    "num_nodes_avg": 225.1,
                    "path_length_avg": 226.58193071270148,
                    "smoothness_avg": 0.09811354338078526,
                    "success_improvement": 0.0,
                    "time_improvement": -169.19499633932136,
                    "length_improvement": 24.812449781649452,
                    "smoothness_improvement": 1274.4764578499003,
                    "objective_score": -39.42362665621702
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.050639772415161134,
                    "num_nodes_avg": 311.6,
                    "path_length_avg": 118.95801706398773,
                    "smoothness_avg": 0.12470345444191666,
                    "success_improvement": 0.0,
                    "time_improvement": -82.34785572446405,
                    "length_improvement": 26.952611371196777,
                    "smoothness_improvement": 864.8301146945379,
                    "objective_score": -14.989683869627171
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner designed to improve planning efficiency, path quality, robustness, and success rate by tuning parameters such as reduced step size for finer node expansion, increased max iterations, goal bias sampling, and a shorter collision checking resolution. It alternates growth of two trees from the start and goal, extending towards sampled points with a goal bias. After connecting the trees, the path is reconstructed and smoothed through shortcutting to yield high-quality, smooth paths while maintaining strict collision and boundary checks.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately extending each tree towards either the goal (with a bias) or a randomly sampled free point. It carefully checks node and edge collisions, attempts to connect the two trees when nodes get close, and upon success, reconstructs and smooths the path using shortcutting to eliminate unnecessary detours, resulting in efficient, robust, and smooth path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 2.5, goal_sample_rate: float = 0.2, collision_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):  # Increased smoothing attempts for better quality\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 29.59367,
          "time_improvement": -121.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012711930274963378,
                    "num_nodes_avg": 121.2,
                    "path_length_avg": 156.51037510281344,
                    "smoothness_avg": 0.016563812396447348,
                    "success_improvement": 0.0,
                    "time_improvement": -28.614607505897894,
                    "length_improvement": 21.77761882258332,
                    "smoothness_improvement": 59.15780818635535,
                    "objective_score": -3.933069446320927
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048055505752563475,
                    "num_nodes_avg": 607.8,
                    "path_length_avg": 239.61838345230382,
                    "smoothness_avg": 0.06947459962334016,
                    "success_improvement": 0.0,
                    "time_improvement": -216.67132761659968,
                    "length_improvement": 20.48651371982447,
                    "smoothness_improvement": 873.2723771907903,
                    "objective_score": -56.537733655061054
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.060466766357421875,
                    "num_nodes_avg": 670.2,
                    "path_length_avg": 127.86634277088353,
                    "smoothness_avg": 0.08306683969289017,
                    "success_improvement": 0.0,
                    "time_improvement": -117.7337034114899,
                    "length_improvement": 21.482362740593366,
                    "smoothness_improvement": 542.6877974381493,
                    "objective_score": -28.31019948813755
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT planner with optimized parameters and advanced path smoothing to improve planning efficiency, robustness, and path quality. It grows two trees simultaneously from start and goal with goal-biased sampling, fine collision checking resolution, and rigorous node/edge validation. Post planning, a shortcut smoothing technique refines the path to reduce length and unnecessary detours.",
          "planning_mechanism": "The planner alternates expanding two trees, each extension biased towards sampled points with a probability of sampling the goal to guide growth. It performs strict collision checking on nodes and edges. When the two trees connect, the path is reconstructed and smoothed via shortcutting to improve smoothness and reduce path length, balancing exploration and exploitation for improved success rates and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 10000,\n        step_size: float = 2.5,\n        goal_sample_rate: float = 0.2,\n        collision_resolution: float = 0.25,\n        smoothing_trials: int = 100,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (\n                        random.uniform(0, bounds[0]),\n                        random.uniform(0, bounds[1]),\n                        random.uniform(0, bounds[2]),\n                    )\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (\n                not _is_within_bounds(new_pos)\n                or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)\n            ):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (\n                    not _is_within_bounds(next_pos)\n                    or self._is_in_obstacle(next_pos, obstacles, is_3d)\n                    or self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)\n                ):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Remove duplicated connecting node position to avoid repetition\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smoothing_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (\n                    not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n                    and self._is_within_bounds(p1, bounds)\n                    and self._is_within_bounds(p2, bounds)\n                ):\n                    # shortcut possible, splice path\n                    path = path[: i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _is_within_bounds(self, pos, bounds):\n        for i, coord in enumerate(pos):\n            if coord < 0 or coord > bounds[i]:\n                return False\n        return True",
          "objective": 35.90885,
          "time_improvement": -90.0,
          "length_improvement": 24.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.019858360290527344,
                    "num_nodes_avg": 132.1,
                    "path_length_avg": 153.60459036753133,
                    "smoothness_avg": 0.02175630533123696,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -100.91954244802848,
                    "length_improvement": 23.229902104336634,
                    "smoothness_improvement": 109.05126113934247,
                    "objective_score": -75.08462600784449
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043272757530212404,
                    "num_nodes_avg": 578.7,
                    "path_length_avg": 232.53440407362814,
                    "smoothness_avg": 0.07092289878811679,
                    "success_improvement": 0.0,
                    "time_improvement": -185.15445550154442,
                    "length_improvement": 22.83721773935766,
                    "smoothness_improvement": 893.561656706293,
                    "objective_score": -46.51108481906033
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023084235191345216,
                    "num_nodes_avg": 379.4,
                    "path_length_avg": 119.94329094844231,
                    "smoothness_avg": 0.1043484649215158,
                    "success_improvement": 0.0,
                    "time_improvement": 16.876388115031,
                    "length_improvement": 26.347593852244266,
                    "smoothness_improvement": 707.3436444001499,
                    "objective_score": 13.869153426958901
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm introduces an adaptive bidirectional Anytime RRT*-like planner with heuristic-guided informed sampling focusing on promising regions, combined with dynamic tree pruning and local dense re-sampling in high-cost branches. It interleaves exploration and exploitation phases: broadly exploring early, then exploiting promising paths by biasing samples around the current best path ellipsoid and dynamically pruning non-promising nodes to improve efficiency. In addition, it employs an adaptive rewiring radius and integrates shortcut smoothing progressively during the search to improve path quality and smoothness without waiting for full convergence. This approach significantly enhances planning efficiency, success rate, solution quality, and path smoothness, while reducing search time and ensuring robustness in complex environments.",
          "planning_mechanism": "The planner grows two trees bidirectionally, alternating between start and goal expansions. Sampling is adaptively switched between uniform random, heuristic-informed ellipsoid around the best path, and local dense resampling on high-cost branches, guided by the current best path cost. After adding new nodes, neighborhood rewiring optimizes local paths with an adaptive radius. Dynamic pruning removes nodes unlikely to improve the best path. Each extension attempts connection to the other tree with collision checks. Progressive shortcut smoothing is integrated to maintain path quality along the search. Early termination occurs on finding a sufficiently good path, balancing exploration/exploitation and ensuring success and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, min_radius: float = 6.0,\n                 max_radius: float = 20.0, rewire_factor: float = 1.5,\n                 pruning_threshold_factor: float = 1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.rewire_factor = rewire_factor\n        self.pruning_threshold_factor = pruning_threshold_factor\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            distance_val = dist(from_pos, to_pos)\n            if distance_val <= max_step:\n                return to_pos\n            ratio = max_step / distance_val\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, new_node, radius):\n            radius_sq = radius * radius\n            px = new_node.position\n            return [node for node in tree if (sum((px[d]-node.position[d])**2 for d in range(dim)) <= radius_sq)]\n\n        def adaptive_radius(iteration):\n            # Linear interpolation shrinking radius as iterations grow\n            scale = min(1.0, iteration / (self.max_iter*0.75))\n            r = self.max_radius - (self.max_radius - self.min_radius)*scale\n            return max(self.min_radius, r)\n\n        def informed_sample(c_best):\n            # If no solution yet, uniform random sampling\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min + 1e-7  # numeric stability\n            center = (np.array(start_pos) + np.array(goal_pos)) * 0.5\n            a1 = (np.array(goal_pos) - np.array(start_pos)) / c_min\n\n            while True:\n                # Sample unit n-ball\n                dir_random = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(dir_random)\n                if norm_dir == 0:\n                    continue\n                unit_dir = dir_random / norm_dir\n                radius = random.uniform(0, 1) ** (1/dim)\n                sample_ball = radius * unit_dir\n\n                # Rotation matrix: align ellipsoid to line start-goal\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                r1 = c_best / 2.0\n                if dim == 2:\n                    r_rest = math.sqrt(c_best**2 - c_min**2)/2.0\n                    L = np.diag([r1, r_rest])\n                elif dim == 3:\n                    r_rest = math.sqrt(c_best**2 - c_min**2)/2.0\n                    L = np.diag([r1, r_rest, r_rest])\n                else:\n                    # Higher dims fallback: isotropic ellipsoid\n                    L = np.diag([c_best/2.0]*dim)\n\n                sample_transf = U @ L @ sample_ball + center\n                sample = tuple(np.clip(sample_transf, [0]*dim, bounds))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old edge\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.remove_child(neighbor)\n                            if (old_parent, neighbor) in edges:\n                                edges.remove((old_parent, neighbor))\n                        # Insert new edge\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def dynamic_prune(tree, best_cost):\n            # Remove nodes with cost worse than threshold * best_cost and no children to reduce search scope\n            threshold = best_cost * self.pruning_threshold_factor\n            to_remove = [node for node in tree if node.cost > threshold and len(node.children) == 0]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                tree.remove(node)\n\n        def attempt_connect(node_from_a, tree_b, nodes, edges):\n            nearest_b = nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n\n            current = nearest_b\n            while True:\n                new_pos = steer(current.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n                new_cost = current.cost + dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_cost = new_node.cost + dist(new_pos, node_from_a.position)\n                    final_node = Node(node_from_a.position, parent=new_node, cost=final_cost)\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                current = new_node\n\n        def extract_path(node_start, node_goal):\n            # Extract path from root to node_start, and root to node_goal then concatenate\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortcut_made = False\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i+1] + path[j:]\n                        shortcut_made = True\n                        break\n                    j -= 1\n                if not shortcut_made:\n                    i += 1\n            return path\n\n        def dense_resample_on_branch(tree, best_cost, fraction=0.1, samples_per_branch=5):\n            # Identify highest cost nodes (fraction from top) and resample densely around them\n            sorted_nodes = sorted(tree, key=lambda n: n.cost, reverse=True)\n            count = max(1, int(len(tree) * fraction))\n            samples = []\n            radius = self.step_size * 2.5\n            for node in sorted_nodes[:count]:\n                center = np.array(node.position)\n                for _ in range(samples_per_branch):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_np = center + offset\n                    sample_clipped = tuple(np.clip(sample_np, [0]*dim, bounds))\n                    if not self._is_in_obstacle(sample_clipped, obstacles, is_3d):\n                        samples.append(sample_clipped)\n            return samples\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        best_path_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        for iter_count in range(self.max_iter):\n            # Alternate growth order each iteration\n            if iter_count % 2 == 0:\n                trees_sequence = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            else:\n                trees_sequence = [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            # Progressive dense resampling phase every 25 iterations if a path exists\n            dense_samples = []\n            if best_path_cost < float(\"inf\") and (iter_count % 25 == 0) and len(start_tree) > 10:\n                dense_samples = dense_resample_on_branch(start_tree, best_path_cost, fraction=0.1, samples_per_branch=5)\n\n            for tree_a, tree_b in trees_sequence:\n                # Sample selection strategy\n                sample = None\n                prob_goal_bias = self.goal_sample_rate\n                prob_informed = 0.6 if best_path_cost < float(\"inf\") else 0.0\n\n                # If dense resamples available, select one with priority\n                if dense_samples and random.random() < 0.4:\n                    sample = dense_samples.pop(random.randint(0, len(dense_samples)-1))\n                else:\n                    if random.random() < prob_goal_bias:\n                        sample = goal_pos if tree_a is start_tree else start_pos\n                    elif random.random() < prob_informed:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n\n                curr_radius = adaptive_radius(iter_count)*self.rewire_factor\n                neighbors = near(tree_a, new_node, curr_radius)\n\n                # Choose best parent minimizing cost\n                min_cost = tentative_cost\n                min_parent = nearest_node\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_cand = node.cost + edge_c\n                    if cost_cand + 1e-9 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost_cand\n                            min_parent = node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors, edges)\n\n                connect_node = attempt_connect(new_node, tree_b, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, connect_node)\n                    else:\n                        path = extract_path(connect_node, new_node)\n\n                    path_len = 0.0\n                    for i in range(len(path)-1):\n                        path_len += dist(path[i], path[i+1])\n\n                    # Accept path only if better than current best by threshold\n                    if path_len + 1e-9 < best_path_cost:\n                        best_path_cost = path_len\n                        best_path = path\n                        # Progressive smoothing after each improvement\n                        best_path = shortcut_path(best_path)\n\n                        # Prune nodes unlikely to improve solution\n                        dynamic_prune(start_tree, best_path_cost)\n                        dynamic_prune(goal_tree, best_path_cost)\n\n                        # Early termination if path is close enough to direct dist\n                        if best_path_cost <= 1.05 * dist(start_pos, goal_pos):\n                            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n                        # Return path at first improvement for anytime planning\n                        return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            # After full iteration, if no connection but best path found, yield best known\n            if success_state and best_path:\n                # Continue smoothing progressively\n                best_path = shortcut_path(best_path)\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n        # Return failure if no path found\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.10981,
          "time_improvement": -170.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03076789379119873,
                    "num_nodes_avg": 104.2,
                    "path_length_avg": 164.06481454932924,
                    "smoothness_avg": 0.04761889990524928,
                    "success_improvement": 0.0,
                    "time_improvement": -211.2981662220121,
                    "length_improvement": 18.001982596685288,
                    "smoothness_improvement": 357.5588974184752,
                    "objective_score": -58.00125886017419
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04348978996276855,
                    "num_nodes_avg": 247.8,
                    "path_length_avg": 230.22395471615914,
                    "smoothness_avg": 0.11080137668549299,
                    "success_improvement": 0.0,
                    "time_improvement": -186.58463394784553,
                    "length_improvement": 23.60390300214643,
                    "smoothness_improvement": 1452.2208097255862,
                    "objective_score": -43.99350553529644
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05870811939239502,
                    "num_nodes_avg": 285.5,
                    "path_length_avg": 120.20631556796214,
                    "smoothness_avg": 0.11240615199909001,
                    "success_improvement": 0.0,
                    "time_improvement": -111.40102283741659,
                    "length_improvement": 26.186080890989434,
                    "smoothness_improvement": 769.6859362157281,
                    "objective_score": -24.33466099194845
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional RRT* framework with adaptive goal-biased sampling, local rewiring for optimality, and iterative shortcut smoothing to obtain high-quality, smooth, and efficient paths. It grows two trees from start and goal, alternately extending them by sampling points biased towards the goal. Each extension performs rewiring in a dynamic neighborhood to reduce path costs, and the trees are connected when feasible. Final paths undergo shortcut smoothing to enhance smoothness and reduce length, while strict collision and edge checks ensure safety and robustness. This approach balances exploration, exploitation, and path optimization to improve success rate, path quality, and planning speed.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal positions via goal-biased sampling. For each new node, it finds near neighbors within a radius to connect and rewire for local optimality. Upon connection of the two trees, the path is reconstructed and shortcut smoothing is applied to improve smoothness and reduce path length. Continuous collision and edge checks guarantee valid paths, and dynamic rewiring enables improvements during growth, yielding efficient, smooth, and robust paths with high success rate.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root (start or goal)\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0,\n                 goal_sample_rate: float = 0.1, smooth_iter: int = 30, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_point(tree_id):\n            # tree_id=0 for start tree, 1 for goal tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree_id == 0 else start_position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def rewire(tree, new_node):\n            neighbors = near(tree, new_node.position, self.radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if tentative_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    # Remove old parent-child edge\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = tentative_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def connect_trees(node_a, tree_b):\n            connect_candidate = nearest(tree_b, node_a.position)\n            if distance(node_a.position, connect_candidate.position) <= self.step_size and collision_free_edge(node_a.position, connect_candidate.position):\n                return node_a, connect_candidate\n            # Attempt multi-step connect stepping from connect_candidate towards node_a\n            curr = connect_candidate\n            connection_chain = []\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if not collision_free_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                new_cost = curr.cost + distance(curr.position, new_pos)\n                new_node = Node(new_pos, parent=curr, cost=new_cost)\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                connection_chain.append(new_node)\n                if distance(new_pos, node_a.position) <= self.step_size:\n                    # Final connection node\n                    if collision_free_edge(new_pos, node_a.position):\n                        final_cost = new_node.cost + distance(new_pos, node_a.position)\n                        final_node = Node(node_a.position, parent=new_node, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree_b.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return node_a, final_node\n                    else:\n                        return None\n                curr = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_position, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_position, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path: list = []\n\n        for iter_idx in range(self.max_iter):\n            for tree_idx, (tree_a, tree_b) in enumerate([(start_tree, goal_tree), (goal_tree, start_tree)]):\n                sample = sample_point(tree_idx)\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                # Choose best parent among near neighbors (including nearest_node)\n                neighbors = near(tree_a, new_pos, self.radius)\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                min_node = nearest_node\n                for n in neighbors:\n                    edge_cost = distance(n.position, new_pos)\n                    cost_through_n = n.cost + edge_cost\n                    if cost_through_n < min_cost and collision_free_edge(n.position, new_pos):\n                        min_cost = cost_through_n\n                        min_node = n\n\n                new_node = Node(new_pos, parent=min_node, cost=min_cost)\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire around new_node\n                rewire(tree_a, new_node)\n\n                # Attempt to connect trees\n                connected = connect_trees(new_node, tree_b)\n                if connected is not None:\n                    node_a, node_b = connected\n                    success_state = True\n                    extracted_path = extract_path(node_a, node_b)\n                    extracted_path = shortcut_smooth(extracted_path)\n                    break\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.41565,
          "time_improvement": -48.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.019983386993408202,
                    "num_nodes_avg": 96.8,
                    "path_length_avg": 166.77313349849555,
                    "smoothness_avg": 0.02015511633976813,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -102.18451637181161,
                    "length_improvement": 16.648390816890878,
                    "smoothness_improvement": 93.6658097544331,
                    "objective_score": -76.85734769939313
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.025251436233520507,
                    "num_nodes_avg": 204.1,
                    "path_length_avg": 246.50859252054116,
                    "smoothness_avg": 0.037164962057354575,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -66.39936904354164,
                    "length_improvement": 18.20010924483608,
                    "smoothness_improvement": 420.6454037284594,
                    "objective_score": -64.17656184545297
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02065930366516113,
                    "num_nodes_avg": 180.7,
                    "path_length_avg": 127.40998736268537,
                    "smoothness_avg": 0.05821271331541609,
                    "success_improvement": 0.0,
                    "time_improvement": 25.608280913702707,
                    "length_improvement": 21.762592452539355,
                    "smoothness_improvement": 350.39152376451136,
                    "objective_score": 13.78696038344124
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a simplified, efficient bidirectional RRT* approach with adaptive sampling biased towards the goal and rewiring for path cost improvement. It grows two trees from start and goal positions, ensures strict collision checks for nodes and edges, and applies iterative shortcut smoothing on the final path to improve smoothness and reduce path length, balancing exploration, optimality, and computational effort for robustness and success.",
          "planning_mechanism": "The planner alternately extends two trees rooted at start and goal by sampling points biased towards the goal. Each new node attempts connection and rewiring within a radius to reduce path cost. Upon connection of the two trees, the path is reconstructed and shortcut smoothed by repeatedly trying direct edge shortcuts that avoid obstacles, yielding a high-quality, collision-free path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0, smooth_iter: int = 30, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        path: list = []\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_point():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def distance(a, b):\n            import math\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def connect_trees(node_a, tree_b):\n            nearest_node = nearest(tree_b, node_a.position)\n            if distance(node_a.position, nearest_node.position) <= self.step_size and collision_free_edge(node_a.position, nearest_node.position):\n                return node_a, nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + distance(new_node.position, near_node.position)\n                if tentative_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    # Update parent edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = tentative_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            sample = sample_point()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                connected = connect_trees(new_node, tree_b)\n                if connected:\n                    node_a, node_b = connected\n                    success_state = True\n                    path = extract_path(node_a, node_b)\n                    path = shortcut_smooth(path)\n                    break\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.49808,
          "time_improvement": -100.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.012702202796936036,
                    "num_nodes_avg": 120.2,
                    "path_length_avg": 170.62270338530837,
                    "smoothness_avg": 0.01756925692681046,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -28.516188482079535,
                    "length_improvement": 14.724412787590483,
                    "smoothness_improvement": 68.81889006022847,
                    "objective_score": -55.26587953680461
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03232300281524658,
                    "num_nodes_avg": 289.0,
                    "path_length_avg": 257.0629136417843,
                    "smoothness_avg": 0.027047463719607312,
                    "success_improvement": 0.0,
                    "time_improvement": -112.9988656609489,
                    "length_improvement": 14.697828428232635,
                    "smoothness_improvement": 278.9089747056285,
                    "objective_score": -29.565549139109994
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0721182107925415,
                    "num_nodes_avg": 424.0,
                    "path_length_avg": 132.0228046459418,
                    "smoothness_avg": 0.05061262358100262,
                    "success_improvement": 0.0,
                    "time_improvement": -159.6891824254657,
                    "length_improvement": 18.930044759831567,
                    "smoothness_improvement": 291.58966071300836,
                    "objective_score": -42.66279747210835
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm improves bidirectional RRT by tuning key parameters: reducing step size for finer node expansions, increasing maximum iterations for thorough search, and biasing sampling towards the goal to enhance convergence speed. It also integrates a goal bias sampling with a certain probability to direct growth towards the goal, and employs shortened collision checking resolution to enhance accuracy. Additionally, path smoothing is applied post planning to improve path quality and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal simultaneously, alternately expanding each tree towards sampled points. Sampling is biased towards the goal to increase success and convergence speed. Collision checks are strictly enforced for nodes and edges before insertion. When trees connect, the path is reconstructed and then smoothed by shortcutting to reduce unnecessary detours, resulting in improved path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            # Shortcut smoothing with max trials = 50\n            if len(path) <= 2:\n                return path\n            import random\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    # shortcut possible\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.82017,
          "time_improvement": -50.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.008735418319702148,
                    "num_nodes_avg": 121.9,
                    "path_length_avg": 158.79688158358158,
                    "smoothness_avg": 0.017264620570270624,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 11.618269272519385,
                    "length_improvement": 20.634844860245124,
                    "smoothness_improvement": 65.89171039649618,
                    "objective_score": -42.05809169421266
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026499056816101076,
                    "num_nodes_avg": 449.3,
                    "path_length_avg": 240.15460051249525,
                    "smoothness_avg": 0.04002816589212556,
                    "success_improvement": 0.0,
                    "time_improvement": -74.62081339337057,
                    "length_improvement": 20.308578758222435,
                    "smoothness_improvement": 460.75613797892566,
                    "objective_score": -16.020747576472054
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.052319788932800294,
                    "num_nodes_avg": 571.0,
                    "path_length_avg": 128.29426974238464,
                    "smoothness_avg": 0.06187473290802109,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -88.39739731919414,
                    "length_improvement": 21.219589801337207,
                    "smoothness_improvement": 378.7245543077222,
                    "objective_score": -70.38167846395218
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 43.98048200212903,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.002286410331726074,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 76.86694616382907,
                    "length_improvement": 14.547294318234119,
                    "smoothness_improvement": 6.939088459328463,
                    "objective_score": 26.004238155092185
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.007691335678100586,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 49.31641146656528,
                    "length_improvement": 8.292841453028517,
                    "smoothness_improvement": 4.557864045526364,
                    "objective_score": -133.5237189491971
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.00499422550201416,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 82.01638222560287,
                    "length_improvement": 4.825184687042764,
                    "smoothness_improvement": 1.6166365256828326,
                    "objective_score": -24.421965212282167
               }
          ]
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm hybridizes bidirectional RRT* concepts with adaptive informed sampling and dynamic neighborhood rewiring to improve planning efficiency, path quality, and success rate. It grows two trees simultaneously from start and goal nodes, biasing sampling towards goal and around the current best path ellipsoid to accelerate convergence. Local rewiring with an adaptive radius improves path optimality, and direct connection attempts coupled with path shortcutting enhance final path smoothness and reduce path length. This approach balances exploration and exploitation to reduce search time and improve robustness.",
          "planning_mechanism": "The planner alternates extending two trees from start and goal by sampling points either randomly with goal bias or informed near the best path. New nodes are inserted only if collision free. Each extension includes selecting a minimal cost parent from neighbors within an adaptive radius and rewiring neighbors to optimize local paths. After each extension, a direct connection to the other tree is attempted with incremental collision-checked steps. Upon success, the path is extracted by bridging both trees and then shortcut-smoothed to improve smoothness and length. Early termination upon first valid path ensures efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, goal_sample_rate: float=0.12,\n                 min_radius: float=8.0, max_radius: float=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            distance_val = dist(from_pos, to_pos)\n            if distance_val <= max_step:\n                return to_pos\n            ratio = max_step / distance_val\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, new_node, radius):\n            radius_sq = radius * radius\n            px = new_node.position\n            return [node for node in tree if (sum((px[d]-node.position[d])**2 for d in range(dim)) <= radius_sq)]\n\n        def adaptive_radius(iteration):\n            # Shrink radius as tree grows to balance computation\n            scale = min(1.0, iteration / (self.max_iter/2))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r)\n\n        def informed_sample(c_best):\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min + 1e-3  # numeric stability\n            center = (np.array(start_pos) + np.array(goal_pos)) / 2\n            a1 = (np.array(goal_pos) - np.array(start_pos)) / c_min\n\n            while True:\n                # Sample unit ball\n                direction = np.random.normal(0,1,dim)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction = direction / norm\n                radius = random.uniform(0,1) ** (1/dim)\n                point_ball = radius * direction\n\n                # Rotation matrix via SVD as in original\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n                sample_np = U @ L @ point_ball + center\n                sample = tuple(np.clip(sample_np, [0]*dim, bounds))\n                if (self._is_in_obstacle(sample, obstacles, is_3d) == False):\n                    return sample\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Re-assign parent after removing old connection\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b, nodes, edges):\n            nearest_b = nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n\n            current = nearest_b\n            while True:\n                new_pos = steer(current.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_node = Node(node_from_a.position, parent=new_node,\n                                      cost=new_node.cost + dist(new_pos, node_from_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                current = new_node\n\n        def extract_path(node_start, node_goal):\n            # Extract path from root to node_start, and root to node_goal then concatenate\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) -1\n                while j > i +1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        # Initialize trees\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path_cost = float(\"inf\")\n        best_path = []\n\n        for iter_count in range(self.max_iter):\n            # Alternate growth order for balanced growth\n            trees_sequence = [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_count % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            for tree_a, tree_b in trees_sequence:\n                # Sampling with goal bias and informed sampling around current best path\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    prob_informed = 0.6 if best_path_cost < float(\"inf\") else 0.0\n                    if random.random() < prob_informed:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                curr_radius = adaptive_radius(iter_count)\n                neighbors = near(tree_a, new_node, curr_radius)\n\n                # Choose best parent with minimal cost\n                min_cost = tentative_cost\n                min_parent = nearest_node\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_cand = node.cost + edge_c\n                    if cost_cand + 1e-7 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost_cand\n                            min_parent = node\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire within neighborhood to improve path cost locally\n                rewire(tree_a, new_node, neighbors, edges)\n\n                # Attempt to connect the opposite tree\n                connect_node = attempt_connect(new_node, tree_b, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, connect_node)\n                    else:\n                        path = extract_path(connect_node, new_node)\n                    pl_cost = 0.0\n                    for i in range(len(path)-1):\n                        pl_cost += dist(path[i], path[i+1])\n                    if pl_cost < best_path_cost:\n                        best_path_cost = pl_cost\n                        best_path = path\n                    # Shortcut path for smoothness\n                    shortcut = shortcut_path(path)\n                    return PlannerResult(success=True, path=shortcut, nodes=nodes, edges=edges)\n        # If no direct connect, but best path found during rewiring/informed sampling\n        if best_path:\n            shortcut = shortcut_path(best_path)\n            return PlannerResult(success=True, path=shortcut, nodes=nodes, edges=edges)\n\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 47.11715,
          "time_improvement": -186.0,
          "length_improvement": 24.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021401190757751466,
                    "num_nodes_avg": 89.4,
                    "path_length_avg": 159.27680250095096,
                    "smoothness_avg": 0.045322283545694966,
                    "success_improvement": 0.0,
                    "time_improvement": -116.52933031643646,
                    "length_improvement": 20.39498499850227,
                    "smoothness_improvement": 335.4912467301596,
                    "objective_score": -29.202345861579687
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05286543369293213,
                    "num_nodes_avg": 302.0,
                    "path_length_avg": 228.6095590521175,
                    "smoothness_avg": 0.08825173709188504,
                    "success_improvement": 0.0,
                    "time_improvement": -248.36730589762044,
                    "length_improvement": 24.139614100911526,
                    "smoothness_improvement": 1136.3220287170914,
                    "objective_score": -64.00065880551836
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0814192533493042,
                    "num_nodes_avg": 349.8,
                    "path_length_avg": 118.27019003682929,
                    "smoothness_avg": 0.12487806627004805,
                    "success_improvement": 0.0,
                    "time_improvement": -193.18114112391922,
                    "length_improvement": 27.3749786012693,
                    "smoothness_improvement": 866.1810856914279,
                    "objective_score": -48.14844118846476
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 52.752541255711016,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0051594734191894535,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 47.79835678825919,
                    "length_improvement": 21.158844301429212,
                    "smoothness_improvement": 158.83369146092565,
                    "objective_score": 19.365444354068227
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.021558094024658202,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -42.06135485959018,
                    "length_improvement": 27.333600643728058,
                    "smoothness_improvement": 213.19280910618096,
                    "objective_score": -106.08572228360053
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008537554740905761,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 69.25727099697029,
                    "length_improvement": 31.694181530357035,
                    "smoothness_improvement": 269.3273114473463,
                    "objective_score": -71.53734583760075
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a generalized bidirectional RRT* inspired planner that balances exploration efficiency and path quality by alternating tree expansions from start and goal states, using informed sampling inside an ellipsoidal heuristic region when a feasible path exists to focus search. It integrates rewiring to optimize path costs, strict collision and boundary checks for robustness, and iterative shortcut smoothing to produce shorter, smoother paths with improved success rates and reduced search times.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, alternately expanding towards samples biased either randomly or within an informed ellipsoidal subset based on current best path cost. Each new node adds rewiring of neighbors to minimize cumulative costs adhering to collision-free constraints. Trees attempt connection after expansions. Upon connection, the path is extracted and smoothed by iterative shortcutting, resulting in efficient convergence and high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 10.0, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, self.collision_resolution)\n\n        def sample_free_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def build_rotation_matrix(a):\n            dim = len(a)\n            a = np.array(a)\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            if dim == 2:\n                c = np.dot(e1, a)\n                s = np.linalg.norm(np.cross(e1, a))\n                theta = math.acos(min(max(c, -1),1))\n                rot = np.array([[math.cos(theta), -math.sin(theta)],\n                                [math.sin(theta),  math.cos(theta)]])\n                return rot\n            elif dim == 3:\n                v = np.cross(e1, a)\n                s = np.linalg.norm(v)\n                c = np.dot(e1, a)\n                if s == 0:\n                    return np.eye(3)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                rot = np.eye(3) + vx + (vx @ vx) * ((1 - c) / (s ** 2))\n                return rot\n            return np.eye(dim)\n\n        def sample_in_ellipse(best_cost):\n            if best_cost == math.inf:\n                return sample_free_uniform()\n\n            c_min = dist(start_position, goal_position)\n            if best_cost < c_min:\n                return sample_free_uniform()\n\n            a1 = tuple((goal_position[i] - start_position[i]) / c_min for i in range(len(bounds)))\n            rot = build_rotation_matrix(a1)\n            r1 = best_cost / 2.0\n            rn = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            dim = len(bounds)\n            lengths = [r1] + [rn]*(dim-1)\n\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    r = random.uniform(0, 1) ** 0.5\n                    unit = np.array([r * math.cos(theta), r * math.sin(theta)])\n                elif dim == 3:\n                    phi = random.uniform(0, 2 * math.pi)\n                    costheta = random.uniform(-1, 1)\n                    u = random.uniform(0, 1)\n                    sintheta = math.sqrt(1 - costheta**2)\n                    r = u ** (1/3)\n                    unit = np.array([\n                        r * sintheta * math.cos(phi),\n                        r * sintheta * math.sin(phi),\n                        r * costheta\n                    ])\n                else:\n                    return sample_free_uniform()\n\n                sample_vec = unit * lengths\n                sample_rot = rot @ sample_vec\n                center = np.array([(start_position[i] + goal_position[i]) / 2 for i in range(dim)])\n                sample_point = tuple((sample_rot + center).tolist())\n                if in_bounds(sample_point) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    return sample_point\n\n        def find_neighbors(tree, pos):\n            return [node for node in tree if dist(node.position, pos) <= self.neighbor_radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                if collision_free_edge(new_node.position, neighbor.position):\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost:\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        new_node.add_child(neighbor)\n                        neighbor.cost = new_cost\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def connect_trees(from_node, to_tree):\n            current = nearest_node(to_tree, from_node.position)\n            while True:\n                new_pos = steer(current.position, from_node.position)\n                if (not in_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    not collision_free_edge(current.position, new_pos)):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                to_tree.append(new_node)\n                if dist(new_pos, from_node.position) <= self.step_size:\n                    final_node = Node(from_node.position, parent=new_node, cost=new_node.cost + dist(new_pos, from_node.position))\n                    new_node.add_child(final_node)\n                    to_tree.append(final_node)\n                    return final_node\n                current = new_node\n\n        def extract_path(node1, node2):\n            path1 = node1.path_from_root()\n            path2 = node2.path_from_root()\n            return path1 + path2[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialization\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n        success = False\n\n        for _ in range(self.max_iter):\n            sample_point = (goal_position if random.random() < self.goal_sample_rate\n                            else (sample_in_ellipse(best_cost) if best_cost < math.inf else sample_free_uniform()))\n\n            for tree, other_tree in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = nearest_node(tree, sample_point)\n                new_pos = steer(nearest.position, sample_point)\n                if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                    continue\n\n                new_cost = nearest.cost + dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                neighbors = find_neighbors(tree, new_node.position)\n                rewire(tree, new_node, neighbors)\n\n                connection_node = connect_trees(new_node, other_tree)\n                if connection_node:\n                    path = extract_path(new_node, connection_node)\n                    path_length = sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n                    if path_length < best_cost:\n                        best_cost = path_length\n                        best_path = smooth_path(path)\n                        success = True\n\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 118.96292,
          "time_improvement": -203.0,
          "length_improvement": 26.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.02467672824859619,
                    "num_nodes_avg": 71.8,
                    "path_length_avg": 158.87387793641332,
                    "smoothness_avg": 0.02664146288424867,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -149.67000680249134,
                    "length_improvement": 20.59636282315002,
                    "smoothness_improvement": 155.99160012489662,
                    "objective_score": -90.00177147549289
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.06038820743560791,
                    "num_nodes_avg": 270.5,
                    "path_length_avg": 226.70629568072454,
                    "smoothness_avg": 0.09414589073109278,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -297.9401219807257,
                    "length_improvement": 24.771181277805276,
                    "smoothness_improvement": 1218.8934570529264,
                    "objective_score": -128.33333305339198
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.0728447437286377,
                    "num_nodes_avg": 275.3,
                    "path_length_avg": 111.28239262830115,
                    "smoothness_avg": 0.11127752920477456,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -162.30534195170154,
                    "length_improvement": 31.665907162103775,
                    "smoothness_improvement": 760.9537862928609,
                    "objective_score": -138.55365222162538
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT with dynamic goal biasing and adaptive step sizing to improve planning efficiency, success rate, and path quality. It grows two trees from start and goal, alternately extending toward sampled points with an enhanced goal bias schedule. It adds rewiring around new nodes to optimize cost and applies iterative shortcut smoothing post path extraction. Additional pruning limits tree size to reduce search overhead, and thorough collision and edge validations ensure robustness and path validity. Adaptive step sizing adjusts exploration granularity over iterations for faster convergence and smoother paths.",
          "planning_mechanism": "The planner alternates growth of two trees rooted at start and goal by sampling free configurations biased dynamically towards the goal. It extends trees by steering within an adaptive step size, validating node placements and connecting edges strictly. After connecting trees, it reconstructs the path, performs local rewiring to optimize node costs, and applies iterative shortcut smoothing to improve path smoothness and length before returning the final result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def rewire(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost updates to children\n        for child in self.children:\n            child.rewire(self, self.cost + self._distance(self.position, child.position))\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, \n                 collision_resolution: float = 0.5, max_tree_size: int = 1500):\n        self.max_iter = max_iter\n        self.init_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.max_tree_size = max_tree_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free(iteration):\n            # Dynamic goal bias: increase bias as iterations rise (favor goal more later)\n            adaptive_goal_rate = min(0.5, self.goal_sample_rate + iteration * 1e-4)\n            if random.random() < adaptive_goal_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos, curr_step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= curr_step_size:\n                return to_pos\n            ratio = curr_step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_collision_free_node(pos):\n            return _is_within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def _is_collision_free_edge(p1, p2):\n            return ( _is_within_bounds(p2) and\n                     not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution) )\n\n        def _add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        def _prune_tree(tree):\n            # Limit tree size to max_tree_size for memory and speed\n            if len(tree) > self.max_tree_size:\n                # Prune oldest nodes except roots\n                # Keep roots intact:\n                roots = [n for n in tree if n.parent is None]\n                prunable = [n for n in tree if n.parent is not None]\n                remove_count = len(tree) - self.max_tree_size\n                if remove_count <= 0:\n                    return\n                # Remove by oldest first (left side of list)\n                for rm_node in prunable[:remove_count]:\n                    # Remove children references\n                    if rm_node.parent:\n                        rm_node.parent.remove_child(rm_node)\n                    tree.remove(rm_node)\n                    if rm_node in nodes:\n                        nodes.remove(rm_node)\n\n        def _find_near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if self._distance(node.position, pos) <= radius_sq]\n\n        def _rewire_nearby(tree, new_node, radius=10.0):\n            near_nodes = [node for node in tree if node != new_node and self._distance(node.position, new_node.position) <= radius]\n            for node in near_nodes:\n                potential_cost = new_node.cost + self._distance(new_node.position, node.position)\n                if potential_cost < node.cost and _is_collision_free_edge(new_node.position, node.position):\n                    node.rewire(new_node, potential_cost)\n\n        def _extend_tree(tree, point, curr_step_size):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point, curr_step_size)\n            if not _is_collision_free_node(new_pos):\n                return None\n            if not _is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + self._distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            _add_node(tree, new_node)\n            _rewire_nearby(tree, new_node, radius=5.0)\n            _prune_tree(tree)\n            return new_node\n\n        def _connect_trees(tree, target_node, curr_step_size):\n            current = _nearest(tree, target_node.position)\n            while True:\n                next_pos = _steer(current.position, target_node.position, curr_step_size)\n                if not _is_collision_free_node(next_pos):\n                    return None\n                if not _is_collision_free_edge(current.position, next_pos):\n                    return None\n                new_cost = current.cost + self._distance(current.position, next_pos)\n                next_node = Node(next_pos, parent=current, cost=new_cost)\n                current.add_child(next_node)\n                _add_node(tree, next_node)\n                _rewire_nearby(tree, next_node, radius=5.0)\n                _prune_tree(tree)\n                if self._distance(next_node.position, target_node.position) <= curr_step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            # Iterative shortcut smoothing with increased attempts for smoother results\n            if len(path) <= 2:\n                return path\n            attempts = max(80, len(path)*4)\n            for _ in range(attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def _adaptive_step_size(iteration):\n            # Progressive step size decrease from initial to half by last iteration\n            return max(self.init_step_size * (1 - iteration / self.max_iter * 0.5), self.init_step_size * 0.5)\n\n        for iteration in range(self.max_iter):\n            curr_step = _adaptive_step_size(iteration)\n            rand_point = _sample_free(iteration)\n\n            new_a = _extend_tree(tree_a, rand_point, curr_step)\n            if not new_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a, curr_step)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=[(node.parent, node) for node in nodes if node.parent]\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 128.00883,
          "time_improvement": -178.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028017449378967284,
                    "num_nodes_avg": 146.5,
                    "path_length_avg": 169.81525426385505,
                    "smoothness_avg": 0.0369474264864319,
                    "success_improvement": 0.0,
                    "time_improvement": -183.47018723736832,
                    "length_improvement": 15.127968097698202,
                    "smoothness_improvement": 255.01919950314416,
                    "objective_score": -50.74036655415513
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.04272439479827881,
                    "num_nodes_avg": 322.4,
                    "path_length_avg": 243.16656749225757,
                    "smoothness_avg": 0.10094387553767885,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -181.54091004785593,
                    "length_improvement": 19.309106214959307,
                    "smoothness_improvement": 1314.1266914822493,
                    "objective_score": -94.02981831395365
               },
               {
                    "map_id": 2,
                    "success_rate": 0.6,
                    "time_avg": 0.07452979087829589,
                    "num_nodes_avg": 461.2,
                    "path_length_avg": 106.69533510271341,
                    "smoothness_avg": 0.12560590472331615,
                    "success_improvement": -40.0,
                    "time_improvement": -168.3729982597856,
                    "length_improvement": 34.48263681180907,
                    "smoothness_improvement": 871.8123688141649,
                    "objective_score": -239.25631027150305
               }
          ],
          "success_rate": 0.8333333333333334
     },
     {
          "operator": "m3",
          "algorithm_description": "This simplified hybrid RRT* planner integrates goal bias sampling, dynamic neighbor searching with rewiring to incrementally improve path cost and quality. It ensures collision-free node and edge expansions within map bounds, balancing exploration and exploitation to efficiently find smooth, robust paths with reduced planning time.",
          "planning_mechanism": "The planner grows a tree from the start position by iteratively sampling states with goal bias. For each sampled point, it steers a fixed step size towards the sample from the nearest existing node. New nodes are added only if collision-free and within bounds. For each new node, neighbors within a dynamically scaled radius are found to select the best parent minimizing path cost. The planner then rewires neighbors via the new node to improve costs. When a node reaches near the goal, a final connection is attempted. The solution path is extracted by backtracking from the goal node once found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Dynamic neighbor radius based on node count & dimension\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            gamma = self.neighbor_factor\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim)))\n\n            # Find neighbor nodes within radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            # Choose parent minimizing cost + collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                c = near_node.cost + math.dist(near_node.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = near_node\n\n            # Connect new node to best parent\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if beneficial and collision-free\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge & update parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new node can connect directly to goal\n            dist_goal = math.dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 132.8663,
          "time_improvement": -452.0,
          "length_improvement": 14.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04421133995056152,
                    "num_nodes_avg": 277.1,
                    "path_length_avg": 175.4057816503535,
                    "smoothness_avg": 0.014822768672657066,
                    "success_improvement": 0.0,
                    "time_improvement": -347.31398080829035,
                    "length_improvement": 12.333876243262361,
                    "smoothness_improvement": 42.42852531337951,
                    "objective_score": -101.51527636726773
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14756877422332765,
                    "num_nodes_avg": 975.3,
                    "path_length_avg": 271.0520755830754,
                    "smoothness_avg": 0.006851663576418842,
                    "success_improvement": 0.0,
                    "time_improvement": -872.4338328405295,
                    "length_improvement": 10.055751221700547,
                    "smoothness_improvement": -4.014777589414016,
                    "objective_score": -259.7390734957658
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06594605445861816,
                    "num_nodes_avg": 520.3,
                    "path_length_avg": 133.0968329704542,
                    "smoothness_avg": 0.019142422483870408,
                    "success_improvement": 0.0,
                    "time_improvement": -137.46397447113193,
                    "length_improvement": 18.270526668026136,
                    "smoothness_improvement": 48.104844114373854,
                    "objective_score": -37.34456278716248
               }
          ],
          "success_rate": 1.0
     }
]