[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.47449114023227,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012044763565063477,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": -21.86446156592386,
                    "length_improvement": 12.401486536989607,
                    "smoothness_improvement": 60.71897053377777,
                    "objective_score": -3.7754463097103477
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017744064331054688,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": -16.928046454483464,
                    "length_improvement": 14.190408824541839,
                    "smoothness_improvement": 52.81399740357816,
                    "objective_score": -1.9762621844187802
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009687995910644532,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.11466785256512,
                    "length_improvement": 11.655572158065754,
                    "smoothness_improvement": 61.933425488650386,
                    "objective_score": 22.175181914825938
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -1.486610468143649,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008508419990539551,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 13.914954384712244,
                    "length_improvement": 5.9265718433081265,
                    "smoothness_improvement": 7.497776338222911,
                    "objective_score": 5.397289565766413
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017635869979858398,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": -16.21507822540353,
                    "length_improvement": 0.3867603104208941,
                    "smoothness_improvement": 0.5583282013809732,
                    "objective_score": -4.784379764529976
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024777650833129883,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 10.77859785250502,
                    "length_improvement": 2.8534839845313615,
                    "smoothness_improvement": 8.529090107346295,
                    "objective_score": 3.84692160319451
               }
          ]
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner with optimized parameters to improve efficiency, path quality, and success rate. It features reduced step size for finer expansions, increased maximum iterations for deeper search, and a goal bias sampling probability to accelerate convergence. Collision checking is precise with a refined resolution, and post-planning path smoothing via shortcutting reduces unnecessary detours and improves smoothness.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions, alternately expanding each towards sampled points biased towards the goal. Each new node and edge is strictly checked for collision-free feasibility. When the trees connect, the planner reconstructs the path, smooths it by iteratively shortcutting, and returns the optimized trajectory along with explored graph data.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.6782,
          "time_improvement": -33.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010827350616455077,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 163.9683475002103,
                    "smoothness_avg": 0.014173695614508616,
                    "success_improvement": 0.0,
                    "time_improvement": -9.547127756576938,
                    "length_improvement": 18.050195900642194,
                    "smoothness_improvement": 36.19173375747664,
                    "objective_score": 0.9268595219427409
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03178107738494873,
                    "num_nodes_avg": 498.6,
                    "path_length_avg": 249.62854531281232,
                    "smoothness_avg": 0.0401662199932736,
                    "success_improvement": 0.0,
                    "time_improvement": -109.42774008867326,
                    "length_improvement": 17.164803355659895,
                    "smoothness_improvement": 462.6901432691145,
                    "objective_score": -27.081910639124423
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02228260040283203,
                    "num_nodes_avg": 378.2,
                    "path_length_avg": 125.71203140928696,
                    "smoothness_avg": 0.05507350730124254,
                    "success_improvement": 0.0,
                    "time_improvement": 19.762980565745675,
                    "length_improvement": 22.805239694513528,
                    "smoothness_improvement": 326.10349972973546,
                    "objective_score": 12.120459607275086
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm improves bidirectional RRT by tuning key parameters: reducing step size for finer node expansions, increasing maximum iterations for thorough search, and biasing sampling towards the goal to enhance convergence speed. It also integrates a goal bias sampling with a certain probability to direct growth towards the goal, and employs shortened collision checking resolution to enhance accuracy. Additionally, path smoothing is applied post planning to improve path quality and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal simultaneously, alternately expanding each tree towards sampled points. Sampling is biased towards the goal to increase success and convergence speed. Collision checks are strictly enforced for nodes and edges before insertion. When trees connect, the path is reconstructed and then smoothed by shortcutting to reduce unnecessary detours, resulting in improved path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            # Shortcut smoothing with max trials = 50\n            if len(path) <= 2:\n                return path\n            import random\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    # shortcut possible\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.82017,
          "time_improvement": -50.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.008735418319702148,
                    "num_nodes_avg": 121.9,
                    "path_length_avg": 158.79688158358158,
                    "smoothness_avg": 0.017264620570270624,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 11.618269272519385,
                    "length_improvement": 20.634844860245124,
                    "smoothness_improvement": 65.89171039649618,
                    "objective_score": -42.05809169421266
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026499056816101076,
                    "num_nodes_avg": 449.3,
                    "path_length_avg": 240.15460051249525,
                    "smoothness_avg": 0.04002816589212556,
                    "success_improvement": 0.0,
                    "time_improvement": -74.62081339337057,
                    "length_improvement": 20.308578758222435,
                    "smoothness_improvement": 460.75613797892566,
                    "objective_score": -16.020747576472054
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.052319788932800294,
                    "num_nodes_avg": 571.0,
                    "path_length_avg": 128.29426974238464,
                    "smoothness_avg": 0.06187473290802109,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -88.39739731919414,
                    "length_improvement": 21.219589801337207,
                    "smoothness_improvement": 378.7245543077222,
                    "objective_score": -70.38167846395218
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 43.98048200212903,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.002286410331726074,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 76.86694616382907,
                    "length_improvement": 14.547294318234119,
                    "smoothness_improvement": 6.939088459328463,
                    "objective_score": 26.004238155092185
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.007691335678100586,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 49.31641146656528,
                    "length_improvement": 8.292841453028517,
                    "smoothness_improvement": 4.557864045526364,
                    "objective_score": -133.5237189491971
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.00499422550201416,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 82.01638222560287,
                    "length_improvement": 4.825184687042764,
                    "smoothness_improvement": 1.6166365256828326,
                    "objective_score": -24.421965212282167
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 52.752541255711016,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0051594734191894535,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 47.79835678825919,
                    "length_improvement": 21.158844301429212,
                    "smoothness_improvement": 158.83369146092565,
                    "objective_score": 19.365444354068227
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.021558094024658202,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -42.06135485959018,
                    "length_improvement": 27.333600643728058,
                    "smoothness_improvement": 213.19280910618096,
                    "objective_score": -106.08572228360053
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008537554740905761,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 69.25727099697029,
                    "length_improvement": 31.694181530357035,
                    "smoothness_improvement": 269.3273114473463,
                    "objective_score": -71.53734583760075
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This simplified hybrid RRT* planner integrates goal bias sampling, dynamic neighbor searching with rewiring to incrementally improve path cost and quality. It ensures collision-free node and edge expansions within map bounds, balancing exploration and exploitation to efficiently find smooth, robust paths with reduced planning time.",
          "planning_mechanism": "The planner grows a tree from the start position by iteratively sampling states with goal bias. For each sampled point, it steers a fixed step size towards the sample from the nearest existing node. New nodes are added only if collision-free and within bounds. For each new node, neighbors within a dynamically scaled radius are found to select the best parent minimizing path cost. The planner then rewires neighbors via the new node to improve costs. When a node reaches near the goal, a final connection is attempted. The solution path is extracted by backtracking from the goal node once found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Dynamic neighbor radius based on node count & dimension\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            gamma = self.neighbor_factor\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim)))\n\n            # Find neighbor nodes within radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            # Choose parent minimizing cost + collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                c = near_node.cost + math.dist(near_node.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = near_node\n\n            # Connect new node to best parent\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if beneficial and collision-free\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge & update parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new node can connect directly to goal\n            dist_goal = math.dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 132.8663,
          "time_improvement": -452.0,
          "length_improvement": 14.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04421133995056152,
                    "num_nodes_avg": 277.1,
                    "path_length_avg": 175.4057816503535,
                    "smoothness_avg": 0.014822768672657066,
                    "success_improvement": 0.0,
                    "time_improvement": -347.31398080829035,
                    "length_improvement": 12.333876243262361,
                    "smoothness_improvement": 42.42852531337951,
                    "objective_score": -101.51527636726773
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14756877422332765,
                    "num_nodes_avg": 975.3,
                    "path_length_avg": 271.0520755830754,
                    "smoothness_avg": 0.006851663576418842,
                    "success_improvement": 0.0,
                    "time_improvement": -872.4338328405295,
                    "length_improvement": 10.055751221700547,
                    "smoothness_improvement": -4.014777589414016,
                    "objective_score": -259.7390734957658
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06594605445861816,
                    "num_nodes_avg": 520.3,
                    "path_length_avg": 133.0968329704542,
                    "smoothness_avg": 0.019142422483870408,
                    "success_improvement": 0.0,
                    "time_improvement": -137.46397447113193,
                    "length_improvement": 18.270526668026136,
                    "smoothness_improvement": 48.104844114373854,
                    "objective_score": -37.34456278716248
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm integrates the exploration efficiency of a basic RRT with the path optimality improvements of RRT*\u2014including goal biasing, neighbor rewiring, and adaptive steering\u2014combined with a dynamic neighbor radius scaling based on node density. It performs rigorous collision checking for nodes and edges, ensures nodes stay within bounds, and incrementally improves path cost while promoting path smoothness and robustness. The planner balances exploration and exploitation via goal sampling and rewiring neighbors to progressively shorten path length and increase success rate.",
          "planning_mechanism": "The planner samples points with goal bias, steers towards them from the nearest nodes with fixed step size, rejects samples in collision or out of bounds, and adds valid nodes. It selects the best parent among neighbors within a dynamically scaled radius to minimize cost, adds edges only if collision-free, and rewires neighbors to improve paths. Once within step size of goal, it attempts final connection. The path is traced back from goal node if successful.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # factor to scale neighbor search radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_idx in range(1, self.max_iter + 1):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Dynamic neighbor radius based on iteration and nodes count\n            n_nodes = len(nodes)\n            gamma = self.neighbor_factor\n            dim = len(bounds)\n            # Radius scaling as per RRT* theoretical bound:\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)))\n\n            # Find neighbors within radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            # Choose best parent minimizing cost + edge validity\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_node\n\n            # Connect new_node to best parent\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to potentially improve their cost through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge and update parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new node can connect directly to goal\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path if success\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 177.31653,
          "time_improvement": -604.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05419919490814209,
                    "num_nodes_avg": 284.2,
                    "path_length_avg": 165.482775399497,
                    "smoothness_avg": 0.016891900008800545,
                    "success_improvement": 0.0,
                    "time_improvement": -448.3674020754835,
                    "length_improvement": 17.293299392497616,
                    "smoothness_improvement": 62.310325494896546,
                    "objective_score": -130.74000911667105
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.15224525928497315,
                    "num_nodes_avg": 933.7,
                    "path_length_avg": 259.50582756375985,
                    "smoothness_avg": 0.007024509778030356,
                    "success_improvement": 0.0,
                    "time_improvement": -903.2504626909287,
                    "length_improvement": 13.887186941464913,
                    "smoothness_improvement": -1.5933684061602176,
                    "objective_score": -268.2056682610164
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15545496940612794,
                    "num_nodes_avg": 883.6,
                    "path_length_avg": 124.91386658373274,
                    "smoothness_avg": 0.019892198189482964,
                    "success_improvement": 0.0,
                    "time_improvement": -459.77503414752243,
                    "length_improvement": 23.295360979661872,
                    "smoothness_improvement": 53.9058556683744,
                    "objective_score": -133.00390876998247
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 188.97047424566063,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.034190583229064944,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -245.92767166641744,
                    "length_improvement": 8.639069807597604,
                    "smoothness_improvement": -38.9355540051658,
                    "objective_score": -72.24516530843155
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23241231441497803,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -1431.5272414194005,
                    "length_improvement": -1.1692154216563917,
                    "smoothness_improvement": -45.85769819397494,
                    "objective_score": -429.92130400112126
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08899827003479004,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -220.4722874933787,
                    "length_improvement": 7.95110876006046,
                    "smoothness_improvement": -38.697786285519925,
                    "objective_score": -64.74495342742911
               }
          ]
     },
     {
          "operator": "e1",
          "algorithm_description": "This Planner implements RRT* (Rapidly-exploring Random Tree Star), an asymptotically optimal sampling-based path planner that incrementally builds a tree towards the goal while rewiring nodes within a neighborhood radius to reduce path cost. This improves path quality, smoothness, success rate, and efficiency over naive RRT.",
          "planning_mechanism": "The planner samples random points, connects them by the lowest-cost parent within a radius if free of collisions, and rewires neighbors to shorten paths. It terminates when the goal is reached or max iterations expire, then extracts the optimal path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, search_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        def distance(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            new_pos = tuple(from_pos[d] + direction[d]*self.step_size for d in range(len(from_pos)))\n            return new_pos\n\n        def find_nearest(nodes, sample):\n            return min(nodes, key=lambda n: distance(n.position, sample))\n\n        def find_near(nodes, new_node, radius):\n            return [node for node in nodes if distance(node.position, new_node.position) <= radius]\n\n        for _ in range(self.max_iter):\n            # Sample point (goal biasing)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = find_nearest(nodes, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            # Check bounds\n            out_of_bounds = any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds)))\n            if out_of_bounds:\n                continue\n\n            # Check collision for new node pos\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            \n            # Find neighbors within radius\n            neighbors = find_near(nodes, new_node, self.search_radius)\n\n            # Choose parent with minimum cost + edge cost, check collision\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for node in neighbors:\n                edge_cost = distance(node.position, new_pos)\n                cost = node.cost + edge_cost\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_node = node\n            \n            new_node.parent = min_node\n            new_node.cost = min_cost\n            min_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors to new node if cheaper and collision free\n            for node in neighbors:\n                if node == min_node:\n                    continue\n                edge_cost = distance(new_node.position, node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        # Rewire\n                        if node.parent:\n                            node.parent.remove_child(node)\n                            edges.remove((node.parent, node))\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n            # Check if goal can be connected to new node directly (within step size)\n            if distance(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node,\n                                     cost=new_node.cost + distance(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 203.21722,
          "time_improvement": -695.0,
          "length_improvement": 24.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08516473770141601,
                    "num_nodes_avg": 382.4,
                    "path_length_avg": 166.63575379732103,
                    "smoothness_avg": 0.020723393476121822,
                    "success_improvement": 0.0,
                    "time_improvement": -761.6653077765501,
                    "length_improvement": 16.71705187111335,
                    "smoothness_improvement": 99.12625215137012,
                    "objective_score": -224.6605506979855
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2160618782043457,
                    "num_nodes_avg": 907.3,
                    "path_length_avg": 224.7715692277033,
                    "smoothness_avg": 0.01672571524002643,
                    "success_improvement": 0.0,
                    "time_improvement": -1323.7827850694584,
                    "length_improvement": 25.41318896962671,
                    "smoothness_improvement": 134.31119747551438,
                    "objective_score": -391.38064173953455
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02791097164154053,
                    "num_nodes_avg": 283.3,
                    "path_length_avg": 115.64457953157512,
                    "smoothness_avg": 0.03213987081764254,
                    "success_improvement": 0.0,
                    "time_improvement": -0.5041213119173451,
                    "length_improvement": 28.987261620933317,
                    "smoothness_improvement": 148.66604847500068,
                    "objective_score": 6.3895461729864635
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT with adaptive sampling and dynamic step size adjustment for improved planning efficiency, success rate, and path quality. It introduces informed sampling biased towards the current best path, dynamically adjusts step size based on local obstacle density, and applies aggressive path smoothing via shortcutting and spline interpolation for smooth and short paths. Robust collision checking and edge validation ensure safe expansions and better convergence.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansions. Sampling is dynamically biased towards the goal and regions near the current best path for efficient exploration. Each extension step adapts the step size based on obstacle proximity. When the two trees connect, the path is reconstructed, extensively smoothed with shortcutting and cubic spline interpolation to improve smoothness and reduce length, then returned as the final path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float=3.0, goal_sample_rate: float=0.15, collision_resolution: float=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n        best_connect = None\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free() -> Tuple[float, ...]:\n            # With probability goal_sample_rate, sample goal directly for bias\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            # With small probability sample near current best path if exists for informed sampling\n            if best_connect is not None and random.random() < 0.2:\n                path = best_connect.path_from_root()\n                if len(path) > 2:\n                    idx = random.randint(0, len(path) - 2)\n                    p1, p2 = path[idx], path[idx+1]\n                    alpha = random.uniform(0,1)\n                    sample = tuple(p1[d] + alpha*(p2[d] - p1[d]) for d in range(len(p1)))\n                    if _is_within_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Uniform random sample in free space\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            # Return node in tree nearest to point\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _dynamic_step_size(pos: Tuple[float, ...]) -> float:\n            # Estimate obstacle density nearby and reduce step size in cluttered areas\n            check_range = self.step_size * 2\n            cnt = 0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    cx, cy, cz = x + w/2, y + h/2, z + d/2\n                    dist_to_obs = math.dist(pos, (cx, cy, cz))\n                    if dist_to_obs < check_range + max(w,h,d)/2:\n                        cnt += 1\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    cx, cy = x + w_/2, y + h_/2\n                    dist_to_obs = math.dist(pos, (cx, cy))\n                    if dist_to_obs < check_range + max(w_,h_)/2:\n                        cnt += 1\n            if cnt == 0:\n                return self.step_size\n            else:\n                return max(self.step_size / (1 + cnt), self.step_size * 0.2)\n\n        def _extend_tree(tree: List[Node], point: Tuple[float, ...]):\n            nearest_node = _nearest(tree, point)\n            dynamic_step = _dynamic_step_size(nearest_node.position)\n            new_pos = _steer(nearest_node.position, point, dynamic_step)\n\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree: List[Node], new_node: Node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                dynamic_step = _dynamic_step_size(current.position)\n                next_pos = _steer(current.position, new_node.position, dynamic_step)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= dynamic_step:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a: Node, node_b: Node) -> List[Tuple[float, ...]]:\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _shortcut_smooth(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            for _ in range(trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def _cubic_spline_smooth(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            try:\n                import numpy as np\n                from scipy.interpolate import CubicSpline\n            except ImportError:\n                # Fallback: no spline smoothing if libs unavailable\n                return path\n            if len(path) < 4:\n                return path\n\n            dims = len(path[0])\n            path_np = np.array(path)\n            num_points = len(path)\n\n            # Parameter t: cumulative distance along path\n            dist = np.zeros(num_points)\n            dist[1:] = np.cumsum(np.linalg.norm(np.diff(path_np, axis=0), axis=1))\n            cs_funcs = [CubicSpline(dist, path_np[:, d]) for d in range(dims)]\n\n            smoothed_path = []\n            resolution = max(dist[-1]/(num_points*5), 0.01)  # denser interpolation\n            ts = np.arange(0, dist[-1], resolution)\n            for t in ts:\n                pt = tuple(cs(t) for cs in cs_funcs)\n                if (not _is_within_bounds(pt) or self._is_in_obstacle(pt, obstacles, is_3d) \n                    or self._is_edge_in_obstacle(smoothed_path[-1] if smoothed_path else pt, pt, obstacles, is_3d, self.collision_resolution)):\n                    return path  # Abort smoothing if obstacle detected\n                smoothed_path.append(pt)\n            return smoothed_path if smoothed_path else path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_start = _extend_tree(tree_start, rand_point)\n            if new_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_goal = _connect_trees(tree_goal, new_start)\n            if new_goal is not None:\n                candidate_path = _reconstruct_path(new_start, new_goal)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if candidate_cost < best_path_cost:\n                    best_path_cost = candidate_cost\n                    best_connect = new_start\n                    extracted_path = candidate_path\n                    success_state = True\n                    # Aggressive smoothing on candidate path\n                    extracted_path = _shortcut_smooth(extracted_path, trials=150)\n                    extracted_path = _cubic_spline_smooth(extracted_path)\n                    break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 256.55061,
          "time_improvement": -672.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02612292766571045,
                    "num_nodes_avg": 236.2,
                    "path_length_avg": 149.55670683106166,
                    "smoothness_avg": 0.01981247787287812,
                    "success_improvement": 0.0,
                    "time_improvement": -164.3021174563507,
                    "length_improvement": 25.252995389644518,
                    "smoothness_improvement": 90.37347668005924,
                    "objective_score": -43.788168775576
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.15865614414215087,
                    "num_nodes_avg": 1280.6,
                    "path_length_avg": 230.71969094734158,
                    "smoothness_avg": 0.08375590703309015,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -945.4962654793288,
                    "length_improvement": 23.439400949136978,
                    "smoothness_improvement": 1073.3397699852385,
                    "objective_score": -323.59430060404503
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.279067325592041,
                    "num_nodes_avg": 1624.2,
                    "path_length_avg": 121.86693114793975,
                    "smoothness_avg": 0.379060520513509,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -904.8885687573564,
                    "length_improvement": 25.166362887717565,
                    "smoothness_improvement": 2832.7896899084412,
                    "objective_score": -402.2693496001212
               }
          ],
          "success_rate": 0.8666666666666666
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the informed bidirectional RRT* approach with dynamic neighbor rewiring and adaptive step sizing from single-tree RRT* variants. It employs informed ellipsoidal sampling biased by the current best solution to focus search, while growing two trees (from start and goal) that attempt to connect for faster convergence. Dynamic neighborhood rewiring improves path optimality, and local shortcut smoothing enhances final path smoothness. Efficiency is improved by adaptive radius scaling and pruning unreachable branches. The planner maintains strict collision checks on nodes and edges and respects map bounds.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling mostly within an informed ellipsoid based on the current best solution cost to reduce search space and focus on promising regions. Each extension chooses parents among neighbors minimizing costs, rewires neighbors for improved paths, and tries to connect both trees to form a complete path. After connection, a local shortcut smoothing procedure refines the path to reduce unnecessary waypoints while ensuring collision-free shortcuts. The process adapts step sizes and neighbor search radius dynamically for balance between exploration and efficient convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root of the tree\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 neighbor_factor: float = 30.0, smooth_iter: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor  # Used to scale rewiring radius dynamically\n        self.smooth_iter = smooth_iter           # Number of local shortcut smoothing iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []    # Stores nodes that are expansions beyond roots\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = _distance(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def _steer(from_p, to_p, max_step):\n            dist = _distance(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: _distance(n.position, point))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_a)) + path_b\n\n        def _local_shortcut(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not _is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def _informed_sample(c_best):\n            # Sample uniformly in map if no solution found yet\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle(pt):\n                        return pt\n\n            c_min = _distance(start_pos, goal_pos)\n            if c_best < c_min:\n                c_min = c_best  # numerical safeguard\n\n            center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n            direction_vec = tuple((g - s) / c_min for s, g in zip(start_pos, goal_pos))\n\n            # Gram-Schmidt orthonormal basis\n            basis = [direction_vec]\n            for _ in range(dim - 1):\n                vec = [random.gauss(0, 1) for __ in range(dim)]\n                for b in basis:\n                    proj = sum(vec[d] * b[d] for d in range(dim))\n                    vec = [vec[d] - proj * b[d] for d in range(dim)]\n                norm = math.sqrt(sum(x * x for x in vec))\n                if norm > 1e-9:\n                    basis.append(tuple(x / norm for x in vec))\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n            radii = [r1] + [r_other] * (dim - 1)\n\n            while True:\n                while True:\n                    sample = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in sample))\n                    if 1e-9 < norm <= 1.0:\n                        sample = [x / norm for x in sample]\n                        break\n                u = random.uniform(0, 1) ** (1.0 / dim)\n                sample_scaled = [radii[i] * u * sample[i] for i in range(dim)]\n\n                new_point = list(center)\n                for i in range(dim):\n                    for d in range(dim):\n                        new_point[d] += basis[i][d] * sample_scaled[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n\n                if not _is_in_obstacle(new_point):\n                    return new_point\n\n        def _rewire(tree, new_node, radius):\n            near_nodes = _near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not _is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old connection\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, new_cost)\n                        edges.append((new_node, near_node))\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            c_best = best_cost\n            sample = _informed_sample(c_best)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = _nearest(tree_a, sample)\n                new_pos = _steer(nearest_node.position, sample, self.step_size)\n\n                # Check bounds\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                    continue\n                if _is_in_obstacle(new_pos):\n                    continue\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                # Create new node and find best parent among neighbors\n                new_node = Node(new_pos)\n                n_nodes = len(tree_a)\n                # Adaptive radius for neighbors used in rewiring:\n                radius = min(self.step_size * 3,\n                             self.neighbor_factor * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)))\n\n                near_nodes = _near(tree_a, new_pos, radius)\n                min_cost = nearest_node.cost + _distance(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if _is_edge_in_obstacle(near_node.position, new_pos):\n                        continue\n                    cost = near_node.cost + _distance(near_node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = near_node\n\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for cost improvement\n                _rewire(tree_a, new_node, radius)\n\n                # Attempt to connect new_node to other tree\n                nearest_other = _nearest(tree_b, new_node.position)\n                dist_connect = _distance(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and not _is_edge_in_obstacle(new_node.position, nearest_other.position):\n                    candidate_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_path = _extract_path(new_node, nearest_other)\n\n            # Early stop if sufficiently good path found (after minimum iterations)\n            if success_state and iter_count > self.max_iter // 10:\n                break\n\n        # If a path was found, perform local shortcut smoothing to improve smoothness & length\n        if success_state and best_path:\n            path = best_path\n            for _ in range(self.smooth_iter):\n                path = _local_shortcut(path)\n            extracted_path = path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree + nodes,\n            edges=edges\n        )",
          "objective": 272.55385,
          "time_improvement": -939.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.21923460960388183,
                    "num_nodes_avg": 1175.8,
                    "path_length_avg": 157.15636338715737,
                    "smoothness_avg": 0.04699571723321052,
                    "success_improvement": 0.0,
                    "time_improvement": -2118.1346700309246,
                    "length_improvement": 21.45476008698255,
                    "smoothness_improvement": 351.5708805412327,
                    "objective_score": -629.3915945891747
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08462791442871094,
                    "num_nodes_avg": 1002.0,
                    "path_length_avg": 234.63384451840466,
                    "smoothness_avg": 0.1070944461728982,
                    "success_improvement": 0.0,
                    "time_improvement": -457.67249966221203,
                    "length_improvement": 22.14055237254947,
                    "smoothness_improvement": 1400.2902755212244,
                    "objective_score": -125.87218804654759
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09444963932037354,
                    "num_nodes_avg": 1253.2,
                    "path_length_avg": 121.54117811921726,
                    "smoothness_avg": 0.13078905994266155,
                    "success_improvement": 0.0,
                    "time_improvement": -240.10202618649225,
                    "length_improvement": 25.366394871045777,
                    "smoothness_improvement": 911.9144194521435,
                    "objective_score": -62.3977567844778
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a hybrid informed bidirectional RRT* with adaptive sampling and path smoothing. It grows two trees from start and goal while focusing sampling in an informed ellipsoidal region to bias exploration towards the optimal path region. It adaptively adjusts step sizes for efficient expansion and performs local shortcut smoothing on the found path to improve path quality and smoothness.",
          "planning_mechanism": "The planner alternately expands two trees towards samples drawn mostly within an ellipsoidal informed set computed from the current best solution cost. Each extension attempts rewiring for path cost improvement. Once the trees connect, the path is extracted and locally smoothed via shortcutting to reduce unnecessary waypoints and ensure collision-free shortcuts, resulting in better path quality and faster convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0, smooth_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        def informed_sample(c_best):\n            # If no solution yet, sample whole space uniformly\n            if c_best == float('inf'):\n                while True:\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n\n            # Informed sampling in ellipsoid around start & goal\n            c_min = math.dist(start_position, goal_position)\n            if c_best < c_min:\n                c_min = c_best  # numerical safeguard\n\n            # Ellipsoid center\n            center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n            # Unit vector from start to goal\n            direction = tuple((g - s) / c_min for s, g in zip(start_position, goal_position))\n\n            # Create orthonormal basis via Gram-Schmidt\n            def ortho_basis(vec):\n                basis = [vec]\n                for _ in range(dim - 1):\n                    v = [random.gauss(0,1) for __ in range(dim)]\n                    # Subtract projections\n                    for b in basis:\n                        proj = sum(v[d]*b[d] for d in range(dim))\n                        v = [v[d] - proj*b[d] for d in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in v))\n                    if norm > 1e-6:\n                        basis.append(tuple(x/norm for x in v))\n                return basis\n\n            basis = ortho_basis(direction)\n            # Radii of the ellipsoid\n            r1 = c_best / 2.0\n            r_others = math.sqrt(c_best*c_best - c_min*c_min)/2.0 if c_best > c_min else 0.0\n            radii = [r1] + [r_others]*(dim-1)\n\n            while True:\n                # sample uniformly in unit n-ball\n                while True:\n                    sample = [random.gauss(0,1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in sample))\n                    if norm <= 1.0 and norm > 1e-6:\n                        sample = [x / norm for x in sample]\n                        break\n                # scale with radii and random radius^(1/dim)\n                u = random.uniform(0,1) ** (1.0/dim)\n                sample = [radii[i]*u*sample[i] for i in range(dim)]\n\n                # rotate and translate to ellipsoid space\n                new_point = [center[d] for d in range(dim)]\n                for i in range(dim):\n                    for d in range(dim):\n                        new_point[d] += basis[i][d]*sample[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n                if not self._is_in_obstacle(new_point, obstacles, is_3d):\n                    return new_point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if self._distance(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos, max_step):\n            dist = self._distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_a)) + path_b\n\n        def reconstruct_path(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def local_shortcut(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                dist = self._distance(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    # Connect new edge\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            c_best = best_cost\n            sample = informed_sample(c_best)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree_a, new_pos, self.radius)\n                min_cost = nearest_node.cost + self._distance(nearest_node.position, new_pos)\n                min_parent = nearest_node\n\n                for near_node in near_nodes:\n                    cost = near_node.cost + self._distance(near_node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near_node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nearby nodes for optimality\n                rewire(tree_a, new_node)\n\n                # Try connecting to other tree\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = self._distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    candidate_cost = new_node.cost + dist_connect + connect_node.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_path = extract_path(new_node, connect_node)\n\n            # Early break if solution found with good cost\n            if success_state and iter_count > self.max_iter // 10:\n                break\n\n        if success_state and best_path:\n            # Path smoothing via local shortcutting\n            path = best_path\n            for _ in range(self.smooth_iter):\n                path = local_shortcut(path)\n            extracted_path = path\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree + nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 293.42562,
          "time_improvement": -1007.0,
          "length_improvement": 26.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.22914626598358154,
                    "num_nodes_avg": 1232.2,
                    "path_length_avg": 151.05556807923077,
                    "smoothness_avg": 0.04946771756942938,
                    "success_improvement": 0.0,
                    "time_improvement": -2218.4171422782074,
                    "length_improvement": 24.503878944109687,
                    "smoothness_improvement": 375.3237549358324,
                    "objective_score": -658.747748119961
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09055137634277344,
                    "num_nodes_avg": 1009.0,
                    "path_length_avg": 225.45937519639352,
                    "smoothness_avg": 0.08516524523696775,
                    "success_improvement": 0.0,
                    "time_improvement": -496.7063318742989,
                    "length_improvement": 25.184951679703754,
                    "smoothness_improvement": 1093.0832438791554,
                    "objective_score": -138.50949300695316
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11305840015411377,
                    "num_nodes_avg": 1205.2,
                    "path_length_avg": 115.90098836757991,
                    "smoothness_avg": 0.09945529687228734,
                    "success_improvement": 0.0,
                    "time_improvement": -307.1099820655753,
                    "length_improvement": 28.82981114929822,
                    "smoothness_improvement": 669.4852233060038,
                    "objective_score": -83.01960627328293
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a simplified and generalized RRT* variant designed to efficiently find smooth and collision-free paths in both 2D and 3D environments. It uses fixed step sizes, goal biasing for faster convergence, adaptive neighbor radius for rewiring, and rigorous collision checks to maintain robustness and path quality. The rewiring step helps reduce path length and improve smoothness while ensuring no invalid nodes or edges are added.",
          "planning_mechanism": "The planner incrementally samples points within map bounds with a fixed probability of sampling the goal. For each sample, it finds the nearest tree node and steers toward it by a fixed step size. It accepts new nodes only if they and the connecting edges are collision-free and within bounds. Neighboring nodes within a dynamically adjusted radius are considered to choose the parent with the minimum cost and to rewire for path improvement. The process continues until the goal is connected or max iterations are reached, finally extracting and returning the optimized path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children: List[Node] = []\n        self.valid = True               # For collision or other validation\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n\n            # Adaptive neighbor radius: shrink over iterations for faster convergence & refinement\n            neighbor_radius = max(self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.5), self.step_size * 1.5)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node in tree to sample\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + direction[d] / dist * scale for d in range(len(bounds)))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision check for node position and edge from nearest\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within radius for rewiring and parent selection\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= neighbor_radius]\n\n            # Choose best parent minimizing cost and with collision-free connection\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if reduces cost and edge is collision free\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect goal if within step size and collision free\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            node = nodes[-1]\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 294.68541,
          "time_improvement": -999.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.10493555068969726,
                    "num_nodes_avg": 278.6,
                    "path_length_avg": 162.4528117599165,
                    "smoothness_avg": 0.020614816246580923,
                    "success_improvement": 0.0,
                    "time_improvement": -961.6990790102133,
                    "length_improvement": 18.807646097074123,
                    "smoothness_improvement": 98.08295888898189,
                    "objective_score": -284.25777968920426
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2624242305755615,
                    "num_nodes_avg": 909.4,
                    "path_length_avg": 234.3150377697144,
                    "smoothness_avg": 0.01053129730459921,
                    "success_improvement": 0.0,
                    "time_improvement": -1629.2967412104435,
                    "length_improvement": 22.24634323747723,
                    "smoothness_improvement": 47.533354896899375,
                    "objective_score": -484.10208694115306
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1408143997192383,
                    "num_nodes_avg": 493.3,
                    "path_length_avg": 115.77530303340964,
                    "smoothness_avg": 0.02944454172251948,
                    "success_improvement": 0.0,
                    "time_improvement": -407.05606718412366,
                    "length_improvement": 28.90698951589068,
                    "smoothness_improvement": 127.8122983393269,
                    "objective_score": -115.69636076036232
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 349.28087629035116,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04928519725799561,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "smoothness_avg": 0.014115946270353475,
                    "success_improvement": 0.0,
                    "time_improvement": -398.649391876571,
                    "length_improvement": 21.16112596316623,
                    "smoothness_improvement": 35.636833785179014,
                    "objective_score": -115.18440820141214
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.42683241367340086,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "smoothness_avg": 0.011462143624438778,
                    "success_improvement": 0.0,
                    "time_improvement": -2712.6972131709017,
                    "length_improvement": 25.195979140247676,
                    "smoothness_improvement": 60.57361731541344,
                    "objective_score": -808.467100036644
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1480414628982544,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "smoothness_avg": 0.020633789931938304,
                    "success_improvement": 0.0,
                    "time_improvement": -433.07987043258106,
                    "length_improvement": 27.173113785558407,
                    "smoothness_improvement": 59.64354793304998,
                    "objective_score": -124.19112063299738
               }
          ]
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an optimized and refined RRT* variant with tuned parameters for improved efficiency, path quality, and success rate in 2D/3D environments. It employs adaptive neighbor radius scaling based on iteration count, goal biasing, and rewiring to achieve shorter, smoother paths while respecting collision and boundary constraints.",
          "planning_mechanism": "Planning mechanism: The planner incrementally samples points in the bounded space with goal biasing, finds the nearest node, and steers towards the sample using a fixed step size. It validates node and edge collisions, connects the new node choosing the best parent among neighbors within a dynamically scaled radius, and rewires neighbors to reduce path costs. The process repeats until the goal is reached or iteration limit is exceeded, then extracts and returns the optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.5, goal_sample_rate: float = 0.15, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Dynamic neighbor radius shrinks as iterations increase (for faster convergence)\n            neighbor_radius = self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter)**0.5)\n            neighbor_radius = max(neighbor_radius, self.step_size * 1.5)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node search\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + direction[d] / dist * scale for d in range(len(bounds)))\n\n            # Bounds check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find nearby nodes for potential rewiring and best parent selection\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= neighbor_radius]\n\n            # Choose best parent from near nodes\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to potentially reduce cost\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        # Update parent and add new edge\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check goal reaching with safe connection\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path backward from goal_node if success\n        if success_state:\n            node = nodes[-1]\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 495.55441,
          "time_improvement": -1613.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.14350197315216065,
                    "num_nodes_avg": 227.2,
                    "path_length_avg": 164.12929598622088,
                    "smoothness_avg": 0.020655984144223045,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -1351.8998731166507,
                    "length_improvement": 17.969755394289972,
                    "smoothness_improvement": 98.47853161098192,
                    "objective_score": -451.48361819808235
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.45711603164672854,
                    "num_nodes_avg": 1051.9,
                    "path_length_avg": 235.6620395304657,
                    "smoothness_avg": 0.009652673888803365,
                    "success_improvement": 0.0,
                    "time_improvement": -2912.2571461789116,
                    "length_improvement": 21.799362482162223,
                    "smoothness_improvement": 35.22468517899821,
                    "objective_score": -869.141147931346
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.18728911876678467,
                    "num_nodes_avg": 439.6,
                    "path_length_avg": 117.15879937338202,
                    "smoothness_avg": 0.030292819476407735,
                    "success_improvement": 0.0,
                    "time_improvement": -574.4060563238808,
                    "length_improvement": 28.057439419925913,
                    "smoothness_improvement": 134.3754198361579,
                    "objective_score": -166.03845191399824
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is an enhanced RRT* variant incorporating adaptive neighbor radius scaling, goal biasing, and efficient rewiring. It refines path quality and planning speed by dynamically adjusting connection radius and prioritizing lower-cost connections while ensuring collision-free nodes and edges. Additionally, batch rewiring based on updated costs promotes better path smoothness and shorter lengths, improving success rates and robustness in 2D/3D bounded environments.",
          "planning_mechanism": "The planner incrementally samples the space with goal biasing, finds nearest nodes, and extends toward samples constrained by step size and bounds. It dynamically scales the neighbor search radius based on progress to balance exploration and exploitation, connects new nodes choosing minimal cost parents from near nodes while performing collision checks on nodes and edges. Rewiring of neighbors is performed to reduce costs, ensuring path smoothness and optimality. The process continues until the goal is reached or iterations are exhausted, then extracts and returns the refined path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4500, step_size: float = 4.0, goal_sample_rate: float = 0.15, base_neighbor_radius: float = 18.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Adaptive neighbor radius scales down as iterations increase (explore then exploit)\n            neighbor_radius = self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.6)\n            neighbor_radius = max(neighbor_radius, self.step_size * 1.7)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node search\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision check for node\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Collision check for edge\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbor nodes within adaptive radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= neighbor_radius]\n\n            # Choose best parent to minimize cost + collision checks\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve cost if possible (only if edge is collision-free)\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge safely\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Update parent and add new edge\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Attempt direct connection to goal if close enough and collision-free\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path from goal_node backwards if success\n        if success_state:\n            node = nodes[-1]\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 746.03681,
          "time_improvement": -2448.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.31168811321258544,
                    "num_nodes_avg": 407.9,
                    "path_length_avg": 163.4753623556092,
                    "smoothness_avg": 0.017225723029483792,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -3053.5450146422418,
                    "length_improvement": 18.296585137588686,
                    "smoothness_improvement": 65.51795300373561,
                    "objective_score": -962.076597600136
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5240156412124634,
                    "num_nodes_avg": 1156.6,
                    "path_length_avg": 231.54072949104912,
                    "smoothness_avg": 0.009372344872334874,
                    "success_improvement": 0.0,
                    "time_improvement": -3353.105449540765,
                    "length_improvement": 23.16695258336466,
                    "smoothness_improvement": 31.297545048172836,
                    "objective_score": -1001.1417566203158
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2879826784133911,
                    "num_nodes_avg": 609.7,
                    "path_length_avg": 117.03725506875833,
                    "smoothness_avg": 0.027892430226335037,
                    "success_improvement": 0.0,
                    "time_improvement": -936.9917041480978,
                    "length_improvement": 28.132074944916962,
                    "smoothness_improvement": 115.80361806992944,
                    "objective_score": -274.8920781650963
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a streamlined, generalized RRT* variant designed for efficient path planning in 2D or 3D spaces. It incrementally builds a tree from start to goal by sampling, steering, and rewiring nodes to iteratively improve path cost and quality. The approach balances exploration and exploitation, maintaining collision and edge-validity checks to ensure robust, feasible paths.",
          "planning_mechanism": "The planner samples points within bounds, extends the nearest existing node toward samples with a fixed step size, validates new nodes and connecting edges against obstacles, and rewires neighbors within a radius to optimize path costs. Upon reaching near the goal, it finalizes the path by connecting to the goal node. Throughout, it maintains and updates node parent-child relationships and costs to improve path quality progressively.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        nodes = []\n        edges = []\n        root = Node(start_position)\n        nodes.append(root)\n        success = False\n\n        for _ in range(self.max_iter):\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node and steer towards sample\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + direction[d]/dist * scale for d in range(len(bounds)))\n\n            # Bound check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_node\n\n            # Connect new_node\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Update parent and edges\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if goal reached\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success:\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 795.36845,
          "time_improvement": -2670.0,
          "length_improvement": 26.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.12200891971588135,
                    "num_nodes_avg": 262.1,
                    "path_length_avg": 160.31053176222167,
                    "smoothness_avg": 0.020643529268731024,
                    "success_improvement": 0.0,
                    "time_improvement": -1134.4411102051843,
                    "length_improvement": 19.878337049404657,
                    "smoothness_improvement": 98.35885561869833,
                    "objective_score": -335.86487137358085
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.9854721784591675,
                    "num_nodes_avg": 1319.4,
                    "path_length_avg": 221.71317278337733,
                    "smoothness_avg": 0.015905122000469153,
                    "success_improvement": 0.0,
                    "time_improvement": -6393.965221981668,
                    "length_improvement": 26.42806838001075,
                    "smoothness_improvement": 122.81547476101757,
                    "objective_score": -1912.2898755446931
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.16171705722808838,
                    "num_nodes_avg": 479.6,
                    "path_length_avg": 113.56485816767322,
                    "smoothness_avg": 0.030858624285259855,
                    "success_improvement": 0.0,
                    "time_improvement": -482.3240747974543,
                    "length_improvement": 30.264335822891898,
                    "smoothness_improvement": 138.7530493177356,
                    "objective_score": -137.95059002806923
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an advanced RRT* planner variant combining adaptive neighbor radius scaling based on iteration progress and node density, enhanced goal biasing for improved convergence, and rigorous collision checking for nodes and edges. It prioritizes lower-cost connections and performs rewiring of neighbors to optimize path cost and smoothness, thereby improving planning efficiency, success rate, and path quality in both 2D and 3D bounded obstacle environments.",
          "planning_mechanism": "The planner samples the space with a goal-biased strategy, extends from the nearest node towards the sample with a fixed step size while respecting boundary constraints and collision checks. It dynamically adjusts neighbor radius combining iteration decay and log-based node density scaling to balance exploration and exploitation. Upon adding a new node, it selects the best parent minimizing path cost and rewires neighbors to reduce costs and enhance smoothness. If the goal node is within reach and collision-free, it connects directly and extracts the final path backward from the goal.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.5, goal_sample_rate: float = 0.2,\n                 base_neighbor_radius: float = 20.0, neighbor_factor: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius      # For iteration-based radius decay\n        self.neighbor_factor = neighbor_factor                # For density-based radius scaling\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Adaptive radius combining iteration decay and node density scaling\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            log_term = math.log(n_nodes + 1) if n_nodes > 0 else 0.0\n            radius_iter = self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.65)\n            radius_density = self.neighbor_factor * ((log_term / (n_nodes + 1)) ** (1 / dim)) if n_nodes > 0 else self.base_neighbor_radius\n            neighbor_radius = max(radius_iter, radius_density, self.step_size * 1.8)\n            neighbor_radius = min(neighbor_radius, self.base_neighbor_radius * 1.5)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(dim))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision check for node\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Collision check for edge (nearest_node \u2192 new_pos)\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                continue\n\n            # Find neighbors within adaptive radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= neighbor_radius]\n\n            # Select best parent minimizing cost + collision free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                # Skip if edge invalid\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                    continue\n                cost_estimate = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_estimate < min_cost:\n                    min_cost = cost_estimate\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce cost through new_node if collision free\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.4):\n                        # Remove old edge safely\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Update parent and add new edge\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check whether direct connection to goal possible\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d, resolution=0.4)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path backward from goal if success\n        if success_state:\n            node = nodes[-1]\n            while node is not None:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 967.07435,
          "time_improvement": -3186.0,
          "length_improvement": 24.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.35120084285736086,
                    "num_nodes_avg": 312.4,
                    "path_length_avg": 162.6430887555788,
                    "smoothness_avg": 0.021275882502007848,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -3453.3201947152847,
                    "length_improvement": 18.712547483488848,
                    "smoothness_improvement": 104.43499027894603,
                    "objective_score": -1081.731373966493
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.6876274347305298,
                    "num_nodes_avg": 1042.5,
                    "path_length_avg": 228.9614705863541,
                    "smoothness_avg": 0.011953731205200383,
                    "success_improvement": 0.0,
                    "time_improvement": -4431.257953727765,
                    "length_improvement": 24.022837948154756,
                    "smoothness_improvement": 67.46028691724273,
                    "objective_score": -1324.2355170941123
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.49230380058288575,
                    "num_nodes_avg": 653.7,
                    "path_length_avg": 114.81983369409326,
                    "smoothness_avg": 0.030076296688047822,
                    "success_improvement": 0.0,
                    "time_improvement": -1672.7279985645596,
                    "length_improvement": 29.49370524867233,
                    "smoothness_improvement": 132.70018391216368,
                    "objective_score": -495.2561576000726
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a generalized and simplified RRT*-inspired planner that incrementally grows a tree by sampling points with goal biasing, steering from nearest nodes respecting a step size, and rewiring neighbors within a radius to improve path cost. It performs collision checks for nodes and edges, enforces map bounds, and dynamically updates parent-child relationships to ensure robustness and path quality. It balances exploration and exploitation efficiently to achieve a high success rate with smooth, optimized paths.",
          "planning_mechanism": "The planner samples points within the given map bounds, biased towards the goal intermittently. It extends from the nearest existing node towards the sample by a fixed step size, validating new points and edges for collisions and boundary conformity. For each new node, it selects the best parent among neighbors within a radius to minimize cost, then rewires neighbors to the new node if shorter paths are found and valid. Upon reaching the goal vicinity, it connects the path and returns the optimized route and exploration data.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D/3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start node\n        self.children = []\n        self.valid = True               # For collision and path validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        nodes = []\n        edges = []\n        root = Node(start_position)\n        nodes.append(root)\n        success = False\n\n        for _ in range(self.max_iter):\n            # Sample: goal biasing or uniform random within bounds\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction_vec = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + direction_vec[d]/dist * scale for d in range(len(bounds)))\n\n            # Enforce boundary limits\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks for node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Select best parent minimizing cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved costs\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge and update parent\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        try:\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Goal check and connect if reachable directly\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success:\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1003.15493,
          "time_improvement": -3139.0,
          "length_improvement": 24.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.2550422430038452,
                    "num_nodes_avg": 378.7,
                    "path_length_avg": 162.42761281782217,
                    "smoothness_avg": 0.016900880755929024,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -2480.42305706856,
                    "length_improvement": 18.820240286133323,
                    "smoothness_improvement": 62.396619398415474,
                    "objective_score": -790.0508859663493
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.8316524267196655,
                    "num_nodes_avg": 1176.4,
                    "path_length_avg": 224.84692860020942,
                    "smoothness_avg": 0.013090239592110938,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -5380.339327629169,
                    "length_improvement": 25.38818218030814,
                    "smoothness_improvement": 83.38167725878705,
                    "objective_score": -1708.6072534663952
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.4600382804870605,
                    "num_nodes_avg": 703.8,
                    "path_length_avg": 116.76167820148422,
                    "smoothness_avg": 0.025751628410904864,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -1556.5436611810278,
                    "length_improvement": 28.301295742453053,
                    "smoothness_improvement": 99.24024321906015,
                    "objective_score": -510.80663798972233
               }
          ],
          "success_rate": 0.8666666666666667
     }
]