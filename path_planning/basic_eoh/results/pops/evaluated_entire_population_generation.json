{
    "operator": "e1",
    "algorithm_description": "This Planner implements RRT* (Rapidly-exploring Random Tree Star), an asymptotically optimal sampling-based path planner that incrementally builds a tree towards the goal while rewiring nodes within a neighborhood radius to reduce path cost. This improves path quality, smoothness, success rate, and efficiency over naive RRT.",
    "planning_mechanism": "The planner samples random points, connects them by the lowest-cost parent within a radius if free of collisions, and rewires neighbors to shorten paths. It terminates when the goal is reached or max iterations expire, then extracts the optimal path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, search_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        def distance(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            new_pos = tuple(from_pos[d] + direction[d]*self.step_size for d in range(len(from_pos)))\n            return new_pos\n\n        def find_nearest(nodes, sample):\n            return min(nodes, key=lambda n: distance(n.position, sample))\n\n        def find_near(nodes, new_node, radius):\n            return [node for node in nodes if distance(node.position, new_node.position) <= radius]\n\n        for _ in range(self.max_iter):\n            # Sample point (goal biasing)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = find_nearest(nodes, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            # Check bounds\n            out_of_bounds = any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds)))\n            if out_of_bounds:\n                continue\n\n            # Check collision for new node pos\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            \n            # Find neighbors within radius\n            neighbors = find_near(nodes, new_node, self.search_radius)\n\n            # Choose parent with minimum cost + edge cost, check collision\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for node in neighbors:\n                edge_cost = distance(node.position, new_pos)\n                cost = node.cost + edge_cost\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_node = node\n            \n            new_node.parent = min_node\n            new_node.cost = min_cost\n            min_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors to new node if cheaper and collision free\n            for node in neighbors:\n                if node == min_node:\n                    continue\n                edge_cost = distance(new_node.position, node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        # Rewire\n                        if node.parent:\n                            node.parent.remove_child(node)\n                            edges.remove((node.parent, node))\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n            # Check if goal can be connected to new node directly (within step size)\n            if distance(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node,\n                                     cost=new_node.cost + distance(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 203.21722,
    "time_improvement": -695.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.08516473770141601,
            "num_nodes_avg": 382.4,
            "path_length_avg": 166.63575379732103,
            "smoothness_avg": 0.020723393476121822,
            "success_improvement": 0.0,
            "time_improvement": -761.6653077765501,
            "length_improvement": 16.71705187111335,
            "smoothness_improvement": 99.12625215137012,
            "objective_score": -224.6605506979855
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2160618782043457,
            "num_nodes_avg": 907.3,
            "path_length_avg": 224.7715692277033,
            "smoothness_avg": 0.01672571524002643,
            "success_improvement": 0.0,
            "time_improvement": -1323.7827850694584,
            "length_improvement": 25.41318896962671,
            "smoothness_improvement": 134.31119747551438,
            "objective_score": -391.38064173953455
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02791097164154053,
            "num_nodes_avg": 283.3,
            "path_length_avg": 115.64457953157512,
            "smoothness_avg": 0.03213987081764254,
            "success_improvement": 0.0,
            "time_improvement": -0.5041213119173451,
            "length_improvement": 28.987261620933317,
            "smoothness_improvement": 148.66604847500068,
            "objective_score": 6.3895461729864635
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm improves bidirectional RRT by tuning key parameters: reducing step size for finer node expansions, increasing maximum iterations for thorough search, and biasing sampling towards the goal to enhance convergence speed. It also integrates a goal bias sampling with a certain probability to direct growth towards the goal, and employs shortened collision checking resolution to enhance accuracy. Additionally, path smoothing is applied post planning to improve path quality and smoothness.",
    "planning_mechanism": "The planner grows two trees from start and goal simultaneously, alternately expanding each tree towards sampled points. Sampling is biased towards the goal to increase success and convergence speed. Collision checks are strictly enforced for nodes and edges before insertion. When trees connect, the path is reconstructed and then smoothed by shortcutting to reduce unnecessary detours, resulting in improved path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            # Shortcut smoothing with max trials = 50\n            if len(path) <= 2:\n                return path\n            import random\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    # shortcut possible\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 42.82017,
    "time_improvement": -50.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.008735418319702148,
            "num_nodes_avg": 121.9,
            "path_length_avg": 158.79688158358158,
            "smoothness_avg": 0.017264620570270624,
            "success_improvement": -9.999999999999998,
            "time_improvement": 11.618269272519385,
            "length_improvement": 20.634844860245124,
            "smoothness_improvement": 65.89171039649618,
            "objective_score": -42.05809169421266
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026499056816101076,
            "num_nodes_avg": 449.3,
            "path_length_avg": 240.15460051249525,
            "smoothness_avg": 0.04002816589212556,
            "success_improvement": 0.0,
            "time_improvement": -74.62081339337057,
            "length_improvement": 20.308578758222435,
            "smoothness_improvement": 460.75613797892566,
            "objective_score": -16.020747576472054
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.052319788932800294,
            "num_nodes_avg": 571.0,
            "path_length_avg": 128.29426974238464,
            "smoothness_avg": 0.06187473290802109,
            "success_improvement": -9.999999999999998,
            "time_improvement": -88.39739731919414,
            "length_improvement": 21.219589801337207,
            "smoothness_improvement": 378.7245543077222,
            "objective_score": -70.38167846395218
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined, generalized RRT* variant designed for efficient path planning in 2D or 3D spaces. It incrementally builds a tree from start to goal by sampling, steering, and rewiring nodes to iteratively improve path cost and quality. The approach balances exploration and exploitation, maintaining collision and edge-validity checks to ensure robust, feasible paths.",
    "planning_mechanism": "The planner samples points within bounds, extends the nearest existing node toward samples with a fixed step size, validates new nodes and connecting edges against obstacles, and rewires neighbors within a radius to optimize path costs. Upon reaching near the goal, it finalizes the path by connecting to the goal node. Throughout, it maintains and updates node parent-child relationships and costs to improve path quality progressively.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        nodes = []\n        edges = []\n        root = Node(start_position)\n        nodes.append(root)\n        success = False\n\n        for _ in range(self.max_iter):\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node and steer towards sample\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + direction[d]/dist * scale for d in range(len(bounds)))\n\n            # Bound check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_node\n\n            # Connect new_node\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Update parent and edges\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if goal reached\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success:\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 795.36845,
    "time_improvement": -2670.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.12200891971588135,
            "num_nodes_avg": 262.1,
            "path_length_avg": 160.31053176222167,
            "smoothness_avg": 0.020643529268731024,
            "success_improvement": 0.0,
            "time_improvement": -1134.4411102051843,
            "length_improvement": 19.878337049404657,
            "smoothness_improvement": 98.35885561869833,
            "objective_score": -335.86487137358085
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.9854721784591675,
            "num_nodes_avg": 1319.4,
            "path_length_avg": 221.71317278337733,
            "smoothness_avg": 0.015905122000469153,
            "success_improvement": 0.0,
            "time_improvement": -6393.965221981668,
            "length_improvement": 26.42806838001075,
            "smoothness_improvement": 122.81547476101757,
            "objective_score": -1912.2898755446931
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.16171705722808838,
            "num_nodes_avg": 479.6,
            "path_length_avg": 113.56485816767322,
            "smoothness_avg": 0.030858624285259855,
            "success_improvement": 0.0,
            "time_improvement": -482.3240747974543,
            "length_improvement": 30.264335822891898,
            "smoothness_improvement": 138.7530493177356,
            "objective_score": -137.95059002806923
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a hybrid informed bidirectional RRT* with adaptive sampling and path smoothing. It grows two trees from start and goal while focusing sampling in an informed ellipsoidal region to bias exploration towards the optimal path region. It adaptively adjusts step sizes for efficient expansion and performs local shortcut smoothing on the found path to improve path quality and smoothness.",
    "planning_mechanism": "The planner alternately expands two trees towards samples drawn mostly within an ellipsoidal informed set computed from the current best solution cost. Each extension attempts rewiring for path cost improvement. Once the trees connect, the path is extracted and locally smoothed via shortcutting to reduce unnecessary waypoints and ensure collision-free shortcuts, resulting in better path quality and faster convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0, smooth_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        def informed_sample(c_best):\n            # If no solution yet, sample whole space uniformly\n            if c_best == float('inf'):\n                while True:\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n\n            # Informed sampling in ellipsoid around start & goal\n            c_min = math.dist(start_position, goal_position)\n            if c_best < c_min:\n                c_min = c_best  # numerical safeguard\n\n            # Ellipsoid center\n            center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n            # Unit vector from start to goal\n            direction = tuple((g - s) / c_min for s, g in zip(start_position, goal_position))\n\n            # Create orthonormal basis via Gram-Schmidt\n            def ortho_basis(vec):\n                basis = [vec]\n                for _ in range(dim - 1):\n                    v = [random.gauss(0,1) for __ in range(dim)]\n                    # Subtract projections\n                    for b in basis:\n                        proj = sum(v[d]*b[d] for d in range(dim))\n                        v = [v[d] - proj*b[d] for d in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in v))\n                    if norm > 1e-6:\n                        basis.append(tuple(x/norm for x in v))\n                return basis\n\n            basis = ortho_basis(direction)\n            # Radii of the ellipsoid\n            r1 = c_best / 2.0\n            r_others = math.sqrt(c_best*c_best - c_min*c_min)/2.0 if c_best > c_min else 0.0\n            radii = [r1] + [r_others]*(dim-1)\n\n            while True:\n                # sample uniformly in unit n-ball\n                while True:\n                    sample = [random.gauss(0,1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in sample))\n                    if norm <= 1.0 and norm > 1e-6:\n                        sample = [x / norm for x in sample]\n                        break\n                # scale with radii and random radius^(1/dim)\n                u = random.uniform(0,1) ** (1.0/dim)\n                sample = [radii[i]*u*sample[i] for i in range(dim)]\n\n                # rotate and translate to ellipsoid space\n                new_point = [center[d] for d in range(dim)]\n                for i in range(dim):\n                    for d in range(dim):\n                        new_point[d] += basis[i][d]*sample[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n                if not self._is_in_obstacle(new_point, obstacles, is_3d):\n                    return new_point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if self._distance(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos, max_step):\n            dist = self._distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_a)) + path_b\n\n        def reconstruct_path(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def local_shortcut(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                dist = self._distance(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    # Connect new edge\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            c_best = best_cost\n            sample = informed_sample(c_best)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree_a, new_pos, self.radius)\n                min_cost = nearest_node.cost + self._distance(nearest_node.position, new_pos)\n                min_parent = nearest_node\n\n                for near_node in near_nodes:\n                    cost = near_node.cost + self._distance(near_node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near_node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nearby nodes for optimality\n                rewire(tree_a, new_node)\n\n                # Try connecting to other tree\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = self._distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    candidate_cost = new_node.cost + dist_connect + connect_node.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_path = extract_path(new_node, connect_node)\n\n            # Early break if solution found with good cost\n            if success_state and iter_count > self.max_iter // 10:\n                break\n\n        if success_state and best_path:\n            # Path smoothing via local shortcutting\n            path = best_path\n            for _ in range(self.smooth_iter):\n                path = local_shortcut(path)\n            extracted_path = path\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree + nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 293.42562,
    "time_improvement": -1007.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.22914626598358154,
            "num_nodes_avg": 1232.2,
            "path_length_avg": 151.05556807923077,
            "smoothness_avg": 0.04946771756942938,
            "success_improvement": 0.0,
            "time_improvement": -2218.4171422782074,
            "length_improvement": 24.503878944109687,
            "smoothness_improvement": 375.3237549358324,
            "objective_score": -658.747748119961
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09055137634277344,
            "num_nodes_avg": 1009.0,
            "path_length_avg": 225.45937519639352,
            "smoothness_avg": 0.08516524523696775,
            "success_improvement": 0.0,
            "time_improvement": -496.7063318742989,
            "length_improvement": 25.184951679703754,
            "smoothness_improvement": 1093.0832438791554,
            "objective_score": -138.50949300695316
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11305840015411377,
            "num_nodes_avg": 1205.2,
            "path_length_avg": 115.90098836757991,
            "smoothness_avg": 0.09945529687228734,
            "success_improvement": 0.0,
            "time_improvement": -307.1099820655753,
            "length_improvement": 28.82981114929822,
            "smoothness_improvement": 669.4852233060038,
            "objective_score": -83.01960627328293
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm integrates the exploration efficiency of a basic RRT with the path optimality improvements of RRT*\u2014including goal biasing, neighbor rewiring, and adaptive steering\u2014combined with a dynamic neighbor radius scaling based on node density. It performs rigorous collision checking for nodes and edges, ensures nodes stay within bounds, and incrementally improves path cost while promoting path smoothness and robustness. The planner balances exploration and exploitation via goal sampling and rewiring neighbors to progressively shorten path length and increase success rate.",
    "planning_mechanism": "The planner samples points with goal bias, steers towards them from the nearest nodes with fixed step size, rejects samples in collision or out of bounds, and adds valid nodes. It selects the best parent among neighbors within a dynamically scaled radius to minimize cost, adds edges only if collision-free, and rewires neighbors to improve paths. Once within step size of goal, it attempts final connection. The path is traced back from goal node if successful.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # factor to scale neighbor search radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_idx in range(1, self.max_iter + 1):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Dynamic neighbor radius based on iteration and nodes count\n            n_nodes = len(nodes)\n            gamma = self.neighbor_factor\n            dim = len(bounds)\n            # Radius scaling as per RRT* theoretical bound:\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)))\n\n            # Find neighbors within radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            # Choose best parent minimizing cost + edge validity\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_node\n\n            # Connect new_node to best parent\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to potentially improve their cost through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge and update parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new node can connect directly to goal\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path if success\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 177.31653,
    "time_improvement": -604.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05419919490814209,
            "num_nodes_avg": 284.2,
            "path_length_avg": 165.482775399497,
            "smoothness_avg": 0.016891900008800545,
            "success_improvement": 0.0,
            "time_improvement": -448.3674020754835,
            "length_improvement": 17.293299392497616,
            "smoothness_improvement": 62.310325494896546,
            "objective_score": -130.74000911667105
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.15224525928497315,
            "num_nodes_avg": 933.7,
            "path_length_avg": 259.50582756375985,
            "smoothness_avg": 0.007024509778030356,
            "success_improvement": 0.0,
            "time_improvement": -903.2504626909287,
            "length_improvement": 13.887186941464913,
            "smoothness_improvement": -1.5933684061602176,
            "objective_score": -268.2056682610164
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15545496940612794,
            "num_nodes_avg": 883.6,
            "path_length_avg": 124.91386658373274,
            "smoothness_avg": 0.019892198189482964,
            "success_improvement": 0.0,
            "time_improvement": -459.77503414752243,
            "length_improvement": 23.295360979661872,
            "smoothness_improvement": 53.9058556683744,
            "objective_score": -133.00390876998247
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an optimized and refined RRT* variant with tuned parameters for improved efficiency, path quality, and success rate in 2D/3D environments. It employs adaptive neighbor radius scaling based on iteration count, goal biasing, and rewiring to achieve shorter, smoother paths while respecting collision and boundary constraints.",
    "planning_mechanism": "Planning mechanism: The planner incrementally samples points in the bounded space with goal biasing, finds the nearest node, and steers towards the sample using a fixed step size. It validates node and edge collisions, connects the new node choosing the best parent among neighbors within a dynamically scaled radius, and rewires neighbors to reduce path costs. The process repeats until the goal is reached or iteration limit is exceeded, then extracts and returns the optimized path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.5, goal_sample_rate: float = 0.15, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Dynamic neighbor radius shrinks as iterations increase (for faster convergence)\n            neighbor_radius = self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter)**0.5)\n            neighbor_radius = max(neighbor_radius, self.step_size * 1.5)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node search\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + direction[d] / dist * scale for d in range(len(bounds)))\n\n            # Bounds check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find nearby nodes for potential rewiring and best parent selection\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= neighbor_radius]\n\n            # Choose best parent from near nodes\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to potentially reduce cost\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        # Update parent and add new edge\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check goal reaching with safe connection\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path backward from goal_node if success\n        if success_state:\n            node = nodes[-1]\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 495.55441,
    "time_improvement": -1613.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.14350197315216065,
            "num_nodes_avg": 227.2,
            "path_length_avg": 164.12929598622088,
            "smoothness_avg": 0.020655984144223045,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1351.8998731166507,
            "length_improvement": 17.969755394289972,
            "smoothness_improvement": 98.47853161098192,
            "objective_score": -451.48361819808235
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.45711603164672854,
            "num_nodes_avg": 1051.9,
            "path_length_avg": 235.6620395304657,
            "smoothness_avg": 0.009652673888803365,
            "success_improvement": 0.0,
            "time_improvement": -2912.2571461789116,
            "length_improvement": 21.799362482162223,
            "smoothness_improvement": 35.22468517899821,
            "objective_score": -869.141147931346
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.18728911876678467,
            "num_nodes_avg": 439.6,
            "path_length_avg": 117.15879937338202,
            "smoothness_avg": 0.030292819476407735,
            "success_improvement": 0.0,
            "time_improvement": -574.4060563238808,
            "length_improvement": 28.057439419925913,
            "smoothness_improvement": 134.3754198361579,
            "objective_score": -166.03845191399824
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a generalized and simplified RRT*-inspired planner that incrementally grows a tree by sampling points with goal biasing, steering from nearest nodes respecting a step size, and rewiring neighbors within a radius to improve path cost. It performs collision checks for nodes and edges, enforces map bounds, and dynamically updates parent-child relationships to ensure robustness and path quality. It balances exploration and exploitation efficiently to achieve a high success rate with smooth, optimized paths.",
    "planning_mechanism": "The planner samples points within the given map bounds, biased towards the goal intermittently. It extends from the nearest existing node towards the sample by a fixed step size, validating new points and edges for collisions and boundary conformity. For each new node, it selects the best parent among neighbors within a radius to minimize cost, then rewires neighbors to the new node if shorter paths are found and valid. Upon reaching the goal vicinity, it connects the path and returns the optimized route and exploration data.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D/3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start node\n        self.children = []\n        self.valid = True               # For collision and path validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random\n        import math\n\n        nodes = []\n        edges = []\n        root = Node(start_position)\n        nodes.append(root)\n        success = False\n\n        for _ in range(self.max_iter):\n            # Sample: goal biasing or uniform random within bounds\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction_vec = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + direction_vec[d]/dist * scale for d in range(len(bounds)))\n\n            # Enforce boundary limits\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks for node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Select best parent minimizing cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved costs\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge and update parent\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        try:\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Goal check and connect if reachable directly\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success:\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1003.15493,
    "time_improvement": -3139.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.2550422430038452,
            "num_nodes_avg": 378.7,
            "path_length_avg": 162.42761281782217,
            "smoothness_avg": 0.016900880755929024,
            "success_improvement": -9.999999999999998,
            "time_improvement": -2480.42305706856,
            "length_improvement": 18.820240286133323,
            "smoothness_improvement": 62.396619398415474,
            "objective_score": -790.0508859663493
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.8316524267196655,
            "num_nodes_avg": 1176.4,
            "path_length_avg": 224.84692860020942,
            "smoothness_avg": 0.013090239592110938,
            "success_improvement": -19.999999999999996,
            "time_improvement": -5380.339327629169,
            "length_improvement": 25.38818218030814,
            "smoothness_improvement": 83.38167725878705,
            "objective_score": -1708.6072534663952
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.4600382804870605,
            "num_nodes_avg": 703.8,
            "path_length_avg": 116.76167820148422,
            "smoothness_avg": 0.025751628410904864,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1556.5436611810278,
            "length_improvement": 28.301295742453053,
            "smoothness_improvement": 99.24024321906015,
            "objective_score": -510.80663798972233
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is an RRT* (Rapidly-exploring Random Tree Star) variant that incrementally builds a tree rooted at the start node with dynamic rewiring to optimize the path quality and ensure asymptotic optimality. It improves planning efficiency and path quality by connecting new samples not only to the nearest node but also to nearby nodes within a specified radius, rewiring the tree to shorten paths when possible. The algorithm incorporates goal biasing and a straightforward smoothing step at completion.",
    "planning_mechanism": "The planner samples points within bounds, biased occasionally toward the goal. For each sample, it steers from the nearest node, checks collisions, and inserts the new node. Then it searches neighbors within a radius to connect and possibly rewire for minimum path cost while checking collisions. The process iterates until the goal is connected or max iterations reached. Finally, the code extracts and smooths the path for better quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D point\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius   # Radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        success_state = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            # Sample with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = self._nearest(nodes, sample)\n            new_pos = self._steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + self._distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n\n            # Find neighbors within radius for potential rewiring\n            neighbors = self._near(nodes, new_node.position, self.neighbor_radius)\n\n            # Choose parent with minimum cost\n            min_cost = new_node.cost\n            min_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                if not self._is_edge_in_obstacle(neighbor.position, new_node.position, obstacles, is_3d):\n                    cost_candidate = neighbor.cost + self._distance(neighbor.position, new_node.position)\n                    if cost_candidate < min_cost:\n                        min_cost = cost_candidate\n                        min_parent = neighbor\n\n            # Set minimum cost parent\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if better path through new_node\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    cost_through_new = new_node.cost + self._distance(new_node.position, neighbor.position)\n                    if cost_through_new < neighbor.cost:\n                        # Rewire: change parent\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n                        # Update descendants cost recursively\n                        self._update_descendants_cost(neighbor)\n\n            # Check if goal reachable\n            if self._distance(new_node.position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + self._distance(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        extracted_path = []\n        if success_state and goal_node:\n            extracted_path = self._extract_path(goal_node)\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _nearest(self, nodes: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(nodes, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, nodes: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in nodes if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step_size: float) -> Tuple[float, ...]:\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def _update_descendants_cost(self, node: Node):\n        # Recursively update cost for all descendants after rewiring\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._distance(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-6:\n                self._update_descendants_cost(child)\n\n    def _extract_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        current = node\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path) -1\n            while j > i +1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1069.68665,
    "time_improvement": -3594.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.42514069080352784,
            "num_nodes_avg": 320.2,
            "path_length_avg": 156.21855419407137,
            "smoothness_avg": 0.04913305203031206,
            "success_improvement": 0.0,
            "time_improvement": -4201.416220805975,
            "length_improvement": 21.923468107936873,
            "smoothness_improvement": 372.10803186396026,
            "objective_score": -1254.1796324608854
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.8141914367675781,
            "num_nodes_avg": 902.8,
            "path_length_avg": 220.6355595803509,
            "smoothness_avg": 0.08099681785822022,
            "success_improvement": 0.0,
            "time_improvement": -5265.276656182148,
            "length_improvement": 26.785656898052117,
            "smoothness_improvement": 1034.6875820681325,
            "objective_score": -1569.0524275646933
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3931962728500366,
            "num_nodes_avg": 546.8,
            "path_length_avg": 115.66952479077864,
            "smoothness_avg": 0.09393220582452902,
            "success_improvement": 0.0,
            "time_improvement": -1315.8534648467248,
            "length_improvement": 28.97194372905466,
            "smoothness_improvement": 626.7530905601618,
            "objective_score": -385.8278852554057
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced RRT* variant incorporating adaptive neighbor radius scaling, goal biasing, and efficient rewiring. It refines path quality and planning speed by dynamically adjusting connection radius and prioritizing lower-cost connections while ensuring collision-free nodes and edges. Additionally, batch rewiring based on updated costs promotes better path smoothness and shorter lengths, improving success rates and robustness in 2D/3D bounded environments.",
    "planning_mechanism": "The planner incrementally samples the space with goal biasing, finds nearest nodes, and extends toward samples constrained by step size and bounds. It dynamically scales the neighbor search radius based on progress to balance exploration and exploitation, connects new nodes choosing minimal cost parents from near nodes while performing collision checks on nodes and edges. Rewiring of neighbors is performed to reduce costs, ensuring path smoothness and optimality. The process continues until the goal is reached or iterations are exhausted, then extracts and returns the refined path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4500, step_size: float = 4.0, goal_sample_rate: float = 0.15, base_neighbor_radius: float = 18.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Adaptive neighbor radius scales down as iterations increase (explore then exploit)\n            neighbor_radius = self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.6)\n            neighbor_radius = max(neighbor_radius, self.step_size * 1.7)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node search\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision check for node\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Collision check for edge\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbor nodes within adaptive radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= neighbor_radius]\n\n            # Choose best parent to minimize cost + collision checks\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve cost if possible (only if edge is collision-free)\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge safely\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Update parent and add new edge\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Attempt direct connection to goal if close enough and collision-free\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path from goal_node backwards if success\n        if success_state:\n            node = nodes[-1]\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 746.03681,
    "time_improvement": -2448.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.31168811321258544,
            "num_nodes_avg": 407.9,
            "path_length_avg": 163.4753623556092,
            "smoothness_avg": 0.017225723029483792,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3053.5450146422418,
            "length_improvement": 18.296585137588686,
            "smoothness_improvement": 65.51795300373561,
            "objective_score": -962.076597600136
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.5240156412124634,
            "num_nodes_avg": 1156.6,
            "path_length_avg": 231.54072949104912,
            "smoothness_avg": 0.009372344872334874,
            "success_improvement": 0.0,
            "time_improvement": -3353.105449540765,
            "length_improvement": 23.16695258336466,
            "smoothness_improvement": 31.297545048172836,
            "objective_score": -1001.1417566203158
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2879826784133911,
            "num_nodes_avg": 609.7,
            "path_length_avg": 117.03725506875833,
            "smoothness_avg": 0.027892430226335037,
            "success_improvement": 0.0,
            "time_improvement": -936.9917041480978,
            "length_improvement": 28.132074944916962,
            "smoothness_improvement": 115.80361806992944,
            "objective_score": -274.8920781650963
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner with optimized parameters to improve efficiency, path quality, and success rate. It features reduced step size for finer expansions, increased maximum iterations for deeper search, and a goal bias sampling probability to accelerate convergence. Collision checking is precise with a refined resolution, and post-planning path smoothing via shortcutting reduces unnecessary detours and improves smoothness.",
    "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions, alternately expanding each towards sampled points biased towards the goal. Each new node and edge is strictly checked for collision-free feasibility. When the trees connect, the planner reconstructs the path, smooths it by iteratively shortcutting, and returns the optimized trajectory along with explored graph data.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.6782,
    "time_improvement": -33.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010827350616455077,
            "num_nodes_avg": 119.0,
            "path_length_avg": 163.9683475002103,
            "smoothness_avg": 0.014173695614508616,
            "success_improvement": 0.0,
            "time_improvement": -9.547127756576938,
            "length_improvement": 18.050195900642194,
            "smoothness_improvement": 36.19173375747664,
            "objective_score": 0.9268595219427409
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03178107738494873,
            "num_nodes_avg": 498.6,
            "path_length_avg": 249.62854531281232,
            "smoothness_avg": 0.0401662199932736,
            "success_improvement": 0.0,
            "time_improvement": -109.42774008867326,
            "length_improvement": 17.164803355659895,
            "smoothness_improvement": 462.6901432691145,
            "objective_score": -27.081910639124423
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02228260040283203,
            "num_nodes_avg": 378.2,
            "path_length_avg": 125.71203140928696,
            "smoothness_avg": 0.05507350730124254,
            "success_improvement": 0.0,
            "time_improvement": 19.762980565745675,
            "length_improvement": 22.805239694513528,
            "smoothness_improvement": 326.10349972973546,
            "objective_score": 12.120459607275086
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This simplified hybrid RRT* planner integrates goal bias sampling, dynamic neighbor searching with rewiring to incrementally improve path cost and quality. It ensures collision-free node and edge expansions within map bounds, balancing exploration and exploitation to efficiently find smooth, robust paths with reduced planning time.",
    "planning_mechanism": "The planner grows a tree from the start position by iteratively sampling states with goal bias. For each sampled point, it steers a fixed step size towards the sample from the nearest existing node. New nodes are added only if collision-free and within bounds. For each new node, neighbors within a dynamically scaled radius are found to select the best parent minimizing path cost. The planner then rewires neighbors via the new node to improve costs. When a node reaches near the goal, a final connection is attempted. The solution path is extracted by backtracking from the goal node once found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Dynamic neighbor radius based on node count & dimension\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            gamma = self.neighbor_factor\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim)))\n\n            # Find neighbor nodes within radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            # Choose parent minimizing cost + collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                c = near_node.cost + math.dist(near_node.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = near_node\n\n            # Connect new node to best parent\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if beneficial and collision-free\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge & update parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new node can connect directly to goal\n            dist_goal = math.dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 132.8663,
    "time_improvement": -452.0,
    "length_improvement": 14.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04421133995056152,
            "num_nodes_avg": 277.1,
            "path_length_avg": 175.4057816503535,
            "smoothness_avg": 0.014822768672657066,
            "success_improvement": 0.0,
            "time_improvement": -347.31398080829035,
            "length_improvement": 12.333876243262361,
            "smoothness_improvement": 42.42852531337951,
            "objective_score": -101.51527636726773
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.14756877422332765,
            "num_nodes_avg": 975.3,
            "path_length_avg": 271.0520755830754,
            "smoothness_avg": 0.006851663576418842,
            "success_improvement": 0.0,
            "time_improvement": -872.4338328405295,
            "length_improvement": 10.055751221700547,
            "smoothness_improvement": -4.014777589414016,
            "objective_score": -259.7390734957658
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06594605445861816,
            "num_nodes_avg": 520.3,
            "path_length_avg": 133.0968329704542,
            "smoothness_avg": 0.019142422483870408,
            "success_improvement": 0.0,
            "time_improvement": -137.46397447113193,
            "length_improvement": 18.270526668026136,
            "smoothness_improvement": 48.104844114373854,
            "objective_score": -37.34456278716248
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements an Enhanced Anytime RRT* planner incorporating adaptive sampling, informed sampling ellipses, and heuristic path smoothing. It balances exploration and exploitation by biasing samples within an ellipse defined by the current best solution cost, dynamically adjusts neighbor searching radius according to node density, and refines the final path using shortcut smoothing to improve path quality and smoothness while maintaining collision-free guarantees. The approach improves planning efficiency, success rate, and final path optimality by iteratively refining paths and focusing search toward promising regions.",
    "planning_mechanism": "The planner starts with the initial node and iteratively samples points biased by the goal and informed sampling ellipse around the best path found so far. It extends the nearest nodes toward sampled points with collision checking, selects optimal parent nodes by evaluating nearby neighbors within a radius determined adaptively, and performs rewiring steps to reduce path costs in the tree. When a path to the goal is found, it extracts the path and applies shortcut smoothing by attempting to connect non-consecutive nodes directly if collision-free, thereby shortening and smoothing the path before returning the result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 50.0, smoothing_iters: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def sample_point():\n            # If a path exists, sample from informed ellipse, else uniform + goal bias\n            if best_goal_node is None or random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < self.goal_sample_rate else tuple(\n                    random.uniform(0, bounds[d]) for d in range(dim)\n                )\n            else:\n                # Informed sampling ellipse around start and goal\n                c_min = math.dist(start_position, goal_position)\n                c_best = best_cost\n                if c_best < float('inf'):\n                    # Compute ellipse parameters (foci at start and goal)\n                    center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n                    diff = tuple((goal_position[d] - start_position[d]) for d in range(dim))\n                    dist_foci = math.dist(start_position, goal_position)\n\n                    # Generate random sample in unit ball\n                    def random_unit_ball(dim_):\n                        import random\n                        import math\n                        while True:\n                            point = [random.uniform(-1, 1) for _ in range(dim_)]\n                            norm = math.sqrt(sum(x*x for x in point))\n                            if 0 < norm <= 1:\n                                return tuple(x / norm * (random.uniform(0,1) ** (1/dim_)) for x in point)\n                    # Transform random point to ellipse:\n                    a = c_best / 2  # major axis radius\n                    b = math.sqrt(a*a - (dist_foci/2)**2) if a > dist_foci/2 else 0.0  # minor axis radius, clamp zero if numerical\n                    if b == 0.0:\n                        # Degenerate ellipse: line segment\n                        sample = tuple(start_position[d] + diff[d] * random.uniform(0,1) for d in range(dim))\n                        # Make sure sample inside bounds\n                        sample_clamped = tuple(\n                            max(0.0, min(bounds[d], sample[d])) for d in range(dim)\n                        )\n                        return sample_clamped\n\n                    # Create orthonormal basis: first axis along diff vector\n                    unit_diff = tuple(diff[d]/dist_foci for d in range(dim))\n                    if dim == 2:\n                        ortho = (-unit_diff[1], unit_diff[0])\n                        # Sample in ellipse coordinate system\n                        r = random_unit_ball(dim)\n                        # x = r[0]*a, y = r[1]*b\n                        sample_ellipse = (\n                            center[0] + unit_diff[0]*r[0]*a + ortho[0]*r[1]*b,\n                            center[1] + unit_diff[1]*r[0]*a + ortho[1]*r[1]*b,\n                        )\n                        sample_clamped = tuple(max(0.0, min(bounds[d], sample_ellipse[d])) for d in range(dim))\n                        return sample_clamped\n                    else:\n                        # For 3D or higher dims, build orthonormal basis using Gram-Schmidt\n                        import numpy as np\n                        diff_vec = np.array(diff)\n                        basis = [diff_vec / dist_foci]\n                        # Generate dim-1 orthonormal vectors orthogonal to diff_vec\n                        def gram_schmidt(vecs):\n                            ortho_basis = []\n                            for v in vecs:\n                                w = v.copy()\n                                for b_ in ortho_basis:\n                                    w -= np.dot(b_, v) * b_\n                                norm = np.linalg.norm(w)\n                                if norm > 1e-10:\n                                    ortho_basis.append(w / norm)\n                            return ortho_basis\n                        random_vecs = [np.random.randn(dim) for _ in range(dim - 1)]\n                        ortho_basis = gram_schmidt(random_vecs)\n                        ortho_basis = [v / np.linalg.norm(v) for v in ortho_basis]\n                        # Sample in unit ball\n                        r = random_unit_ball(dim)\n                        # Construct point in ellipse\n                        sample_pt = np.array(center)\n                        sample_pt += basis[0] * r[0] * a\n                        for i in range(1, dim):\n                            sample_pt += ortho_basis[i-1] * r[i] * b\n                        sample_clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                        return sample_clamped\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist == 0:\n                return None\n            scale = min(self.step_size, dist)\n            direction = tuple((to_pos[d] - from_pos[d])/dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + direction[d]*scale for d in range(dim))\n            return new_pos\n\n        def get_neighbors(node_list, position, radius):\n            return [node for node in node_list if math.dist(node.position, position) <= radius]\n\n        for iter_count in range(self.max_iter):\n            sample = sample_point()\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if new_pos is None:\n                continue\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighbor radius based on nodes and dimension\n            n_nodes = len(nodes)\n            gamma = self.neighbor_factor\n            radius = min(self.step_size * 5,\n                         gamma * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n\n            near_nodes = get_neighbors(nodes, new_pos, radius)\n\n            # Choose best parent for minimum cost and collision free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                edge_clear = not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d)\n                if not edge_clear:\n                    continue\n                temp_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if temp_cost < min_cost:\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            # Create and connect new node\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if better path and no collision\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                edge_clear = not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                if not edge_clear:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    # Remove old edge\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if new_node can connect to goal\n            dist_goal = math.dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    if goal_node.cost < best_cost:\n                        best_goal_node = goal_node\n                        best_cost = goal_node.cost\n\n        if success_state:\n            # Extract path from best goal_node\n            path_nodes = []\n            node = best_goal_node\n            while node:\n                path_nodes.append(node)\n                node = node.parent\n            extracted_path = [n.position for n in reversed(path_nodes)]\n\n            # Path shortcut smoothing\n            extracted_path = self._shortcut_smoothing(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_smoothing(self, path: \"List[Tuple[float, ...]]\", obstacles, is_3d, bounds):\n        import random\n\n        if len(path) < 3:\n            return path\n\n        def collision_free(p1, p2):\n            if any(p1[d] < 0 or p1[d] > bounds[d] for d in range(len(bounds))) or \\\n               any(p2[d] < 0 or p2[d] > bounds[d] for d in range(len(bounds))):\n                return False\n            if self._is_in_obstacle(p2, obstacles, is_3d) or self._is_in_obstacle(p1, obstacles, is_3d):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        max_trials = self.smoothing_iters\n        path_len = len(path)\n\n        for _ in range(max_trials):\n            if path_len <= 2:\n                break\n            i = random.randint(0, path_len - 2)\n            j = random.randint(i + 1, path_len - 1)\n            if j == i + 1:\n                continue\n            if collision_free(path[i], path[j]):\n                # Remove intermediate points between i and j\n                path = path[:i + 1] + path[j:]\n                path_len = len(path)\n\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3718.48857,
    "time_improvement": -12417.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.907587480545044,
            "num_nodes_avg": 3261.4,
            "path_length_avg": 156.77315322512194,
            "smoothness_avg": 0.04103145306538532,
            "success_improvement": 0.0,
            "time_improvement": -19200.26438051496,
            "length_improvement": 21.64628484274461,
            "smoothness_improvement": 294.2616579012156,
            "objective_score": -5754.278748896433
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.4912437677383423,
            "num_nodes_avg": 3281.6,
            "path_length_avg": 233.23340700515126,
            "smoothness_avg": 0.043622455704450565,
            "success_improvement": 0.0,
            "time_improvement": -9726.847857167546,
            "length_improvement": 22.60526491835663,
            "smoothness_improvement": 511.1086842176947,
            "objective_score": -2910.977760745504
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.3398027181625367,
            "num_nodes_avg": 4578.6,
            "path_length_avg": 114.88517344284662,
            "smoothness_avg": 0.05186163248556062,
            "success_improvement": 0.0,
            "time_improvement": -8325.353988112971,
            "length_improvement": 29.453582706805083,
            "smoothness_improvement": 301.25323747623656,
            "objective_score": -2490.2092137051486
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the informed bidirectional RRT* approach with dynamic neighbor rewiring and adaptive step sizing from single-tree RRT* variants. It employs informed ellipsoidal sampling biased by the current best solution to focus search, while growing two trees (from start and goal) that attempt to connect for faster convergence. Dynamic neighborhood rewiring improves path optimality, and local shortcut smoothing enhances final path smoothness. Efficiency is improved by adaptive radius scaling and pruning unreachable branches. The planner maintains strict collision checks on nodes and edges and respects map bounds.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling mostly within an informed ellipsoid based on the current best solution cost to reduce search space and focus on promising regions. Each extension chooses parents among neighbors minimizing costs, rewires neighbors for improved paths, and tries to connect both trees to form a complete path. After connection, a local shortcut smoothing procedure refines the path to reduce unnecessary waypoints while ensuring collision-free shortcuts. The process adapts step sizes and neighbor search radius dynamically for balance between exploration and efficient convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root of the tree\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 neighbor_factor: float = 30.0, smooth_iter: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor  # Used to scale rewiring radius dynamically\n        self.smooth_iter = smooth_iter           # Number of local shortcut smoothing iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []    # Stores nodes that are expansions beyond roots\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = _distance(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def _steer(from_p, to_p, max_step):\n            dist = _distance(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: _distance(n.position, point))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_a)) + path_b\n\n        def _local_shortcut(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not _is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def _informed_sample(c_best):\n            # Sample uniformly in map if no solution found yet\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle(pt):\n                        return pt\n\n            c_min = _distance(start_pos, goal_pos)\n            if c_best < c_min:\n                c_min = c_best  # numerical safeguard\n\n            center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n            direction_vec = tuple((g - s) / c_min for s, g in zip(start_pos, goal_pos))\n\n            # Gram-Schmidt orthonormal basis\n            basis = [direction_vec]\n            for _ in range(dim - 1):\n                vec = [random.gauss(0, 1) for __ in range(dim)]\n                for b in basis:\n                    proj = sum(vec[d] * b[d] for d in range(dim))\n                    vec = [vec[d] - proj * b[d] for d in range(dim)]\n                norm = math.sqrt(sum(x * x for x in vec))\n                if norm > 1e-9:\n                    basis.append(tuple(x / norm for x in vec))\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n            radii = [r1] + [r_other] * (dim - 1)\n\n            while True:\n                while True:\n                    sample = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in sample))\n                    if 1e-9 < norm <= 1.0:\n                        sample = [x / norm for x in sample]\n                        break\n                u = random.uniform(0, 1) ** (1.0 / dim)\n                sample_scaled = [radii[i] * u * sample[i] for i in range(dim)]\n\n                new_point = list(center)\n                for i in range(dim):\n                    for d in range(dim):\n                        new_point[d] += basis[i][d] * sample_scaled[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n\n                if not _is_in_obstacle(new_point):\n                    return new_point\n\n        def _rewire(tree, new_node, radius):\n            near_nodes = _near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not _is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old connection\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, new_cost)\n                        edges.append((new_node, near_node))\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            c_best = best_cost\n            sample = _informed_sample(c_best)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = _nearest(tree_a, sample)\n                new_pos = _steer(nearest_node.position, sample, self.step_size)\n\n                # Check bounds\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                    continue\n                if _is_in_obstacle(new_pos):\n                    continue\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                # Create new node and find best parent among neighbors\n                new_node = Node(new_pos)\n                n_nodes = len(tree_a)\n                # Adaptive radius for neighbors used in rewiring:\n                radius = min(self.step_size * 3,\n                             self.neighbor_factor * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)))\n\n                near_nodes = _near(tree_a, new_pos, radius)\n                min_cost = nearest_node.cost + _distance(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if _is_edge_in_obstacle(near_node.position, new_pos):\n                        continue\n                    cost = near_node.cost + _distance(near_node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = near_node\n\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for cost improvement\n                _rewire(tree_a, new_node, radius)\n\n                # Attempt to connect new_node to other tree\n                nearest_other = _nearest(tree_b, new_node.position)\n                dist_connect = _distance(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and not _is_edge_in_obstacle(new_node.position, nearest_other.position):\n                    candidate_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_path = _extract_path(new_node, nearest_other)\n\n            # Early stop if sufficiently good path found (after minimum iterations)\n            if success_state and iter_count > self.max_iter // 10:\n                break\n\n        # If a path was found, perform local shortcut smoothing to improve smoothness & length\n        if success_state and best_path:\n            path = best_path\n            for _ in range(self.smooth_iter):\n                path = _local_shortcut(path)\n            extracted_path = path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree + nodes,\n            edges=edges\n        )",
    "objective": 272.55385,
    "time_improvement": -939.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.21923460960388183,
            "num_nodes_avg": 1175.8,
            "path_length_avg": 157.15636338715737,
            "smoothness_avg": 0.04699571723321052,
            "success_improvement": 0.0,
            "time_improvement": -2118.1346700309246,
            "length_improvement": 21.45476008698255,
            "smoothness_improvement": 351.5708805412327,
            "objective_score": -629.3915945891747
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08462791442871094,
            "num_nodes_avg": 1002.0,
            "path_length_avg": 234.63384451840466,
            "smoothness_avg": 0.1070944461728982,
            "success_improvement": 0.0,
            "time_improvement": -457.67249966221203,
            "length_improvement": 22.14055237254947,
            "smoothness_improvement": 1400.2902755212244,
            "objective_score": -125.87218804654759
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09444963932037354,
            "num_nodes_avg": 1253.2,
            "path_length_avg": 121.54117811921726,
            "smoothness_avg": 0.13078905994266155,
            "success_improvement": 0.0,
            "time_improvement": -240.10202618649225,
            "length_improvement": 25.366394871045777,
            "smoothness_improvement": 911.9144194521435,
            "objective_score": -62.3977567844778
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT with adaptive sampling and dynamic step size adjustment for improved planning efficiency, success rate, and path quality. It introduces informed sampling biased towards the current best path, dynamically adjusts step size based on local obstacle density, and applies aggressive path smoothing via shortcutting and spline interpolation for smooth and short paths. Robust collision checking and edge validation ensure safe expansions and better convergence.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansions. Sampling is dynamically biased towards the goal and regions near the current best path for efficient exploration. Each extension step adapts the step size based on obstacle proximity. When the two trees connect, the path is reconstructed, extensively smoothed with shortcutting and cubic spline interpolation to improve smoothness and reduce length, then returned as the final path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float=3.0, goal_sample_rate: float=0.15, collision_resolution: float=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n        best_connect = None\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free() -> Tuple[float, ...]:\n            # With probability goal_sample_rate, sample goal directly for bias\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            # With small probability sample near current best path if exists for informed sampling\n            if best_connect is not None and random.random() < 0.2:\n                path = best_connect.path_from_root()\n                if len(path) > 2:\n                    idx = random.randint(0, len(path) - 2)\n                    p1, p2 = path[idx], path[idx+1]\n                    alpha = random.uniform(0,1)\n                    sample = tuple(p1[d] + alpha*(p2[d] - p1[d]) for d in range(len(p1)))\n                    if _is_within_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Uniform random sample in free space\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            # Return node in tree nearest to point\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _dynamic_step_size(pos: Tuple[float, ...]) -> float:\n            # Estimate obstacle density nearby and reduce step size in cluttered areas\n            check_range = self.step_size * 2\n            cnt = 0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    cx, cy, cz = x + w/2, y + h/2, z + d/2\n                    dist_to_obs = math.dist(pos, (cx, cy, cz))\n                    if dist_to_obs < check_range + max(w,h,d)/2:\n                        cnt += 1\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    cx, cy = x + w_/2, y + h_/2\n                    dist_to_obs = math.dist(pos, (cx, cy))\n                    if dist_to_obs < check_range + max(w_,h_)/2:\n                        cnt += 1\n            if cnt == 0:\n                return self.step_size\n            else:\n                return max(self.step_size / (1 + cnt), self.step_size * 0.2)\n\n        def _extend_tree(tree: List[Node], point: Tuple[float, ...]):\n            nearest_node = _nearest(tree, point)\n            dynamic_step = _dynamic_step_size(nearest_node.position)\n            new_pos = _steer(nearest_node.position, point, dynamic_step)\n\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree: List[Node], new_node: Node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                dynamic_step = _dynamic_step_size(current.position)\n                next_pos = _steer(current.position, new_node.position, dynamic_step)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= dynamic_step:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a: Node, node_b: Node) -> List[Tuple[float, ...]]:\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _shortcut_smooth(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            for _ in range(trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def _cubic_spline_smooth(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            try:\n                import numpy as np\n                from scipy.interpolate import CubicSpline\n            except ImportError:\n                # Fallback: no spline smoothing if libs unavailable\n                return path\n            if len(path) < 4:\n                return path\n\n            dims = len(path[0])\n            path_np = np.array(path)\n            num_points = len(path)\n\n            # Parameter t: cumulative distance along path\n            dist = np.zeros(num_points)\n            dist[1:] = np.cumsum(np.linalg.norm(np.diff(path_np, axis=0), axis=1))\n            cs_funcs = [CubicSpline(dist, path_np[:, d]) for d in range(dims)]\n\n            smoothed_path = []\n            resolution = max(dist[-1]/(num_points*5), 0.01)  # denser interpolation\n            ts = np.arange(0, dist[-1], resolution)\n            for t in ts:\n                pt = tuple(cs(t) for cs in cs_funcs)\n                if (not _is_within_bounds(pt) or self._is_in_obstacle(pt, obstacles, is_3d) \n                    or self._is_edge_in_obstacle(smoothed_path[-1] if smoothed_path else pt, pt, obstacles, is_3d, self.collision_resolution)):\n                    return path  # Abort smoothing if obstacle detected\n                smoothed_path.append(pt)\n            return smoothed_path if smoothed_path else path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_start = _extend_tree(tree_start, rand_point)\n            if new_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_goal = _connect_trees(tree_goal, new_start)\n            if new_goal is not None:\n                candidate_path = _reconstruct_path(new_start, new_goal)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if candidate_cost < best_path_cost:\n                    best_path_cost = candidate_cost\n                    best_connect = new_start\n                    extracted_path = candidate_path\n                    success_state = True\n                    # Aggressive smoothing on candidate path\n                    extracted_path = _shortcut_smooth(extracted_path, trials=150)\n                    extracted_path = _cubic_spline_smooth(extracted_path)\n                    break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 256.55061,
    "time_improvement": -672.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02612292766571045,
            "num_nodes_avg": 236.2,
            "path_length_avg": 149.55670683106166,
            "smoothness_avg": 0.01981247787287812,
            "success_improvement": 0.0,
            "time_improvement": -164.3021174563507,
            "length_improvement": 25.252995389644518,
            "smoothness_improvement": 90.37347668005924,
            "objective_score": -43.788168775576
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.15865614414215087,
            "num_nodes_avg": 1280.6,
            "path_length_avg": 230.71969094734158,
            "smoothness_avg": 0.08375590703309015,
            "success_improvement": -9.999999999999998,
            "time_improvement": -945.4962654793288,
            "length_improvement": 23.439400949136978,
            "smoothness_improvement": 1073.3397699852385,
            "objective_score": -323.59430060404503
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.279067325592041,
            "num_nodes_avg": 1624.2,
            "path_length_avg": 121.86693114793975,
            "smoothness_avg": 0.379060520513509,
            "success_improvement": -30.000000000000004,
            "time_improvement": -904.8885687573564,
            "length_improvement": 25.166362887717565,
            "smoothness_improvement": 2832.7896899084412,
            "objective_score": -402.2693496001212
        }
    ],
    "success_rate": 0.8666666666666666
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an advanced RRT* planner variant combining adaptive neighbor radius scaling based on iteration progress and node density, enhanced goal biasing for improved convergence, and rigorous collision checking for nodes and edges. It prioritizes lower-cost connections and performs rewiring of neighbors to optimize path cost and smoothness, thereby improving planning efficiency, success rate, and path quality in both 2D and 3D bounded obstacle environments.",
    "planning_mechanism": "The planner samples the space with a goal-biased strategy, extends from the nearest node towards the sample with a fixed step size while respecting boundary constraints and collision checks. It dynamically adjusts neighbor radius combining iteration decay and log-based node density scaling to balance exploration and exploitation. Upon adding a new node, it selects the best parent minimizing path cost and rewires neighbors to reduce costs and enhance smoothness. If the goal node is within reach and collision-free, it connects directly and extracts the final path backward from the goal.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.5, goal_sample_rate: float = 0.2,\n                 base_neighbor_radius: float = 20.0, neighbor_factor: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius      # For iteration-based radius decay\n        self.neighbor_factor = neighbor_factor                # For density-based radius scaling\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Adaptive radius combining iteration decay and node density scaling\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            log_term = math.log(n_nodes + 1) if n_nodes > 0 else 0.0\n            radius_iter = self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.65)\n            radius_density = self.neighbor_factor * ((log_term / (n_nodes + 1)) ** (1 / dim)) if n_nodes > 0 else self.base_neighbor_radius\n            neighbor_radius = max(radius_iter, radius_density, self.step_size * 1.8)\n            neighbor_radius = min(neighbor_radius, self.base_neighbor_radius * 1.5)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(dim))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision check for node\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Collision check for edge (nearest_node \u2192 new_pos)\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                continue\n\n            # Find neighbors within adaptive radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= neighbor_radius]\n\n            # Select best parent minimizing cost + collision free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                # Skip if edge invalid\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                    continue\n                cost_estimate = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_estimate < min_cost:\n                    min_cost = cost_estimate\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce cost through new_node if collision free\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.4):\n                        # Remove old edge safely\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Update parent and add new edge\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check whether direct connection to goal possible\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d, resolution=0.4)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path backward from goal if success\n        if success_state:\n            node = nodes[-1]\n            while node is not None:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 967.07435,
    "time_improvement": -3186.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.35120084285736086,
            "num_nodes_avg": 312.4,
            "path_length_avg": 162.6430887555788,
            "smoothness_avg": 0.021275882502007848,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3453.3201947152847,
            "length_improvement": 18.712547483488848,
            "smoothness_improvement": 104.43499027894603,
            "objective_score": -1081.731373966493
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6876274347305298,
            "num_nodes_avg": 1042.5,
            "path_length_avg": 228.9614705863541,
            "smoothness_avg": 0.011953731205200383,
            "success_improvement": 0.0,
            "time_improvement": -4431.257953727765,
            "length_improvement": 24.022837948154756,
            "smoothness_improvement": 67.46028691724273,
            "objective_score": -1324.2355170941123
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.49230380058288575,
            "num_nodes_avg": 653.7,
            "path_length_avg": 114.81983369409326,
            "smoothness_avg": 0.030076296688047822,
            "success_improvement": 0.0,
            "time_improvement": -1672.7279985645596,
            "length_improvement": 29.49370524867233,
            "smoothness_improvement": 132.70018391216368,
            "objective_score": -495.2561576000726
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified and generalized RRT* variant designed to efficiently find smooth and collision-free paths in both 2D and 3D environments. It uses fixed step sizes, goal biasing for faster convergence, adaptive neighbor radius for rewiring, and rigorous collision checks to maintain robustness and path quality. The rewiring step helps reduce path length and improve smoothness while ensuring no invalid nodes or edges are added.",
    "planning_mechanism": "The planner incrementally samples points within map bounds with a fixed probability of sampling the goal. For each sample, it finds the nearest tree node and steers toward it by a fixed step size. It accepts new nodes only if they and the connecting edges are collision-free and within bounds. Neighboring nodes within a dynamically adjusted radius are considered to choose the parent with the minimum cost and to rewire for path improvement. The process continues until the goal is connected or max iterations are reached, finally extracting and returning the optimized path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children: List[Node] = []\n        self.valid = True               # For collision or other validation\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n\n            # Adaptive neighbor radius: shrink over iterations for faster convergence & refinement\n            neighbor_radius = max(self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.5), self.step_size * 1.5)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node in tree to sample\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + direction[d] / dist * scale for d in range(len(bounds)))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision check for node position and edge from nearest\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within radius for rewiring and parent selection\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= neighbor_radius]\n\n            # Choose best parent minimizing cost and with collision-free connection\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if reduces cost and edge is collision free\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect goal if within step size and collision free\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            node = nodes[-1]\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 294.68541,
    "time_improvement": -999.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.10493555068969726,
            "num_nodes_avg": 278.6,
            "path_length_avg": 162.4528117599165,
            "smoothness_avg": 0.020614816246580923,
            "success_improvement": 0.0,
            "time_improvement": -961.6990790102133,
            "length_improvement": 18.807646097074123,
            "smoothness_improvement": 98.08295888898189,
            "objective_score": -284.25777968920426
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2624242305755615,
            "num_nodes_avg": 909.4,
            "path_length_avg": 234.3150377697144,
            "smoothness_avg": 0.01053129730459921,
            "success_improvement": 0.0,
            "time_improvement": -1629.2967412104435,
            "length_improvement": 22.24634323747723,
            "smoothness_improvement": 47.533354896899375,
            "objective_score": -484.10208694115306
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1408143997192383,
            "num_nodes_avg": 493.3,
            "path_length_avg": 115.77530303340964,
            "smoothness_avg": 0.02944454172251948,
            "success_improvement": 0.0,
            "time_improvement": -407.05606718412366,
            "length_improvement": 28.90698951589068,
            "smoothness_improvement": 127.8122983393269,
            "objective_score": -115.69636076036232
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a hybrid informed bidirectional RRT* variant that leverages heuristic-informed sampling within an ellipsoidal subset of the space defined by start and goal positions to focus exploration and improve planning efficiency. It maintains two growing trees from start and goal, rewiring nodes for cost optimization (RRT*), and performs path pruning and smoothing via shortcutting to enhance path quality and smoothness while ensuring robustness via strict collision and boundary checks.",
    "planning_mechanism": "The planner alternately expands bidirectional RRT* trees. Sampling is biased: with a high probability, samples are drawn from an ellipsoid encapsulating possible better paths (informed sampling), and otherwise uniformly over space. Each new node considers rewiring nearby nodes to optimize path cost. Trees attempt connection after each expansion to rapidly find feasible paths. Once connected, the path is extracted, then iteratively smoothed by shortcutting collision-free edges to reduce detours and path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag for collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        from math import dist\n        return dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=10.0, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n        self.neighbor_radius = neighbor_radius    # Radius to consider for rewiring in RRT*\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def is_collision_free_edge(from_pos, to_pos):\n            return (not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, self.collision_resolution))\n\n        # Informed sampling within ellipse defined by current best cost\n        def sample_in_ellipse(best_cost):\n            if best_cost == math.inf:\n                # No solution yet, uniform random sample\n                return sample_free_uniform()\n            c_min = dist(start_position, goal_position)\n            if best_cost < c_min:\n                # Numerical inaccuracies, fallback uniform\n                return sample_free_uniform()\n            a1 = tuple((goal_position[i] - start_position[i]) / c_min for i in range(len(bounds)))\n\n            # Construct rotation matrix to align x-axis with a1\n            def build_rotation_matrix(a):\n                # Handle 2D & 3D cases\n                import numpy as np\n                dim = len(a)\n                a = np.array(a)\n                e1 = np.zeros(dim)\n                e1[0] = 1.0\n                v = np.cross(e1, a) if dim == 3 else (0,)\n                s = np.linalg.norm(v)\n                c = np.dot(e1, a)\n                if dim == 2:\n                    # 2D rotation matrix\n                    theta = math.acos(c)\n                    rot = np.array([\n                        [math.cos(theta), -math.sin(theta)],\n                        [math.sin(theta), math.cos(theta)]\n                    ])\n                    return rot\n                elif dim == 3:\n                    if s == 0:\n                        return np.eye(3)\n                    vx = np.array([[0, -v[2], v[1]],\n                                   [v[2], 0, -v[0]],\n                                   [-v[1], v[0], 0]])\n                    rot = np.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                    return rot\n                # fallback\n                return np.eye(dim)\n\n            import numpy as np\n            rot = build_rotation_matrix(a1)\n\n            r1 = best_cost / 2.0\n            rn = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            # Radii for other axes\n            dim = len(bounds)\n            if dim == 2:\n                lengths = [r1, rn]\n            elif dim == 3:\n                lengths = [r1, rn, rn]\n            else:\n                lengths = [r1] + [rn]*(dim-1)\n\n            while True:\n                # Sample uniformly in unit ball\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    r = random.uniform(0, 1) ** 0.5\n                    unit = np.array([r * math.cos(theta), r * math.sin(theta)])\n                elif dim == 3:\n                    phi = random.uniform(0, 2 * math.pi)\n                    costheta = random.uniform(-1, 1)\n                    u = random.uniform(0, 1)\n                    sintheta = math.sqrt(1 - costheta**2)\n                    r = u ** (1.0 / 3.0)\n                    unit = np.array([\n                        r * sintheta * math.cos(phi),\n                        r * sintheta * math.sin(phi),\n                        r * costheta\n                    ])\n                else:\n                    # Higher dims uniform sampling skipped for simplicity - fallback uniform\n                    return sample_free_uniform()\n\n                # Scale by radii\n                sample_vec = np.multiply(unit, lengths)\n                # Rotate to world frame\n                sample_rot = rot @ sample_vec\n                center = np.array([(start_position[i] + goal_position[i]) / 2.0 for i in range(dim)])\n                sample_point = tuple((sample_rot + center).tolist())\n                if in_bounds(sample_point) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    return sample_point\n\n        def sample_free_uniform():\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        # Find neighbors within radius in given tree\n        def find_neighbors(tree, new_pos):\n            neighbors = []\n            for node in tree:\n                if dist(node.position, new_pos) <= self.neighbor_radius:\n                    neighbors.append(node)\n            return neighbors\n\n        # Rewire near nodes for cost optimization (RRT*)\n        def rewire(tree, new_node, neighbors):\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                edge_free = is_collision_free_edge(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if edge_free and new_cost < near_node.cost:\n                    # Rewire near_node to new_node\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    new_node.add_child(near_node)\n                    near_node.cost = new_cost\n\n        # Attempt to connect two trees (bidirectional)\n        def connect_trees(node_from, tree_to):\n            nearest = nearest_node(tree_to, node_from.position)\n            # Try extending from nearest towards node_from position with step_size increments\n            current = nearest\n            while True:\n                new_pos = steer(current.position, node_from.position)\n                if (not in_bounds(new_pos)\n                    or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                    or not is_collision_free_edge(current.position, new_pos)):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                current = new_node\n                if dist(new_pos, node_from.position) <= self.step_size:\n                    # connect final node\n                    final_new_node = Node(node_from.position, parent=current, cost=current.cost + dist(new_pos, node_from.position))\n                    current.add_child(final_new_node)\n                    tree_to.append(final_new_node)\n                    nodes.append(final_new_node)\n                    edges.append((current, final_new_node))\n                    return final_new_node\n\n        # Nearest node search\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        # Extract full path from start to goal via connecting nodes\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        # Smooth path by shortcutting via random checks\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_nodes = (None, None)\n\n        for _ in range(self.max_iter):\n            # Sampling with goal bias and informed sampling if solution found\n            if random.random() < self.goal_sample_rate:\n                sample_point = goal_position\n            else:\n                if best_cost < math.inf:\n                    sample_point = sample_in_ellipse(best_cost)\n                else:\n                    sample_point = sample_free_uniform()\n\n            # Alternate expansions between the two trees\n            for tree, other_tree in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = nearest_node(tree, sample_point)\n                new_pos = steer(nearest.position, sample_point)\n\n                if (not in_bounds(new_pos)\n                    or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                    or not is_collision_free_edge(nearest.position, new_pos)):\n                    continue\n\n                new_cost = nearest.cost + dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                neighbors = find_neighbors(tree, new_node.position)\n                rewire(tree, new_node, neighbors)\n\n                # Try to connect new_node to other_tree\n                connect_node = connect_trees(new_node, other_tree)\n                if connect_node:\n                    # Reconstruct path\n                    path = extract_path(new_node, connect_node)\n                    path_cost = sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        success_state = True\n                        extracted_path = smooth_path(path)\n                        best_nodes = (new_node, connect_node)\n\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 229.14492,
    "time_improvement": -515.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.027021265029907225,
            "num_nodes_avg": 105.2,
            "path_length_avg": 160.88171807961118,
            "smoothness_avg": 0.02966770978592918,
            "success_improvement": -9.999999999999998,
            "time_improvement": -173.39116255059653,
            "length_improvement": 19.592863617928842,
            "smoothness_improvement": 185.0701004347362,
            "objective_score": -97.1734255394195
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.06624782085418701,
            "num_nodes_avg": 333.9,
            "path_length_avg": 227.72438609382203,
            "smoothness_avg": 0.0931158151292383,
            "success_improvement": -19.999999999999996,
            "time_improvement": -336.5532118134656,
            "length_improvement": 24.433344435207932,
            "smoothness_improvement": 1204.4630877504983,
            "objective_score": -190.05697921824557
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.31507723331451415,
            "num_nodes_avg": 613.8,
            "path_length_avg": 113.62318167299891,
            "smoothness_avg": 0.11934226504222545,
            "success_improvement": -19.999999999999996,
            "time_improvement": -1034.5560049416251,
            "length_improvement": 30.228521677154852,
            "smoothness_improvement": 823.3506143346463,
            "objective_score": -400.2043440753833
        }
    ],
    "success_rate": 0.8333333333333334
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid path planning algorithm combines bidirectional search from the dual-tree RRT with asymptotically optimal rewiring from RRT*. It grows two trees from start and goal, alternately extending towards random samples and attempting connections. Each extension uses rewiring within a neighborhood radius to optimize paths locally. The goal biasing accelerates convergence. Collision and edge checks ensure validity. The hybrid approach improves planning efficiency, path quality, robustness, success rate, and smoothness by leveraging complementary strengths of both methods.",
    "planning_mechanism": "The planner maintains start and goal trees, grows them bidirectionally by sampling points and steering towards them. For each new node added, it finds neighbors within a radius to rewire and minimize cost. After each extension, it attempts to connect the two trees directly. If a connection is found without collision, the path is extracted. Goal biasing increases attempts towards the goal to speed up convergence. The algorithm terminates early upon a successful path or after max iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, search_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-assign parent\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            # Try building connection backward from connect_node towards node_a\n            curr = connect_node\n            connection_chain = []\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                connection_chain.append(new_node)\n                if distance(new_pos, node_a.position) < self.step_size:\n                    # Final connect node\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_from_start, node_from_goal):\n            path_start = []\n            node = node_from_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_from_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree selection for expanding\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing on sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                # Boundary check\n                out_of_bounds = any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds)))\n                if out_of_bounds:\n                    continue\n\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Find neighbors for rewiring\n                neighbors = find_near(tree_a, new_node, self.search_radius)\n                # Choose best parent\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = cost\n                            min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors through new_node if better\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt to connect the other tree directly\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.2445,
    "time_improvement": -28.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013188529014587402,
            "num_nodes_avg": 194.0,
            "path_length_avg": 173.0342779839435,
            "smoothness_avg": 0.021996203295678553,
            "success_improvement": 0.0,
            "time_improvement": -33.436657226802765,
            "length_improvement": 13.519130982034183,
            "smoothness_improvement": 111.35638469997163,
            "objective_score": -6.770389048134134
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024630069732666016,
            "num_nodes_avg": 484.0,
            "path_length_avg": 244.14905520536445,
            "smoothness_avg": 0.015383195714505082,
            "success_improvement": 0.0,
            "time_improvement": -62.30475071249689,
            "length_improvement": 18.9830835527118,
            "smoothness_improvement": 115.50378905411706,
            "objective_score": -14.317289557936123
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.024231910705566406,
            "num_nodes_avg": 405.4,
            "path_length_avg": 130.81419641767454,
            "smoothness_avg": 0.028347178181784644,
            "success_improvement": 0.0,
            "time_improvement": 12.743743770384414,
            "length_improvement": 19.672203019772287,
            "smoothness_improvement": 119.32200113298974,
            "objective_score": 8.354173740734732
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates the strengths of both informed bidirectional RRT* with dynamic neighbor rewiring and adaptive step sizing, and enhanced bidirectional RRT with adaptive sampling and spline-based smoothing. It adaptively samples within an informed ellipsoid and around the current best path, dynamically adjusts step sizes based on local obstacle density, uses dual-tree growth with rewiring for path optimality, and applies aggressive smoothing via shortcutting and cubic spline interpolation to produce efficient, smooth, and short collision-free paths.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling primarily inside an informed ellipsoid based on the current best solution cost and occasionally near the best path for focused exploration. Each extension step dynamically adjusts its step size according to local obstacle density to safely navigate cluttered areas. The planner selects parents among neighbors optimizing cost and rewires nearby nodes to improve connectivity. Upon connection of both trees, it reconstructs the path and applies multiple rounds of local shortcut smoothing and cubic spline interpolation to refine path smoothness while ensuring safety through strict collision checks on nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0,\n                 neighbor_factor: float = 25.0,\n                 shortcut_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor  # Radius scaling for rewiring\n        self.shortcut_trials = shortcut_trials  # Shortcut smoothing attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n        best_connect = None\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            dist = _distance(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def _steer(from_p, to_p, max_step):\n            dist = _distance(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: _distance(n.position, point))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _path_cost(path):\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += _distance(path[i], path[i+1])\n            return total\n\n        def _extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _informed_ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle(pt):\n                        return pt\n\n            c_min = _distance(start_pos, goal_pos)\n            if c_best < c_min:\n                c_min = c_best  # safeguard\n\n            center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n            direction = tuple((g - s) / c_min for s, g in zip(start_pos, goal_pos))\n\n            basis = [direction]\n            for _ in range(dim - 1):\n                vec = [random.gauss(0, 1) for __ in range(dim)]\n                for b in basis:\n                    proj = sum(vec[d] * b[d] for d in range(dim))\n                    vec = [vec[d] - proj * b[d] for d in range(dim)]\n                norm = math.sqrt(sum(x * x for x in vec))\n                if norm > 1e-9:\n                    basis.append(tuple(x / norm for x in vec))\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n            radii = [r1] + [r_other] * (dim - 1)\n\n            while True:\n                while True:\n                    sample = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in sample))\n                    if 1e-9 < norm <= 1.0:\n                        sample = [x / norm for x in sample]\n                        break\n                u = random.uniform(0, 1) ** (1.0/dim)\n                sample_scaled = [radii[i] * u * sample[i] for i in range(dim)]\n\n                new_point = [center[d] for d in range(dim)]\n                for i in range(dim):\n                    for d in range(dim):\n                        new_point[d] += basis[i][d] * sample_scaled[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n\n                if not _is_in_obstacle(new_point):\n                    return new_point\n\n        def _sample_near_path(best_path):\n            if not best_path or len(best_path) < 2:\n                return None\n            idx = random.randint(0, len(best_path) - 2)\n            p1, p2 = best_path[idx], best_path[idx + 1]\n            alpha = random.uniform(0, 1)\n            candidate = tuple(p1[d] + alpha*(p2[d] - p1[d]) for d in range(dim))\n            if not _is_in_obstacle(candidate):\n                return candidate\n            return None\n\n        def _dynamic_step_size(pos):\n            check_range = self.step_size * 2\n            cnt = 0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    cx, cy, cz = x + w/2, y + h/2, z + d/2\n                    dist_to_obs = _distance(pos, (cx, cy, cz))\n                    if dist_to_obs < check_range + max(w, h, d)/2:\n                        cnt += 1\n                else:\n                    x, y, w_, h_ = obs\n                    cx, cy = x + w_/2, y + h_/2\n                    dist_to_obs = _distance(pos, (cx, cy))\n                    if dist_to_obs < check_range + max(w_, h_)/2:\n                        cnt += 1\n            if cnt == 0:\n                return self.step_size\n            else:\n                return max(self.step_size / (1 + cnt), self.step_size * 0.25)\n\n        def _rewire(tree, new_node, radius):\n            near_nodes = _near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not _is_edge_in_obstacle(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, new_cost)\n                        edges.append((new_node, near_node))\n\n        def _local_shortcut(path):\n            if len(path) < 3:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not _is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def _shortcut_smooth(path, trials):\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                if not _is_edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def _cubic_spline_smooth(path):\n            try:\n                import numpy as np\n                from scipy.interpolate import CubicSpline\n            except ImportError:\n                return path\n            if len(path) < 4:\n                return path\n            dims = len(path[0])\n            path_np = np.array(path)\n            dist_arr = np.zeros(len(path))\n            dist_arr[1:] = np.cumsum(np.linalg.norm(np.diff(path_np, axis=0), axis=1))\n            cs_funcs = [CubicSpline(dist_arr, path_np[:, d]) for d in range(dims)]\n            resolution = max(dist_arr[-1] / (len(path) * 5), 0.01)\n            smoothed_path = []\n            ts = np.arange(0, dist_arr[-1] + resolution, resolution)\n            for t in ts:\n                pt = tuple(cs(t) for cs in cs_funcs)\n                if (not _is_within_bounds(pt) or _is_in_obstacle(pt) or\n                    (len(smoothed_path) > 0 and _is_edge_in_obstacle(smoothed_path[-1], pt))):\n                    return path\n                smoothed_path.append(pt)\n            return smoothed_path if smoothed_path else path\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n\n            # Sampling with mixed strategies\n            sample = None\n            prob = random.random()\n            if prob < 0.1 and best_path:\n                sample = _sample_near_path(best_path)\n            if sample is None:\n                sample = _informed_ellipsoid_sample(best_cost)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = _nearest(tree_a, sample)\n                dynamic_step = _dynamic_step_size(nearest_node.position)\n                new_pos = _steer(nearest_node.position, sample, dynamic_step)\n\n                if (not _is_within_bounds(new_pos) or\n                    _is_in_obstacle(new_pos) or\n                    _is_edge_in_obstacle(nearest_node.position, new_pos)):\n                    continue\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree_a)\n                radius = min(dynamic_step * 3,\n                             self.neighbor_factor * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)))\n\n                near_nodes = _near(tree_a, new_pos, radius)\n                min_cost = nearest_node.cost + _distance(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if _is_edge_in_obstacle(near_node.position, new_pos):\n                        continue\n                    cost = near_node.cost + _distance(near_node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = near_node\n\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                _rewire(tree_a, new_node, radius)\n\n                nearest_other = _nearest(tree_b, new_node.position)\n                dist_conn = _distance(new_node.position, nearest_other.position)\n                if dist_conn <= dynamic_step and not _is_edge_in_obstacle(new_node.position, nearest_other.position):\n                    candidate_cost = new_node.cost + dist_conn + nearest_other.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_connect = new_node\n                        best_path = _extract_path(new_node, nearest_other)\n\n            if success_state and iter_count > self.max_iter // 15:\n                break\n\n        if success_state and best_path:\n            path = best_path\n            for _ in range(5):  # multiple shortcut smoothing passes\n                path = _shortcut_smooth(path, self.shortcut_trials)\n            path = _cubic_spline_smooth(path)\n            extracted_path = path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 374.10064,
    "time_improvement": -1219.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.12344834804534913,
            "num_nodes_avg": 473.3,
            "path_length_avg": 158.6134230158977,
            "smoothness_avg": 0.044058863591475525,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1149.004713499327,
            "length_improvement": 20.726535689062096,
            "smoothness_improvement": 323.35133920647866,
            "objective_score": -388.93935021595325
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.25077497959136963,
            "num_nodes_avg": 1077.8,
            "path_length_avg": 233.77348081209502,
            "smoothness_avg": 0.10015584105794609,
            "success_improvement": 0.0,
            "time_improvement": -1552.5316813669886,
            "length_improvement": 22.42605015770263,
            "smoothness_improvement": 1303.087085704656,
            "objective_score": -454.75885895003273
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2932645082473755,
            "num_nodes_avg": 1099.2,
            "path_length_avg": 131.32967945221947,
            "smoothness_avg": 0.12481426927881571,
            "success_improvement": 0.0,
            "time_improvement": -956.0109512456658,
            "length_improvement": 19.355665383341243,
            "smoothness_improvement": 865.6874886323623,
            "objective_score": -278.6037148538697
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an improved and tuned RRT*-based planner with goal biasing, adaptive neighbor radius, and optimized rewiring to enhance path planning efficiency, success rate, and path quality. It samples the search space with a goal bias, incrementally grows a tree from the start node, and optimizes path cost by rewiring nodes within an adaptive radius while enforcing collision and boundary constraints strictly.",
    "planning_mechanism": "The planner samples points biased towards the goal, extends the nearest node towards the sampled point within step size limits, performs collision checks for nodes and edges, selects the best parent node from neighbors in an adaptive radius to minimize cost, rewires neighbors to improve overall path cost, and terminates successfully upon connecting a valid path to the goal region. This process balances exploration and exploitation efficiently, yielding smooth and shorter paths while reducing planning time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start node\n        self.children = []\n        self.valid = True               # For collision and path validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius_max: float = 30.0, neighbor_radius_min: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_max = neighbor_radius_max\n        self.neighbor_radius_min = neighbor_radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        root = Node(start_position)\n        nodes.append(root)\n\n        def adaptive_radius(iteration):\n            # Decay radius from max to min smoothly over iterations\n            frac = min(iteration / self.max_iter, 1.0)\n            return self.neighbor_radius_max - frac * (self.neighbor_radius_max - self.neighbor_radius_min)\n\n        success = False\n        goal_node = None\n\n        for i in range(self.max_iter):\n            # Sample point (goal biasing)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction_vec = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction_vec[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check boundary limits\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Dynamic neighbor radius based on iteration count and node density\n            radius = adaptive_radius(i)\n\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= radius]\n\n            # Choose best parent minimizing cost and valid edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge and update parent safely\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        try:\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if goal is reachable and connect\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3012.42962,
    "time_improvement": -9952.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.6847682952880859,
            "num_nodes_avg": 252.5,
            "path_length_avg": 153.9561606287669,
            "smoothness_avg": 0.02945930314640514,
            "success_improvement": -9.999999999999998,
            "time_improvement": -6828.232268896211,
            "length_improvement": 23.05419066688754,
            "smoothness_improvement": 183.0675696668048,
            "objective_score": -2092.943504687152
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.5240118503570557,
            "num_nodes_avg": 939.8,
            "path_length_avg": 223.32396984331317,
            "smoothness_avg": 0.025170096050714845,
            "success_improvement": 0.0,
            "time_improvement": -16532.478860759096,
            "length_improvement": 25.893551419834154,
            "smoothness_improvement": 252.60885777267313,
            "objective_score": -4953.3019036548985
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 1.831498098373413,
            "num_nodes_avg": 646.0,
            "path_length_avg": 115.18041080329662,
            "smoothness_avg": 0.05440761594685376,
            "success_improvement": -9.999999999999998,
            "time_improvement": -6495.008924286508,
            "length_improvement": 29.272289182090955,
            "smoothness_improvement": 320.9515010565289,
            "objective_score": -1991.0434619442517
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified bidirectional RRT planner optimized for enhanced efficiency, path quality, and robustness. It alternates growth of two trees from start and goal, samples points with goal bias, and ensures strict collision checking for newly added nodes and connecting edges. Upon connection, it reconstructs the path and applies shortcut smoothing to reduce unnecessary detours and improve smoothness. The design balances exploration depth and computational effort for improved success rates and faster convergence.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal by sampling free configurations biased toward the goal. It extends each tree by steering towards sampled points within step size, validating new nodes and edges via collision-free checks. When the two trees connect, the planner reconstructs the full path and performs iterative shortcut smoothing to optimize path quality before returning the result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 3.0, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                         \n        start_position = map.start                 \n        goal_position = map.goal                   \n        obstacles = map.obstacles                  \n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, target_node):\n            current = _nearest(tree, target_node.position)\n            while True:\n                next_pos = _steer(current.position, target_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, target_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(40):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if not new_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.98769,
    "time_improvement": -24.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01088719367980957,
            "num_nodes_avg": 134.1,
            "path_length_avg": 175.03233523134534,
            "smoothness_avg": 0.013335379012390985,
            "success_improvement": 0.0,
            "time_improvement": -10.152597731537979,
            "length_improvement": 12.52052117410358,
            "smoothness_improvement": 28.136545147160557,
            "objective_score": -0.4009923589048745
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023423933982849122,
            "num_nodes_avg": 412.5,
            "path_length_avg": 250.35117199926208,
            "smoothness_avg": 0.021827263057035733,
            "success_improvement": 0.0,
            "time_improvement": -54.356678931773125,
            "length_improvement": 16.925011373547015,
            "smoothness_improvement": 205.77897991876952,
            "objective_score": -11.893106505228687
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.029634523391723632,
            "num_nodes_avg": 463.6,
            "path_length_avg": 126.67064640606554,
            "smoothness_avg": 0.03621107325015106,
            "success_improvement": 0.0,
            "time_improvement": -6.710428151123073,
            "length_improvement": 22.216592338552495,
            "smoothness_improvement": 180.16492496948817,
            "objective_score": 3.3310146472210187
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner merges adaptive informed bidirectional RRT* with dynamic neighbor radius scaling and path smoothing leveraging local shortcutting, combining strengths of both approaches: fast convergence from bidirectional search and focused sampling within informed ellipsoids along with rewiring for optimality and adaptive radius to enhance planning efficiency, path quality, and robustness in 2D/3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions with alternating expansions towards samples biased by an informed ellipsoid around the currently best path cost. It uses adaptive neighbor radius decreasing with iterations for rewiring and parent selection to improve path cost. When connections between the trees occur, it extracts the path and applies iterative local shortcutting for smoothness, ensuring all new nodes and edges are collision-free and within map boundaries, iterating until the maximum iteration is reached or a satisfactory path is found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_neighbor_radius: float = 20.0, smooth_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_neighbor_radius = base_neighbor_radius\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            distance = _distance(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def ortho_basis(vec):\n            # Gram-Schmidt orthonormal basis for dim-dimensional vec\n            basis = [vec]\n            for _ in range(dim - 1):\n                v = [random.gauss(0, 1) for __ in range(dim)]\n                for b in basis:\n                    proj = sum(v[d]*b[d] for d in range(dim))\n                    v = [v[d] - proj*b[d] for d in range(dim)]\n                norm = math.sqrt(sum(x*x for x in v))\n                if norm > 1e-6:\n                    basis.append(tuple(x/norm for x in v))\n                else:\n                    # Retry if vector near-zero\n                    basis.append(tuple(0.0 for _ in range(dim)))\n            return basis\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle(point):\n                        return point\n            c_min = _distance(start_position, goal_position)\n            if c_best < c_min:\n                c_min = c_best  # numerical safeguard\n\n            center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n            vec = tuple((g - s) / c_min for s, g in zip(start_position, goal_position))\n            basis = ortho_basis(vec)\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n            radii = [r1] + [r_others]*(dim-1)\n\n            while True:\n                while True:\n                    sample = [random.gauss(0,1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in sample))\n                    if norm > 1e-6:\n                        sample = [x / norm for x in sample]\n                        break\n                u = random.uniform(0,1) ** (1.0/dim)\n                sample_scaled = [radii[i]*u*sample[i] for i in range(dim)]\n                new_point = [center[d] for d in range(dim)]\n                for i in range(dim):\n                    for d in range(dim):\n                        new_point[d] += basis[i][d]*sample_scaled[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n                if not _is_in_obstacle(new_point):\n                    return new_point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: _distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos, max_step):\n            dist = _distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extract_path(n1, n2):\n            path_start = []\n            cur = n1\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n2\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_start)) + path_goal\n\n        def local_shortcut(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i + 1:\n                    if not _is_edge_in_obstacle(path[i], path[j], resolution=0.5):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def rewire(tree, new_node, neighbor_radius):\n            near_nodes = near(tree, new_node.position, neighbor_radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                dist = _distance(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist\n                if new_cost < near_node.cost and not _is_edge_in_obstacle(new_node.position, near_node.position, resolution=0.5):\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        try:\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                    near_node.update_parent(new_node, new_cost)\n                    edges.append((new_node, near_node))\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            # Adaptive neighbor radius scaling (shrink over iterations)\n            neighbor_radius = self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter)**0.6)\n            neighbor_radius = max(neighbor_radius, self.step_size * 1.5)\n\n            c_best = best_cost\n            sample = informed_sample(c_best)\n\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            swapped = False\n            for tree_a, tree_b in trees:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                # Bounds check\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                    continue\n                # Collision checks\n                if _is_in_obstacle(new_pos):\n                    continue\n                if _is_edge_in_obstacle(nearest_node.position, new_pos, resolution=0.5):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, neighbor_radius)\n                min_cost = nearest_node.cost + _distance(nearest_node.position, new_pos)\n                min_parent = nearest_node\n\n                for near_node in near_nodes:\n                    cost = near_node.cost + _distance(near_node.position, new_pos)\n                    if cost < min_cost and not _is_edge_in_obstacle(near_node.position, new_pos, resolution=0.5):\n                        min_cost = cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos)\n                new_node.update_parent(min_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbor_radius)\n\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = _distance(connect_node.position, new_node.position)\n                if dist_connect <= self.step_size and not _is_edge_in_obstacle(new_node.position, connect_node.position, resolution=0.5):\n                    candidate_cost = new_node.cost + dist_connect + connect_node.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_path = extract_path(new_node, connect_node)\n\n                if swapped:\n                    break\n                swapped = True\n\n            if success_state and iter_count > self.max_iter // 10:\n                break\n\n        extracted_path = []\n        if success_state and best_path:\n            path = best_path\n            for _ in range(self.smooth_iter):\n                path = local_shortcut(path)\n            extracted_path = path\n\n        all_nodes = start_tree + goal_tree + nodes\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
    "objective": 524.28995,
    "time_improvement": -1666.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.3682706832885742,
            "num_nodes_avg": 1237.6,
            "path_length_avg": 154.48084009985195,
            "smoothness_avg": 0.04826272575960765,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3626.0265248918117,
            "length_improvement": 22.791960910194287,
            "smoothness_improvement": 363.7452698175832,
            "objective_score": -1131.4308389364166
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.11246733665466309,
            "num_nodes_avg": 1018.8,
            "path_length_avg": 223.7846192250175,
            "smoothness_avg": 0.08641810422875061,
            "success_improvement": -9.999999999999998,
            "time_improvement": -641.1259179191005,
            "length_improvement": 25.740692370522478,
            "smoothness_improvement": 1110.6345943846386,
            "objective_score": -231.63646392970247
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.23035216331481934,
            "num_nodes_avg": 1521.4,
            "path_length_avg": 115.62708116832816,
            "smoothness_avg": 0.09665652710160201,
            "success_improvement": 0.0,
            "time_improvement": -729.4710074442029,
            "length_improvement": 28.99800667008609,
            "smoothness_improvement": 647.8311530884729,
            "objective_score": -209.80254513380126
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates informed sampling within an adaptive ellipsoid, bidirectional tree growth with dynamic step sizing based on local obstacle density, and rewiring for path optimality. It employs a mixed sampling strategy combining ellipsoid-based and goal-biased samples, adaptive neighbor radius scaling influenced by iteration progress and node density, and performs aggressive shortcut-based smoothing and cubic spline interpolation to produce shorter, smoother, and collision-free paths efficiently in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling primarily inside an informed ellipsoid and with goal biasing to improve convergence. It dynamically adjusts step sizes and neighbor radii based on local obstacle density and iteration progress. Parents are selected to minimize path cost, with rewiring optimizing connectivity and cost. On connection, the path is extracted and further refined with repeated shortcut smoothing and spline interpolation, all collision-validated to ensure safety and improved path smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 base_neighbor_radius: float = 20.0,\n                 neighbor_factor: float = 30.0,\n                 shortcut_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n        self.neighbor_factor = neighbor_factor\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n        best_connect = None\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _is_within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _dynamic_step_size(pos):\n            check_range = self.step_size * 2\n            cnt = 0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    cx, cy, cz = x + w/2, y + h/2, z + d/2\n                    dist_to_obs = _distance(pos, (cx, cy, cz))\n                    if dist_to_obs < check_range + max(w, h, d)/2:\n                        cnt += 1\n                else:\n                    x, y, w_, h_ = obs\n                    cx, cy = x + w_/2, y + h_/2\n                    dist_to_obs = _distance(pos, (cx, cy))\n                    if dist_to_obs < check_range + max(w_, h_)/2:\n                        cnt += 1\n            if cnt == 0:\n                return self.step_size\n            else:\n                return max(self.step_size / (1 + cnt), self.step_size * 0.25)\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: _distance(n.position, point))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _informed_ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n            c_min = _distance(start_pos, goal_pos)\n            if c_best < c_min:\n                c_min = c_best  # safeguard\n\n            center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n            direction = tuple((g - s) / c_min for s, g in zip(start_pos, goal_pos))\n\n            basis = [direction]\n            for _ in range(dim - 1):\n                vec = [random.gauss(0, 1) for __ in range(dim)]\n                for b in basis:\n                    proj = sum(vec[d] * b[d] for d in range(dim))\n                    vec = [vec[d] - proj * b[d] for d in range(dim)]\n                norm = math.sqrt(sum(x * x for x in vec))\n                if norm > 1e-9:\n                    basis.append(tuple(x / norm for x in vec))\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n            radii = [r1] + [r_other] * (dim - 1)\n\n            while True:\n                while True:\n                    sample = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in sample))\n                    if 1e-9 < norm <= 1.0:\n                        sample = [x / norm for x in sample]\n                        break\n                u = random.uniform(0, 1) ** (1.0/dim)\n                sample_scaled = [radii[i] * u * sample[i] for i in range(dim)]\n\n                new_point = [center[d] for d in range(dim)]\n                for i in range(dim):\n                    for d_ in range(dim):\n                        new_point[d_] += basis[i][d_] * sample_scaled[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n\n                if not self._is_in_obstacle(new_point, obstacles, is_3d):\n                    return new_point\n\n        def _sample_goal_bias():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            return None\n\n        def _sample_mixed(c_best, best_path):\n            sample = _sample_goal_bias()\n            if sample:\n                return sample\n            if best_path and random.random() < 0.1:\n                # Sample near best path segment\n                idx = random.randint(0, len(best_path) - 2)\n                p1, p2 = best_path[idx], best_path[idx + 1]\n                alpha = random.uniform(0, 1)\n                candidate = tuple(p1[d] + alpha*(p2[d] - p1[d]) for d in range(dim))\n                if (self._is_within_bounds(candidate, bounds) if hasattr(self, '_is_within_bounds') else True) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            return _informed_ellipsoid_sample(c_best)\n\n        def _rewire(tree, new_node, radius):\n            near_nodes = _near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.update_parent(new_node, new_cost)\n                        edges.append((new_node, near_node))\n\n        def _shortcut_smooth(path, trials):\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def _cubic_spline_smooth(path):\n            try:\n                import numpy as np\n                from scipy.interpolate import CubicSpline\n            except ImportError:\n                return path\n            if len(path) < 4:\n                return path\n            dims = len(path[0])\n            path_np = np.array(path)\n            dist_arr = np.zeros(len(path))\n            dist_arr[1:] = np.cumsum(np.linalg.norm(np.diff(path_np, axis=0), axis=1))\n            cs_funcs = [CubicSpline(dist_arr, path_np[:, d]) for d in range(dims)]\n            resolution = max(dist_arr[-1] / (len(path) * 5), 0.01)\n            smoothed_path = []\n            ts = np.arange(0, dist_arr[-1] + resolution, resolution)\n            for t in ts:\n                pt = tuple(cs(t) for cs in cs_funcs)\n                if (not _is_within_bounds(pt) or\n                    self._is_in_obstacle(pt, obstacles, is_3d) or\n                    (len(smoothed_path) > 0 and self._is_edge_in_obstacle(smoothed_path[-1], pt, obstacles, is_3d, resolution=0.5))):\n                    return path\n                smoothed_path.append(pt)\n            return smoothed_path if smoothed_path else path\n\n        iter_count = 0\n        grow_from_start = True  # Alternate trees\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n\n            sample = _sample_mixed(best_cost, best_path)\n\n            for tree_a, tree_b in ((start_tree, goal_tree), (goal_tree, start_tree)):\n                nearest_node = _nearest(tree_a, sample)\n                step = _dynamic_step_size(nearest_node.position)\n                direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n                dist = _distance(nearest_node.position, sample)\n                if dist == 0:\n                    continue\n                scale = min(step, dist)\n                new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(dim))\n\n                if not _is_within_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                    continue\n\n                n_nodes = len(tree_a)\n                radius_iter = self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.65)\n                log_term = math.log(n_nodes + 1)\n                radius_density = self.neighbor_factor * ((log_term / (n_nodes + 1)) ** (1.0 / dim))\n                neighbor_radius = max(radius_iter, radius_density, self.step_size * 1.8)\n                neighbor_radius = min(neighbor_radius, self.base_neighbor_radius * 1.5)\n\n                near_nodes = _near(tree_a, new_pos, neighbor_radius)\n\n                min_cost = nearest_node.cost + _distance(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                        continue\n                    cost = near_node.cost + _distance(near_node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                _rewire(tree_a, new_node, neighbor_radius)\n\n                nearest_other = _nearest(tree_b, new_node.position)\n                dist_connect = _distance(new_node.position, nearest_other.position)\n                step_other = _dynamic_step_size(nearest_other.position)\n                max_connect_step = max(step, step_other)\n                if dist_connect <= max_connect_step:\n                    if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d, resolution=0.4):\n                        candidate_cost = new_node.cost + dist_connect + nearest_other.cost\n                        if candidate_cost < best_cost:\n                            best_cost = candidate_cost\n                            success_state = True\n                            best_connect = new_node\n                            best_path = _extract_path(new_node, nearest_other)\n\n            if success_state and iter_count > self.max_iter // 10:\n                break\n\n        if success_state and best_path:\n            path = best_path\n            for _ in range(5):\n                path = _shortcut_smooth(path, self.shortcut_trials)\n            path = _cubic_spline_smooth(path)\n            extracted_path = path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _is_within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
    "objective": 2484.1352,
    "time_improvement": -8141.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.4563600063323974,
            "num_nodes_avg": 639.4,
            "path_length_avg": 154.9724582389424,
            "smoothness_avg": 0.041944347894098545,
            "success_improvement": -9.999999999999998,
            "time_improvement": -14634.911736468586,
            "length_improvement": 22.546254889463043,
            "smoothness_improvement": 303.033451288215,
            "objective_score": -4434.449102706242
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.9564141035079956,
            "num_nodes_avg": 1021.8,
            "path_length_avg": 226.5742992919153,
            "smoothness_avg": 0.08340853372595294,
            "success_improvement": -19.999999999999996,
            "time_improvement": -6202.481248841309,
            "length_improvement": 24.814982145248756,
            "smoothness_improvement": 1068.4734037702042,
            "objective_score": -1950.4390112044919
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.0239432334899903,
            "num_nodes_avg": 939.5,
            "path_length_avg": 118.75471143473014,
            "smoothness_avg": 0.09555911080343707,
            "success_improvement": 0.0,
            "time_improvement": -3587.0989758748083,
            "length_improvement": 27.0774532748981,
            "smoothness_improvement": 639.3404476981157,
            "objective_score": -1067.5174998689722
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced RRT* variant utilizing adaptive neighbor radius and goal biasing along with efficient rewiring for path optimization. It incorporates stricter collision checks, adaptive step sizes based on environment scale, and path shortcut smoothing to improve success rate, planning efficiency, and path quality in 2D and 3D spaces.",
    "planning_mechanism": "The planner incrementally samples within map bounds with increased goal sampling rate for faster convergence. It chooses the best parent among neighbors within a dynamically shrinking radius, adds new collision-free nodes and edges, and rewires neighbors to improve paths. After goal connection, it applies shortcut smoothing to reduce path length and improve smoothness before returning the optimized path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.25, base_neighbor_radius: float = 25.0, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                      # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: list[tuple] = []\n        nodes: list[Node] = []\n        edges: list[tuple] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n\n            # Adaptive neighbor radius shrinks over iterations for refinement; min radius at least step_size*1.5\n            neighbor_radius = max(self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.6), self.step_size * 1.5)\n\n            # Goal biased sampling for faster convergence\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node to the sampled point\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            vec = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + vec[d] / dist * scale for d in range(len(bounds)))\n\n            # Check map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision check for new node and edge from nearest_node\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            # Find neighbors within radius for choosing best parent and rewiring\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= neighbor_radius]\n\n            # Choose best parent minimizing cost + collision free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                tentative_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                        min_cost = tentative_cost\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if it improves cost and edge collision free\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if within step size to goal -> attempt to connect goal directly\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d, resolution=0.5)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path from root to goal_node\n                    extracted_path = goal_node.path_from_root()\n                    # Apply shortcut smoothing to improve path quality\n                    extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d)\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_smooth(self, path: list[tuple], obstacles, is_3d) -> list[tuple]:\n        if len(path) <= 2:\n            return path\n        for _ in range(self.smoothing_iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 2)\n            j = random.randint(i + 1, len(path) - 1)\n            if j == i + 1:\n                continue\n            p1, p2 = path[i], path[j]\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 336.17542,
    "time_improvement": -1089.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.09235446453094483,
            "num_nodes_avg": 290.1,
            "path_length_avg": 159.81901204229115,
            "smoothness_avg": 0.037590065664500086,
            "success_improvement": -9.999999999999998,
            "time_improvement": -834.4083038639114,
            "length_improvement": 20.12399388118572,
            "smoothness_improvement": 261.1941694066883,
            "objective_score": -294.9917215359028
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2949181795120239,
            "num_nodes_avg": 1182.0,
            "path_length_avg": 222.56755575730185,
            "smoothness_avg": 0.047154646119450146,
            "success_improvement": 0.0,
            "time_improvement": -1843.422090388912,
            "length_improvement": 26.14455520420016,
            "smoothness_improvement": 560.5912775760627,
            "objective_score": -544.9947596879533
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.19163918495178223,
            "num_nodes_avg": 759.9,
            "path_length_avg": 114.08652126478816,
            "smoothness_avg": 0.07735457180805323,
            "success_improvement": 0.0,
            "time_improvement": -590.0701322717482,
            "length_improvement": 29.944003255749635,
            "smoothness_improvement": 498.49200428103046,
            "objective_score": -168.5397790089694
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This planner is a simplified yet efficient RRT* variant that uses adaptive neighbor radius based on node density and iteration count, combined with goal bias sampling, fixed-step steering, and rigorous collision checks for nodes and edges in both 2D and 3D spaces. It optimizes path quality via parent selection minimizing cost and rewiring neighbors through new nodes to reduce overall path cost and enhance smoothness. The planner ensures valid expansions within map bounds to maintain robustness and speed up convergence toward the goal.",
    "planning_mechanism": "The planner grows a tree by sampling points with goal bias, extending nearest nodes toward samples by a fixed step size if collision-free and inside bounds. It dynamically computes neighbor radius from node density and iteration progress, selects the best parent minimizing cost for new nodes, and rewires neighbors when beneficial. Upon a node reaching near the goal, a connection attempt is made, and a path is extracted by backtracking from the goal node.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 base_neighbor_radius: float = 20.0, neighbor_factor: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Adaptive neighbor radius based on iteration decay and node density\n            n_nodes = len(nodes)\n            log_term = math.log(n_nodes + 1) if n_nodes > 0 else 0.0\n            radius_iter = self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.65)\n            radius_density = self.neighbor_factor * ((log_term / (n_nodes + 1)) ** (1 / dim)) if n_nodes > 0 else self.base_neighbor_radius\n            neighbor_radius = max(radius_iter, radius_density, self.step_size * 1.8)\n            neighbor_radius = min(neighbor_radius, self.base_neighbor_radius * 1.5)\n\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(dim))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision check for new node\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Collision check edge from nearest node to new node\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            # Find neighbors within adaptive radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= neighbor_radius]\n\n            # Parent selection minimizing cost + collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                    continue\n                candidate_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if candidate_cost < min_cost:\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if cost improves and edge is collision free\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new node can connect to goal directly\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, resolution=0.5)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path backward\n                    node = goal_node\n                    while node is not None:\n                        extracted_path.append(node.position)\n                        node = node.parent\n                    extracted_path.reverse()\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 917.36225,
    "time_improvement": -2802.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.19049086570739746,
            "num_nodes_avg": 242.7,
            "path_length_avg": 164.4982008836826,
            "smoothness_avg": 0.02226919588671029,
            "success_improvement": -19.999999999999996,
            "time_improvement": -1827.3161035715489,
            "length_improvement": 17.78538027226684,
            "smoothness_improvement": 113.97950680494333,
            "objective_score": -644.0678574829866
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.574802827835083,
            "num_nodes_avg": 941.5,
            "path_length_avg": 230.2821893778219,
            "smoothness_avg": 0.012606324191209864,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3687.77773239025,
            "length_improvement": 23.584578771240437,
            "smoothness_improvement": 76.60248752401101,
            "objective_score": -1151.233391525207
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.8303853034973144,
            "num_nodes_avg": 939.8,
            "path_length_avg": 115.44061993274062,
            "smoothness_avg": 0.12738533328607365,
            "success_improvement": -19.999999999999996,
            "time_improvement": -2890.119668715375,
            "length_improvement": 29.112505101350656,
            "smoothness_improvement": 885.5798002937453,
            "objective_score": -956.7855005928736
        }
    ],
    "success_rate": 0.8333333333333334
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner merges bidirectional tree growth, goal biasing, and asymptotically optimal rewiring from RRT* principles combined with adaptive sampling and dynamic neighborhood radius scaling. It grows two trees simultaneously from start and goal, extends alternately towards biased random samples or via informed sampling near the current best paths, locally rewires nodes to optimize path cost, and attempts timely direct tree connections. It leverages adaptive radius for efficient rewiring, early stopping upon connection, and path smoothing via short-cutting to improve smoothness and path length while respecting collision and boundary constraints.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling points either randomly biased towards the goal or informed around the best path area to accelerate convergence. Each extension includes rewiring neighbors within a dynamically scaled radius to locally optimize paths. After extension, it tries to directly connect the two trees, checking collision validity. When a connection is found, the path is extracted and refined by shortcutting to improve smoothness and path quality. The planning terminates early upon success or after reaching max iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 min_search_radius: float = 10.0, max_search_radius: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_search_radius = min_search_radius\n        self.max_search_radius = max_search_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-assign parent\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b):\n            nearest_b = find_nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n            # Attempt to connect with small incremental steps\n            curr = nearest_b\n            while True:\n                new_pos = steer(curr.position, node_from_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                if distance(new_pos, node_from_a.position) < self.step_size * 1.01:\n                    # Final connect node to node_from_a\n                    final_node = Node(node_from_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_from_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Attempt to shortcut the path by removing unnecessary intermediate nodes\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        # Shortcut is possible; remove intermediate nodes between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        # Initialize trees\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: list = []\n\n        best_path_cost = float(\"inf\")\n        best_path = []\n\n        # For adaptive radius based on iteration count\n        def adaptive_radius(iteration):\n            scale = min(1.0, iteration / (self.max_iter/2))\n            r = self.max_search_radius - (self.max_search_radius - self.min_search_radius) * scale\n            return r if r > self.min_search_radius else self.min_search_radius\n\n        # Informed sampling around the current best path cost ellipsoid if any, else uniform\n        def informed_sample():\n            if best_path_cost == float(\"inf\"):\n                # Uniform sampling\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                return sample\n            else:\n                # Informed sampling ellipsoid around start-goal with best cost\n                # Simplified: sample around the line segment start-goal with Gaussian noise proportional to cost\n                import numpy as np\n                dim = len(bounds)\n                start = np.array(start_position)\n                goal = np.array(goal_position)\n                center = (start + goal) / 2\n                c_best = best_path_cost\n                c_min = distance(start_position, goal_position)\n                if c_best < c_min:\n                    c_best = c_min + 1e-3  # Avoid degenerate case\n\n                # Sampling in prolate hyperspheroid\n                while True:\n                    # Sample unit ball\n                    direction = np.random.normal(0,1,dim)\n                    norm = np.linalg.norm(direction)\n                    if norm == 0:\n                        continue\n                    direction /= norm\n                    radius = random.uniform(0,1) ** (1/dim)\n                    point_ball = radius * direction\n\n                    # Stretch and translate the sample to ellipsoid\n                    a1 = (goal - start) / c_min\n                    I = np.eye(dim)\n                    M = np.outer(a1, a1)\n                    U, _, _ = np.linalg.svd(M)\n                    L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n                    sample = U @ L @ point_ball + center\n                    sample = np.clip(sample, [0]*dim, bounds)\n                    sample_tuple = tuple(float(v) for v in sample)\n\n                    if not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                        return sample_tuple\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree growth: start_tree first on even, goal_tree first on odd to balance\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_count % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]:\n                # Goal biasing and sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    # With probability, use informed sampling around best path\n                    if best_path_cost < float(\"inf\") and random.random() < 0.6:\n                        sample = informed_sample()\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                # Boundary check\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n\n                # Collision checks for new node and edge\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node with tentative cost\n                tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                # Adaptive neighborhood radius for rewiring\n                curr_radius = adaptive_radius(iter_count)\n\n                neighbors = find_near(tree_a, new_node, curr_radius)\n\n                # Choose best parent from neighbors for minimal cost path\n                min_cost = tentative_cost\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_node.position)\n                    cost = node.cost + edge_cost\n                    if cost + 1e-7 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost\n                            min_node = node\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors with new_node as better parent candidate\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt connecting the other tree\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n\n                    # Save best path cost found so far\n                    path_cost = 0.0\n                    for i in range(len(extracted_path) - 1):\n                        path_cost += distance(extracted_path[i], extracted_path[i+1])\n                    if path_cost < best_path_cost:\n                        best_path_cost = path_cost\n                        best_path = extracted_path\n\n                    # Perform path shortcutting to smooth path\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n        # If no path found, but best path may have been updated by heuristic sampling and rewiring (unlikely)\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 27.10239,
    "time_improvement": -120.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.020557212829589843,
            "num_nodes_avg": 84.2,
            "path_length_avg": 163.18597505252896,
            "smoothness_avg": 0.04818481693406371,
            "success_improvement": 0.0,
            "time_improvement": -107.99027388470499,
            "length_improvement": 18.441218130223056,
            "smoothness_improvement": 362.9966620927936,
            "objective_score": -26.89385522890292
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04085087776184082,
            "num_nodes_avg": 225.1,
            "path_length_avg": 226.58193071270148,
            "smoothness_avg": 0.09811354338078526,
            "success_improvement": 0.0,
            "time_improvement": -169.19499633932136,
            "length_improvement": 24.812449781649452,
            "smoothness_improvement": 1274.4764578499003,
            "objective_score": -39.42362665621702
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.050639772415161134,
            "num_nodes_avg": 311.6,
            "path_length_avg": 118.95801706398773,
            "smoothness_avg": 0.12470345444191666,
            "success_improvement": 0.0,
            "time_improvement": -82.34785572446405,
            "length_improvement": 26.952611371196777,
            "smoothness_improvement": 864.8301146945379,
            "objective_score": -14.989683869627171
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an optimized bidirectional RRT* variant with adaptive informed sampling, dynamic neighbor rewiring, and local shortcut smoothing for enhanced path optimality, efficiency, and robustness. It alternately grows two trees from start and goal while biasing samples within an ellipsoidal region determined by the best solution to focus the search. Adaptive rewiring reduces path cost, pruning avoids fruitless expansions, and incremental smoothing improves path quality.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal with samples biased by an informed ellipsoid defined by the current best path cost, enabling focused exploration. Each new node selects the best parent within an adaptive radius and rewires neighbors to improve costs. The two trees attempt to connect when nodes are close, potentially closing a solution quickly. After a solution is found, local shortcut smoothing refines the path for smoothness and length. Collision and bounds checks are rigorously enforced during node addition and edge creation.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root of the tree\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 neighbor_factor: float = 30.0, smooth_iter: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor  # scaling for rewiring radius\n        self.smooth_iter = smooth_iter           # local shortcut smoothing iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        success_state = False\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            length = dist(from_p, to_p)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            length = dist(from_p, to_p)\n            if length <= max_step:\n                return to_p\n            ratio = max_step / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            r_nodes = [node for node in tree if dist(node.position, point) <= radius]\n            return r_nodes\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def local_shortcut(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_min = c_best  # safeguard numerical\n\n            center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n            direction = tuple((g - s) / c_min for s, g in zip(start_pos, goal_pos))\n\n            # Construct orthonormal basis with Gram-Schmidt\n            basis = [direction]\n            for _ in range(dim - 1):\n                vec = [random.gauss(0, 1) for __ in range(dim)]\n                for b in basis:\n                    proj = sum(vec[d] * b[d] for d in range(dim))\n                    vec = [vec[d] - proj * b[d] for d in range(dim)]\n                norm = math.sqrt(sum(x * x for x in vec))\n                if norm > 1e-9:\n                    basis.append(tuple(x / norm for x in vec))\n            r1 = c_best / 2.0\n            r_rest = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n            radii = [r1] + [r_rest] * (dim - 1)\n\n            while True:\n                # Sample uniformly on unit n-ball surface\n                while True:\n                    sample = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in sample))\n                    if 1e-9 < norm <= 1.0:\n                        sample = [x / norm for x in sample]\n                        break\n                u = random.uniform(0, 1) ** (1.0 / dim)\n                scaled = [radii[i] * u * sample[i] for i in range(dim)]\n\n                point = list(center)\n                for i in range(dim):\n                    for d in range(dim):\n                        point[d] += basis[i][d] * scaled[i]\n                point = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n                if not is_in_obstacle(point):\n                    return point\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, new_cost)\n                        edges.append((new_node, near_node))\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            c_best = best_cost\n            sample = informed_sample(c_best)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree_a)\n                radius = min(self.step_size * 3,\n                             self.neighbor_factor * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)))\n\n                near_nodes = near(tree_a, new_pos, radius)\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if is_edge_in_obstacle(near_node.position, new_pos):\n                        continue\n                    cost = near_node.cost + dist(near_node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = near_node\n\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewire(tree_a, new_node, radius)\n\n                nearest_other = nearest(tree_b, new_node.position)\n                dist_connect = dist(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                    candidate_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_path = extract_path(new_node, nearest_other)\n\n            if success_state and iter_count > self.max_iter // 10:\n                break\n\n        if success_state and best_path:\n            path = best_path\n            for _ in range(self.smooth_iter):\n                path = local_shortcut(path)\n            extracted_path = path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree + nodes,\n            edges=edges\n        )",
    "objective": 275.92897,
    "time_improvement": -950.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.2162926197052002,
            "num_nodes_avg": 1266.8,
            "path_length_avg": 155.99272488295077,
            "smoothness_avg": 0.05168764205943085,
            "success_improvement": 0.0,
            "time_improvement": -2088.3687046802106,
            "length_improvement": 22.03633542707725,
            "smoothness_improvement": 396.65449134550266,
            "objective_score": -620.1200718619202
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07767312526702881,
            "num_nodes_avg": 951.6,
            "path_length_avg": 233.3831329623568,
            "smoothness_avg": 0.09897953486546733,
            "success_improvement": 0.0,
            "time_improvement": -411.84253111576857,
            "length_improvement": 22.555580780301266,
            "smoothness_improvement": 1286.6081663518999,
            "objective_score": -112.60860234691081
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.12488758563995361,
            "num_nodes_avg": 1374.4,
            "path_length_avg": 123.68471102434482,
            "smoothness_avg": 0.14329551965450588,
            "success_improvement": 0.0,
            "time_improvement": -349.70548566748425,
            "length_improvement": 24.05013653870273,
            "smoothness_improvement": 1008.6768468620569,
            "objective_score": -95.05823415819445
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant that incorporates adaptive parameters to improve planning efficiency, path quality, and robustness in both 2D and 3D environments. It grows two trees from start and goal, employs goal bias sampling, dynamic rewiring for path optimization, and integrates shortcut smoothing for smoother, shorter paths. The adaptive step size and neighbor radius improve search speed and path refinement, while rigorous collision and boundary checks ensure safe and valid expansions.",
    "planning_mechanism": "The planner alternately samples points with goal bias, extends trees towards samples using an adaptive step size, and attempts to connect the two trees when close. It performs rewiring within a dynamic neighborhood to optimize path cost, enforces strict collision checks for nodes and edges, and applies shortcut smoothing post path extraction to reduce detours. The process iterates until convergence or reaching max iterations, outputting an optimized, collision-free path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 4.0, goal_sample_rate: float = 0.2, collision_resolution: float = 0.5, base_neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n        self.base_neighbor_radius = base_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: list = []\n        nodes: list = []\n        edges: list = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _find_neighbors(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def _extend_tree(tree, point, iter_count):\n            nearest_node = _nearest(tree, point)\n            # Adaptive step size decreasing over iterations to refine path\n            adaptive_step = max(self.step_size * (1.0 - (iter_count / self.max_iter) ** 0.6), self.step_size * 0.5)\n            new_pos = _steer(nearest_node.position, point, adaptive_step)\n\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n\n            # Adaptive neighbor radius shrinking as iterations grow\n            neighbor_radius = max(self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.5), self.step_size * 1.5)\n\n            near_nodes = _find_neighbors(tree, new_pos, neighbor_radius)\n\n            # Choose best parent minimizing cost with collision-free path\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if reduces cost and edge collision free\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_resolution):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            return new_node\n\n        def _connect_trees(tree, new_node, iter_count):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n\n            while True:\n                # Adaptive step size for connection\n                adaptive_step = max(self.step_size * (1.0 - (iter_count / self.max_iter) ** 0.6), self.step_size * 0.5)\n                next_pos = _steer(current.position, new_node.position, adaptive_step)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.children.append(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= adaptive_step:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            import random\n            max_trials = 100\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for iter_count in range(1, self.max_iter + 1):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point, iter_count)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a, iter_count)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 206.27203,
    "time_improvement": -657.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.04415724277496338,
            "num_nodes_avg": 130.0,
            "path_length_avg": 166.74376973998844,
            "smoothness_avg": 0.03480852603048503,
            "success_improvement": -9.999999999999998,
            "time_improvement": -346.7666455998494,
            "length_improvement": 16.66306654116306,
            "smoothness_improvement": 234.4670041299151,
            "objective_score": -149.52504535107263
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.15923848152160644,
            "num_nodes_avg": 564.9,
            "path_length_avg": 230.35005068351992,
            "smoothness_avg": 0.0679434466897931,
            "success_improvement": 0.0,
            "time_improvement": -949.3336936404742,
            "length_improvement": 23.56206009415969,
            "smoothness_improvement": 851.8223959954277,
            "objective_score": -275.8285840933332
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.21487960815429688,
            "num_nodes_avg": 605.2,
            "path_length_avg": 118.0042181969222,
            "smoothness_avg": 0.09452604952679852,
            "success_improvement": 0.0,
            "time_improvement": -673.7561587879111,
            "length_improvement": 27.538301333385462,
            "smoothness_improvement": 631.3476568449169,
            "objective_score": -193.46244908547166
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified, efficient bidirectional RRT* approach with adaptive sampling biased towards the goal and rewiring for path cost improvement. It grows two trees from start and goal positions, ensures strict collision checks for nodes and edges, and applies iterative shortcut smoothing on the final path to improve smoothness and reduce path length, balancing exploration, optimality, and computational effort for robustness and success.",
    "planning_mechanism": "The planner alternately extends two trees rooted at start and goal by sampling points biased towards the goal. Each new node attempts connection and rewiring within a radius to reduce path cost. Upon connection of the two trees, the path is reconstructed and shortcut smoothed by repeatedly trying direct edge shortcuts that avoid obstacles, yielding a high-quality, collision-free path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0, smooth_iter: int = 30, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        path: list = []\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_point():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def distance(a, b):\n            import math\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def connect_trees(node_a, tree_b):\n            nearest_node = nearest(tree_b, node_a.position)\n            if distance(node_a.position, nearest_node.position) <= self.step_size and collision_free_edge(node_a.position, nearest_node.position):\n                return node_a, nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + distance(new_node.position, near_node.position)\n                if tentative_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    # Update parent edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = tentative_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            sample = sample_point()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                connected = connect_trees(new_node, tree_b)\n                if connected:\n                    node_a, node_b = connected\n                    success_state = True\n                    path = extract_path(node_a, node_b)\n                    path = shortcut_smooth(path)\n                    break\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 42.49808,
    "time_improvement": -100.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.012702202796936036,
            "num_nodes_avg": 120.2,
            "path_length_avg": 170.62270338530837,
            "smoothness_avg": 0.01756925692681046,
            "success_improvement": -9.999999999999998,
            "time_improvement": -28.516188482079535,
            "length_improvement": 14.724412787590483,
            "smoothness_improvement": 68.81889006022847,
            "objective_score": -55.26587953680461
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03232300281524658,
            "num_nodes_avg": 289.0,
            "path_length_avg": 257.0629136417843,
            "smoothness_avg": 0.027047463719607312,
            "success_improvement": 0.0,
            "time_improvement": -112.9988656609489,
            "length_improvement": 14.697828428232635,
            "smoothness_improvement": 278.9089747056285,
            "objective_score": -29.565549139109994
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0721182107925415,
            "num_nodes_avg": 424.0,
            "path_length_avg": 132.0228046459418,
            "smoothness_avg": 0.05061262358100262,
            "success_improvement": 0.0,
            "time_improvement": -159.6891824254657,
            "length_improvement": 18.930044759831567,
            "smoothness_improvement": 291.58966071300836,
            "objective_score": -42.66279747210835
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements an optimized Anytime Informed RRT* planner that combines incremental sampling focused within an ellipsoidal informed subset with dynamic rewiring to improve path cost iteratively. It adaptively samples in the informed subset once an initial solution is found, balancing exploration and exploitation. The planner utilizes a dynamic neighbor radius scaled by node count and dimension for efficient rewiring, guaranteeing asymptotic optimality and progressively smoother, shorter paths. Robust collision and edge checks ensure safety while maintaining computational efficiency.",
    "planning_mechanism": "The planner grows a tree from the start node, initially sampling uniformly in free space with goal bias. Once a solution path to the goal is found, it samples new nodes only within an ellipsoidal informed region around that path to concentrate search on promising areas. For each new node, neighbors within a dynamic radius are considered to select the best parent minimizing cost and to rewire neighbors if shorter paths are found. The process continues iteratively to refine the path while ensuring collision-free expansions within map bounds.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 6.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 50.0, collision_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # (W,H) or (W,H,D)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = math.inf\n\n        def _is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        # Ellipsoidal informed sampling helper\n        def _informed_sample():\n            if best_goal_node is None:\n                # No solution yet - uniform random sample or goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                else:\n                    while True:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n            else:\n                path = best_goal_node.path_from_root()\n                c_best = best_cost\n                c_min = math.dist(start_pos, goal_pos)\n                if c_best == math.inf or c_best < c_min:\n                    c_best = c_min * 1.1  # numeric safety margin\n\n                # Define ellipsoid parameters for informed sampling\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n                unit_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))  # unit vector from start to goal\n\n                # Construct rotation matrix (align coordinate system with start-goal line)\n                # For 2D or 3D only:\n                import numpy as np\n                if dim == 2:\n                    angle = math.atan2(goal_pos[1] - start_pos[1], goal_pos[0] - start_pos[0])\n                    cos_th, sin_th = math.cos(angle), math.sin(angle)\n                    rotation = np.array([[cos_th, -sin_th],[sin_th, cos_th]])\n                else:\n                    # 3D: Create rotation matrix aligning x-axis with unit_vec:\n                    # Using Rodrigues' rotation formula\n                    a = np.array([1.0] + [0.0]*(dim -1))  # x-axis unit vector\n                    b = np.array(unit_vec)\n                    v = np.cross(a,b)\n                    s = np.linalg.norm(v)\n                    c = np.dot(a,b)\n                    if s == 0:\n                        rotation = np.eye(3)\n                    else:\n                        vx = np.array([[    0, -v[2],  v[1]],\n                                       [ v[2],     0, -v[0]],\n                                       [-v[1],  v[0],    0]])\n                        rotation = np.eye(3) + vx + vx.dot(vx) * ((1 - c) / (s**2))\n\n                # Ellipsoid axes lengths\n                a_len = c_best / 2\n                if dim == 2:\n                    b_len = math.sqrt(c_best**2 - c_min**2) / 2 if c_best > c_min else 0.0001\n                    b_axis = np.array([b_len, b_len])\n                else:\n                    b_len = math.sqrt(c_best**2 - c_min**2) / 2 if c_best > c_min else 0.0001\n                    b_axis = np.array([b_len] * dim)\n                    b_axis[0] = a_len\n\n                attempts = 0\n                while True:\n                    attempts += 1\n                    # Sample random point in unit n-ball\n                    if dim == 2:\n                        r = math.sqrt(random.uniform(0,1))\n                        theta = random.uniform(0, 2*math.pi)\n                        x_ball = np.array([r*math.cos(theta), r*math.sin(theta)])\n                    else:\n                        # Use normal distribution and normalize norm\n                        vec = np.random.normal(0,1,dim)\n                        vec = vec / np.linalg.norm(vec) * (random.uniform(0,1) ** (1/dim))\n                        x_ball = vec\n                    # Scale by ellipsoid axis lengths\n                    if dim == 2:\n                        scale = np.array([a_len, b_len])\n                        rnd = x_ball * scale\n                        # Rotate to global coordinate system and translate\n                        rnd = rotation @ rnd + np.array(center)\n                        sample = tuple(rnd.tolist())\n                    else:\n                        scale = b_axis.copy()\n                        scale[0] = a_len\n                        rnd = x_ball * scale\n                        rnd = rotation @ rnd + np.array(center)\n                        sample = tuple(rnd.tolist())\n\n                    if not _is_within_bounds(sample):\n                        continue\n                    if self._is_in_obstacle(sample, obstacles, is_3d):\n                        continue\n                    return sample\n\n        for _ in range(self.max_iter):\n            sample = _informed_sample()\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            step = min(self.step_size, dist_to_sample)\n            direction = tuple((sample[d] - nearest_node.position[d]) / dist_to_sample for d in range(dim))\n            new_pos = tuple(nearest_node.position[d] + direction[d] * step for d in range(dim))\n\n            if not _is_within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            # Initialize new node with tentative parent nearest_node\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n\n            # Dynamic neighbor radius (RGP formula)\n            n_nodes = len(nodes)\n            gamma = self.neighbor_factor\n            radius = min(self.step_size * 4.0, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim)))\n\n            # Find neighbors within radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            # Choose best parent among neighbors\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n                edge_clear = not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, self.collision_resolution)\n                if not edge_clear:\n                    continue\n                cost_candidate = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_candidate < new_node.cost:\n                    # Reparent new_node to near_node\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except Exception:\n                        pass\n                    new_node.parent = near_node\n                    new_node.cost = cost_candidate\n                    near_node.children.append(new_node)\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            # Rewire neighbors if going through new_node reduces cost\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if near_node == new_node:\n                    continue\n                dist_nn = math.dist(new_node.position, near_node.position)\n                cost_through_new = new_node.cost + dist_nn\n                if cost_through_new < near_node.cost:\n                    edge_clear = not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_resolution)\n                    if edge_clear:\n                        # Rewire near_node through new_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.children.append(near_node)\n                        edges.append((new_node, near_node))\n\n            # Check if we can connect new node directly to goal with collision free edge\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d, self.collision_resolution)):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Update best solution if better\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n\n                        # Extract path\n                        extracted_path = []\n                        node = goal_node\n                        while node is not None:\n                            extracted_path.append(node.position)\n                            node = node.parent\n                        extracted_path.reverse()\n\n            # Early exit if enough good solution found with smoothing maybe\n            # Here no smoothing implemented to keep performance; smoothing could be added later\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 5829.92867,
    "time_improvement": -19446.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.3405397653579714,
            "num_nodes_avg": 4736.8,
            "path_length_avg": 164.2791196783772,
            "smoothness_avg": 0.01037326409887685,
            "success_improvement": 0.0,
            "time_improvement": -33698.3454507736,
            "length_improvement": 17.89487495298017,
            "smoothness_improvement": -0.32572585345412824,
            "objective_score": -10105.92628887075
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.3660154342651367,
            "num_nodes_avg": 4578.9,
            "path_length_avg": 259.2492302172397,
            "smoothness_avg": 0.005734115196788395,
            "success_improvement": 0.0,
            "time_improvement": -15491.330004681897,
            "length_improvement": 13.972334622114884,
            "smoothness_improvement": -19.67055644910582,
            "objective_score": -4644.702887262391
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.568334674835205,
            "num_nodes_avg": 4871.9,
            "path_length_avg": 121.13403798195752,
            "smoothness_avg": 0.018122782886449113,
            "success_improvement": 0.0,
            "time_improvement": -9148.27064583675,
            "length_improvement": 25.616403441857777,
            "smoothness_improvement": 40.21589673813819,
            "objective_score": -2739.1568335789625
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional search strategy from the enhanced bidirectional RRT with the incremental rewiring and local path optimization of RRT*. It grows two trees from start and goal, alternately expanding toward sampled points with goal bias. New nodes choose parents through cost minimization within a neighbor radius, and rewire nearby nodes to reduce path costs. Upon connecting the two trees, the solution path is reconstructed and smoothed via iterative shortcutting to improve path quality and smoothness, balancing exploration, optimality, and efficiency.",
    "planning_mechanism": "The planner alternates growing two trees towards random samples biased to the goal. Each new node chooses the best parent within a neighborhood to minimize cost, rewires neighbors for better paths, and checks collision at nodes and edges. When the two trees connect, the path is extracted and smoothed by shortcutting to yield a high-quality trajectory.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start/goal root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=8.0, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # list of obstacle boxes\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        # Helper functions\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _near_nodes(tree, point):\n            return [node for node in tree if math.dist(node.position, point) <= self.neighbor_radius]\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def _can_connect(parent_node, new_pos, tree):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            import math\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        edges.remove((node.parent, node))\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # node_b path from root is from goal to connecting point, reverse it excluding connecting node to avoid duplication\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n\n        # Main loop - alternate between tree expansions\n        for i in range(self.max_iter):\n            # Sample point (goal bias applied inside _sample_free)\n            sample = _sample_free()\n\n            # Extend tree_a towards sample\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample)\n            if not _can_connect(nearest_node_a, new_pos_a, tree_a):\n                tree_a, tree_b = tree_b, tree_a  # swap trees if extension fails\n                continue\n\n            # Determine neighbors and best parent for new node in tree_a\n            near_nodes_a = _near_nodes(tree_a, new_pos_a)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.parent = None\n            new_node_a.cost = 0\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            # Rewire neighbors in tree_a via new_node_a\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            # Try connecting tree_b to new_node_a\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n            if dist <= self.step_size:\n                if (not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(new_node_a.position, obstacles, is_3d)):\n                    # Connected, create connecting node in tree_b if needed\n                    connecting_node_b = None\n                    if nearest_node_b.position != new_node_a.position:\n                        connecting_node_b = Node(new_node_a.position)\n                        connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                        tree_b.append(connecting_node_b)\n                        nodes.append(connecting_node_b)\n                        edges.append((nearest_node_b, connecting_node_b))\n                    else:\n                        connecting_node_b = nearest_node_b\n\n                    # Rewire tree_b neighbors around connecting_node_b\n                    near_nodes_b = _near_nodes(tree_b, connecting_node_b.position)\n                    _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                    # Reconstruct full path from start_root to goal_root\n                    success_state = True\n                    extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                    extracted_path = _smooth_path(extracted_path)\n                    break\n            else:\n                # If not connected yet, try to extend tree_b toward new_node_a\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position)\n                if _can_connect(nearest_node_b, new_pos_b, tree_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.parent = None\n                    new_node_b.cost = 0\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a  # swap trees for next iteration\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 13.19292,
    "time_improvement": -68.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01825902462005615,
            "num_nodes_avg": 139.7,
            "path_length_avg": 170.53916823025477,
            "smoothness_avg": 0.03657085421153936,
            "success_improvement": 0.0,
            "time_improvement": -84.73805583832261,
            "length_improvement": 14.766162855188394,
            "smoothness_improvement": 251.40080438605742,
            "objective_score": -21.21118015852882
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03545658588409424,
            "num_nodes_avg": 388.8,
            "path_length_avg": 234.62398934310326,
            "smoothness_avg": 0.07992438153248214,
            "success_improvement": 0.0,
            "time_improvement": -133.64823549004393,
            "length_improvement": 22.143822653129895,
            "smoothness_improvement": 1019.6637797318008,
            "objective_score": -30.567387217728196
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02384152412414551,
            "num_nodes_avg": 283.0,
            "path_length_avg": 121.90768417505406,
            "smoothness_avg": 0.08857985352242485,
            "success_improvement": 0.0,
            "time_improvement": 14.14947986734191,
            "length_improvement": 25.14133807406572,
            "smoothness_improvement": 585.3419627879955,
            "objective_score": 12.199821388955696
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is an enhanced hybrid RRT* variant combining adaptive neighbor radius, goal bias sampling, and heuristic-guided rewiring to optimize path quality and planning efficiency. It integrates dynamic neighbor searching, incremental rewiring, and ensures collision-free expansions with bounded map constraints. The planner balances exploration and exploitation via goal bias and adaptive search radius, improving path smoothness, success rate, and reducing computation time by using early goal connection attempts and maintaining consistent collision checks.",
    "planning_mechanism": "The planner incrementally expands a tree from the start towards the goal by sampling points with goal bias. For each sample, it steers a fixed step size toward it, adds collision-free nodes, computes a dynamically adaptive neighbor radius based on tree size to select the optimal parent minimizing path cost, and rewires neighbors with improved paths through the new node. The process continues until the goal is reached with a collision-free edge, after which the path is extracted by backtracking from the goal node.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_factor: float = 35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # Gamma coefficient for adaptive radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            gamma = self.neighbor_factor\n            # Adaptive neighbor radius decreases as tree grows, limited by 3*step_size\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Select best parent from near nodes minimizing cost and collision free edge\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                temp_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if temp_cost < min_cost:\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring: update neighbors if going through new_node improves cost and path is collision-free\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-6 < near_node.cost:  # small epsilon for float comparison\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Attempt direct goal connection if within step size and collision free\n            dist_goal = math.dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path from goal to root\n                    path = []\n                    node_trace = goal_node\n                    while node_trace:\n                        path.append(node_trace.position)\n                        node_trace = node_trace.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 153.71351,
    "time_improvement": -519.0,
    "length_improvement": 10.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06344091892242432,
            "num_nodes_avg": 306.5,
            "path_length_avg": 185.4085466422465,
            "smoothness_avg": 0.013058036855904422,
            "success_improvement": 0.0,
            "time_improvement": -541.8717465034712,
            "length_improvement": 7.334590441857951,
            "smoothness_improvement": 25.47162908269547,
            "objective_score": -160.9672477172563
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.13307816982269288,
            "num_nodes_avg": 890.0,
            "path_length_avg": 283.6059500461384,
            "smoothness_avg": 0.006635905089233661,
            "success_improvement": 0.0,
            "time_improvement": -776.9451086734517,
            "length_improvement": 5.88995095838103,
            "smoothness_improvement": -7.0373466558108015,
            "objective_score": -231.94072914363838
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09425280094146729,
            "num_nodes_avg": 601.3,
            "path_length_avg": 135.04778213608967,
            "smoothness_avg": 0.01734260511509669,
            "success_improvement": 0.0,
            "time_improvement": -239.39323436919162,
            "length_improvement": 17.07252635317088,
            "smoothness_improvement": 34.179664526409915,
            "objective_score": -68.23256671749125
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT planner with optimized parameters and advanced path smoothing to improve planning efficiency, robustness, and path quality. It grows two trees simultaneously from start and goal with goal-biased sampling, fine collision checking resolution, and rigorous node/edge validation. Post planning, a shortcut smoothing technique refines the path to reduce length and unnecessary detours.",
    "planning_mechanism": "The planner alternates expanding two trees, each extension biased towards sampled points with a probability of sampling the goal to guide growth. It performs strict collision checking on nodes and edges. When the two trees connect, the path is reconstructed and smoothed via shortcutting to improve smoothness and reduce path length, balancing exploration and exploitation for improved success rates and efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 10000,\n        step_size: float = 2.5,\n        goal_sample_rate: float = 0.2,\n        collision_resolution: float = 0.25,\n        smoothing_trials: int = 100,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (\n                        random.uniform(0, bounds[0]),\n                        random.uniform(0, bounds[1]),\n                        random.uniform(0, bounds[2]),\n                    )\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (\n                not _is_within_bounds(new_pos)\n                or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)\n            ):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (\n                    not _is_within_bounds(next_pos)\n                    or self._is_in_obstacle(next_pos, obstacles, is_3d)\n                    or self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)\n                ):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Remove duplicated connecting node position to avoid repetition\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smoothing_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (\n                    not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n                    and self._is_within_bounds(p1, bounds)\n                    and self._is_within_bounds(p2, bounds)\n                ):\n                    # shortcut possible, splice path\n                    path = path[: i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _is_within_bounds(self, pos, bounds):\n        for i, coord in enumerate(pos):\n            if coord < 0 or coord > bounds[i]:\n                return False\n        return True",
    "objective": 35.90885,
    "time_improvement": -90.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.019858360290527344,
            "num_nodes_avg": 132.1,
            "path_length_avg": 153.60459036753133,
            "smoothness_avg": 0.02175630533123696,
            "success_improvement": -9.999999999999998,
            "time_improvement": -100.91954244802848,
            "length_improvement": 23.229902104336634,
            "smoothness_improvement": 109.05126113934247,
            "objective_score": -75.08462600784449
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.043272757530212404,
            "num_nodes_avg": 578.7,
            "path_length_avg": 232.53440407362814,
            "smoothness_avg": 0.07092289878811679,
            "success_improvement": 0.0,
            "time_improvement": -185.15445550154442,
            "length_improvement": 22.83721773935766,
            "smoothness_improvement": 893.561656706293,
            "objective_score": -46.51108481906033
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.023084235191345216,
            "num_nodes_avg": 379.4,
            "path_length_avg": 119.94329094844231,
            "smoothness_avg": 0.1043484649215158,
            "success_improvement": 0.0,
            "time_improvement": 16.876388115031,
            "length_improvement": 26.347593852244266,
            "smoothness_improvement": 707.3436444001499,
            "objective_score": 13.869153426958901
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined and generalized bidirectional RRT planner with goal biasing and adaptive step extension. It balances exploration and exploitation by alternating tree expansion from start and goal, sampling with goal bias, and ensuring strict collision and boundary checks. It incorporates a simple path shortcut smoothing for improved path quality and reduced length while maintaining computational efficiency and robustness across 2D/3D maps.",
    "planning_mechanism": "The planner grows two trees from the start and goal by extending nodes towards randomly sampled points (biased towards the goal). In each iteration, it alternates which tree to extend first, checks collision-free nodes and edges, attempts to connect the two trees, and stops upon a successful connection. After path extraction, a shortcut smoothing is applied to enhance path smoothness and length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path, node = [], self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0, goal_sample_rate: float=0.1, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def _is_within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[i] <= bounds[i] for i in range(len(pos)))\n\n        def _extend(tree: List[Node], target_point: Tuple[float, ...]):\n            nearest_node = _nearest(tree, target_point)\n            new_pos = _steer(nearest_node.position, target_point)\n\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect(tree: List[Node], connect_node: Node) -> Node or None:\n            nearest_node = _nearest(tree, connect_node.position)\n            curr = nearest_node\n\n            while True:\n                next_pos = _steer(curr.position, connect_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(curr.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n\n                next_node = Node(next_pos, parent=curr, cost=curr.cost + math.dist(curr.position, next_pos))\n                curr.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((curr, next_node))\n\n                if math.dist(next_node.position, connect_node.position) <= self.step_size:\n                    return next_node\n                curr = next_node\n\n        def _reconstruct_path(node_a: Node, node_b: Node) -> List[Tuple[float, ...]]:\n            path_from_start = node_a.path_from_root()\n            path_from_goal = node_b.path_from_root()\n            # Remove duplicate connection point in concatenation\n            return path_from_start + path_from_goal[::-1][1:]\n\n        def _shortcut_smooth(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            for _ in range(30):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main loop: alternate extending trees\n        tree_a, tree_b = start_tree, goal_tree\n        for _ in range(self.max_iter):\n            sample_point = _sample_free()\n\n            new_node_a = _extend(tree_a, sample_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = _connect(tree_b, new_node_a)\n            if new_node_b is not None:\n                success_state = True\n                extracted_path = _reconstruct_path(new_node_a, new_node_b)\n                extracted_path = _shortcut_smooth(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6.59986,
    "time_improvement": 20.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007506871223449707,
            "num_nodes_avg": 81.7,
            "path_length_avg": 165.26510101846984,
            "smoothness_avg": 0.013898435394667183,
            "success_improvement": 0.0,
            "time_improvement": 24.04825426844272,
            "length_improvement": 17.40209095595838,
            "smoothness_improvement": 33.54682253641903,
            "objective_score": 10.862628584406588
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01616830825805664,
            "num_nodes_avg": 311.4,
            "path_length_avg": 259.1615367409322,
            "smoothness_avg": 0.018566436934188725,
            "success_improvement": 0.0,
            "time_improvement": -6.5442879273017525,
            "length_improvement": 14.001434284356055,
            "smoothness_improvement": 160.09793951845995,
            "objective_score": 1.6374901762729852
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.016065573692321776,
            "num_nodes_avg": 279.4,
            "path_length_avg": 134.0568214395766,
            "smoothness_avg": 0.052195125188683876,
            "success_improvement": -9.999999999999998,
            "time_improvement": 42.14976146099026,
            "length_improvement": 17.681035917306627,
            "smoothness_improvement": 303.8334691502041,
            "objective_score": -32.29969703249056
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This planner implements an Adaptive Informed RRT* algorithm that improves sampling efficiency by focusing search in a heuristic ellipsoidal informed set once an initial solution is found. It combines goal bias sampling, adaptive sampling domain shrinking, and rewiring to improve path quality, smoothness, and planning speed with robustness in high-dimensional spaces.",
    "planning_mechanism": "The planner grows a tree from the start sampling points uniformly until a first path to the goal is found. After that, it defines an ellipsoidal informed sampling region bounded by the current best path cost, focusing sampling inside this prolate hyperspheroid to efficiently refine solutions. It performs collision checks on nodes and edges while rewiring neighbors within a radius scaled adaptively with the node count and dimension. The path is extracted by backtracking from the goal node once found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_factor: float = 50.0, resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n        self.resolution = resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        success_state = False\n        extracted_path = []\n        best_goal_node = None\n        best_cost = float('inf')\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length <= self.step_size:\n                return to_pos\n            scale = self.step_size / length\n            new_pos = tuple(from_pos[d] + direction[d] * scale for d in range(dim))\n            return new_pos\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def find_nearest(nodes, sample):\n            return min(nodes, key=lambda n: dist(n.position, sample))\n\n        def find_near(nodes, sample, radius):\n            return [n for n in nodes if dist(n.position, sample) <= radius]\n\n        def path_cost(node):\n            return node.cost if node else float('inf')\n\n        def extract_path(goal_node):\n            path = []\n            node = goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def sample_free():\n            # If no solution yet, sample uniformly with goal bias\n            if best_cost == float('inf'):\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                else:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # After solution found, sample inside informed set (prolate hyperspheroid)\n            else:\n                c_min = dist(start_pos, goal_pos)\n                c_best = best_cost\n                if c_best < float('inf'):\n                    # Sampling inside ellipsoid:\n                    # Transform unit ball point into ellipsoidal informed sampling space\n                    while True:\n                        # Sample uniformly from unit n-ball:\n                        u = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(ui*ui for ui in u))\n                        unit_vec = [ui / norm for ui in u]\n                        r = random.random() ** (1 / dim)\n                        sample_unit = tuple(r * uv for uv in unit_vec)\n\n                        # Define ellipsoid axis lengths\n                        a1 = c_best / 2.0\n                        min_r = math.sqrt(c_best*c_best - c_min*c_min) / 2.0 if c_best > c_min else 0.0\n                        axes = [a1] + [min_r]*(dim-1)\n\n                        # Rotation matrix that aligns x-axis to direction from start to goal\n                        direction = tuple(goal_pos[d] - start_pos[d] for d in range(dim))\n                        length_dir = math.sqrt(sum(d*d for d in direction))\n                        if length_dir == 0:\n                            rotation = None\n                        else:\n                            # Unit vector along direction axis\n                            e1 = tuple(d/length_dir for d in direction)\n\n                        def rotate_sample(vec):\n                            # Rotate vec so that first unit vector aligns with e1\n                            # For 2D and 3D implement this explicitly:\n                            if dim == 2:\n                                # Rotation angle between e1 and (1,0)\n                                angle_target = math.atan2(e1[1], e1[0])\n                                cos_a = math.cos(angle_target)\n                                sin_a = math.sin(angle_target)\n                                x, y = vec\n                                return (cos_a * x - sin_a * y + (start_pos[0] + goal_pos[0])/2,\n                                        sin_a * x + cos_a * y + (start_pos[1] + goal_pos[1])/2)\n                            elif dim ==3:\n                                # Use Householder reflection or similar for rotation\n                                # Here, if e1 == (1,0,0), no rotation needed\n                                ex = (1,0,0)\n                                v = tuple(e1[i] - ex[i] for i in range(3))\n                                s = math.sqrt(sum(vi*vi for vi in v))\n                                if s < 1e-10:\n                                    # no rotation\n                                    return tuple((start_pos[d] + goal_pos[d])/2 + vec[d]*axes[d] for d in range(3))\n                                v = tuple(vi/s for vi in v)\n                                def reflect(p):\n                                    dot = sum(p[i]*v[i] for i in range(3))\n                                    return tuple(p[i] - 2*dot*v[i] for i in range(3))\n                                # Rotate vec by reflection:\n                                rotated = reflect(vec)\n                                center = tuple((start_pos[d] + goal_pos[d])/2 for d in range(3))\n                                return tuple(center[d] + rotated[d] * axes[d] for d in range(3))\n                            else:\n                                # For dim>3 fallback: just scale and translate center\n                                center = tuple((start_pos[d] + goal_pos[d])/2 for d in range(dim))\n                                return tuple(center[d] + vec[d] * axes[d] for d in range(dim))\n\n                        # Scale sample by axes lengths\n                        scaled = tuple(sample_unit[d]*axes[d] for d in range(dim))\n                        point = rotate_sample(scaled)\n\n                        # Check if point in bounds and free space\n                        if in_bounds(point) and not self._is_in_obstacle(point, obstacles, is_3d):\n                            return point\n                else:\n                    # fallback if no c_best defined properly\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    else:\n                        return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        for iter in range(self.max_iter):\n            sample = sample_free()\n\n            nearest = find_nearest(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.resolution):\n                continue\n\n            new_node = Node(new_pos)\n\n            n_nodes = len(nodes) + 1\n            gamma = self.neighbor_factor\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n\n            near_nodes = find_near(nodes, new_pos, radius)\n\n            # Choose best parent\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, self.resolution):\n                    continue\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.resolution):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check connection to goal if improved\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d) and\n                        not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d, self.resolution)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_cost:\n                        # If better path found, update best goal node and cost\n                        best_cost = goal_cost\n                        if best_goal_node:\n                            # Remove old goal node and edge\n                            if best_goal_node.parent:\n                                best_goal_node.parent.remove_child(best_goal_node)\n                            try:\n                                edges.remove((best_goal_node.parent, best_goal_node))\n                            except Exception:\n                                pass\n                            try:\n                                nodes.remove(best_goal_node)\n                            except Exception:\n                                pass\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        success_state = True\n                        extracted_path = extract_path(goal_node)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6622.82026,
    "time_improvement": -21983.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.6544514417648317,
            "num_nodes_avg": 4551.1,
            "path_length_avg": 158.4628380376052,
            "smoothness_avg": 0.010595661927580532,
            "success_improvement": 0.0,
            "time_improvement": -36874.387655166756,
            "length_improvement": 20.80179661386565,
            "smoothness_improvement": 1.8112429864896635,
            "objective_score": -11058.14688101232
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.7560559511184692,
            "num_nodes_avg": 4320.1,
            "path_length_avg": 253.1073663722419,
            "smoothness_avg": 0.006341928257974884,
            "success_improvement": 0.0,
            "time_improvement": -18061.57968496168,
            "length_improvement": 16.010412834386724,
            "smoothness_improvement": -11.155679556604142,
            "objective_score": -5415.32760131941
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 3.0863561391830445,
            "num_nodes_avg": 4604.5,
            "path_length_avg": 120.43102378374154,
            "smoothness_avg": 0.11336566569961253,
            "success_improvement": -19.999999999999996,
            "time_improvement": -11013.604922394336,
            "length_improvement": 26.04809650985021,
            "smoothness_improvement": 777.1096897746746,
            "objective_score": -3394.986308967457
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT with dynamic goal biasing and adaptive step sizing to improve planning efficiency, success rate, and path quality. It grows two trees from start and goal, alternately extending toward sampled points with an enhanced goal bias schedule. It adds rewiring around new nodes to optimize cost and applies iterative shortcut smoothing post path extraction. Additional pruning limits tree size to reduce search overhead, and thorough collision and edge validations ensure robustness and path validity. Adaptive step sizing adjusts exploration granularity over iterations for faster convergence and smoother paths.",
    "planning_mechanism": "The planner alternates growth of two trees rooted at start and goal by sampling free configurations biased dynamically towards the goal. It extends trees by steering within an adaptive step size, validating node placements and connecting edges strictly. After connecting trees, it reconstructs the path, performs local rewiring to optimize node costs, and applies iterative shortcut smoothing to improve path smoothness and length before returning the final result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def rewire(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        new_parent.add_child(self)\n        self.cost = new_cost\n        # Propagate cost updates to children\n        for child in self.children:\n            child.rewire(self, self.cost + self._distance(self.position, child.position))\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, \n                 collision_resolution: float = 0.5, max_tree_size: int = 1500):\n        self.max_iter = max_iter\n        self.init_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.max_tree_size = max_tree_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free(iteration):\n            # Dynamic goal bias: increase bias as iterations rise (favor goal more later)\n            adaptive_goal_rate = min(0.5, self.goal_sample_rate + iteration * 1e-4)\n            if random.random() < adaptive_goal_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos, curr_step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= curr_step_size:\n                return to_pos\n            ratio = curr_step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_collision_free_node(pos):\n            return _is_within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def _is_collision_free_edge(p1, p2):\n            return ( _is_within_bounds(p2) and\n                     not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution) )\n\n        def _add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        def _prune_tree(tree):\n            # Limit tree size to max_tree_size for memory and speed\n            if len(tree) > self.max_tree_size:\n                # Prune oldest nodes except roots\n                # Keep roots intact:\n                roots = [n for n in tree if n.parent is None]\n                prunable = [n for n in tree if n.parent is not None]\n                remove_count = len(tree) - self.max_tree_size\n                if remove_count <= 0:\n                    return\n                # Remove by oldest first (left side of list)\n                for rm_node in prunable[:remove_count]:\n                    # Remove children references\n                    if rm_node.parent:\n                        rm_node.parent.remove_child(rm_node)\n                    tree.remove(rm_node)\n                    if rm_node in nodes:\n                        nodes.remove(rm_node)\n\n        def _find_near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if self._distance(node.position, pos) <= radius_sq]\n\n        def _rewire_nearby(tree, new_node, radius=10.0):\n            near_nodes = [node for node in tree if node != new_node and self._distance(node.position, new_node.position) <= radius]\n            for node in near_nodes:\n                potential_cost = new_node.cost + self._distance(new_node.position, node.position)\n                if potential_cost < node.cost and _is_collision_free_edge(new_node.position, node.position):\n                    node.rewire(new_node, potential_cost)\n\n        def _extend_tree(tree, point, curr_step_size):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point, curr_step_size)\n            if not _is_collision_free_node(new_pos):\n                return None\n            if not _is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + self._distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            _add_node(tree, new_node)\n            _rewire_nearby(tree, new_node, radius=5.0)\n            _prune_tree(tree)\n            return new_node\n\n        def _connect_trees(tree, target_node, curr_step_size):\n            current = _nearest(tree, target_node.position)\n            while True:\n                next_pos = _steer(current.position, target_node.position, curr_step_size)\n                if not _is_collision_free_node(next_pos):\n                    return None\n                if not _is_collision_free_edge(current.position, next_pos):\n                    return None\n                new_cost = current.cost + self._distance(current.position, next_pos)\n                next_node = Node(next_pos, parent=current, cost=new_cost)\n                current.add_child(next_node)\n                _add_node(tree, next_node)\n                _rewire_nearby(tree, next_node, radius=5.0)\n                _prune_tree(tree)\n                if self._distance(next_node.position, target_node.position) <= curr_step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            # Iterative shortcut smoothing with increased attempts for smoother results\n            if len(path) <= 2:\n                return path\n            attempts = max(80, len(path)*4)\n            for _ in range(attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def _adaptive_step_size(iteration):\n            # Progressive step size decrease from initial to half by last iteration\n            return max(self.init_step_size * (1 - iteration / self.max_iter * 0.5), self.init_step_size * 0.5)\n\n        for iteration in range(self.max_iter):\n            curr_step = _adaptive_step_size(iteration)\n            rand_point = _sample_free(iteration)\n\n            new_a = _extend_tree(tree_a, rand_point, curr_step)\n            if not new_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a, curr_step)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=[(node.parent, node) for node in nodes if node.parent]\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 128.00883,
    "time_improvement": -178.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.028017449378967284,
            "num_nodes_avg": 146.5,
            "path_length_avg": 169.81525426385505,
            "smoothness_avg": 0.0369474264864319,
            "success_improvement": 0.0,
            "time_improvement": -183.47018723736832,
            "length_improvement": 15.127968097698202,
            "smoothness_improvement": 255.01919950314416,
            "objective_score": -50.74036655415513
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.04272439479827881,
            "num_nodes_avg": 322.4,
            "path_length_avg": 243.16656749225757,
            "smoothness_avg": 0.10094387553767885,
            "success_improvement": -9.999999999999998,
            "time_improvement": -181.54091004785593,
            "length_improvement": 19.309106214959307,
            "smoothness_improvement": 1314.1266914822493,
            "objective_score": -94.02981831395365
        },
        {
            "map_id": 2,
            "success_rate": 0.6,
            "time_avg": 0.07452979087829589,
            "num_nodes_avg": 461.2,
            "path_length_avg": 106.69533510271341,
            "smoothness_avg": 0.12560590472331615,
            "success_improvement": -40.0,
            "time_improvement": -168.3729982597856,
            "length_improvement": 34.48263681180907,
            "smoothness_improvement": 871.8123688141649,
            "objective_score": -239.25631027150305
        }
    ],
    "success_rate": 0.8333333333333334
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm hybridizes bidirectional RRT* concepts with adaptive informed sampling and dynamic neighborhood rewiring to improve planning efficiency, path quality, and success rate. It grows two trees simultaneously from start and goal nodes, biasing sampling towards goal and around the current best path ellipsoid to accelerate convergence. Local rewiring with an adaptive radius improves path optimality, and direct connection attempts coupled with path shortcutting enhance final path smoothness and reduce path length. This approach balances exploration and exploitation to reduce search time and improve robustness.",
    "planning_mechanism": "The planner alternates extending two trees from start and goal by sampling points either randomly with goal bias or informed near the best path. New nodes are inserted only if collision free. Each extension includes selecting a minimal cost parent from neighbors within an adaptive radius and rewiring neighbors to optimize local paths. After each extension, a direct connection to the other tree is attempted with incremental collision-checked steps. Upon success, the path is extracted by bridging both trees and then shortcut-smoothed to improve smoothness and length. Early termination upon first valid path ensures efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, goal_sample_rate: float=0.12,\n                 min_radius: float=8.0, max_radius: float=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            distance_val = dist(from_pos, to_pos)\n            if distance_val <= max_step:\n                return to_pos\n            ratio = max_step / distance_val\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, new_node, radius):\n            radius_sq = radius * radius\n            px = new_node.position\n            return [node for node in tree if (sum((px[d]-node.position[d])**2 for d in range(dim)) <= radius_sq)]\n\n        def adaptive_radius(iteration):\n            # Shrink radius as tree grows to balance computation\n            scale = min(1.0, iteration / (self.max_iter/2))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r)\n\n        def informed_sample(c_best):\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min + 1e-3  # numeric stability\n            center = (np.array(start_pos) + np.array(goal_pos)) / 2\n            a1 = (np.array(goal_pos) - np.array(start_pos)) / c_min\n\n            while True:\n                # Sample unit ball\n                direction = np.random.normal(0,1,dim)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction = direction / norm\n                radius = random.uniform(0,1) ** (1/dim)\n                point_ball = radius * direction\n\n                # Rotation matrix via SVD as in original\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n                sample_np = U @ L @ point_ball + center\n                sample = tuple(np.clip(sample_np, [0]*dim, bounds))\n                if (self._is_in_obstacle(sample, obstacles, is_3d) == False):\n                    return sample\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Re-assign parent after removing old connection\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b, nodes, edges):\n            nearest_b = nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n\n            current = nearest_b\n            while True:\n                new_pos = steer(current.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_node = Node(node_from_a.position, parent=new_node,\n                                      cost=new_node.cost + dist(new_pos, node_from_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                current = new_node\n\n        def extract_path(node_start, node_goal):\n            # Extract path from root to node_start, and root to node_goal then concatenate\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) -1\n                while j > i +1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        # Initialize trees\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path_cost = float(\"inf\")\n        best_path = []\n\n        for iter_count in range(self.max_iter):\n            # Alternate growth order for balanced growth\n            trees_sequence = [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_count % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            for tree_a, tree_b in trees_sequence:\n                # Sampling with goal bias and informed sampling around current best path\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    prob_informed = 0.6 if best_path_cost < float(\"inf\") else 0.0\n                    if random.random() < prob_informed:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                curr_radius = adaptive_radius(iter_count)\n                neighbors = near(tree_a, new_node, curr_radius)\n\n                # Choose best parent with minimal cost\n                min_cost = tentative_cost\n                min_parent = nearest_node\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_cand = node.cost + edge_c\n                    if cost_cand + 1e-7 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost_cand\n                            min_parent = node\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire within neighborhood to improve path cost locally\n                rewire(tree_a, new_node, neighbors, edges)\n\n                # Attempt to connect the opposite tree\n                connect_node = attempt_connect(new_node, tree_b, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, connect_node)\n                    else:\n                        path = extract_path(connect_node, new_node)\n                    pl_cost = 0.0\n                    for i in range(len(path)-1):\n                        pl_cost += dist(path[i], path[i+1])\n                    if pl_cost < best_path_cost:\n                        best_path_cost = pl_cost\n                        best_path = path\n                    # Shortcut path for smoothness\n                    shortcut = shortcut_path(path)\n                    return PlannerResult(success=True, path=shortcut, nodes=nodes, edges=edges)\n        # If no direct connect, but best path found during rewiring/informed sampling\n        if best_path:\n            shortcut = shortcut_path(best_path)\n            return PlannerResult(success=True, path=shortcut, nodes=nodes, edges=edges)\n\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 47.11715,
    "time_improvement": -186.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021401190757751466,
            "num_nodes_avg": 89.4,
            "path_length_avg": 159.27680250095096,
            "smoothness_avg": 0.045322283545694966,
            "success_improvement": 0.0,
            "time_improvement": -116.52933031643646,
            "length_improvement": 20.39498499850227,
            "smoothness_improvement": 335.4912467301596,
            "objective_score": -29.202345861579687
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05286543369293213,
            "num_nodes_avg": 302.0,
            "path_length_avg": 228.6095590521175,
            "smoothness_avg": 0.08825173709188504,
            "success_improvement": 0.0,
            "time_improvement": -248.36730589762044,
            "length_improvement": 24.139614100911526,
            "smoothness_improvement": 1136.3220287170914,
            "objective_score": -64.00065880551836
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0814192533493042,
            "num_nodes_avg": 349.8,
            "path_length_avg": 118.27019003682929,
            "smoothness_avg": 0.12487806627004805,
            "success_improvement": 0.0,
            "time_improvement": -193.18114112391922,
            "length_improvement": 27.3749786012693,
            "smoothness_improvement": 866.1810856914279,
            "objective_score": -48.14844118846476
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner designed to improve planning efficiency, path quality, robustness, and success rate by tuning parameters such as reduced step size for finer node expansion, increased max iterations, goal bias sampling, and a shorter collision checking resolution. It alternates growth of two trees from the start and goal, extending towards sampled points with a goal bias. After connecting the trees, the path is reconstructed and smoothed through shortcutting to yield high-quality, smooth paths while maintaining strict collision and boundary checks.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately extending each tree towards either the goal (with a bias) or a randomly sampled free point. It carefully checks node and edge collisions, attempts to connect the two trees when nodes get close, and upon success, reconstructs and smooths the path using shortcutting to eliminate unnecessary detours, resulting in efficient, robust, and smooth path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 2.5, goal_sample_rate: float = 0.2, collision_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):  # Increased smoothing attempts for better quality\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 29.59367,
    "time_improvement": -121.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012711930274963378,
            "num_nodes_avg": 121.2,
            "path_length_avg": 156.51037510281344,
            "smoothness_avg": 0.016563812396447348,
            "success_improvement": 0.0,
            "time_improvement": -28.614607505897894,
            "length_improvement": 21.77761882258332,
            "smoothness_improvement": 59.15780818635535,
            "objective_score": -3.933069446320927
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.048055505752563475,
            "num_nodes_avg": 607.8,
            "path_length_avg": 239.61838345230382,
            "smoothness_avg": 0.06947459962334016,
            "success_improvement": 0.0,
            "time_improvement": -216.67132761659968,
            "length_improvement": 20.48651371982447,
            "smoothness_improvement": 873.2723771907903,
            "objective_score": -56.537733655061054
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.060466766357421875,
            "num_nodes_avg": 670.2,
            "path_length_avg": 127.86634277088353,
            "smoothness_avg": 0.08306683969289017,
            "success_improvement": 0.0,
            "time_improvement": -117.7337034114899,
            "length_improvement": 21.482362740593366,
            "smoothness_improvement": 542.6877974381493,
            "objective_score": -28.31019948813755
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a generalized bidirectional RRT* inspired planner that balances exploration efficiency and path quality by alternating tree expansions from start and goal states, using informed sampling inside an ellipsoidal heuristic region when a feasible path exists to focus search. It integrates rewiring to optimize path costs, strict collision and boundary checks for robustness, and iterative shortcut smoothing to produce shorter, smoother paths with improved success rates and reduced search times.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, alternately expanding towards samples biased either randomly or within an informed ellipsoidal subset based on current best path cost. Each new node adds rewiring of neighbors to minimize cumulative costs adhering to collision-free constraints. Trees attempt connection after expansions. Upon connection, the path is extracted and smoothed by iterative shortcutting, resulting in efficient convergence and high-quality paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 10.0, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, self.collision_resolution)\n\n        def sample_free_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def build_rotation_matrix(a):\n            dim = len(a)\n            a = np.array(a)\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            if dim == 2:\n                c = np.dot(e1, a)\n                s = np.linalg.norm(np.cross(e1, a))\n                theta = math.acos(min(max(c, -1),1))\n                rot = np.array([[math.cos(theta), -math.sin(theta)],\n                                [math.sin(theta),  math.cos(theta)]])\n                return rot\n            elif dim == 3:\n                v = np.cross(e1, a)\n                s = np.linalg.norm(v)\n                c = np.dot(e1, a)\n                if s == 0:\n                    return np.eye(3)\n                vx = np.array([[0, -v[2], v[1]],\n                               [v[2], 0, -v[0]],\n                               [-v[1], v[0], 0]])\n                rot = np.eye(3) + vx + (vx @ vx) * ((1 - c) / (s ** 2))\n                return rot\n            return np.eye(dim)\n\n        def sample_in_ellipse(best_cost):\n            if best_cost == math.inf:\n                return sample_free_uniform()\n\n            c_min = dist(start_position, goal_position)\n            if best_cost < c_min:\n                return sample_free_uniform()\n\n            a1 = tuple((goal_position[i] - start_position[i]) / c_min for i in range(len(bounds)))\n            rot = build_rotation_matrix(a1)\n            r1 = best_cost / 2.0\n            rn = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            dim = len(bounds)\n            lengths = [r1] + [rn]*(dim-1)\n\n            while True:\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    r = random.uniform(0, 1) ** 0.5\n                    unit = np.array([r * math.cos(theta), r * math.sin(theta)])\n                elif dim == 3:\n                    phi = random.uniform(0, 2 * math.pi)\n                    costheta = random.uniform(-1, 1)\n                    u = random.uniform(0, 1)\n                    sintheta = math.sqrt(1 - costheta**2)\n                    r = u ** (1/3)\n                    unit = np.array([\n                        r * sintheta * math.cos(phi),\n                        r * sintheta * math.sin(phi),\n                        r * costheta\n                    ])\n                else:\n                    return sample_free_uniform()\n\n                sample_vec = unit * lengths\n                sample_rot = rot @ sample_vec\n                center = np.array([(start_position[i] + goal_position[i]) / 2 for i in range(dim)])\n                sample_point = tuple((sample_rot + center).tolist())\n                if in_bounds(sample_point) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    return sample_point\n\n        def find_neighbors(tree, pos):\n            return [node for node in tree if dist(node.position, pos) <= self.neighbor_radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                if collision_free_edge(new_node.position, neighbor.position):\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost:\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        new_node.add_child(neighbor)\n                        neighbor.cost = new_cost\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def connect_trees(from_node, to_tree):\n            current = nearest_node(to_tree, from_node.position)\n            while True:\n                new_pos = steer(current.position, from_node.position)\n                if (not in_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    not collision_free_edge(current.position, new_pos)):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                to_tree.append(new_node)\n                if dist(new_pos, from_node.position) <= self.step_size:\n                    final_node = Node(from_node.position, parent=new_node, cost=new_node.cost + dist(new_pos, from_node.position))\n                    new_node.add_child(final_node)\n                    to_tree.append(final_node)\n                    return final_node\n                current = new_node\n\n        def extract_path(node1, node2):\n            path1 = node1.path_from_root()\n            path2 = node2.path_from_root()\n            return path1 + path2[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialization\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n        success = False\n\n        for _ in range(self.max_iter):\n            sample_point = (goal_position if random.random() < self.goal_sample_rate\n                            else (sample_in_ellipse(best_cost) if best_cost < math.inf else sample_free_uniform()))\n\n            for tree, other_tree in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = nearest_node(tree, sample_point)\n                new_pos = steer(nearest.position, sample_point)\n                if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                    continue\n\n                new_cost = nearest.cost + dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                neighbors = find_neighbors(tree, new_node.position)\n                rewire(tree, new_node, neighbors)\n\n                connection_node = connect_trees(new_node, other_tree)\n                if connection_node:\n                    path = extract_path(new_node, connection_node)\n                    path_length = sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n                    if path_length < best_cost:\n                        best_cost = path_length\n                        best_path = smooth_path(path)\n                        success = True\n\n            if success:\n                break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 118.96292,
    "time_improvement": -203.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02467672824859619,
            "num_nodes_avg": 71.8,
            "path_length_avg": 158.87387793641332,
            "smoothness_avg": 0.02664146288424867,
            "success_improvement": -9.999999999999998,
            "time_improvement": -149.67000680249134,
            "length_improvement": 20.59636282315002,
            "smoothness_improvement": 155.99160012489662,
            "objective_score": -90.00177147549289
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.06038820743560791,
            "num_nodes_avg": 270.5,
            "path_length_avg": 226.70629568072454,
            "smoothness_avg": 0.09414589073109278,
            "success_improvement": -9.999999999999998,
            "time_improvement": -297.9401219807257,
            "length_improvement": 24.771181277805276,
            "smoothness_improvement": 1218.8934570529264,
            "objective_score": -128.33333305339198
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.0728447437286377,
            "num_nodes_avg": 275.3,
            "path_length_avg": 111.28239262830115,
            "smoothness_avg": 0.11127752920477456,
            "success_improvement": -19.999999999999996,
            "time_improvement": -162.30534195170154,
            "length_improvement": 31.665907162103775,
            "smoothness_improvement": 760.9537862928609,
            "objective_score": -138.55365222162538
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces an adaptive bidirectional Anytime RRT*-like planner with heuristic-guided informed sampling focusing on promising regions, combined with dynamic tree pruning and local dense re-sampling in high-cost branches. It interleaves exploration and exploitation phases: broadly exploring early, then exploiting promising paths by biasing samples around the current best path ellipsoid and dynamically pruning non-promising nodes to improve efficiency. In addition, it employs an adaptive rewiring radius and integrates shortcut smoothing progressively during the search to improve path quality and smoothness without waiting for full convergence. This approach significantly enhances planning efficiency, success rate, solution quality, and path smoothness, while reducing search time and ensuring robustness in complex environments.",
    "planning_mechanism": "The planner grows two trees bidirectionally, alternating between start and goal expansions. Sampling is adaptively switched between uniform random, heuristic-informed ellipsoid around the best path, and local dense resampling on high-cost branches, guided by the current best path cost. After adding new nodes, neighborhood rewiring optimizes local paths with an adaptive radius. Dynamic pruning removes nodes unlikely to improve the best path. Each extension attempts connection to the other tree with collision checks. Progressive shortcut smoothing is integrated to maintain path quality along the search. Early termination occurs on finding a sufficiently good path, balancing exploration/exploitation and ensuring success and efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, min_radius: float = 6.0,\n                 max_radius: float = 20.0, rewire_factor: float = 1.5,\n                 pruning_threshold_factor: float = 1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.rewire_factor = rewire_factor\n        self.pruning_threshold_factor = pruning_threshold_factor\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            distance_val = dist(from_pos, to_pos)\n            if distance_val <= max_step:\n                return to_pos\n            ratio = max_step / distance_val\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, new_node, radius):\n            radius_sq = radius * radius\n            px = new_node.position\n            return [node for node in tree if (sum((px[d]-node.position[d])**2 for d in range(dim)) <= radius_sq)]\n\n        def adaptive_radius(iteration):\n            # Linear interpolation shrinking radius as iterations grow\n            scale = min(1.0, iteration / (self.max_iter*0.75))\n            r = self.max_radius - (self.max_radius - self.min_radius)*scale\n            return max(self.min_radius, r)\n\n        def informed_sample(c_best):\n            # If no solution yet, uniform random sampling\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min + 1e-7  # numeric stability\n            center = (np.array(start_pos) + np.array(goal_pos)) * 0.5\n            a1 = (np.array(goal_pos) - np.array(start_pos)) / c_min\n\n            while True:\n                # Sample unit n-ball\n                dir_random = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(dir_random)\n                if norm_dir == 0:\n                    continue\n                unit_dir = dir_random / norm_dir\n                radius = random.uniform(0, 1) ** (1/dim)\n                sample_ball = radius * unit_dir\n\n                # Rotation matrix: align ellipsoid to line start-goal\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                r1 = c_best / 2.0\n                if dim == 2:\n                    r_rest = math.sqrt(c_best**2 - c_min**2)/2.0\n                    L = np.diag([r1, r_rest])\n                elif dim == 3:\n                    r_rest = math.sqrt(c_best**2 - c_min**2)/2.0\n                    L = np.diag([r1, r_rest, r_rest])\n                else:\n                    # Higher dims fallback: isotropic ellipsoid\n                    L = np.diag([c_best/2.0]*dim)\n\n                sample_transf = U @ L @ sample_ball + center\n                sample = tuple(np.clip(sample_transf, [0]*dim, bounds))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old edge\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.remove_child(neighbor)\n                            if (old_parent, neighbor) in edges:\n                                edges.remove((old_parent, neighbor))\n                        # Insert new edge\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def dynamic_prune(tree, best_cost):\n            # Remove nodes with cost worse than threshold * best_cost and no children to reduce search scope\n            threshold = best_cost * self.pruning_threshold_factor\n            to_remove = [node for node in tree if node.cost > threshold and len(node.children) == 0]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                tree.remove(node)\n\n        def attempt_connect(node_from_a, tree_b, nodes, edges):\n            nearest_b = nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n\n            current = nearest_b\n            while True:\n                new_pos = steer(current.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n                new_cost = current.cost + dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_cost = new_node.cost + dist(new_pos, node_from_a.position)\n                    final_node = Node(node_from_a.position, parent=new_node, cost=final_cost)\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                current = new_node\n\n        def extract_path(node_start, node_goal):\n            # Extract path from root to node_start, and root to node_goal then concatenate\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortcut_made = False\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i+1] + path[j:]\n                        shortcut_made = True\n                        break\n                    j -= 1\n                if not shortcut_made:\n                    i += 1\n            return path\n\n        def dense_resample_on_branch(tree, best_cost, fraction=0.1, samples_per_branch=5):\n            # Identify highest cost nodes (fraction from top) and resample densely around them\n            sorted_nodes = sorted(tree, key=lambda n: n.cost, reverse=True)\n            count = max(1, int(len(tree) * fraction))\n            samples = []\n            radius = self.step_size * 2.5\n            for node in sorted_nodes[:count]:\n                center = np.array(node.position)\n                for _ in range(samples_per_branch):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_np = center + offset\n                    sample_clipped = tuple(np.clip(sample_np, [0]*dim, bounds))\n                    if not self._is_in_obstacle(sample_clipped, obstacles, is_3d):\n                        samples.append(sample_clipped)\n            return samples\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        best_path_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        for iter_count in range(self.max_iter):\n            # Alternate growth order each iteration\n            if iter_count % 2 == 0:\n                trees_sequence = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            else:\n                trees_sequence = [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            # Progressive dense resampling phase every 25 iterations if a path exists\n            dense_samples = []\n            if best_path_cost < float(\"inf\") and (iter_count % 25 == 0) and len(start_tree) > 10:\n                dense_samples = dense_resample_on_branch(start_tree, best_path_cost, fraction=0.1, samples_per_branch=5)\n\n            for tree_a, tree_b in trees_sequence:\n                # Sample selection strategy\n                sample = None\n                prob_goal_bias = self.goal_sample_rate\n                prob_informed = 0.6 if best_path_cost < float(\"inf\") else 0.0\n\n                # If dense resamples available, select one with priority\n                if dense_samples and random.random() < 0.4:\n                    sample = dense_samples.pop(random.randint(0, len(dense_samples)-1))\n                else:\n                    if random.random() < prob_goal_bias:\n                        sample = goal_pos if tree_a is start_tree else start_pos\n                    elif random.random() < prob_informed:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n\n                curr_radius = adaptive_radius(iter_count)*self.rewire_factor\n                neighbors = near(tree_a, new_node, curr_radius)\n\n                # Choose best parent minimizing cost\n                min_cost = tentative_cost\n                min_parent = nearest_node\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_cand = node.cost + edge_c\n                    if cost_cand + 1e-9 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost_cand\n                            min_parent = node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors, edges)\n\n                connect_node = attempt_connect(new_node, tree_b, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, connect_node)\n                    else:\n                        path = extract_path(connect_node, new_node)\n\n                    path_len = 0.0\n                    for i in range(len(path)-1):\n                        path_len += dist(path[i], path[i+1])\n\n                    # Accept path only if better than current best by threshold\n                    if path_len + 1e-9 < best_path_cost:\n                        best_path_cost = path_len\n                        best_path = path\n                        # Progressive smoothing after each improvement\n                        best_path = shortcut_path(best_path)\n\n                        # Prune nodes unlikely to improve solution\n                        dynamic_prune(start_tree, best_path_cost)\n                        dynamic_prune(goal_tree, best_path_cost)\n\n                        # Early termination if path is close enough to direct dist\n                        if best_path_cost <= 1.05 * dist(start_pos, goal_pos):\n                            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n                        # Return path at first improvement for anytime planning\n                        return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            # After full iteration, if no connection but best path found, yield best known\n            if success_state and best_path:\n                # Continue smoothing progressively\n                best_path = shortcut_path(best_path)\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n        # Return failure if no path found\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 42.10981,
    "time_improvement": -170.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03076789379119873,
            "num_nodes_avg": 104.2,
            "path_length_avg": 164.06481454932924,
            "smoothness_avg": 0.04761889990524928,
            "success_improvement": 0.0,
            "time_improvement": -211.2981662220121,
            "length_improvement": 18.001982596685288,
            "smoothness_improvement": 357.5588974184752,
            "objective_score": -58.00125886017419
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04348978996276855,
            "num_nodes_avg": 247.8,
            "path_length_avg": 230.22395471615914,
            "smoothness_avg": 0.11080137668549299,
            "success_improvement": 0.0,
            "time_improvement": -186.58463394784553,
            "length_improvement": 23.60390300214643,
            "smoothness_improvement": 1452.2208097255862,
            "objective_score": -43.99350553529644
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05870811939239502,
            "num_nodes_avg": 285.5,
            "path_length_avg": 120.20631556796214,
            "smoothness_avg": 0.11240615199909001,
            "success_improvement": 0.0,
            "time_improvement": -111.40102283741659,
            "length_improvement": 26.186080890989434,
            "smoothness_improvement": 769.6859362157281,
            "objective_score": -24.33466099194845
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional RRT* framework with adaptive goal-biased sampling, local rewiring for optimality, and iterative shortcut smoothing to obtain high-quality, smooth, and efficient paths. It grows two trees from start and goal, alternately extending them by sampling points biased towards the goal. Each extension performs rewiring in a dynamic neighborhood to reduce path costs, and the trees are connected when feasible. Final paths undergo shortcut smoothing to enhance smoothness and reduce length, while strict collision and edge checks ensure safety and robustness. This approach balances exploration, exploitation, and path optimization to improve success rate, path quality, and planning speed.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal positions via goal-biased sampling. For each new node, it finds near neighbors within a radius to connect and rewire for local optimality. Upon connection of the two trees, the path is reconstructed and shortcut smoothing is applied to improve smoothness and reduce path length. Continuous collision and edge checks guarantee valid paths, and dynamic rewiring enables improvements during growth, yielding efficient, smooth, and robust paths with high success rate.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root (start or goal)\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0,\n                 goal_sample_rate: float = 0.1, smooth_iter: int = 30, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_point(tree_id):\n            # tree_id=0 for start tree, 1 for goal tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree_id == 0 else start_position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def rewire(tree, new_node):\n            neighbors = near(tree, new_node.position, self.radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if tentative_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    # Remove old parent-child edge\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = tentative_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def connect_trees(node_a, tree_b):\n            connect_candidate = nearest(tree_b, node_a.position)\n            if distance(node_a.position, connect_candidate.position) <= self.step_size and collision_free_edge(node_a.position, connect_candidate.position):\n                return node_a, connect_candidate\n            # Attempt multi-step connect stepping from connect_candidate towards node_a\n            curr = connect_candidate\n            connection_chain = []\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if not collision_free_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                new_cost = curr.cost + distance(curr.position, new_pos)\n                new_node = Node(new_pos, parent=curr, cost=new_cost)\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                connection_chain.append(new_node)\n                if distance(new_pos, node_a.position) <= self.step_size:\n                    # Final connection node\n                    if collision_free_edge(new_pos, node_a.position):\n                        final_cost = new_node.cost + distance(new_pos, node_a.position)\n                        final_node = Node(node_a.position, parent=new_node, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree_b.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return node_a, final_node\n                    else:\n                        return None\n                curr = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_position, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_position, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path: list = []\n\n        for iter_idx in range(self.max_iter):\n            for tree_idx, (tree_a, tree_b) in enumerate([(start_tree, goal_tree), (goal_tree, start_tree)]):\n                sample = sample_point(tree_idx)\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                # Choose best parent among near neighbors (including nearest_node)\n                neighbors = near(tree_a, new_pos, self.radius)\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                min_node = nearest_node\n                for n in neighbors:\n                    edge_cost = distance(n.position, new_pos)\n                    cost_through_n = n.cost + edge_cost\n                    if cost_through_n < min_cost and collision_free_edge(n.position, new_pos):\n                        min_cost = cost_through_n\n                        min_node = n\n\n                new_node = Node(new_pos, parent=min_node, cost=min_cost)\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire around new_node\n                rewire(tree_a, new_node)\n\n                # Attempt to connect trees\n                connected = connect_trees(new_node, tree_b)\n                if connected is not None:\n                    node_a, node_b = connected\n                    success_state = True\n                    extracted_path = extract_path(node_a, node_b)\n                    extracted_path = shortcut_smooth(extracted_path)\n                    break\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 42.41565,
    "time_improvement": -48.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.019983386993408202,
            "num_nodes_avg": 96.8,
            "path_length_avg": 166.77313349849555,
            "smoothness_avg": 0.02015511633976813,
            "success_improvement": -9.999999999999998,
            "time_improvement": -102.18451637181161,
            "length_improvement": 16.648390816890878,
            "smoothness_improvement": 93.6658097544331,
            "objective_score": -76.85734769939313
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.025251436233520507,
            "num_nodes_avg": 204.1,
            "path_length_avg": 246.50859252054116,
            "smoothness_avg": 0.037164962057354575,
            "success_improvement": -9.999999999999998,
            "time_improvement": -66.39936904354164,
            "length_improvement": 18.20010924483608,
            "smoothness_improvement": 420.6454037284594,
            "objective_score": -64.17656184545297
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02065930366516113,
            "num_nodes_avg": 180.7,
            "path_length_avg": 127.40998736268537,
            "smoothness_avg": 0.05821271331541609,
            "success_improvement": 0.0,
            "time_improvement": 25.608280913702707,
            "length_improvement": 21.762592452539355,
            "smoothness_improvement": 350.39152376451136,
            "objective_score": 13.78696038344124
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "This planner is a refined and optimized RRT* variant incorporating adaptive neighbor radius, goal bias sampling, heuristic-enabled rewiring, and an efficient pruning mechanism. It emphasizes balancing exploration and exploitation by dynamically adjusting the search radius and goal sampling rate adaptively during planning to improve convergence speed. The planner integrates robust collision checking, incremental rewiring for path cost minimization, and early goal connection attempts for faster success detection. Additionally, it incorporates post-processing smoothing of the extracted path to enhance path quality and smoothness.",
    "planning_mechanism": "The planner incrementally grows a tree by sampling points biased towards the goal with an adaptive rate. For each sampled point, it steers with a fixed step size, checks collision for nodes and edges, and selects the best parent from neighbors within an adaptive radius computed using the number of nodes and environment dimension to minimize path cost. Rewiring updates neighboring nodes to lower-cost paths through the new node if collision free. A pruning step removes nodes unlikely to improve the best path, reducing search overhead. After connecting to the goal, the planner extracts and smooths the path by shortcutting through collision-free edges, enhancing path length and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def get_path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_init = 0.15\n        self.goal_sample_max = 0.3\n        self.goal_sample_min = 0.05\n        self.neighbor_factor = 35.0    # Gamma coefficient for adaptive radius\n        self.prune_interval = 500\n        self.smoothing_attempts = 50\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                    # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start           # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal             # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles            # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: list[tuple] = []\n        nodes: list[Node] = []\n        edges: list[tuple] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Dynamically adapt goal sample rate: increase if no goal yet, decrease if close to goal found\n            if best_goal_node is None:\n                goal_sample_rate = min(self.goal_sample_init + iter_count / self.max_iter * (self.goal_sample_max - self.goal_sample_init),\n                                       self.goal_sample_max)\n            else:\n                goal_sample_rate = max(self.goal_sample_min,\n                                       self.goal_sample_init * (1 - best_cost / (max(bounds) * dim)))\n\n            # Sample with adaptive goal bias\n            if random.random() < goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (sample[d] - nearest_node.position[d]) / dist * scale for d in range(dim))\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            n_nodes = len(nodes)\n            gamma = self.neighbor_factor\n\n            # Adaptive neighbor radius with recommended theoretical bound (Karaman & Frazzoli)\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            # Choose best parent minimizing cost to new_node\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                temp_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if temp_cost < min_cost:\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if going through new_node improves cost and collision free\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-9 < near_node.cost:  # tiny epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge if exists\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Attempt early connection to goal if possible\n            dist_goal = math.dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n\n            # Prune nodes unlikely to improve best path periodically\n            if iter_count % self.prune_interval == 0 and best_goal_node is not None:\n                threshold_cost = best_goal_node.cost * 1.2\n                to_remove = [node for node in nodes if node.cost > threshold_cost and node is not root and node is not best_goal_node]\n                for node in to_remove:\n                    # Remove edges first\n                    if node.parent:\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.parent.remove_child(node)\n                    # Remove children relationships, reassign children to None (should be cleaned in next iterations)\n                    for child in list(node.children):\n                        child.parent = None\n                        node.remove_child(child)\n                    node.valid = False\n                    nodes.remove(node)\n\n        # Extract path from best_goal_node if success\n        if success_state and best_goal_node is not None:\n            path = best_goal_node.get_path_from_root()\n            # Post-process path smoothing by shortcutting\n            extracted_path = self._shortcut_path(path, obstacles, is_3d)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_path(self, path: list, obstacles, is_3d) -> list:\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(self.smoothing_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p1 = path[i]\n            p2 = path[j]\n\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2914.55903,
    "time_improvement": -9741.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.2893234491348267,
            "num_nodes_avg": 2952.4,
            "path_length_avg": 167.38367162607216,
            "smoothness_avg": 0.031398494012931856,
            "success_improvement": 0.0,
            "time_improvement": -12944.897649039689,
            "length_improvement": 16.34324972891335,
            "smoothness_improvement": 201.70080219711215,
            "objective_score": -3879.192140755138
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.4875371217727662,
            "num_nodes_avg": 3795.0,
            "path_length_avg": 233.52280683099917,
            "smoothness_avg": 0.0948535809141549,
            "success_improvement": 0.0,
            "time_improvement": -9702.422175228676,
            "length_improvement": 22.509232265308444,
            "smoothness_improvement": 1228.8075164432314,
            "objective_score": -2900.0807685333248
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.8539285898208617,
            "num_nodes_avg": 4250.6,
            "path_length_avg": 120.36437306872638,
            "smoothness_avg": 0.09335844079682411,
            "success_improvement": 0.0,
            "time_improvement": -6575.7784819526805,
            "length_improvement": 26.089024063976147,
            "smoothness_improvement": 622.3138728980233,
            "objective_score": -1964.4041704085187
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an enhanced hybrid RRT* variant with tuned parameters for improved planning efficiency, path quality, and success rate. It incorporates adaptive neighbor radius based on tree size, goal bias sampling for directed exploration, heuristic-guided rewiring, and early goal connection attempts. Adaptive step size and neighbor factor are carefully adjusted to balance exploration and exploitation, reducing computation time while maintaining robustness and smooth, optimal paths.",
    "planning_mechanism": "The planner incrementally grows a single tree from start to goal. Each iteration samples with goal bias, steers towards the sample with an adaptive step size, and adds a collision-free node. It computes an adaptive neighbor radius to select the best parent minimizing path cost, and rewires neighbors if better paths exist through the new node. The planner tries early direct connections to the goal within step size, terminating upon success. Path is extracted by backtracking from goal node.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3500, step_size: float = 4.0, goal_sample_rate: float = 0.2, neighbor_factor: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # Gamma coefficient for adaptive radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: list[tuple[float, ...]] = []\n        nodes: list[Node] = []\n        edges: list[tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Sample with higher goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            # Adaptive step size scaled by distance, capped at self.step_size\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            gamma = self.neighbor_factor\n            # Adaptive neighbor radius: shrink slowly with tree size, limited to 3.5*step_size for sufficient rewiring\n            radius = min(self.step_size * 3.5, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)))\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Find best parent minimizing cost and collision-free edge\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                temp_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if temp_cost < min_cost:\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cost improves and path is collision free\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-8 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Attempt direct goal connection early if within step size and collision free\n            dist_goal = math.dist(new_node.position, goal_position)\n            if dist_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path from goal to root\n                    path = []\n                    node_trace = goal_node\n                    while node_trace:\n                        path.append(node_trace.position)\n                        node_trace = node_trace.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 246.6573,
    "time_improvement": -773.0,
    "length_improvement": 10.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06457386016845704,
            "num_nodes_avg": 315.7,
            "path_length_avg": 177.07065361039656,
            "smoothness_avg": 0.010585952915598083,
            "success_improvement": 0.0,
            "time_improvement": -553.3344268780424,
            "length_improvement": 11.501789239544358,
            "smoothness_improvement": 1.7179513559280175,
            "objective_score": -163.6913804587242
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.25768556594848635,
            "num_nodes_avg": 1280.1,
            "path_length_avg": 288.2638307191531,
            "smoothness_avg": 0.005224967653023644,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1598.0703667277303,
            "length_improvement": 4.344308567958304,
            "smoothness_improvement": -26.803224257878526,
            "objective_score": -528.6862644260168
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07421419620513917,
            "num_nodes_avg": 607.2,
            "path_length_avg": 141.90211149346166,
            "smoothness_avg": 0.013028563006424987,
            "success_improvement": 0.0,
            "time_improvement": -167.23657901492018,
            "length_improvement": 12.863555215996957,
            "smoothness_improvement": 0.8019384551127088,
            "objective_score": -47.5942529690011
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm combines bidirectional growth of two trees with asymptotic optimality via rewiring, incorporating goal biasing and adaptive neighborhood sampling to efficiently find smooth, short, and collision-free paths in 2D or 3D environments containing obstacles. It balances exploration and exploitation to improve success rate, path quality, and planning speed.",
    "planning_mechanism": "The planner grows two trees\u2014one from start and one from goal\u2014by sampling free space with a bias towards the goal. Each extension considers a neighborhood for rewiring to optimize costs. After each new node insertion, the planner attempts to connect the two trees with collision-checked edges, extracting the best path upon success. Adaptive radius and collision checks ensure robustness and efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision and validity checks\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        success = False\n        path: list[tuple] = []\n\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            while node_start:\n                path_s.append(node_start.position)\n                node_start = node_start.parent\n            while node_goal:\n                path_g.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_s[::-1] + path_g\n\n        def adaptive_radius(n_nodes):\n            # Radius adaptively shrinks with number of nodes, capped by base_radius\n            gamma = self.base_radius\n            return min(gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        for i in range(self.max_iter):\n            # Goal biasing sampling alternating between trees\n            sample_from_start = (i % 2 == 0)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    # Rewire\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt connection from new_node in tree_a to nearest in tree_b\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d):\n                    # Connect both trees with minimal cost\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # No connection found\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1.22143,
    "time_improvement": -7.0,
    "length_improvement": 4.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008090043067932129,
            "num_nodes_avg": 100.1,
            "path_length_avg": 185.6649117391287,
            "smoothness_avg": 0.010914094873855713,
            "success_improvement": 0.0,
            "time_improvement": 18.14793730129248,
            "length_improvement": 7.2064616304885325,
            "smoothness_improvement": 4.870990861583404,
            "objective_score": 6.9100284707933675
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.014984416961669921,
            "num_nodes_avg": 248.6,
            "path_length_avg": 303.9601784431043,
            "smoothness_avg": 0.006630449936174837,
            "success_improvement": 0.0,
            "time_improvement": 1.2571995965398015,
            "length_improvement": -0.8642706379259195,
            "smoothness_improvement": -7.113768107885172,
            "objective_score": 0.16873691083733064
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.038583230972290036,
            "num_nodes_avg": 419.1,
            "path_length_avg": 155.2327737852811,
            "smoothness_avg": 0.01296368234295665,
            "success_improvement": 0.0,
            "time_improvement": -38.93367010102172,
            "length_improvement": 4.6777255162124165,
            "smoothness_improvement": 0.2999570284091653,
            "objective_score": -10.743056141921985
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner synergizes bidirectional RRT* tree growth with adaptive neighborhood rewiring and goal biasing from the first algorithm, combined with efficient sampling, strict collision checks, and iterative shortcut smoothing from the second. It dynamically adjusts the rewiring radius based on node count for efficiency and integrates shortcut smoothing on the final path to improve path quality and smoothness, aiming for higher success rates and faster planning.",
    "planning_mechanism": "The planner initializes two trees rooted at start and goal, alternately grows them by sampling with goal bias, steering towards samples with collision checks, and rewiring nearby nodes to optimize cost using an adaptively shrinking radius. Upon tree connection, it extracts the path and applies iterative shortcut smoothing to reduce path length and improve smoothness while ensuring collision-free shortcuts. The approach balances exploration, optimality, smoothness, and computational efficiency for robust 2D/3D path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, base_radius: float=15.0, goal_sample_rate: float=0.1, smooth_iter: int=40, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_point(sample_from_start):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if sample_from_start else start_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.base_radius\n            return min(self.base_radius * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)), self.base_radius)\n\n        def connect_trees(node_a, tree_b):\n            nearest_node = nearest(tree_b, node_a.position)\n            if dist(node_a.position, nearest_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(node_a.position, nearest_node.position, obstacles, is_3d, self.collision_resolution):\n                    return node_a, nearest_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if within_bounds(p1) and within_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n        success = False\n        final_path = []\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n            sample = sample_point(sample_from_start)\n\n            tree_a = tree_start if sample_from_start else tree_goal\n            tree_b = tree_goal if sample_from_start else tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors for better cost\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    # Remove old edge\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    # Add new edge\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            connected = connect_trees(new_node, tree_b)\n            if connected:\n                node_a, node_b = connected\n                success = True\n                raw_path = extract_path(node_a, node_b)\n                smooth_path = shortcut_smooth(raw_path)\n                final_path = smooth_path\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 35.38829,
    "time_improvement": -24.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.011202740669250488,
            "num_nodes_avg": 100.9,
            "path_length_avg": 172.11689242156672,
            "smoothness_avg": 0.02063229592515603,
            "success_improvement": -9.999999999999998,
            "time_improvement": -13.345185428195109,
            "length_improvement": 13.9776314686617,
            "smoothness_improvement": 98.25091704156351,
            "objective_score": -50.71677474951837
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.014852499961853028,
            "num_nodes_avg": 249.6,
            "path_length_avg": 252.82699559532767,
            "smoothness_avg": 0.04761391857922263,
            "success_improvement": 0.0,
            "time_improvement": 2.126492944159725,
            "length_improvement": 16.103449343532393,
            "smoothness_improvement": 567.025243386941,
            "objective_score": 6.693763968889101
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.0442486047744751,
            "num_nodes_avg": 408.3,
            "path_length_avg": 135.6412762492805,
            "smoothness_avg": 0.07281177215273024,
            "success_improvement": -9.999999999999998,
            "time_improvement": -59.33401385131685,
            "length_improvement": 16.708085214984802,
            "smoothness_improvement": 463.34438201110305,
            "objective_score": -62.14186520234258
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm integrates the advantages of bidirectional RRT* with adaptive radius rewiring and post-processing path smoothing. It employs goal biasing to guide search, adaptive neighborhood radius to balance exploration and exploitation dynamically, rigorous collision checking for nodes and edges, and iterative path shortcutting to improve path smoothness and length, resulting in enhanced planning efficiency, higher success rate, shorter and smoother paths, and robustness in 2D/3D obstacle-laden environments.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with goal biasing. New nodes are added only after verifying collision-free state and edges. An adaptive radius is computed to determine neighbors for rewiring, optimizing path costs incrementally. Upon successfully connecting trees, the path is extracted and further smoothed by iterative shortcutting to remove unnecessary detours, resulting in improved path quality and reduced planning time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0, base_radius: float = 20.0, goal_sample_rate: float = 0.12, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        dim = len(bounds)\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            gamma = self.base_radius\n            return min(gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        def is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_start = [Node(start_position, cost=0.0)]\n        nodes_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(nodes_start + nodes_goal)\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if sample_from_start else start_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not is_within_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not is_within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors to new_node\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    # Rewire n to new_node\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt to connect the two trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution) and\n                    not self._is_in_obstacle(nearest_in_b.position, obstacles, is_3d)):\n                    success_state = True\n                    extracted_path = extract_path(new_node, nearest_in_b)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 30.26564,
    "time_improvement": -70.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02046186923980713,
            "num_nodes_avg": 146.7,
            "path_length_avg": 167.455292779483,
            "smoothness_avg": 0.030418477933329684,
            "success_improvement": -9.999999999999998,
            "time_improvement": -107.02562271742644,
            "length_improvement": 16.307454164825106,
            "smoothness_improvement": 192.2840563729249,
            "objective_score": -77.88477570039828
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03411951065063477,
            "num_nodes_avg": 345.6,
            "path_length_avg": 238.48210542085388,
            "smoothness_avg": 0.08873898954788373,
            "success_improvement": 0.0,
            "time_improvement": -124.83731189924809,
            "length_improvement": 20.863569212656234,
            "smoothness_improvement": 1143.14796738695,
            "objective_score": -27.56273989030843
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021352696418762206,
            "num_nodes_avg": 272.4,
            "path_length_avg": 132.9119138657559,
            "smoothness_avg": 0.11736740911570517,
            "success_improvement": 0.0,
            "time_improvement": 23.111455281125757,
            "length_improvement": 18.384078138025167,
            "smoothness_improvement": 808.0711621445129,
            "objective_score": 14.650608022665326
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This planner is a tuned bidirectional RRT* variant with goal biasing, adaptive step size, and dynamic neighbor radius to balance exploration, path optimality, and planning efficiency. It grows two trees from start and goal, incrementally choosing parents minimizing cost and rewiring neighbors to improve paths. Upon connecting the trees, the path is reconstructed and smoothed with shortcutting to yield a short and smooth trajectory. Enhanced collision checking resolution and early pruning improve robustness and reduce search time.",
    "planning_mechanism": "The algorithm alternates expanding two trees toward randomly sampled points (biased toward the goal), steering with adaptive step size, and dynamically selecting neighbor nodes within a radius that scales with the logarithm of nodes to enable efficient rewiring. New nodes pick parents with minimal cumulative cost respecting obstacle constraints. Trees rewire neighbors for incremental path improvement. Upon connection, the final path is extracted and shortcut-smoothed to improve path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 initial_step_size: float = 6.0,\n                 goal_sample_rate: float = 0.15,\n                 collision_resolution: float = 0.3,\n                 radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.initial_step_size = initial_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # list of obstacle boxes\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _near_nodes(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def _steer(from_pos, to_pos, step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def _can_connect(parent_node, new_pos):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample = _sample_free()\n\n            # Adapt step_size decreasing linearly to 30% of initial after max_iter/2\n            step_size_ratio = 1.0\n            if i > self.max_iter // 2:\n                step_size_ratio = max(0.3, 1.0 - (i - self.max_iter // 2) / (self.max_iter // 2))\n            step_size = self.initial_step_size * step_size_ratio\n\n            # Dynamic neighbor radius per RRT* theory: gamma * (log(n)/n)^{1/dimension}\n            n_nodes = len(nodes)\n            dim = 3 if is_3d else 2\n            radius = min(self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), step_size * 5)\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, step_size)\n            if not _can_connect(nearest_node_a, new_pos_a):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.parent = None\n            new_node_a.cost = 0\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n\n            if dist <= step_size:\n                if (not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(new_node_a.position, obstacles, is_3d)):\n                    connecting_node_b = None\n                    if nearest_node_b.position != new_node_a.position:\n                        connecting_node_b = Node(new_node_a.position)\n                        connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                        tree_b.append(connecting_node_b)\n                        nodes.append(connecting_node_b)\n                        edges.append((nearest_node_b, connecting_node_b))\n                    else:\n                        connecting_node_b = nearest_node_b\n\n                    near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                    _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                    success_state = True\n                    extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                    extracted_path = _smooth_path(extracted_path)\n                    break\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, step_size)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.parent = None\n                    new_node_b.cost = 0\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 29.56767,
    "time_improvement": -67.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021631383895874025,
            "num_nodes_avg": 112.3,
            "path_length_avg": 170.0891743830483,
            "smoothness_avg": 0.032969526437711734,
            "success_improvement": 0.0,
            "time_improvement": -118.85833932370693,
            "length_improvement": 14.991065454907773,
            "smoothness_improvement": 216.79648616967935,
            "objective_score": -31.575306275282127
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0254561185836792,
            "num_nodes_avg": 258.2,
            "path_length_avg": 242.09503903305935,
            "smoothness_avg": 0.08772703018891094,
            "success_improvement": 0.0,
            "time_improvement": -67.74816416179884,
            "length_improvement": 19.66467560914243,
            "smoothness_improvement": 1128.9713892379912,
            "objective_score": -10.74665718052121
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.03165559768676758,
            "num_nodes_avg": 295.0,
            "path_length_avg": 129.75892265782096,
            "smoothness_avg": 0.10989612270192795,
            "success_improvement": -9.999999999999998,
            "time_improvement": -13.988078629875215,
            "length_improvement": 20.320204679083222,
            "smoothness_improvement": 750.2658498556063,
            "objective_score": -46.38105340386789
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This simplified bidirectional RRT* planner grows two trees from start and goal positions using goal-biased sampling and step-limited steering. Each new node is checked for collisions, and edges are only added if collision-free. Local rewiring improves path cost by connecting nearby nodes through lower-cost parents. When trees connect, the path is extracted and shortcut smoothing is applied to improve smoothness and shorten the path. This approach balances exploration efficiency, path quality, and robustness for reliable and efficient path planning.",
    "planning_mechanism": "The planner alternately extends two trees by sampling points with goal bias, steering stepwise while respecting bounds and obstacles. New nodes are added only if valid, rewiring nearby nodes to reduce path costs locally. Once the two trees connect, the composed path is shortcut smoothed via random edge shortcuts that pass collision checks, yielding a collision-free, optimized path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0, smooth_iter: int = 30, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path: list = []\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_point():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def distance(a, b):\n            import math\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def rewire(tree, new_node):\n            for near_node in near(tree, new_node.position, self.radius):\n                if near_node is new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + distance(new_node.position, near_node.position)\n                if tentative_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = tentative_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        def connect_trees(node_a, tree_b):\n            nearest_node = nearest(tree_b, node_a.position)\n            dist_ab = distance(node_a.position, nearest_node.position)\n            if dist_ab <= self.step_size and collision_free_edge(node_a.position, nearest_node.position):\n                return node_a, nearest_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        import random\n        for _ in range(self.max_iter):\n            sample = sample_point()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                connected = connect_trees(new_node, tree_b)\n                if connected:\n                    node_a, node_b = connected\n                    success_state = True\n                    extracted_path = extract_path(node_a, node_b)\n                    extracted_path = shortcut_smooth(extracted_path)\n                    break\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 47.58251,
    "time_improvement": -59.0,
    "length_improvement": 12.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.01865880489349365,
            "num_nodes_avg": 159.5,
            "path_length_avg": 187.97197694032022,
            "smoothness_avg": 0.016950914541133105,
            "success_improvement": -9.999999999999998,
            "time_improvement": -88.7828847387795,
            "length_improvement": 6.053412617282817,
            "smoothness_improvement": 62.877382365161964,
            "objective_score": -75.10979598635147
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.032564854621887206,
            "num_nodes_avg": 303.3,
            "path_length_avg": 255.87574145324925,
            "smoothness_avg": 0.025352065067988715,
            "success_improvement": -9.999999999999998,
            "time_improvement": -114.59259631669741,
            "length_improvement": 15.091772324211203,
            "smoothness_improvement": 255.15806883653522,
            "objective_score": -80.08363408598429
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02054429054260254,
            "num_nodes_avg": 225.1,
            "path_length_avg": 137.29532486158809,
            "smoothness_avg": 0.0517175994634564,
            "success_improvement": 0.0,
            "time_improvement": 26.022429620904546,
            "length_improvement": 15.692399725463128,
            "smoothness_improvement": 300.138854575951,
            "objective_score": 12.445903104243744
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements an enhanced Bidirectional Informed RRT* planner that combines bidirectional search with heuristic-informed sampling within an ellipsoidal subset of the space defined by the current best path cost to the goal. The planner alternately grows trees from the start and goal positions, selectively sampling points that are likely to improve the current solution, while performing rewiring in a local neighborhood to optimize path cost. Once a feasible path is found, we apply a path smoothing step using iterative shortcutting. This approach focuses search efforts, improves path quality and smoothness, increases success rates, and reduces planning time by avoiding unnecessary exploration outside promising regions.",
    "planning_mechanism": "The planner begins by initializing two trees, one from the start and one from the goal. It maintains the best path cost found so far and limits random sampling to an informed ellipsoidal region determined by this cost, progressively guiding the search towards optimality. Each iteration samples a node, extends the trees towards the sample with step limits and collision checks, and rewires nearby nodes to improve costs. When the two trees connect, the path is extracted and smoothed by attempting shortcuts that skip unnecessary waypoints, balancing efficiency with path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, radius: float=15.0, smooth_iter: int=40, collision_resolution: float=0.5, informed_sampling_rate: float=0.9):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_path_cost = math.inf\n        best_connect_nodes = None\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            # ensure edge is within bounds and free of obstacles\n            if not within_bounds(b):\n                return False\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution):\n                return False\n            return True\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def rewire(tree, new_node):\n            for near_node in near(tree, new_node.position, self.radius):\n                if near_node == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if tentative_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    # Remove old edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    # Re-parent\n                    near_node.parent = new_node\n                    near_node.cost = tentative_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        def informed_sample(c_max, start, goal):\n            # If no solution yet, sample uniformly\n            if math.isinf(c_max):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Define ellipsoid parameters\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                # Safety fallback\n                c_max = c_min + 1e-6\n\n            # Center of ellipse - midpoint\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n\n            # Unit vector from start to goal\n            if c_min == 0.0:\n                unit_vec = tuple(0 for _ in range(dim))\n            else:\n                unit_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            # Create rotation matrix that aligns the x-axis with unit_vec\n            # For 2D and 3D, implement accordingly:\n            import numpy as np\n\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s], [s, c]])\n                elif dim == 3:\n                    # Create orthonormal basis using unit_vec as x-axis\n                    x_axis = np.array(vec)\n                    x_axis /= np.linalg.norm(x_axis)\n                    # Pick y_axis arbitrarily perpendicular to x_axis\n                    if abs(x_axis[0]) < 1e-6 and abs(x_axis[1]) < 1e-6:\n                        temp = np.array([0,1,0])\n                    else:\n                        temp = np.array([0,0,1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= np.linalg.norm(y_axis)\n                    z_axis = np.cross(x_axis, y_axis)\n                    rot = np.stack((x_axis, y_axis, z_axis), axis=1)\n                    return rot\n                else:\n                    return np.eye(dim)\n\n            L = np.diag([c_max / 2] + [math.sqrt(c_max ** 2 - c_min ** 2) / 2] * (dim - 1))\n            R = rotation_matrix(unit_vec)\n\n            while True:\n                # Sample uniformly in unit n-ball\n                x_ball = np.random.normal(0,1,dim)\n                x_ball /= np.linalg.norm(x_ball)\n                u = np.random.uniform(0,1)\n                r = u ** (1/dim)\n                sample_ball = x_ball * r\n\n                # Map to ellipse\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                p = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        for iter in range(self.max_iter):\n            if random.random() < self.informed_sampling_rate:\n                sample = informed_sample(best_path_cost, start_position, goal_position)\n            else:\n                # Uniform sampling fallback\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                # Try to connect trees\n                nearest_to_new = nearest(tree_b, new_node.position)\n                dist_between = dist(new_node.position, nearest_to_new.position)\n                if dist_between <= self.step_size and collision_free_edge(new_node.position, nearest_to_new.position):\n                    # Candidate path found\n                    total_cost = new_node.cost + dist_between + nearest_to_new.cost\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connect_nodes = (new_node, nearest_to_new)\n\n            if best_connect_nodes is not None:\n                success_state = True\n                node_a, node_b = best_connect_nodes\n                extracted_path = extract_path(node_a, node_b)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.19606,
    "time_improvement": -55.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021587777137756347,
            "num_nodes_avg": 157.9,
            "path_length_avg": 183.3875957340989,
            "smoothness_avg": 0.021361840675895825,
            "success_improvement": 0.0,
            "time_improvement": -118.41714227820741,
            "length_improvement": 8.344642281386934,
            "smoothness_improvement": 105.26094231367485,
            "objective_score": -33.329909515616464
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023389148712158202,
            "num_nodes_avg": 258.6,
            "path_length_avg": 240.93696232439032,
            "smoothness_avg": 0.0498137605068275,
            "success_improvement": 0.0,
            "time_improvement": -54.12745446147175,
            "length_improvement": 20.048964640557564,
            "smoothness_improvement": 597.8429147939263,
            "objective_score": -9.23922883636038
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.025303339958190917,
            "num_nodes_avg": 266.2,
            "path_length_avg": 128.69703998265706,
            "smoothness_avg": 0.06774769573343979,
            "success_improvement": 0.0,
            "time_improvement": 8.885653232875372,
            "length_improvement": 20.972264610522455,
            "smoothness_improvement": 424.1636435599348,
            "objective_score": 8.980967109766777
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm integrates the adaptive bidirectional anytime RRT*-like planner with heuristic-informed ellipsoid sampling, dynamic tree pruning, local dense resampling, and progressive shortcut smoothing, together with the direct connection attempts, adaptive neighborhood rewiring, and balanced tree growth from classic bidirectional RRT*. It combines exploration and exploitation phases, dynamically focuses sampling around promising areas, prunes non-useful nodes, and performs local rewiring with an adaptive radius to efficiently produce high-quality, smooth paths with improved success rate and reduced search time, suitable for both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates extending two trees from start and goal, performing adaptive sampling among uniform random, informed ellipsoid around the current best path, and dense local resampling on high-cost branches. Each new node is collision-checked and rewired locally with an adaptive radius scaled by iteration and rewire factor for path improvement. The trees attempt direct incremental connections after each extension with collision checks. Dynamic pruning removes unpromising leaf nodes. Progressive shortcut smoothing is applied whenever a better path is found. Early termination occurs on finding near-optimal solutions or after a set number of iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 min_radius: float=6.0, max_radius: float=20.0, rewire_factor: float=1.5,\n                 pruning_threshold_factor: float=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.rewire_factor = rewire_factor\n        self.pruning_threshold_factor = pruning_threshold_factor\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, new_node, radius):\n            radius_sq = radius * radius\n            px = new_node.position\n            return [node for node in tree if sum((px[d]-node.position[d])**2 for d in range(dim)) <= radius_sq]\n\n        def adaptive_radius(iteration):\n            scale = min(1.0, iteration / (self.max_iter * 0.75))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r) * self.rewire_factor\n\n        def informed_sample(c_best):\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min + 1e-7\n            center = (np.array(start_pos) + np.array(goal_pos)) * 0.5\n            a1 = (np.array(goal_pos) - np.array(start_pos)) / c_min\n\n            while True:\n                sample_dir = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(sample_dir)\n                if norm_dir == 0:\n                    continue\n                unit_dir = sample_dir / norm_dir\n                radius = random.uniform(0, 1) ** (1 / dim)\n                unit_ball_sample = radius * unit_dir\n\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                r1 = c_best / 2.0\n                if dim == 2:\n                    r_rest = math.sqrt(c_best**2 - c_min**2) / 2.0\n                    L = np.diag([r1, r_rest])\n                elif dim == 3:\n                    r_rest = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r_rest, r_rest])\n                else:\n                    L = np.diag([c_best/2.0]*dim)\n\n                sample_transf = U @ L @ unit_ball_sample + center\n                sample = tuple(np.clip(sample_transf, [0]*dim, bounds))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def dynamic_prune(tree, best_cost):\n            threshold = best_cost * self.pruning_threshold_factor\n            to_remove = [node for node in tree if node.cost > threshold and len(node.children) == 0]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                tree.remove(node)\n\n        def dense_resample_on_branch(tree, best_cost, fraction=0.1, samples_per_branch=5):\n            sorted_nodes = sorted(tree, key=lambda n: n.cost, reverse=True)\n            count = max(1, int(len(tree) * fraction))\n            samples = []\n            radius = self.step_size * 2.5\n            for node in sorted_nodes[:count]:\n                center = np.array(node.position)\n                for _ in range(samples_per_branch):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_np = center + offset\n                    sample_clipped = tuple(np.clip(sample_np, [0]*dim, bounds))\n                    if not self._is_in_obstacle(sample_clipped, obstacles, is_3d):\n                        samples.append(sample_clipped)\n            return samples\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.remove_child(neighbor)\n                            if (old_parent, neighbor) in edges:\n                                edges.remove((old_parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b, nodes, edges):\n            nearest_b = nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n            current = nearest_b\n            while True:\n                new_pos = steer(current.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n                new_cost = current.cost + dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_cost = new_node.cost + dist(new_pos, node_from_a.position)\n                    final_node = Node(node_from_a.position, parent=new_node, cost=final_cost)\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                current = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) -1\n                shortcut_made = False\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i+1] + path[j:]\n                        shortcut_made = True\n                        break\n                    j -= 1\n                if not shortcut_made:\n                    i += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        best_path_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        for iter_count in range(self.max_iter):\n            # Alternate extension order\n            if iter_count % 2 == 0:\n                trees_sequence = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            else:\n                trees_sequence = [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            dense_samples = []\n            if best_path_cost < float(\"inf\") and (iter_count % 25 == 0) and len(start_tree) > 10:\n                dense_samples = dense_resample_on_branch(start_tree, best_path_cost, fraction=0.1, samples_per_branch=5)\n\n            for tree_a, tree_b in trees_sequence:\n                sample = None\n                prob_goal_bias = self.goal_sample_rate\n                prob_informed = 0.6 if best_path_cost < float(\"inf\") else 0.0\n\n                if dense_samples and random.random() < 0.4:\n                    sample = dense_samples.pop(random.randint(0, len(dense_samples)-1))\n                else:\n                    r = random.random()\n                    if r < prob_goal_bias:\n                        sample = goal_pos if tree_a is start_tree else start_pos\n                    elif r < prob_goal_bias + prob_informed:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n\n                curr_radius = adaptive_radius(iter_count)\n                neighbors = near(tree_a, new_node, curr_radius)\n\n                # Select best parent minimizing cost\n                min_cost = tentative_cost\n                min_parent = nearest_node\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_cand = node.cost + edge_c\n                    if cost_cand + 1e-9 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost_cand\n                            min_parent = node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors, edges)\n\n                connect_node = attempt_connect(new_node, tree_b, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path_candidate = extract_path(new_node, connect_node)\n                    else:\n                        path_candidate = extract_path(connect_node, new_node)\n\n                    path_len = 0.0\n                    for i in range(len(path_candidate) - 1):\n                        path_len += dist(path_candidate[i], path_candidate[i + 1])\n\n                    # Accept if strictly better path found\n                    if path_len + 1e-9 < best_path_cost:\n                        best_path_cost = path_len\n                        best_path = shortcut_path(path_candidate)\n\n                        dynamic_prune(start_tree, best_path_cost)\n                        dynamic_prune(goal_tree, best_path_cost)\n\n                        # Early termination if near direct line path length\n                        if best_path_cost <= 1.05 * dist(start_pos, goal_pos):\n                            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n                        # Return improved path for anytime\n                        return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            # If no direct connection found but have best path\n            if success_state and best_path:\n                best_path = shortcut_path(best_path)\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n        # No path found\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 24.74971,
    "time_improvement": -110.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02072300910949707,
            "num_nodes_avg": 74.3,
            "path_length_avg": 162.6673111912633,
            "smoothness_avg": 0.04583645824146655,
            "success_improvement": 0.0,
            "time_improvement": -109.66773930537397,
            "length_improvement": 18.700441342947585,
            "smoothness_improvement": 340.43183140023496,
            "objective_score": -27.4580743660215
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0507392168045044,
            "num_nodes_avg": 270.2,
            "path_length_avg": 228.05133634833987,
            "smoothness_avg": 0.08817866346254657,
            "success_improvement": 0.0,
            "time_improvement": -234.35617617762307,
            "length_improvement": 24.32485127953952,
            "smoothness_improvement": 1135.2983373921786,
            "objective_score": -59.76539091041811
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.023832297325134276,
            "num_nodes_avg": 162.5,
            "path_length_avg": 121.81081351558946,
            "smoothness_avg": 0.10803576440072118,
            "success_improvement": 0.0,
            "time_improvement": 14.182704483777888,
            "length_improvement": 25.200822494563692,
            "smoothness_improvement": 735.8722653221298,
            "objective_score": 12.974337170656755
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm integrates the asymptotic optimality and rewiring benefits of RRT* with bidirectional tree growth, goal biasing, adaptive neighborhood radius, and refined collision checking resolution. It alternates growth between two trees from start and goal, applies rewiring for path cost optimization, and includes path shortcut smoothing at the end to improve path quality and smoothness. The design prioritizes planning efficiency, robustness, path length minimization, and success rate in 2D/3D obstacle environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately towards random samples or biased goal samples. New nodes are added only if collision checks for nodes and edges pass. After node insertion, neighbors within an adaptive radius are rewired if a lower cost path is found. Connection attempts join the two trees when nodes are close enough. Once connected, the planner reconstructs and shortcut-smoothes the path for length and smoothness improvement.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 3.0, base_radius: float = 12.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n\n        edges = []\n        success = False\n        path = []\n\n        import math\n        import random\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative = n.cost + dist(n.position, new_pos)\n                if tentative < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt to connect trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    path = _smooth_path(path)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # No connection found\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = 0\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 30.50714,
    "time_improvement": -124.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.019741010665893555,
            "num_nodes_avg": 179.6,
            "path_length_avg": 169.44487688253477,
            "smoothness_avg": 0.021828820906992442,
            "success_improvement": 0.0,
            "time_improvement": -99.73224236167061,
            "length_improvement": 15.313079153001063,
            "smoothness_improvement": 109.74804638541839,
            "objective_score": -26.30831664597388
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04752800464630127,
            "num_nodes_avg": 463.9,
            "path_length_avg": 242.8552035826887,
            "smoothness_avg": 0.06588403727118823,
            "success_improvement": 0.0,
            "time_improvement": -213.19525400082324,
            "length_improvement": 19.412427294064138,
            "smoothness_improvement": 822.9720490870404,
            "objective_score": -55.96123049599893
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04435839653015137,
            "num_nodes_avg": 416.9,
            "path_length_avg": 123.73078853416737,
            "smoothness_avg": 0.11277190523314992,
            "success_improvement": 0.0,
            "time_improvement": -59.729361031388265,
            "length_improvement": 24.021842171915793,
            "smoothness_improvement": 772.5157674850157,
            "objective_score": -9.251861037608244
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm leverages a bidirectional RRT* approach with enhanced adaptive radius sampling, goal biasing, and dynamic rewiring to efficiently explore the free space. It balances exploration and exploitation through alternate tree expansions and adaptive neighborhood calculations. Post path finding, iterative shortcut smoothing is applied to improve path quality and smoothness, ensuring collision-free paths respecting obstacle and boundary constraints, thus improving success rate, planning speed, and path optimality.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately by sampling points with a goal bias. Each sampled point is steered towards from the nearest node with step size constraints. New nodes are only added if collision checks pass for nodes and edges. Neighborhood rewiring optimizes path costs dynamically by considering nearby nodes within an adaptive radius that shrinks as the number of samples grows. Upon successful connection of the trees, the path is extracted and progressively shortcut smoothed by checking collision-free shortcuts for path segments to reduce path length and increase smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.5, base_radius: float = 18.0, goal_sample_rate: float = 0.15, smooth_iter: int = 40, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        edges = []\n        success = False\n        path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(\n                gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim),\n                self.base_radius\n            )\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)  # Alternate tree expansion\n\n            # Goal biasing sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                if n == nearest_node:\n                    continue\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors to new node if cost improves\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, n.position)\n                if new_cost < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt connection of trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            connect_dist = dist(new_node.position, nearest_in_b.position)\n            if connect_dist <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    path = shortcut_smooth(path)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # Failed to connect trees\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 27.53384,
    "time_improvement": -52.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.015524744987487793,
            "num_nodes_avg": 131.4,
            "path_length_avg": 175.48337423281686,
            "smoothness_avg": 0.019028266188653168,
            "success_improvement": -9.999999999999998,
            "time_improvement": -57.07362611384765,
            "length_improvement": 12.295096216328036,
            "smoothness_improvement": 82.83816960050406,
            "objective_score": -64.24887774288617
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02864375114440918,
            "num_nodes_avg": 324.7,
            "path_length_avg": 252.29524147321936,
            "smoothness_avg": 0.04127327668749704,
            "success_improvement": 0.0,
            "time_improvement": -88.75370388409004,
            "length_improvement": 16.279903351290535,
            "smoothness_improvement": 478.19894369852864,
            "objective_score": -20.979135776476262
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03086709976196289,
            "num_nodes_avg": 315.7,
            "path_length_avg": 130.35972856993104,
            "smoothness_avg": 0.06413054224228673,
            "success_improvement": 0.0,
            "time_improvement": -11.14879047801381,
            "length_improvement": 19.95127365589056,
            "smoothness_improvement": 396.177741859333,
            "objective_score": 2.6265062970706343
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This planner is a simplified yet efficient bidirectional RRT* inspired algorithm combining bidirectional tree growth, goal biasing, adaptive sampling, and local rewiring within a dynamically scaled neighborhood radius. It balances exploration and exploitation by sampling near the current best path and the goal, connects trees early when possible, and improves path quality through rewiring and shortcutting.",
    "planning_mechanism": "The algorithm grows two trees alternately from start and goal positions, sampling points with goal bias and informed sampling near the best path found so far. Each new node picks the best parent from nearby nodes within an adaptive radius to minimize cost, then locally rewires neighbors to optimize paths. The trees attempt to connect after each extension. Upon success, the path is extracted and smoothed by shortcutting, providing efficient and high-quality trajectories while guaranteeing collision-free and boundary-adherent paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, min_radius: float = 10.0, max_radius: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            dist = distance(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def adaptive_radius(iter_idx):\n            scale = min(1.0, iter_idx / (self.max_iter / 2))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r)\n\n        def informed_sample():\n            # If no best path, sample uniformly\n            if best_cost == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            import numpy as np\n            dim = len(bounds)\n            start_np = np.array(start_pos)\n            goal_np = np.array(goal_pos)\n            c_min = distance(start_pos, goal_pos)\n            c_best = max(best_cost, c_min + 1e-6)\n            center = (start_np + goal_np) / 2\n            a1 = (goal_np - start_np) / c_min\n\n            while True:\n                # Sample unit ball\n                direction = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction /= norm\n                radius = random.uniform(0, 1) ** (1 / dim)\n                point_ball = radius * direction\n\n                # Create orthonormal basis\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1))\n                sample = U @ L @ point_ball + center\n                sample = np.clip(sample, [0] * dim, bounds)\n                sample_t = tuple(float(v) for v in sample)\n                if not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                    return sample_t\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i + 1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def attempt_connect(node_from, other_tree):\n            nearest_other = find_nearest(other_tree, node_from.position)\n            if self._is_edge_in_obstacle(node_from.position, nearest_other.position, obstacles, is_3d):\n                return None\n\n            curr = nearest_other\n            while True:\n                new_pos = steer(curr.position, node_from.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n\n                if distance(new_pos, node_from.position) < self.step_size * 1.01:\n                    final_node = Node(node_from.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_from.position))\n                    new_node.add_child(final_node)\n                    other_tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iter_idx in range(self.max_iter):\n            # Alternate tree growth order every iteration\n            growing_orders = [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_idx % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            for tree_a, tree_b in growing_orders:\n                # Sampling with goal bias and informed sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    if best_cost < float('inf') and random.random() < 0.6:\n                        sample = informed_sample()\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                radius = adaptive_radius(iter_idx)\n                neighbors = find_near(tree_a, new_node, radius)\n\n                # Select minimal cost parent from neighbors\n                min_cost = tentative_cost\n                min_parent = nearest\n                for n in neighbors:\n                    edge_c = distance(n.position, new_node.position)\n                    c = n.cost + edge_c\n                    if c + 1e-7 < min_cost and not self._is_edge_in_obstacle(n.position, new_node.position, obstacles, is_3d):\n                        min_cost = c\n                        min_parent = n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors)\n\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, connect_node)\n                    else:\n                        path = extract_path(connect_node, new_node)\n\n                    path_cost = 0.0\n                    for i in range(len(path) - 1):\n                        path_cost += distance(path[i], path[i + 1])\n\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = path\n\n                    extracted_path = shortcut_path(best_path)\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 21.2552,
    "time_improvement": -99.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023629164695739745,
            "num_nodes_avg": 100.0,
            "path_length_avg": 168.44793223574646,
            "smoothness_avg": 0.04471091512583583,
            "success_improvement": 0.0,
            "time_improvement": -139.07114634040437,
            "length_improvement": 15.811342505335576,
            "smoothness_improvement": 329.61675024528,
            "objective_score": -36.91099164982779
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031334757804870605,
            "num_nodes_avg": 226.0,
            "path_length_avg": 231.10272343163825,
            "smoothness_avg": 0.08920429874467865,
            "success_improvement": 0.0,
            "time_improvement": -106.48662831071465,
            "length_improvement": 23.312297812281674,
            "smoothness_improvement": 1149.6665020823436,
            "objective_score": -21.53519642034634
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.041659760475158694,
            "num_nodes_avg": 289.0,
            "path_length_avg": 117.51014688918721,
            "smoothness_avg": 0.11931802799898128,
            "success_improvement": 0.0,
            "time_improvement": -50.01189046350488,
            "length_improvement": 27.84169087969108,
            "smoothness_improvement": 823.1630924306397,
            "objective_score": -5.319413500960049
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a hybrid Bidirectional RRT* with informed sampling and dynamic rewiring to improve planning efficiency and path quality. It uses an ellipse-based informed sampling heuristic to focus growth towards the goal after an initial feasible path is found, reducing unnecessary exploration. Adaptive radius rewiring optimizes node connections and path costs. Post-planning, a refined shortcut smoothing with collision checks ensures path smoothness and shorter lengths while maintaining robustness and success rate.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately using goal bias and informed sampling within an ellipse region once a first path is found. Nodes are connected and rewired within an adaptive neighborhood to improve cost dynamically. Collision checks are strictly enforced on nodes and edges. Upon connecting trees, the path is extracted and iteratively shortcut smoothed for optimality and smoothness. This balances exploration and exploitation, reducing planning time and improving final path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, base_radius: float=20.0, goal_sample_rate: float=0.1, smooth_iter: int=60, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n\n        success_state = False\n        extracted_path = []\n        nodes_start = [Node(start_position, cost=0.0)]\n        nodes_goal = [Node(goal_position, cost=0.0)]\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(\n                gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim),\n                self.base_radius\n            )\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def extract_path(node_s, node_g):\n            path_from_start = node_s.path_from_root()\n            path_from_goal = node_g.path_from_root()\n            return path_from_start + path_from_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Informed sampling ellipse parameters - updated after first solution\n        def informed_sample(c_best, c_min, start, goal):\n            # Returns a point sampled inside prolate hyperspheroid (ellipse) defined by start-goal and current best cost\n            if c_best == float('inf'):\n                # No solution so uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple(goal[d] - start[d] for d in range(dim))\n            a1_len = dist(start, goal)\n            if a1_len == 0:\n                return center\n\n            # Build rotation matrix from unit vector a1 to x-axis \n            # Only for 2D or 3D cases\n            u = [a / a1_len for a in a1]\n\n            # Sample uniformly within unit n-ball\n            while True:\n                # Sample point in unit n-ball via normal distrib and scale\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x**2 for x in x_ball))\n                x_unit = [x / norm for x in x_ball]\n                r = random.uniform(0,1) ** (1/dim)\n                x_rand = [r * x for x in x_unit]\n\n                # Scale along axis of ellipse\n                L1 = c_best / 2.0                      # long semi-axis\n                if c_best**2 - c_min**2 < 0:\n                    L2 = 0.0\n                else:\n                    L2 = math.sqrt(c_best**2 - c_min**2) / 2.0   # short semi-axis\n\n                if dim == 2:\n                    # Rotate x_rand by angle theta to align with a1\n                    # x_rand = (x, y)\n                    # R = [[u_x, -u_y], [u_y, u_x]] \n                    # But u is unit vector along a1, which is goal-start vector\n                    cos_theta = u[0]\n                    sin_theta = u[1]\n                    x_prime = (L1 * x_rand[0]*cos_theta - L2 * x_rand[1]*sin_theta,\n                               L1 * x_rand[0]*sin_theta + L2 * x_rand[1]*cos_theta)\n                    sample = tuple(center[d] + x_prime[d] for d in range(2))\n                elif dim == 3:\n                    # Align samples in 3D: rotate x_rand into direction u by Householder transform\n                    # Construct Householder matrix to rotate x axis to u\n                    # x axis unit vector:\n                    e1 = [1.0, 0.0, 0.0]\n                    v = [e1[i] - u[i] for i in range(3)]\n                    v_norm = math.sqrt(sum(x**2 for x in v))\n                    if v_norm > 1e-10:\n                        v = [x/v_norm for x in v]\n                        # Householder matrix H = I - 2 v v^T\n                        # Apply H to column vector [L1*x_rand[0], L2*x_rand[1], L2*x_rand[2]]\n                        x_scaled = [L1 * x_rand[0], L2 * x_rand[1], L2 * x_rand[2]]\n                        dot = sum(v[i] * x_scaled[i] for i in range(3))\n                        x_prime = [x_scaled[i] - 2 * v[i] * dot for i in range(3)]\n                    else:\n                        # u == e1, no rotation needed\n                        x_prime = [L1 * x_rand[0], L2 * x_rand[1], L2 * x_rand[2]]\n\n                    sample = tuple(center[d] + x_prime[d] for d in range(3))\n                else:\n                    # For >3D or 1D fallback uniform sampling\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if within_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Sampling strategy:\n            # Before first solution: goal biasing + uniform random sampling\n            # After first solution: goal biasing + informed sampling within ellipse\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if sample_from_start else start_position\n            else:\n                if c_best == float('inf'):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                else:\n                    sample = informed_sample(c_best, c_min, start_position, goal_position)\n\n            if not within_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not collision_free_node(new_pos):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                if n == nearest_node:\n                    continue\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = tentative_cost\n                        min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring of neighbors to new node for cost optimization\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                        if n.parent:\n                            n.parent.remove_child(n)\n                            if (n.parent, n) in edges:\n                                edges.remove((n.parent, n))\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            # Attempt to connect trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            connect_dist = dist(new_node.position, nearest_in_b.position)\n            if connect_dist <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    candidate_path = extract_path(new_node, nearest_in_b)\n                    candidate_cost = sum(dist(candidate_path[j], candidate_path[j+1]) for j in range(len(candidate_path)-1))\n                    if candidate_cost < c_best:\n                        c_best = candidate_cost\n                        success_state = True\n                        extracted_path = shortcut_smooth(candidate_path)\n\n            if success_state and i - self.max_iter * 0.1 > 0:\n                # Early break if improved solution found and iterated enough after\n                break\n\n        all_nodes = nodes_start + nodes_goal\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 44.22498,
    "time_improvement": -114.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03476603031158447,
            "num_nodes_avg": 206.1,
            "path_length_avg": 168.2876124843938,
            "smoothness_avg": 0.026157083469661762,
            "success_improvement": 0.0,
            "time_improvement": -251.74983234994716,
            "length_improvement": 15.891468776148859,
            "smoothness_improvement": 151.33731135905808,
            "objective_score": -71.58996939295908
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024351739883422853,
            "num_nodes_avg": 271.3,
            "path_length_avg": 242.57388141777966,
            "smoothness_avg": 0.0597784555667645,
            "success_improvement": 0.0,
            "time_improvement": -60.47064072874214,
            "length_improvement": 19.505779505933376,
            "smoothness_improvement": 737.4387167351586,
            "objective_score": -10.552842733760174
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.03582448959350586,
            "num_nodes_avg": 368.0,
            "path_length_avg": 125.07511420726541,
            "smoothness_avg": 0.10413673171594354,
            "success_improvement": -9.999999999999998,
            "time_improvement": -28.99976734183322,
            "length_improvement": 23.19634522509254,
            "smoothness_improvement": 705.7054654585065,
            "objective_score": -50.53213383023892
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates the bidirectional search strategy of RRT with the heuristic-informed sampling and local rewiring optimization of Informed RRT*. It starts by growing two trees from start and goal, alternating expansions. Sampling is biased towards the goal and progressively focused inside an ellipsoidal informed region defined by the best path cost found so far, improving convergence speed and path quality. Nodes and edges undergo strict collision checks, while rewiring locally optimizes paths and reduces cost. Upon connection, the path is reconstructed and refined via iterative shortcut smoothing to improve smoothness and shorten path length. This design balances exploration, exploitation, optimization, and smoothing to enhance success rate, efficiency, and robustness.",
    "planning_mechanism": "The planner samples points either within an ellipsoidal informed subset of the search space (focused by the current best path cost) or directly towards the goal with some bias. It then alternately extends two trees\u2014one from the start, one from the goal\u2014towards those samples, performing collision checking and limiting steps. Local rewiring updates the tree to reduce path costs. When the trees connect, a collision-free path is extracted and refined with shortcut smoothing, resulting in a high-quality, smooth, and efficient solution faster than naive sampling or simple bidirectional RRT.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 4.0,\n        radius: float = 20.0,\n        goal_sample_rate: float = 0.15,\n        informed_sampling_rate: float = 0.85,\n        collision_resolution: float = 0.3,\n        smoothing_trials: int = 60,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_sample_rate = goal_sample_rate\n        self.informed_sampling_rate = informed_sampling_rate\n        self.collision_resolution = collision_resolution\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            neighbors = []\n            r2 = radius * radius\n            px = np.array(point)\n            for node in tree:\n                diff = np.array(node.position) - px\n                if diff.dot(diff) <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            if not within_bounds(b):\n                return False\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution):\n                return False\n            return True\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def rewire(tree, new_node):\n            neighbors = near(tree, new_node.position, self.radius)\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if tentative_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    # Remove old parent-child relation & edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    # Re-assign parent and update cost\n                    near_node.parent = new_node\n                    near_node.cost = tentative_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        def informed_sample(c_max, start, goal):\n            if math.isinf(c_max):\n                # Uniform random sample\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                c_max = c_min + 1e-6\n\n            center = np.array([(start[i] + goal[i]) / 2 for i in range(dim)])\n\n            if c_min == 0.0:\n                unit_vec = np.zeros(dim)\n            else:\n                unit_vec = np.array([(goal[i] - start[i]) / c_min for i in range(dim)])\n\n            # Rotation matrix aligning x-axis with unit_vec\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s], [s, c]])\n                elif dim == 3:\n                    x_axis = vec / np.linalg.norm(vec)\n                    if abs(x_axis[0]) < 1e-6 and abs(x_axis[1]) < 1e-6:\n                        temp = np.array([0,1,0])\n                    else:\n                        temp = np.array([0,0,1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= np.linalg.norm(y_axis)\n                    z_axis = np.cross(x_axis, y_axis)\n                    return np.stack((x_axis, y_axis, z_axis), axis=1)\n                else:\n                    return np.eye(dim)\n\n            L_diag = [c_max / 2] + [math.sqrt(c_max**2 - c_min**2)/2] * (dim-1)\n            L = np.diag(L_diag)\n            R = rotation_matrix(unit_vec)\n\n            while True:\n                # Sample inside unit n-ball\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                u = np.random.uniform(0,1)\n                r = u ** (1/dim)\n                sample_ball = x_ball * r\n\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                p = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smoothing_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path)-2)\n                j = random.randint(i+1, len(path)-1)\n                if j == i+1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialization\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_path_cost = math.inf\n        best_connect_nodes = None\n\n        for iter in range(self.max_iter):\n            # Sampling: informed ellipsoidal bias or goal bias or uniform fallback\n            p = None\n            roll = random.random()\n            if roll < self.goal_sample_rate:\n                p = goal_position\n            elif roll < self.goal_sample_rate + self.informed_sampling_rate and best_path_cost < math.inf:\n                p = informed_sample(best_path_cost, start_position, goal_position)\n            else:\n                # Uniform random sample\n                while True:\n                    tmp = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(tmp, obstacles, is_3d):\n                        p = tmp\n                        break\n\n            # Alternate tree extensions: start->goal and goal->start\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, p)\n                new_pos = steer(nearest_node.position, p, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                # Try to connect trees\n                nearest_in_other = nearest(tree_b, new_node.position)\n                dist_btwn = dist(new_node.position, nearest_in_other.position)\n                if dist_btwn <= self.step_size and collision_free_edge(new_node.position, nearest_in_other.position):\n                    total_cost = new_node.cost + dist_btwn + nearest_in_other.cost\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connect_nodes = (new_node, nearest_in_other)\n\n            if best_connect_nodes is not None:\n                success_state = True\n                node_a, node_b = best_connect_nodes\n                extracted_path = extract_path(node_a, node_b)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 188.9783,
    "time_improvement": -541.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.06679649353027343,
            "num_nodes_avg": 232.9,
            "path_length_avg": 177.93875004739394,
            "smoothness_avg": 0.028528640357806723,
            "success_improvement": -9.999999999999998,
            "time_improvement": -575.8222089281493,
            "length_improvement": 11.067922984039196,
            "smoothness_improvement": 174.12504809938497,
            "objective_score": -219.66245284114
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.12149956226348876,
            "num_nodes_avg": 450.7,
            "path_length_avg": 233.45847818635758,
            "smoothness_avg": 0.07185322701837385,
            "success_improvement": -9.999999999999998,
            "time_improvement": -700.645567750835,
            "length_improvement": 22.53057868593543,
            "smoothness_improvement": 906.5946611876285,
            "objective_score": -251.15458128212526
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.12383840084075928,
            "num_nodes_avg": 424.3,
            "path_length_avg": 126.93060711857223,
            "smoothness_avg": 0.09691103407332803,
            "success_improvement": 0.0,
            "time_improvement": -345.92749478665417,
            "length_improvement": 22.056960800776597,
            "smoothness_improvement": 649.8002724831192,
            "objective_score": -96.11785491342533
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "This planner is a hybrid asymptotically optimal bidirectional RRT* variant that combines informed sampling for accelerated convergence, adaptive neighborhood radius for efficient rewiring, and balanced bidirectional tree growth. It applies goal biasing and adaptive heuristic sampling around the current best path to improve success rate and path quality. The method dynamically rewires the trees locally to optimize costs, performs strict collision and boundary checks, and applies post-processing shortcut smoothing to generate smooth, shorter, and robust paths efficiently.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling new points biased towards the goal or informed ellipsoidal regions near the current best path. Each extension checks collision and boundaries strictly and selects the best parent among neighbors within an adaptive radius to minimize path cost. It rewires neighbors to optimize local connectivity. The planner attempts to connect the two trees directly after each new node insertion to find a complete path quickly. Upon success, the path is extracted bidirectionally and smoothed by shortcutting. Planning terminates early on success or after max iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 min_search_radius: float = 8.0, max_search_radius: float = 30.0, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_search_radius = min_search_radius\n        self.max_search_radius = max_search_radius\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        # Core data structures\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend(start_tree + goal_tree)\n\n        best_path_cost = float(\"inf\")\n        best_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def in_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def find_near(tree, node, radius):\n            return [n for n in tree if dist(n.position, node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def adaptive_radius(iteration):\n            scale = min(1.0, iteration / (self.max_iter / 2))\n            r = self.max_search_radius - (self.max_search_radius - self.min_search_radius) * scale\n            return max(r, self.min_search_radius)\n\n        def informed_sample():\n            # If no best path found, uniform random sampling\n            if best_path_cost == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            # Ellipsoidal informed sampling centered between start and goal\n            import numpy as np\n            dim = len(bounds)\n            start = np.array(start_position)\n            goal = np.array(goal_position)\n            center = (start + goal) / 2\n            c_best = best_path_cost\n            c_min = dist(start_position, goal_position)\n            if c_best < c_min:\n                c_best = c_min + 1e-3  # avoid degenerate\n\n            while True:\n                direction = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction /= norm\n                radius = random.uniform(0, 1) ** (1 / dim)\n                point_ball = radius * direction\n\n                a1 = (goal - start) / c_min\n                I = np.eye(dim)\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                L_diag = [c_best / 2] + [math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2] * (dim - 1)\n                L = np.diag(L_diag)\n                sample = U @ L @ point_ball + center\n                sample = np.clip(sample, [0] * dim, bounds)\n                sample_tuple = tuple(float(v) for v in sample)\n                if not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                    return sample_tuple\n\n        def attempt_connect(node_from_a, tree_b):\n            nearest_b = find_nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d, self.collision_resolution):\n                return None\n            curr = nearest_b\n            while True:\n                new_pos = steer(curr.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + dist(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_node = Node(node_from_a.position, parent=new_node, cost=new_node.cost + dist(new_pos, node_from_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                        path = path[:i + 1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Balanced alternating tree growth order\n            pairs = [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_count % 2 == 1 else [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            for tree_a, tree_b in pairs:\n                # Sampling with combined goal bias and informed sampling\n                prob = random.random()\n                if prob < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    if best_path_cost < float(\"inf\") and random.random() < 0.6:\n                        sample = informed_sample()\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                if not in_bounds(sample):\n                    continue\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    continue\n\n                tentative_cost = nearest.cost + dist(nearest.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                # Adaptive neighborhood radius\n                curr_radius = adaptive_radius(iter_count)\n                neighbors = find_near(tree_a, new_node, curr_radius)\n\n                # Choose best parent from neighbors to minimize cost\n                min_cost = tentative_cost\n                min_node = nearest\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_total = node.cost + edge_c\n                    if cost_total + 1e-7 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                            min_cost = cost_total\n                            min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt to connect the other tree\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n\n                    # Update best path cost\n                    path_cost = 0.0\n                    for i in range(len(extracted_path) - 1):\n                        path_cost += dist(extracted_path[i], extracted_path[i + 1])\n                    if path_cost < best_path_cost:\n                        best_path_cost = path_cost\n                        best_path = extracted_path\n\n                    # Path shortcutting\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n        # After max iterations, if best path found heuristically\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 81.59619,
    "time_improvement": -188.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03126978874206543,
            "num_nodes_avg": 76.9,
            "path_length_avg": 167.3942029829155,
            "smoothness_avg": 0.0460105808970808,
            "success_improvement": -9.999999999999998,
            "time_improvement": -216.37615364946424,
            "length_improvement": 16.337986257985158,
            "smoothness_improvement": 342.10493536687346,
            "objective_score": -109.93472416640786
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.048982834815979,
            "num_nodes_avg": 239.0,
            "path_length_avg": 230.7539769309238,
            "smoothness_avg": 0.08102050507722287,
            "success_improvement": 0.0,
            "time_improvement": -222.7821472001307,
            "length_improvement": 23.428023699837944,
            "smoothness_improvement": 1035.0194172434735,
            "objective_score": -56.97394233385425
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.06250789165496826,
            "num_nodes_avg": 289.8,
            "path_length_avg": 117.72695684569037,
            "smoothness_avg": 0.11899847271771351,
            "success_improvement": -9.999999999999998,
            "time_improvement": -125.08355518849174,
            "length_improvement": 27.708556505546618,
            "smoothness_improvement": 820.6906945323087,
            "objective_score": -77.87990178277666
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* algorithm with adaptive neighborhood rewiring, goal biasing, and refined collision checks designed to achieve efficient and robust path planning in 2D/3D spaces with obstacles. It balances planning efficiency, path quality, success rate, and smoothness by adaptively adjusting parameters, performing rewiring to minimize costs, and shortcut smoothing the discovered path.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points with goal bias. For each new node, it picks the lowest-cost parent in a neighborhood, rewires neighbors to improve paths, and tries connecting the trees. Once connected, it reconstructs and smooths the path before returning. All node and edge insertions are checked for collisions and map bounds.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4500, step_size: float = 4.0, base_radius: float = 10.0, goal_sample_rate: float = 0.2, collision_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        import random\n        import math\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1 / dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                # Enforce map bounds\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors to reduce cost\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    path = extract_path(new_node, nearest_in_b)\n                    path = smooth_path(path)\n                    all_nodes = nodes_start + nodes_goal\n                    return PlannerResult(True, path, all_nodes, edges)\n\n        all_nodes = nodes_start + nodes_goal\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 24.40837,
    "time_improvement": -105.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025393080711364747,
            "num_nodes_avg": 145.7,
            "path_length_avg": 165.83660060267044,
            "smoothness_avg": 0.02499972032676858,
            "success_improvement": 0.0,
            "time_improvement": -156.9177959928019,
            "length_improvement": 17.116460956741335,
            "smoothness_improvement": 140.2164789872752,
            "objective_score": -42.95096421155592
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0363203763961792,
            "num_nodes_avg": 362.7,
            "path_length_avg": 241.68974884753135,
            "smoothness_avg": 0.07866395509901483,
            "success_improvement": 0.0,
            "time_improvement": -139.3403551329628,
            "length_improvement": 19.799164604277838,
            "smoothness_improvement": 1002.00641664046,
            "objective_score": -32.832241535830974
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03338453769683838,
            "num_nodes_avg": 302.1,
            "path_length_avg": 124.60489761811304,
            "smoothness_avg": 0.11439085101128206,
            "success_improvement": 0.0,
            "time_improvement": -20.213787958265762,
            "length_improvement": 23.485086537156004,
            "smoothness_improvement": 785.0415443192653,
            "objective_score": 2.558088641547799
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified yet robust bidirectional RRT* planner combining key strengths from enhanced RRT and RRT* variants. It balances exploration and path optimality using adaptive step sizes, goal-biased sampling, dynamic nearest-neighbor radius, and incremental rewiring. It ensures collision-free node additions and edge connections, reconstructs the path on successful tree connection, and applies iterative shortcut smoothing to yield efficient, smooth, and relatively short trajectories.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling free points with goal bias. New nodes choose optimal parents within a dynamic radius based on cost and collision checks, and neighbors are rewired incrementally for cost improvement. When the trees connect, the algorithm reconstructs and smooths the path, delivering high-quality results efficiently while respecting bounds and obstacle constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 initial_step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 collision_resolution: float = 0.4,\n                 radius_constant: float = 25.0):\n        self.max_iter = max_iter\n        self.initial_step_size = initial_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def _near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def _steer(from_pos, to_pos, step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def _can_connect(parent_node, new_pos):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = cost\n                    best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid repeating connecting node\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample = _sample_free()\n\n            step_size_ratio = 1.0\n            if i > self.max_iter // 2:\n                step_size_ratio = max(0.3, 1.0 - (i - self.max_iter // 2) / (self.max_iter // 2))\n            step_size = self.initial_step_size * step_size_ratio\n\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            radius = min(\n                self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim),\n                step_size * 5)\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, step_size)\n            if not _can_connect(nearest_node_a, new_pos_a):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.parent = None\n            new_node_a.cost = 0\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n\n            if dist <= step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution) and \\\n               not self._is_in_obstacle(new_node_a.position, obstacles, is_3d):\n                connecting_node_b = None\n                if nearest_node_b.position != new_node_a.position:\n                    connecting_node_b = Node(new_node_a.position)\n                    connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                    tree_b.append(connecting_node_b)\n                    nodes.append(connecting_node_b)\n                    edges.append((nearest_node_b, connecting_node_b))\n                else:\n                    connecting_node_b = nearest_node_b\n\n                near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                extracted_path = _smooth_path(extracted_path)\n                success_state = True\n                break\n\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, step_size)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.parent = None\n                    new_node_b.cost = 0\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 10.568,
    "time_improvement": -59.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01592907905578613,
            "num_nodes_avg": 118.3,
            "path_length_avg": 167.28860831423978,
            "smoothness_avg": 0.02976413116325912,
            "success_improvement": 0.0,
            "time_improvement": -61.16452862594497,
            "length_improvement": 16.390761458466454,
            "smoothness_improvement": 185.99659094977213,
            "objective_score": -14.141223341341338
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02226698398590088,
            "num_nodes_avg": 270.4,
            "path_length_avg": 242.10591955888017,
            "smoothness_avg": 0.08075792718660424,
            "success_improvement": 0.0,
            "time_improvement": -46.732726467178004,
            "length_improvement": 19.661065082570513,
            "smoothness_improvement": 1031.3409533273707,
            "objective_score": -4.930900157002443
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04722607135772705,
            "num_nodes_avg": 453.6,
            "path_length_avg": 133.22746545091334,
            "smoothness_avg": 0.13562652951431517,
            "success_improvement": 0.0,
            "time_improvement": -70.05552030865412,
            "length_improvement": 18.19031045559119,
            "smoothness_improvement": 949.3419016541206,
            "objective_score": -12.631884493207393
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements a Bidirectional Adaptive Informed RRT* with Dynamic Neighborhood and Lazy Collision Checking. It dynamically adjusts the rewiring radius based on the current best path cost and tree density, employs informed sampling within an ellipsoidal heuristic region to focus exploration, and delays expensive collision checks on edges until absolutely necessary (lazy collision checking). It also alternates growth between start and goal trees, aggressively tries to connect trees whenever possible, and applies an efficient iterative shortcut smoothing to improve path quality and reduce runtimes. These strategies improve planning efficiency, path optimality, success rate, and robustness.",
    "planning_mechanism": "The planner initializes bidirectional trees from start and goal, samples points inside an informed ellipsoid computed from the best cost found so far, and progressively reduces the search space. It adaptively adjusts the neighbor radius for rewiring to balance exploration and exploitation. Nodes are lazily checked for edges' collisions only when rewiring or connection is attempted to save computation. Once the trees connect, a smooth path is extracted and refined using iterative shortcutting. This combination accelerates convergence to high-quality, collision-free paths with fewer samples and lower computational overhead.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For lazy collision validation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, radius_max: float=30.0,\n                 smooth_iter: int=50, collision_resolution: float=0.5, informed_sampling_rate: float=0.85):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max               # Max neighbor radius for rewiring\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def lazy_collision_free_edge(a, b, cache):\n            # cache is a dict storing edges checked: keys as (a_pos, b_pos) sorted tuple of positions\n            key = tuple(sorted([a, b]))\n            if key in cache:\n                return cache[key]\n            collision = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            cache[key] = not collision\n            return not collision\n\n        # Ellipsoidal informed sampling around start and goal with max cost c_max\n        def informed_sample(c_max, start, goal):\n            if math.isinf(c_max):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                c_max = c_min + 1e-6\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            if c_min == 0:\n                unit_vec = tuple(0 for _ in range(dim))\n            else:\n                unit_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s],[s, c]])\n                elif dim == 3:\n                    x_axis = np.array(vec)\n                    if np.linalg.norm(x_axis) < 1e-12:\n                        return np.eye(3)\n                    x_axis /= np.linalg.norm(x_axis)\n                    if abs(x_axis[0]) < 1e-6 and abs(x_axis[1]) < 1e-6:\n                        temp = np.array([0,1,0])\n                    else:\n                        temp = np.array([0,0,1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= np.linalg.norm(y_axis)\n                    z_axis = np.cross(x_axis, y_axis)\n                    return np.stack((x_axis, y_axis, z_axis), axis=1)\n                else:\n                    return np.eye(dim)\n\n            L = np.diag([c_max/2] + [math.sqrt(c_max**2 - c_min**2)/2]*(dim-1))\n            R = rotation_matrix(unit_vec)\n\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-12:\n                    continue\n                x_ball /= norm_x\n                r = np.random.uniform(0,1) ** (1/dim)\n                sample_ball = x_ball * r\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                p = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        # Iterative shortcut smoothing for path improvement\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i+1, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if lazy_collision_free_edge(p1, p2, collision_edge_cache):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Extract path from two connected nodes in start and goal trees\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        start_tree = [Node(start_position, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_position, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        best_path_cost = math.inf\n        best_nodes_pair = None\n\n        collision_edge_cache = dict()\n\n        def rewire(tree, new_node, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if tentative_cost < neighbor.cost:\n                    if lazy_collision_free_edge(new_node.position, neighbor.position, collision_edge_cache):\n                        # Remove old edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = tentative_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        # Main iteration loop\n        for iter in range(self.max_iter):\n            # Adaptive radius for rewiring based on log(n)/n (RRT* radius formula variant)\n            n = len(nodes)\n            gamma = self.radius_max\n            radius = min(gamma * (math.log(n + 1) / (n + 1)) ** (1/dim), self.radius_max)\n\n            # Adaptive informed sampling with probability\n            if random.random() < self.informed_sampling_rate:\n                sample = informed_sample(best_path_cost, start_position, goal_position)\n            else:\n                # Uniform random sample\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate growing start and goal trees each iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not collision_free_node(new_pos):\n                    continue\n                if not lazy_collision_free_edge(nearest_node.position, new_pos, collision_edge_cache):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                # Check nearby nodes in tree_a to choose best parent\n                neighbors = near(tree_a, new_pos, radius)\n                min_cost = new_cost\n                min_node = nearest_node\n                for neighbor in neighbors:\n                    cost_thru_neighbor = neighbor.cost + dist(neighbor.position, new_pos)\n                    if cost_thru_neighbor < min_cost and lazy_collision_free_edge(neighbor.position, new_pos, collision_edge_cache):\n                        min_cost = cost_thru_neighbor\n                        min_node = neighbor\n\n                new_node = Node(new_pos, parent=min_node, cost=min_cost)\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                rewire(tree_a, new_node, radius)\n\n                # Attempt to connect to other tree\n                nearest_in_other = nearest(tree_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_in_other.position)\n                if dist_to_other <= self.step_size:\n                    if lazy_collision_free_edge(new_node.position, nearest_in_other.position, collision_edge_cache):\n                        total_cost = new_node.cost + dist_to_other + nearest_in_other.cost\n                        if total_cost < best_path_cost:\n                            best_path_cost = total_cost\n                            best_nodes_pair = (new_node, nearest_in_other)\n\n            if best_nodes_pair is not None:\n                success_state = True\n                node_a, node_b = best_nodes_pair\n                extracted_path = extract_path(node_a, node_b)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 9.25217,
    "time_improvement": -48.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016823577880859374,
            "num_nodes_avg": 124.7,
            "path_length_avg": 181.0057098000428,
            "smoothness_avg": 0.023313968234768005,
            "success_improvement": 0.0,
            "time_improvement": -70.21473680147821,
            "length_improvement": 9.53508597773914,
            "smoothness_improvement": 124.01848050197957,
            "objective_score": -18.53731144238574
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019853615760803224,
            "num_nodes_avg": 252.3,
            "path_length_avg": 247.37377785996983,
            "smoothness_avg": 0.03602037059660371,
            "success_improvement": 0.0,
            "time_improvement": -30.829355814823085,
            "length_improvement": 17.913011478690922,
            "smoothness_improvement": 404.610777290065,
            "objective_score": -3.6431505622584157
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.039774298667907715,
            "num_nodes_avg": 346.6,
            "path_length_avg": 131.1930172650993,
            "smoothness_avg": 0.10347192686467346,
            "success_improvement": 0.0,
            "time_improvement": -43.22256457981163,
            "length_improvement": 19.4395841989017,
            "smoothness_improvement": 700.5618730554656,
            "objective_score": -5.57604316888582
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional growth and rewiring qualities of RRT*-inspired algorithms with adaptive neighborhood radius, refined collision checking, goal biasing, and enhanced path smoothing. It alternates growth from start and goal trees, performs rewiring for cost optimization, adaptively adjusts the search radius to balance exploration and exploitation, and applies post-connection shortcut smoothing for improved path quality and smoothness. The design targets improved planning efficiency, path optimality, robustness, and higher success rates in 2D/3D constrained obstacle spaces.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points with a goal bias. New nodes and edges undergo strict collision checks. It uses an adaptive search radius based on current tree size for neighbor selection and rewiring to optimize cost. Once the trees connect within step size, the algorithm extracts and iteratively shortcut-smooths the path. This balances rapid initial discovery, continual optimization, and final path smoothing for high-quality feasible paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...]: (x,y) or (x,y,z)\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Path cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True                   # For collision checking etc.\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, base_radius: float = 14.0, goal_sample_rate: float = 0.12, collision_resolution: float = 0.5, smoothing_iters: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                   # Environment bounds (W,H) or (W,H,D)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start: List[Node] = [Node(start_pos)]\n        nodes_goal: List[Node] = [Node(goal_pos)]\n\n        edges: List[Tuple[Node, Node]] = []\n        success = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            # Remove duplicate connecting node position\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            return path_s + path_g[::-1]\n\n        def _smooth_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main Planning Loop\n        for iter_num in range(self.max_iter):\n            sample_from_start = (iter_num % 2 == 0)\n\n            # Goal biased sampling with probability goal_sample_rate\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Check out of bounds\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            # Check node collision\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            # Verify new_pos is inside bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            # Collision checks for node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = tentative_cost\n                        min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors around new_node\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                        if n.parent:\n                            n.parent.remove_child(n)\n                            if (n.parent, n) in edges:\n                                edges.remove((n.parent, n))\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            # Attempt to connect nearest node in the other tree\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_between = dist(new_node.position, nearest_in_b.position)\n            if dist_between <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    # Successful connection found\n                    success = True\n                    extracted_path = extract_path(new_node, nearest_in_b)\n                    extracted_path = _smooth_path(extracted_path)\n                    nodes = nodes_start + nodes_goal\n                    return PlannerResult(success, extracted_path, nodes, edges)\n\n        # No connection found within max iterations\n        nodes = nodes_start + nodes_goal\n        return PlannerResult(success, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution=0.5) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 27.65159,
    "time_improvement": -60.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018793630599975585,
            "num_nodes_avg": 166.9,
            "path_length_avg": 171.58537280191186,
            "smoothness_avg": 0.027276670760780046,
            "success_improvement": 0.0,
            "time_improvement": -90.1470013556738,
            "length_improvement": 14.243279865866073,
            "smoothness_improvement": 162.09516438605226,
            "objective_score": -23.384968611598662
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0318150520324707,
            "num_nodes_avg": 346.2,
            "path_length_avg": 240.76510122167946,
            "smoothness_avg": 0.0872203449541166,
            "success_improvement": 0.0,
            "time_improvement": -109.65162279613006,
            "length_improvement": 20.105993968756902,
            "smoothness_improvement": 1121.8732160116701,
            "objective_score": -23.26492196502928
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.02252950668334961,
            "num_nodes_avg": 313.5,
            "path_length_avg": 129.19500878816586,
            "smoothness_avg": 0.11373051944065789,
            "success_improvement": -9.999999999999998,
            "time_improvement": 18.87390013212579,
            "length_improvement": 20.666481765794497,
            "smoothness_improvement": 779.9325616702041,
            "objective_score": -36.30487079885234
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm integrates the efficiency of bidirectional RRT with adaptive rewiring and goal biasing, combining shortcut smoothing and adaptive sampling radius to enhance planning efficiency, path quality, and robustness. It balances exploration and exploitation by dynamically adjusting neighborhood connections and alternates tree expansions from start and goal, ensuring strict collision-free node and edge validations to maximize success rate and minimize path length and search time.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately sampling points biased toward the opposite tree's root. Each new node is connected with minimal cost parent within an adaptive radius, followed by rewiring neighbors to improve path cost dynamically. Upon the trees connecting, a final path is extracted and refined through iterative shortcut smoothing to enhance path smoothness and reduce unnecessary detours.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, base_radius: float=20.0, goal_sample_rate: float=0.15, smooth_iter: int=50, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.base_radius\n            gamma = self.base_radius\n            r = gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim)\n            return min(r, self.base_radius)\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and (not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_start = [Node(start_position, cost=0.0)]\n        nodes_goal = [Node(goal_position, cost=0.0)]\n        edges = []\n        success_state = False\n        extracted_path: list = []\n\n        for iteration in range(self.max_iter):\n            sample_from_start = (iteration % 2 == 0)  # alternate expansions\n\n            # Sample point with goal bias towards opposite tree root\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if sample_from_start else start_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not within_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not collision_free_node(new_pos)) or (not collision_free_edge(nearest_node.position, new_pos)):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose parent with minimum cost plus edge cost and collision-free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                if n == nearest_node:\n                    continue\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(n.position, new_pos):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors if new_node offers better cost path\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, n.position)\n                if new_cost < n.cost and collision_free_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt to connect trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            connect_dist = dist(new_node.position, nearest_in_b.position)\n            if connect_dist <= self.step_size and collision_free_edge(new_node.position, nearest_in_b.position):\n                success_state = True\n                extracted_path = extract_path(new_node, nearest_in_b)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        all_nodes = nodes_start + nodes_goal\n        return PlannerResult(success_state, extracted_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 27.5084,
    "time_improvement": -57.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.019411492347717284,
            "num_nodes_avg": 142.6,
            "path_length_avg": 171.75302667707885,
            "smoothness_avg": 0.02220117442191801,
            "success_improvement": -9.999999999999998,
            "time_improvement": -96.39829792982336,
            "length_improvement": 14.159488070462297,
            "smoothness_improvement": 113.32590442242139,
            "objective_score": -75.52096224274243
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026100778579711915,
            "num_nodes_avg": 290.1,
            "path_length_avg": 243.40108193675945,
            "smoothness_avg": 0.062478689924205674,
            "success_improvement": 0.0,
            "time_improvement": -71.99627961928942,
            "length_improvement": 19.231286388296823,
            "smoothness_improvement": 775.2664052182472,
            "objective_score": -13.876294582036225
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.028390884399414062,
            "num_nodes_avg": 301.0,
            "path_length_avg": 131.9841449195256,
            "smoothness_avg": 0.10988654873260661,
            "success_improvement": 0.0,
            "time_improvement": -2.2322306251980004,
            "length_improvement": 18.953784160752218,
            "smoothness_improvement": 750.1917760943002,
            "objective_score": 6.872046525062545
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an optimized bidirectional RRT* variant integrating adaptive step sizes and dynamically computed rewiring radius for efficient exploration and path quality. It employs goal-biased sampling, strict collision and edge validations, iterative rewiring for cost improvement, and progressive shortcut smoothing. The method focuses on balancing exploration and exploitation, accelerating convergence, enhancing the success rate, and producing smoother, shorter paths with reduced computation time.",
    "planning_mechanism": "The algorithm grows two trees from start and goal alternately by sampling with goal bias, steering within adaptive step sizes, and connecting nodes only if collision-free. It selects optimal parents within a shrinking radius based on node count and rewires neighbors for cost reduction. On trees connection, it reconstructs and smooths the path through iterative shortcutting, ensuring refined and collision-free final trajectories.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4500,\n                 initial_step_size: float = 5.0,\n                 goal_sample_rate: float = 0.17,\n                 collision_resolution: float = 0.4,\n                 base_radius: float = 20.0,\n                 smooth_iter: int = 80):\n        self.max_iter = max_iter\n        self.initial_step_size = initial_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.base_radius = base_radius\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_position, cost=0.0)]\n        nodes_goal = [Node(goal_position, cost=0.0)]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step_size):\n            d = dist(from_pos, to_pos)\n            if d <= step_size:\n                return to_pos\n            ratio = step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(\n                gamma * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim),\n                self.base_radius\n            )\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            if not within_bounds(b):\n                return False\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate connection node\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if sample_from_start else start_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            step_ratio = 1.0\n            # Adaptive step size decreasing after 80% iterations to improve fine tuning\n            if i > 0.8 * self.max_iter:\n                step_ratio = max(0.25, 1.0 - (i - 0.8 * self.max_iter) / (0.2 * self.max_iter))\n            curr_step_size = self.initial_step_size * step_ratio\n\n            new_pos = steer(nearest_node.position, sample, curr_step_size)\n            if not collision_free_node(new_pos):\n                continue\n            if not collision_free_edge(nearest_node.position, new_pos):\n                continue\n\n            n_nodes = len(tree_a)\n            radius = adaptive_radius(n_nodes)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                if n == nearest_node:\n                    continue\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(n.position, new_pos):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos)\n            new_node.parent = None\n            new_node.cost = 0\n            new_node.update_parent(min_node, min_cost)\n\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors for cost improvement\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, n.position)\n                if new_cost + 1e-8 < n.cost and collision_free_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.update_parent(new_node, new_cost)\n                    edges.append((new_node, n))\n\n            nearest_in_b = nearest(tree_b, new_node.position)\n            connect_dist = dist(new_node.position, nearest_in_b.position)\n            if connect_dist <= curr_step_size and collision_free_edge(new_node.position, nearest_in_b.position):\n                # Connect trees by creating a connection node if necessary\n                connection_node = None\n                if nearest_in_b.position != new_node.position:\n                    connection_node = Node(new_node.position)\n                    connection_node.parent = None\n                    connection_node.cost = 0\n                    connection_node.update_parent(nearest_in_b, nearest_in_b.cost + connect_dist)\n                    tree_b.append(connection_node)\n                    edges.append((nearest_in_b, connection_node))\n                else:\n                    connection_node = nearest_in_b\n\n                # Rewire neighbors near connection node in tree_b\n                neighbors_b = near(tree_b, connection_node.position, radius)\n                for n in neighbors_b:\n                    if n == connection_node.parent:\n                        continue\n                    cost_through_conn = connection_node.cost + dist(connection_node.position, n.position)\n                    if cost_through_conn + 1e-8 < n.cost and collision_free_edge(connection_node.position, n.position):\n                        if n.parent:\n                            n.parent.remove_child(n)\n                            if (n.parent, n) in edges:\n                                edges.remove((n.parent, n))\n                        n.update_parent(connection_node, cost_through_conn)\n                        edges.append((connection_node, n))\n\n                extracted_path = extract_path(new_node, connection_node)\n                extracted_path = shortcut_smooth(extracted_path)\n                success_state = True\n                break\n\n        all_nodes = nodes_start + nodes_goal\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 32.14629,
    "time_improvement": -74.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024218487739562988,
            "num_nodes_avg": 158.4,
            "path_length_avg": 174.96959229872508,
            "smoothness_avg": 0.027444630578964763,
            "success_improvement": 0.0,
            "time_improvement": -145.03369886673389,
            "length_improvement": 12.551879488773693,
            "smoothness_improvement": 163.70905108591563,
            "objective_score": -40.181188506835845
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027478623390197753,
            "num_nodes_avg": 273.4,
            "path_length_avg": 249.0980781243686,
            "smoothness_avg": 0.07439754759725252,
            "success_improvement": 0.0,
            "time_improvement": -81.07586245903339,
            "length_improvement": 17.340830315289217,
            "smoothness_improvement": 942.2381474627011,
            "objective_score": -16.143401937338666
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.02664780616760254,
            "num_nodes_avg": 250.7,
            "path_length_avg": 129.44960667827476,
            "smoothness_avg": 0.13106793944396694,
            "success_improvement": -9.999999999999998,
            "time_improvement": 4.044388774372226,
            "length_improvement": 20.510143324032697,
            "smoothness_improvement": 914.0721090080152,
            "objective_score": -40.11429415784171
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined bidirectional RRT* planner that grows two trees from start and goal positions, alternately sampling and extending nodes while rewiring neighbor connections to optimize path costs. It integrates goal biasing, adaptive neighborhood radius, and collision checking to ensure validity and improves path quality by shortcut smoothing once a connection is found.",
    "planning_mechanism": "The planner alternately expands two trees toward random or goal-biased samples, adding new nodes only if they and their connecting edges are collision-free. It rewires neighbors within an adaptive radius to maintain near-optimal paths and attempts to connect the two trees when nodes are proximal. Upon successful connection, the shortest path is extracted and smoothed for improved length and navigation feasibility.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, base_radius: float = 15.0, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        success = False\n        final_path = []\n\n        for i in range(self.max_iter):\n            expand_start_tree = (i % 2 == 0)\n            tree_a = nodes_start if expand_start_tree else nodes_goal\n            tree_b = nodes_goal if expand_start_tree else nodes_start\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if expand_start_tree else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative = n.cost + dist(n.position, new_pos)\n                if tentative < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt connection\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    success = True\n                    final_path = extract_path(new_node, nearest_in_b)\n                    final_path = smooth_path(final_path)\n                    all_nodes = nodes_start + nodes_goal\n                    return PlannerResult(success, final_path, all_nodes, edges)\n\n        all_nodes = nodes_start + nodes_goal\n        return PlannerResult(success, final_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 13.86995,
    "time_improvement": -68.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01863260269165039,
            "num_nodes_avg": 142.8,
            "path_length_avg": 171.92176789776113,
            "smoothness_avg": 0.024019109485770608,
            "success_improvement": 0.0,
            "time_improvement": -88.51778055452367,
            "length_improvement": 14.075152830220997,
            "smoothness_improvement": 130.79401823962203,
            "objective_score": -23.086333509114787
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.029965639114379883,
            "num_nodes_avg": 345.7,
            "path_length_avg": 237.0964916805226,
            "smoothness_avg": 0.06793544900345658,
            "success_improvement": 0.0,
            "time_improvement": -97.46454797688587,
            "length_improvement": 21.32336272909728,
            "smoothness_improvement": 851.7103560954502,
            "objective_score": -20.716140066769054
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03295423984527588,
            "num_nodes_avg": 374.8,
            "path_length_avg": 128.09774808117234,
            "smoothness_avg": 0.10401656939575891,
            "success_improvement": 0.0,
            "time_improvement": -18.664336078585244,
            "length_improvement": 21.34026593998561,
            "smoothness_improvement": 704.7757700809042,
            "objective_score": 2.1926312148260703
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a hybrid bidirectional path planner integrating a rapidly-exploring random tree (RRT) with anytime path improvement through adaptive informed sampling, dynamic neighbor radius, and iterative path smoothing post-connection. It uses goal-biased sampling combined with sampling inside an ellipsoidal informed subset to focus exploration near the current best path, accelerating convergence towards optimal routes. The planner performs strict node and edge collision checks and grows trees alternatively from start and goal, connecting them when close. Upon connection, it iteratively improves the path quality using shortcut smoothing, balancing exploration and exploitation to enhance planning success, path optimality, and smoothness while keeping computational cost controlled.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, sampling with goal bias and adaptive informed sampling based on the best current path cost. Each newly sampled node is connected via the least-cost parent within an adaptive radius, factoring in collision-free rewiring opportunities in the neighborhood. Upon tree connection (nodes within step size and collision-free), the solution path is extracted and improved via multiple iterations of shortcut smoothing. The algorithm uses dynamic neighborhood radius based on current iteration to balance global exploration initially and local exploitation later, thus refining the path incrementally for improved path length, smoothness, and planning efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, min_radius: float = 8.0, max_radius: float = 30.0,\n                 smoothing_iters: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            distance_ = dist(from_p, to_p)\n            if distance_ <= max_step:\n                return to_p\n            ratio = max_step / distance_\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def adaptive_radius(iter_num):\n            scale = min(1.0, iter_num / (self.max_iter * 0.8))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r)\n\n        def informed_sample(best_cost):\n            # If no best path known, uniform random sampling\n            if best_cost == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            import numpy as np\n            start_np = np.array(start_pos)\n            goal_np = np.array(goal_pos)\n            c_min = dist(start_pos, goal_pos)\n            c_best = max(best_cost, c_min + 1e-6)\n            center = (start_np + goal_np) / 2\n            a1 = (goal_np - start_np) / c_min\n\n            while True:\n                # Sample unit ball\n                direction = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction /= norm\n                radius = random.uniform(0, 1) ** (1 / dim)\n                point_ball = radius * direction\n\n                # Create orthonormal basis via SVD\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                L_diag = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1)\n                L = np.diag(L_diag)\n                sample = U @ L @ point_ball + center\n                sample = np.clip(sample, [0]*dim, bounds)\n                sample_t = tuple(float(v) for v in sample)\n                if not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                    return sample_t\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicating connecting node\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialization\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iter_idx in range(self.max_iter):\n\n            # Alternate which tree to grow\n            grow_start = iter_idx % 2 == 0\n            tree_a = tree_start if grow_start else tree_goal\n            tree_b = tree_goal if grow_start else tree_start\n\n            # Sampling with goal bias and informed sampling if path known\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if grow_start else start_pos\n            else:\n                if best_cost < float('inf') and random.random() < 0.6:\n                    sample = informed_sample(best_cost)\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n\n            radius = adaptive_radius(iter_idx)\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Select best parent minimizing cost & collision-free edge\n            min_cost = tentative_cost\n            min_parent = nearest_node\n            for n in neighbors:\n                if n is nearest_node:\n                    continue\n                edge_c = dist(n.position, new_pos)\n                potential_cost = n.cost + edge_c\n                if potential_cost + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, resolution=1.0):\n                        min_cost = potential_cost\n                        min_parent = n\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewiring nearby neighbors through new_node if cheaper & collision-free\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=1.0):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n            # Try to connect to the other tree if nodes are close enough & edge free\n            nearest_in_b = nearest(tree_b, new_node.position)\n            d_connect = dist(new_node.position, nearest_in_b.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, resolution=1.0):\n                    # Connection success\n                    success_state = True\n                    path = extract_path(new_node, nearest_in_b)\n                    path_cost = 0.0\n                    for i in range(len(path)-1):\n                        path_cost += dist(path[i], path[i+1])\n\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = path\n                        extracted_path = shortcut_smooth(best_path)\n                    # Return immediately for fastest found solution with smoothing\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        # If no immediate connection, check if best path found\n        if best_path:\n            extracted_path = shortcut_smooth(best_path)\n            success_state = True\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 28.9685,
    "time_improvement": -123.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03168480396270752,
            "num_nodes_avg": 122.1,
            "path_length_avg": 161.18494038136018,
            "smoothness_avg": 0.04251427651230032,
            "success_improvement": 0.0,
            "time_improvement": -220.57512410928376,
            "length_improvement": 19.441316025934878,
            "smoothness_improvement": 308.50976238886034,
            "objective_score": -60.74172521565386
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03471205234527588,
            "num_nodes_avg": 270.0,
            "path_length_avg": 226.0052186804375,
            "smoothness_avg": 0.08131810058270968,
            "success_improvement": 0.0,
            "time_improvement": -128.74198342796632,
            "length_improvement": 25.003822344991033,
            "smoothness_improvement": 1039.1884442927367,
            "objective_score": -28.425888337928008
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.033362293243408205,
            "num_nodes_avg": 244.2,
            "path_length_avg": 125.50811614307008,
            "smoothness_avg": 0.10898610905166513,
            "success_improvement": 0.0,
            "time_improvement": -20.133688301586808,
            "length_improvement": 22.930455952033004,
            "smoothness_improvement": 743.2250779821566,
            "objective_score": 2.2621100898413413
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates the strengths of enhanced bidirectional RRT* with adaptive rewiring, goal biasing, and shortcut smoothing alongside the efficient dual-tree expansion strategy of bidirectional RRT. It uses adaptive neighborhood radius for rewiring to optimize path cost, goal biasing for directed sampling, and incremental tree connection attempts to efficiently find shorter, smoother, and collision-free paths. The combined approach improves planning efficiency, robustness, and path quality in 2D/3D obstacle-laden environments.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal positions, sampling points with a goal bias to guide exploration. Each new node is added after collision and edge checks, selecting the best parent in an adaptive neighborhood and rewiring neighbors to reduce costs. After node addition, the algorithm tries to connect the two trees within step-size distance. Upon successful connection, it reconstructs the path by joining both trees and performs shortcut smoothing to improve path smoothness and length, returning the final plan promptly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 15.0,\n                 goal_sample_rate: float = 0.15, collision_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        import random\n        import math\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1 / dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            # Find nearest node & steer towards sample\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            # Adaptive radius neighbors\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose parent with lowest cost + collision-free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors to reduce cost\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Try to connect trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    # Connect the two trees via incremental extension from nearest_in_b towards new_node.position\n                    curr = nearest_in_b\n                    connected = False\n                    while True:\n                        next_pos = steer(curr.position, new_node.position)\n                        if self._is_in_obstacle(next_pos, obstacles, is_3d) or \\\n                           self._is_edge_in_obstacle(curr.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                            break\n                        new_connect_node = Node(next_pos, parent=curr, cost=curr.cost + dist(curr.position, next_pos))\n                        curr.add_child(new_connect_node)\n                        tree_b.append(new_connect_node)\n                        edges.append((curr, new_connect_node))\n                        curr = new_connect_node\n                        if dist(curr.position, new_node.position) <= self.step_size:\n                            final_node = Node(new_node.position, parent=curr, cost=curr.cost + dist(curr.position, new_node.position))\n                            curr.add_child(final_node)\n                            tree_b.append(final_node)\n                            edges.append((curr, final_node))\n                            connected = True\n                            nearest_in_b = final_node\n                            break\n                    if connected:\n                        path = extract_path(new_node, nearest_in_b)\n                        path = smooth_path(path)\n                        extracted_path = path\n                        success_state = True\n                        nodes = nodes_start + nodes_goal\n                        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        nodes = nodes_start + nodes_goal\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 19.92914,
    "time_improvement": -90.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.028511476516723634,
            "num_nodes_avg": 162.5,
            "path_length_avg": 176.83102139908817,
            "smoothness_avg": 0.03305597602327,
            "success_improvement": 0.0,
            "time_improvement": -188.46857104261446,
            "length_improvement": 11.62155511553206,
            "smoothness_improvement": 217.6271600644781,
            "objective_score": -53.128124489355535
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03005070686340332,
            "num_nodes_avg": 286.5,
            "path_length_avg": 242.17380898117318,
            "smoothness_avg": 0.08015368382182168,
            "success_improvement": 0.0,
            "time_improvement": -98.0251188542233,
            "length_improvement": 19.638537075452316,
            "smoothness_improvement": 1022.8760844510899,
            "objective_score": -20.365447818921073
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02315089702606201,
            "num_nodes_avg": 243.1,
            "path_length_avg": 126.78895527027764,
            "smoothness_avg": 0.12372883090734614,
            "success_improvement": 0.0,
            "time_improvement": 16.63634670016029,
            "length_improvement": 22.14394356888038,
            "smoothness_improvement": 857.289456411638,
            "objective_score": 13.706140005882354
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner combines bidirectional RRT* growth with adaptive informed sampling, dynamic neighborhood radius scaling, and rigorous collision checking. It alternates tree expansions from start and goal, prioritizes samples near the current best path (informed sampling) to accelerate convergence, rewires locally within an adaptive radius for path cost optimization, and validates connections carefully to ensure robust collision-free paths. After a successful tree connection, it applies iterative shortcut smoothing to improve path quality and smoothness while maintaining planning efficiency and higher success rates in complex 2D/3D spaces.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling with goal bias and informed sampling near the current best path. Each extension steers toward sampled points while avoiding obstacles, rewires neighbors within an adaptively scaled radius for cost optimization, and attempts direct connections between trees. Upon connecting, it extracts the path, refines it via iterative shortcut smoothing, and returns the optimized feasible path. Early stopping upon success reduces search time while dynamic radius and informed sampling improve path quality and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.12, min_search_radius: float = 8.0,\n                 max_search_radius: float = 25.0, smoothing_iters: int = 60,\n                 collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_search_radius = min_search_radius\n        self.max_search_radius = max_search_radius\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_position, cost=0.0)]\n        nodes_goal = [Node(goal_position, cost=0.0)]\n\n        nodes = nodes_start + nodes_goal\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        best_path_cost = float(\"inf\")\n        best_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [n for n in tree if distance(n.position, new_node.position) <= radius]\n\n        def adaptive_radius(iteration, n_nodes):\n            scale_iter = min(1.0, iteration / (self.max_iter / 2))\n            base_r = self.max_search_radius - (self.max_search_radius - self.min_search_radius) * scale_iter\n            if n_nodes == 0:\n                return base_r\n            gamma = base_r\n            return max(self.min_search_radius, min(gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), base_r))\n\n        def informed_sample():\n            if best_path_cost == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            start = np.array(start_position)\n            goal = np.array(goal_position)\n            c_min = distance(start_position, goal_position)\n            c_best = best_path_cost\n            if c_best < c_min:\n                c_best = c_min + 1e-6\n            center = (start + goal) / 2\n            a1 = (goal - start) / c_min\n            I = np.eye(dim)\n            M = np.outer(a1, a1)\n            U, _, _ = np.linalg.svd(M)\n            L_diags = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1)\n            L = np.diag(L_diags)\n            while True:\n                direction = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction /= norm\n                radius = random.uniform(0, 1) ** (1/dim)\n                point_ball = radius * direction\n                sample_np = U @ L @ point_ball + center\n                sample_clipped = np.minimum(np.maximum(sample_np, 0), bounds)\n                sample_t = tuple(float(v) for v in sample_clipped)\n                if not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                    return sample_t\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b):\n            nearest_b = find_nearest(tree_b, node_from_a.position)\n            dist_between = distance(node_from_a.position, nearest_b.position)\n            if dist_between > self.step_size:\n                # Extend tree_b towards node_from_a in incremental steps\n                curr_node = nearest_b\n                while True:\n                    new_pos = steer(curr_node.position, node_from_a.position, self.step_size)\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        return None\n                    if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        return None\n                    new_cost = curr_node.cost + distance(curr_node.position, new_pos)\n                    new_node = Node(new_pos, parent=curr_node, cost=new_cost)\n                    curr_node.add_child(new_node)\n                    tree_b.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((curr_node, new_node))\n                    if distance(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                        # Final connect node_to_a\n                        final_cost = new_node.cost + distance(new_pos, node_from_a.position)\n                        final_node = Node(node_from_a.position, parent=new_node, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree_b.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    curr_node = new_node\n            else:\n                # Direct connection attempt\n                if not self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d, self.collision_resolution):\n                    # Attach nearest_b as child of node_from_a's tree or vice versa\n                    return nearest_b\n            return None\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                # Remove duplicate connecting node\n                return path_start + path_goal[-2::-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iter_count in range(self.max_iter):\n            # Alternate growth: even iter start from start_tree first, odd vice versa\n            if iter_count % 2 == 0:\n                tree_pairs = [(nodes_start, nodes_goal), (nodes_goal, nodes_start)]\n            else:\n                tree_pairs = [(nodes_goal, nodes_start), (nodes_start, nodes_goal)]\n\n            for tree_a, tree_b in tree_pairs:\n                # Sampling with goal bias and informed sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is nodes_start else start_position\n                else:\n                    if best_path_cost < float(\"inf\") and random.random() < 0.6:\n                        sample = informed_sample()\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                # Bound check\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = find_nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                    continue\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    continue\n\n                tentative_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                curr_radius = adaptive_radius(iter_count, len(tree_a))\n                neighbors = find_near(tree_a, new_node, curr_radius)\n\n                # Parent selection with minimal cost\n                min_cost = tentative_cost\n                min_node = nearest_node\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_node.position)\n                    cost_total = node.cost + edge_cost\n                    if cost_total + 1e-10 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                            min_cost = cost_total\n                            min_node = node\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewiring neighbors to new_node if beneficial\n                rewire(tree_a, new_node, neighbors)\n\n                # Try connecting to other tree\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node is not None:\n                    success_state = True\n                    if tree_a is nodes_start:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n\n                    # Update best found path cost and path\n                    path_len = 0.0\n                    for i in range(len(extracted_path) -1):\n                        path_len += distance(extracted_path[i], extracted_path[i+1])\n                    if path_len < best_path_cost:\n                        best_path_cost = path_len\n                        best_path = extracted_path\n\n                    # Shortcut smoothing\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        # If no connection found, but best path found heuristically\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 61.32462,
    "time_improvement": -7.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009485936164855957,
            "num_nodes_avg": 63.8,
            "path_length_avg": 158.00820229792407,
            "smoothness_avg": 0.025076599502371604,
            "success_improvement": 0.0,
            "time_improvement": 4.024807383356571,
            "length_improvement": 21.029019186828318,
            "smoothness_improvement": 140.95519304604923,
            "objective_score": 6.118022017602882
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023838496208190917,
            "num_nodes_avg": 241.5,
            "path_length_avg": 241.07617529926205,
            "smoothness_avg": 0.056381284478848194,
            "success_improvement": 0.0,
            "time_improvement": -57.08851929476161,
            "length_improvement": 20.002769065710577,
            "smoothness_improvement": 689.8476143986819,
            "objective_score": -9.676763903292958
        },
        {
            "map_id": 2,
            "success_rate": 0.6,
            "time_avg": 0.01867554187774658,
            "num_nodes_avg": 203.6,
            "path_length_avg": 110.33039314478413,
            "smoothness_avg": 0.09847030627206266,
            "success_improvement": -40.0,
            "time_improvement": 32.751573447435995,
            "length_improvement": 32.25049219439699,
            "smoothness_improvement": 661.8643550787289,
            "objective_score": -180.41510775149618
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements a Bidirectional Adaptive Informed RRT* algorithm with dynamic neighborhood radius and lazy collision checking to improve efficiency and path quality. It alternates growing trees from the start and goal positions, employs heuristic-informed ellipsoidal sampling around the current best path cost to focus search, dynamically adjusts the rewiring radius for optimal exploration-exploitation balance, and delays collision checks on edges until strictly necessary. Path smoothing via iterative shortcutting enhances final path smoothness and reduces unnecessary waypoints.",
    "planning_mechanism": "The planner initializes two trees growing from start and goal, sampling nodes mainly within an ellipsoidal subset guided by the current best path cost. Each iteration adjusts the rewiring radius adaptively based on the number of nodes, extends trees toward sampled points while ensuring collision-free new nodes and edges. Lazy collision checking caches edge validity to minimize redundant checks, speeding planning. When the two trees connect with a lower-cost path, the path is extracted and shortcut-smoothed for better quality before termination.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For lazy collision validation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 radius_max: float = 25.0, smooth_iter: int = 50,\n                 collision_resolution: float = 0.5, informed_sampling_rate: float = 0.9):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max               # Maximum rewiring radius\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (sum((n.position[i] - point[i]) ** 2 for i in range(dim)) <= radius_sq)]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def lazy_collision_free_edge(a, b, cache):\n            key = tuple(sorted([a, b]))\n            if key in cache:\n                return cache[key]\n            is_collision = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            cache[key] = not is_collision\n            return not is_collision\n\n        # Informed ellipsoidal sampling inside margin defined by c_max cost\n        def informed_sample(c_max, start, goal):\n            if math.isinf(c_max):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                c_max = c_min + 1e-6\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n\n            if c_min == 0.0:\n                unit_vec = tuple(0 for _ in range(dim))\n            else:\n                unit_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s],\n                                     [s, c]])\n                elif dim == 3:\n                    x_axis = np.array(vec)\n                    if np.linalg.norm(x_axis) < 1e-12:\n                        return np.eye(3)\n                    x_axis /= np.linalg.norm(x_axis)\n                    if abs(x_axis[0]) < 1e-6 and abs(x_axis[1]) < 1e-6:\n                        temp = np.array([0, 1, 0])\n                    else:\n                        temp = np.array([0, 0, 1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= np.linalg.norm(y_axis)\n                    z_axis = np.cross(x_axis, y_axis)\n                    return np.stack((x_axis, y_axis, z_axis), axis=1)\n                else:\n                    return np.eye(dim)\n\n            L = np.diag([c_max / 2] + [math.sqrt(c_max ** 2 - c_min ** 2) / 2] * (dim - 1))\n            R = rotation_matrix(unit_vec)\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-12:\n                    continue\n                x_ball /= norm_x\n                r = np.random.uniform(0, 1) ** (1 / dim)\n                sample_ball = x_ball * r\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                p = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if lazy_collision_free_edge(p1, p2, collision_edge_cache):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def rewire(tree, new_node, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if tentative_cost < neighbor.cost:\n                    if lazy_collision_free_edge(new_node.position, neighbor.position, collision_edge_cache):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = tentative_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        start_tree = [Node(start_position, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_position, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        best_path_cost = math.inf\n        best_nodes_pair = None\n        collision_edge_cache = dict()\n\n        for iteration in range(self.max_iter):\n            n = len(nodes)\n            gamma = self.radius_max\n            radius = min(gamma * (math.log(n + 1) / (n + 1)) ** (1 / dim), self.radius_max)\n\n            if random.random() < self.informed_sampling_rate:\n                sample = informed_sample(best_path_cost, start_position, goal_position)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate growth order each iteration for balanced expansion\n            pairs = [(start_tree, goal_tree), (goal_tree, start_tree)] if iteration % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]\n            for tree_a, tree_b in pairs:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not lazy_collision_free_edge(nearest_node.position, new_pos, collision_edge_cache):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n\n                neighbors = near(tree_a, new_pos, radius)\n                min_cost = new_cost\n                min_parent = nearest_node\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and lazy_collision_free_edge(neighbor.position, new_pos, collision_edge_cache):\n                        min_cost = cost_through\n                        min_parent = neighbor\n\n                # Create and connect new node\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nearby nodes to potentially reduce costs\n                rewire(tree_a, new_node, radius)\n\n                # Attempt connection to the other tree for path completion\n                nearest_other = nearest(tree_b, new_node.position)\n                dist_other = dist(new_node.position, nearest_other.position)\n                if dist_other <= self.step_size:\n                    if lazy_collision_free_edge(new_node.position, nearest_other.position, collision_edge_cache):\n                        total_cost = new_node.cost + dist_other + nearest_other.cost\n                        if total_cost < best_path_cost:\n                            best_path_cost = total_cost\n                            best_nodes_pair = (new_node, nearest_other)\n\n            if best_nodes_pair is not None:\n                success_state = True\n                node_a, node_b = best_nodes_pair\n                extracted_path = extract_path(node_a, node_b)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 58.90727,
    "time_improvement": -215.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.027139687538146974,
            "num_nodes_avg": 126.4,
            "path_length_avg": 171.8098150729818,
            "smoothness_avg": 0.026829905713478448,
            "success_improvement": 0.0,
            "time_improvement": -174.58931767634618,
            "length_improvement": 14.131105776011493,
            "smoothness_improvement": 157.80230329822405,
            "objective_score": -48.76156263121043
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03765759468078613,
            "num_nodes_avg": 263.7,
            "path_length_avg": 243.46033176698083,
            "smoothness_avg": 0.05797093301879539,
            "success_improvement": 0.0,
            "time_improvement": -148.15222138778998,
            "length_improvement": 19.211625290118402,
            "smoothness_improvement": 712.1170628267446,
            "objective_score": -37.04275604417958
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11761980056762696,
            "num_nodes_avg": 422.8,
            "path_length_avg": 136.2945144824375,
            "smoothness_avg": 0.08741455705864266,
            "success_improvement": 0.0,
            "time_improvement": -323.53504767775394,
            "length_improvement": 16.30695758809317,
            "smoothness_improvement": 576.3260688351317,
            "objective_score": -90.91749244153188
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified yet effective bidirectional RRT* variant that balances rapid exploration with path quality optimization. It grows two trees from the start and goal positions, incrementally extending them towards sampled points with goal biasing. Each new node connects to the best parent within a neighborhood radius to minimize cost, followed by rewiring neighbors to improve local paths. Collision and edge checks ensure all expansions are valid. The planner terminates early upon successfully connecting the two trees, providing an optimized, smooth path.",
    "planning_mechanism": "The planner alternately grows the start and goal trees by sampling free points (biased towards the goal), steering towards them with a fixed step size without crossing obstacles or boundaries. It rewires neighbors within a specified radius to improve path costs, and attempts to directly connect the two trees after each extension. The output is the lowest-cost feasible path between start and goal.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from start node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, search_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            # Extend backward from connect_node toward node_a until close enough\n            curr = connect_node\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                if distance(new_pos, node_a.position) < self.step_size:\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_from_start, node_from_goal):\n            path_start = []\n            node = node_from_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_from_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        for _ in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                neighbors = find_near(tree_a, new_node, self.search_radius)\n\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                rewire(tree_a, new_node, neighbors)\n\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 16.34412,
    "time_improvement": -68.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011444926261901855,
            "num_nodes_avg": 168.2,
            "path_length_avg": 169.95961264646039,
            "smoothness_avg": 0.02059908963009557,
            "success_improvement": 0.0,
            "time_improvement": -15.795529653555382,
            "length_improvement": 15.05581916557219,
            "smoothness_improvement": 97.93184550094732,
            "objective_score": -1.23783583544744
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02688333988189697,
            "num_nodes_avg": 494.8,
            "path_length_avg": 246.73029177810767,
            "smoothness_avg": 0.014413332321784414,
            "success_improvement": 0.0,
            "time_improvement": -77.15312320304668,
            "length_improvement": 18.12654193075582,
            "smoothness_improvement": 101.91693493907081,
            "objective_score": -19.011043900067484
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.058880853652954104,
            "num_nodes_avg": 659.8,
            "path_length_avg": 128.2792857011045,
            "smoothness_avg": 0.027857580387390345,
            "success_improvement": 0.0,
            "time_improvement": -112.02301856371788,
            "length_improvement": 21.22879090533705,
            "smoothness_improvement": 115.53398500918892,
            "objective_score": -28.783477463002008
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the efficiency of bidirectional RRT with the optimality and informed sampling principles of Bidirectional Informed RRT*. It grows trees alternately from start and goal, samples both uniformly and within an informed ellipsoidal subset based on the current best path cost to bias search towards promising regions, and incrementally rewires nodes locally to improve path cost. It employs strict collision checks on nodes and edges, balances exploration and exploitation through adaptive sampling rates, and applies iterative shortcut smoothing once a valid path is found. This integrated approach enhances planning efficiency, success rate, path quality, smoothness, and reduces search time.",
    "planning_mechanism": "The planner initializes two trees at start and goal. Each iteration performs goal-biased and informed sampling within a dynamically updated ellipsoid based on the best path cost. Trees grow toward samples via collision-free edges, incorporating rewiring in local neighborhoods to optimize costs. When the trees connect, the path is extracted, shortcut-smoothed iteratively to remove unnecessary detours, then returned. The trees alternate growth each iteration to balance exploration from both ends, improving convergence and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0, radius: float=12.0, smooth_iter: int=40, collision_resolution: float=0.4,\n                 goal_sample_rate: float = 0.1, informed_sampling_rate: float = 0.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n        self.goal_sample_rate = goal_sample_rate\n        self.informed_sampling_rate = informed_sampling_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n        best_connect_nodes = None\n\n        # Steering function with step_size limit\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Nearest neighbor in tree to point\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        # Nearby nodes within radius\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        # Collision checks: node free\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        # Collision checks: edge free\n        def collision_free_edge(a, b):\n            if not within_bounds(b):\n                return False\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution):\n                return False\n            return True\n\n        # Extract combined path from two connecting nodes\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        # Rewire nodes in local neighborhood to improve cost\n        def rewire(tree, new_node):\n            for near_node in near(tree, new_node.position, self.radius):\n                if near_node == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if tentative_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    # Remove old edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    # Re-parent\n                    near_node.parent = new_node\n                    near_node.cost = tentative_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        # Informed sample within ellipsoid defined by best path cost\n        def informed_sample(c_max, start, goal):\n            if math.isinf(c_max):\n                # No solution yet \u2192 uniform random sample\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                c_max = c_min + 1e-9  # numerical safety fallback\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            if c_min == 0.0:\n                unit_vec = tuple(0.0 for _ in range(dim))\n            else:\n                unit_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            import numpy as np\n\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s], [s, c]])\n                elif dim == 3:\n                    x_axis = np.array(vec)\n                    nl = np.linalg.norm(x_axis)\n                    if nl < 1e-12:\n                        return np.eye(3)\n                    x_axis /= nl\n                    # Choosing arbitrary axes perpendicular to x_axis\n                    if abs(x_axis[0]) < 1e-8 and abs(x_axis[1]) < 1e-8:\n                        temp = np.array([0, 1, 0])\n                    else:\n                        temp = np.array([0, 0, 1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= np.linalg.norm(y_axis)\n                    z_axis = np.cross(x_axis, y_axis)\n                    rot = np.stack((x_axis, y_axis, z_axis), axis=1)\n                    return rot\n                else:\n                    return np.eye(dim)\n\n            L_diag = [c_max / 2] + [math.sqrt(c_max ** 2 - c_min ** 2) / 2] * (dim - 1)\n            L = np.diag(L_diag)\n            R = rotation_matrix(unit_vec)\n\n            while True:\n                # Sample uniformly in unit n-ball\n                x_ball = np.random.normal(0, 1, dim)\n                x_ball /= np.linalg.norm(x_ball)\n                u = np.random.uniform(0, 1)\n                r = u ** (1 / dim)\n                sample_ball = x_ball * r\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                sample = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n                if within_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        # Path shortcut smoothing by attempting to skip intermediate nodes\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main iterative planning loop\n        for iter in range(self.max_iter):\n            # Sampling strategy mixture:\n            # 1) goal biased sampling: towards goal to help progress\n            # 2) informed sampling biased towards improving solution region\n            sample = None\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sample = goal_position\n            elif r < self.goal_sample_rate + self.informed_sampling_rate:\n                sample = informed_sample(best_path_cost, start_position, goal_position)\n            else:\n                # Uniform random sample\n                while True:\n                    candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(candidate, obstacles, is_3d):\n                        sample = candidate\n                        break\n\n            # Alternate tree expansions: start->goal, goal->start\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                # Check collisions on new node and edge\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire neighborhood for optimizing path cost locally\n                rewire(tree_a, new_node)\n\n                # Try to connect to the other tree within step size\n                nearest_in_other = nearest(tree_b, new_node.position)\n                dist_between = dist(new_node.position, nearest_in_other.position)\n\n                if dist_between <= self.step_size and collision_free_edge(new_node.position, nearest_in_other.position):\n                    total_cost = new_node.cost + dist_between + nearest_in_other.cost\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connect_nodes = (new_node, nearest_in_other)\n\n            if best_connect_nodes is not None:\n                success_state = True\n                node_a, node_b = best_connect_nodes\n                extracted_path = extract_path(node_a, node_b)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 91.35948,
    "time_improvement": -155.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.02070744037628174,
            "num_nodes_avg": 175.3,
            "path_length_avg": 176.54116937007288,
            "smoothness_avg": 0.015945064582938324,
            "success_improvement": -19.999999999999996,
            "time_improvement": -109.51022062264506,
            "length_improvement": 11.766420373722053,
            "smoothness_improvement": 53.212404829860084,
            "objective_score": -130.2337200878998
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.043807363510131835,
            "num_nodes_avg": 404.1,
            "path_length_avg": 246.98906224238948,
            "smoothness_avg": 0.03926579328987155,
            "success_improvement": 0.0,
            "time_improvement": -188.67734809754685,
            "length_improvement": 18.040673136112684,
            "smoothness_improvement": 450.0760304443209,
            "objective_score": -50.74468964981991
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.07400703430175781,
            "num_nodes_avg": 441.0,
            "path_length_avg": 127.58062475799895,
            "smoothness_avg": 0.0779526796305627,
            "success_improvement": -9.999999999999998,
            "time_improvement": -166.49061340196894,
            "length_improvement": 21.65781081244718,
            "smoothness_improvement": 503.11956204656366,
            "objective_score": -93.10002404786842
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements an advanced adaptive bidirectional informed RRT* planner that dynamically balances exploration and exploitation. It integrates heuristic ellipsoidal sampling focused on regions likely to improve the current best path, dense local resampling on high-cost branches for refinement, adaptive neighborhood rewiring to optimize connections, and dynamic pruning of unpromising nodes. The planner alternately grows start and goal trees with balanced sampling strategies including goal bias, informed sampling, and local dense sampling, continuously attempting direct incremental connections between trees. Progressive shortcut smoothing improves path quality whenever better solutions are found. This design improves planning efficiency, path quality, robustness, success rate, smoothness, path lengths, and reduces search time.",
    "planning_mechanism": "The planner initializes bidirectional trees and iteratively samples new nodes using a combination of uniform, goal-biased, informed ellipsoidal, and dense local samples. It adaptively sets the rewiring radius based on iteration progress, connects new nodes with minimized cost parents, performs rewiring within the adaptive neighborhood, and prunes leaves exceeding cost thresholds. After each tree extension, it attempts an incremental direct connection to the opposite tree. When a better path is discovered, progressive shortcut smoothing is applied, and near-optimal solutions trigger early termination. The approach ensures collision-free node additions and edge connections while respecting map boundaries.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, min_radius: float=6.0,\n                 max_radius: float=20.0, rewire_factor: float=1.5,\n                 pruning_threshold_factor: float=1.5, dense_fraction: float=0.1,\n                 dense_samples_per_branch: int=5, smooth_iter: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.rewire_factor = rewire_factor\n        self.pruning_threshold_factor = pruning_threshold_factor\n        self.dense_fraction = dense_fraction\n        self.dense_samples_per_branch = dense_samples_per_branch\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_pos = map.goal                # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, new_node, radius):\n            radius_sq = radius * radius\n            px = new_node.position\n            return [node for node in tree if sum((px[d]-node.position[d])**2 for d in range(dim)) <= radius_sq]\n\n        def adaptive_radius(iteration):\n            scale = min(1.0, iteration / (self.max_iter * 0.75))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r) * self.rewire_factor\n\n        def informed_sample(c_best):\n            if c_best == float(\"inf\"):\n                # Uniform sample if no path found yet\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min + 1e-7\n            center = (np.array(start_pos) + np.array(goal_pos)) * 0.5\n            a1 = (np.array(goal_pos) - np.array(start_pos)) / c_min\n\n            while True:\n                sample_dir = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(sample_dir)\n                if norm_dir == 0:\n                    continue\n                unit_dir = sample_dir / norm_dir\n                radius = random.uniform(0, 1) ** (1 / dim)\n                unit_ball_sample = radius * unit_dir\n\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                r1 = c_best / 2.0\n                if dim == 2:\n                    r_rest = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r_rest])\n                elif dim == 3:\n                    r_rest = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r_rest, r_rest])\n                else:\n                    L = np.diag([c_best/2.0]*dim)\n\n                sample_transf = U @ L @ unit_ball_sample + center\n                sample_clipped = tuple(np.clip(sample_transf, [0]*dim, bounds))\n                if not self._is_in_obstacle(sample_clipped, obstacles, is_3d):\n                    return sample_clipped\n\n        def dynamic_prune(tree, best_cost):\n            threshold = best_cost * self.pruning_threshold_factor\n            to_remove = [node for node in tree if node.cost > threshold and len(node.children) == 0]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                tree.remove(node)\n\n        def dense_resample_on_branch(tree, best_cost):\n            sorted_nodes = sorted(tree, key=lambda n: n.cost, reverse=True)\n            count = max(1, int(len(tree) * self.dense_fraction))\n            samples = []\n            radius = self.step_size * 2.5\n            for node in sorted_nodes[:count]:\n                center = np.array(node.position)\n                for _ in range(self.dense_samples_per_branch):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_np = center + offset\n                    sample_clipped = tuple(np.clip(sample_np, [0]*dim, bounds))\n                    if not self._is_in_obstacle(sample_clipped, obstacles, is_3d):\n                        samples.append(sample_clipped)\n            return samples\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.remove_child(neighbor)\n                            if (old_parent, neighbor) in edges:\n                                edges.remove((old_parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b, nodes, edges):\n            nearest_b = nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n            current = nearest_b\n            while True:\n                new_pos = steer(current.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n                new_cost = current.cost + dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_cost = new_node.cost + dist(new_pos, node_from_a.position)\n                    final_node = Node(node_from_a.position, parent=new_node, cost=final_cost)\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                current = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortcut_made = False\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i+1] + path[j:]\n                        shortcut_made = True\n                        break\n                    j -= 1\n                if not shortcut_made:\n                    i += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        best_path_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree expansion order\n            if iter_count % 2 == 0:\n                trees_sequence = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            else:\n                trees_sequence = [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            dense_samples = []\n            if best_path_cost < float(\"inf\") and (iter_count % 25 == 0) and len(start_tree) > 10:\n                dense_samples = dense_resample_on_branch(start_tree, best_path_cost)\n\n            for tree_a, tree_b in trees_sequence:\n                sample = None\n                prob_goal_bias = self.goal_sample_rate\n                prob_informed = 0.6 if best_path_cost < float(\"inf\") else 0.0\n\n                if dense_samples and random.random() < 0.4:\n                    sample = dense_samples.pop(random.randint(0, len(dense_samples) - 1))\n                else:\n                    r = random.random()\n                    if r < prob_goal_bias:\n                        sample = goal_pos if tree_a is start_tree else start_pos\n                    elif r < prob_goal_bias + prob_informed:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n\n                curr_radius = adaptive_radius(iter_count)\n                neighbors = near(tree_a, new_node, curr_radius)\n\n                # Select best parent minimizing cost\n                min_cost = tentative_cost\n                min_parent = nearest_node\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_cand = node.cost + edge_c\n                    if cost_cand + 1e-9 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost_cand\n                            min_parent = node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors, edges)\n\n                connect_node = attempt_connect(new_node, tree_b, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path_candidate = extract_path(new_node, connect_node)\n                    else:\n                        path_candidate = extract_path(connect_node, new_node)\n\n                    path_len = 0.0\n                    for i in range(len(path_candidate) - 1):\n                        path_len += dist(path_candidate[i], path_candidate[i + 1])\n\n                    if path_len + 1e-9 < best_path_cost:\n                        best_path_cost = path_len\n                        best_path = shortcut_path(path_candidate)\n\n                        dynamic_prune(start_tree, best_path_cost)\n                        dynamic_prune(goal_tree, best_path_cost)\n\n                        # Early termination criteria: near optimal solution\n                        if best_path_cost <= 1.05 * dist(start_pos, goal_pos):\n                            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n                        # Anytime return improved path\n                        return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            # If a path was found but no direct connection this iteration, progressively smooth and return\n            if success_state and best_path:\n                best_path = shortcut_path(best_path)\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n        # Failure case: no path found\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 29.44137,
    "time_improvement": -125.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.029883599281311034,
            "num_nodes_avg": 105.3,
            "path_length_avg": 171.54518875053594,
            "smoothness_avg": 0.04339622370261742,
            "success_improvement": 0.0,
            "time_improvement": -202.3512015322491,
            "length_improvement": 14.263363468514875,
            "smoothness_improvement": 316.98418714007835,
            "objective_score": -56.267766830271356
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04015681743621826,
            "num_nodes_avg": 236.4,
            "path_length_avg": 229.9923488966383,
            "smoothness_avg": 0.09437978338079146,
            "success_improvement": 0.0,
            "time_improvement": -164.621347569655,
            "length_improvement": 23.680757648637048,
            "smoothness_improvement": 1222.170068309614,
            "objective_score": -38.53940239962102
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030024075508117677,
            "num_nodes_avg": 181.9,
            "path_length_avg": 119.8661048616231,
            "smoothness_avg": 0.10696653589197407,
            "success_improvement": 0.0,
            "time_improvement": -8.113159437808594,
            "length_improvement": 26.39499075931936,
            "smoothness_improvement": 727.5996487426938,
            "objective_score": 6.483048564234763
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner combining adaptive radius rewiring and refined parameters for improved convergence speed, path quality, and robustness. It integrates goal biasing, adaptive neighborhood sampling, and path shortcutting smoothing post planning to yield shorter and smoother paths efficiently in 2D and 3D obstacle environments.",
    "planning_mechanism": "The planner simultaneously grows two trees from start and goal. Each iteration samples points with goal bias, extends the nearest tree within adaptive step size and radius with collision checking, then attempts to connect the opposite tree. After successful connection, path rewiring optimizes cost, followed by path shortcut smoothing to reduce detours. The approach balances exploration and exploitation, adaptively refining connectivity and ensuring algorithmic robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0, base_radius: float = 12.0,\n                 goal_sample_rate: float = 0.12, collision_resolution: float = 0.5, shortcut_iterations: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        success = False\n        path: list[tuple] = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def adaptive_radius(n_nodes):\n            # Shrinks adaptively; lower bound to avoid too small radius\n            gamma = self.base_radius\n            r = gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)\n            return max(min(r, self.base_radius), self.step_size * 1.5)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.shortcut_iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal bias sampling with adaptive switching\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not _is_within_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not _is_within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose parent with minimal cost while collision-free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n            nodes_all = nodes_start + nodes_goal\n\n            # Rewiring neighbors to reduce cost if possible\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt connection from new_node in tree_a to nearest in tree_b\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size * 1.2:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    path = shortcut_path(path)\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # If no connection found, return failure with explored nodes\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 29.53858,
    "time_improvement": -63.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.015970921516418456,
            "num_nodes_avg": 147.5,
            "path_length_avg": 171.9006027085146,
            "smoothness_avg": 0.02013861967888325,
            "success_improvement": -9.999999999999998,
            "time_improvement": -61.58787516222252,
            "length_improvement": 14.085730988377257,
            "smoothness_improvement": 93.50729718945175,
            "objective_score": -65.19167986504402
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.033041191101074216,
            "num_nodes_avg": 343.7,
            "path_length_avg": 251.16358408804498,
            "smoothness_avg": 0.06984458889062906,
            "success_improvement": 0.0,
            "time_improvement": -117.7315104305775,
            "length_improvement": 16.65542555736465,
            "smoothness_improvement": 878.4555712741192,
            "objective_score": -27.59609016132972
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030204415321350098,
            "num_nodes_avg": 321.4,
            "path_length_avg": 127.09260355833392,
            "smoothness_avg": 0.07520505187756713,
            "success_improvement": 0.0,
            "time_improvement": -8.762541863445973,
            "length_improvement": 21.957485227933198,
            "smoothness_improvement": 481.8611774097903,
            "objective_score": 4.172040373601799
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined, robust bidirectional RRT* planner integrating adaptive step sizing, goal-biased sampling, and dynamic neighbor radius to efficiently explore the space while ensuring collision-free connections. It incrementally rewires nodes to improve path costs and applies iterative shortcut smoothing to enhance path quality. The simplification ensures clarity and generalization while maintaining high performance and path smoothness in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling points with a goal bias. It extends each tree towards samples using adaptive step sizes, selects optimal parents within a dynamic radius, rewires neighbors for cost reduction, and attempts connections between trees. Upon successful connection, the path is reconstructed and smoothed via shortcutting, producing efficient, smooth, and collision-free paths while respecting map boundaries and obstacle constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.4, radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def _near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def _steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def _can_connect(parent_node, new_pos):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = cost\n                    best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-9 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid repeating connection node\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for iteration in range(self.max_iter):\n            sample = _sample_free()\n\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            radius = min(self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim), self.step_size * 5)\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, self.step_size)\n            if not _can_connect(nearest_node_a, new_pos_a):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n\n            if dist <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution) and \\\n               not self._is_in_obstacle(new_node_a.position, obstacles, is_3d):\n                connecting_node_b = nearest_node_b\n                # Add connecting node if positions different\n                if nearest_node_b.position != new_node_a.position:\n                    connecting_node_b = Node(new_node_a.position)\n                    connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                    tree_b.append(connecting_node_b)\n                    nodes.append(connecting_node_b)\n                    edges.append((nearest_node_b, connecting_node_b))\n\n                near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                extracted_path = _smooth_path(extracted_path)\n                success_state = True\n                break\n\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, self.step_size)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3.05605,
    "time_improvement": -32.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01565694808959961,
            "num_nodes_avg": 103.0,
            "path_length_avg": 167.61993628715476,
            "smoothness_avg": 0.029103129540041062,
            "success_improvement": 0.0,
            "time_improvement": -58.411208190006604,
            "length_improvement": 16.225166922161304,
            "smoothness_improvement": 179.6451805956212,
            "objective_score": -13.380103169591612
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026642584800720216,
            "num_nodes_avg": 319.5,
            "path_length_avg": 248.92646848226113,
            "smoothness_avg": 0.06676181421792608,
            "success_improvement": 0.0,
            "time_improvement": -75.56661963820555,
            "length_improvement": 17.39777620035306,
            "smoothness_improvement": 835.2688605868769,
            "objective_score": -15.014086348456665
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017498159408569337,
            "num_nodes_avg": 237.1,
            "path_length_avg": 127.75970477863079,
            "smoothness_avg": 0.11164852095134119,
            "success_improvement": 0.0,
            "time_improvement": 36.9911890377653,
            "length_improvement": 21.547844891817284,
            "smoothness_improvement": 763.8241479118915,
            "objective_score": 19.226046429252506
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the rapid exploration and bidirectional growth of dual-tree RRT with the optimization and rewiring capabilities of RRT*. It uses goal-biased sampling with adaptive neighborhood radius and incorporates incremental rewiring when adding nodes to improve path quality progressively. The planner grows two trees simultaneously from start and goal, attempts frequent connections, and applies rewiring locally to shorten paths, ensuring collision-free nodes and edges at all steps. Such integration enhances planning efficiency, success rate, and path smoothness while reducing overall search time.",
    "planning_mechanism": "The planner alternates expansions between start and goal trees. Each iteration samples (with goal bias), extends the nearest node towards the sample by a fixed step size, checks collisions on node and edge, then connects the new node to the best parent in its neighborhood to minimize cost. Afterwards, neighbors are rewired if lower-cost paths through the new node exist without collision. It attempts direct connections between the two trees after each expansion, terminating early once a connection is found. The final path is extracted bidirectionally and returned.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from start node\n        self.children = []\n        self.valid = True               # Validity flag for collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, max_radius: float=20.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            curr = connect_node\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                if distance(new_pos, node_a.position) < self.step_size:\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        # Adaptive radius function decreases with iterations, but not below a minimum radius\n        def adaptive_radius(iter_num):\n            gamma = self.max_radius *  (math.log(iter_num + 1 + 1) / (iter_num + 1))**0.5\n            return max(min(gamma, self.max_radius), self.step_size)\n\n        for iter_num in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal bias sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                radius = adaptive_radius(iter_num)\n                neighbors = find_near(tree_a, new_node, radius)\n\n                # Choose best parent minimizing cost for the new node\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors to possibly improve their path costs\n                rewire(tree_a, new_node, neighbors)\n\n                # Try connecting the two trees\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -7.79662,
    "time_improvement": 21.0,
    "length_improvement": 8.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008672499656677246,
            "num_nodes_avg": 171.6,
            "path_length_avg": 178.58706890783012,
            "smoothness_avg": 0.01287433619980249,
            "success_improvement": 0.0,
            "time_improvement": 12.254857027070063,
            "length_improvement": 10.743899448907847,
            "smoothness_improvement": 23.706492344377313,
            "objective_score": 5.943769459624475
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01442580223083496,
            "num_nodes_avg": 417.4,
            "path_length_avg": 285.20214147412014,
            "smoothness_avg": 0.006810454997463837,
            "success_improvement": 0.0,
            "time_improvement": 4.938302639145074,
            "length_improvement": 5.360280641017321,
            "smoothness_improvement": -4.592070180053407,
            "objective_score": 2.5305865690467195
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.015455484390258789,
            "num_nodes_avg": 416.6,
            "path_length_avg": 150.10711452935692,
            "smoothness_avg": 0.014126727627698357,
            "success_improvement": 0.0,
            "time_improvement": 44.346621176700864,
            "length_improvement": 7.825189074258418,
            "smoothness_improvement": 9.298433618285387,
            "objective_score": 14.91551633595337
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is an improved hybrid bidirectional RRT* variant incorporating goal biasing, adaptive neighborhood radius rewiring, incremental tree connection, and enhanced shortcut smoothing. It balances exploration and exploitation by alternating tree growth from start and goal, adaptively optimizing connections for path cost, and aggressively smoothing the final path to improve quality and robustness in complex 2D/3D environments.",
    "planning_mechanism": "The planner alternately samples with goal bias from the two trees (start and goal), steering towards sampled points with step size limits. It selects optimal parents from adaptively sized neighborhoods to minimize cost, rewires neighbors for further cost improvement, and attempts incremental connection between the two trees when nodes are sufficiently close. Upon connection, it reconstructs and aggressively smooths the path, returning early for efficiency and quality. Collision and obstacle-edge checks guard node and edge validity, ensuring robustness and correctness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 15.0,\n                 goal_sample_rate: float = 0.15, collision_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import random\n        import math\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1 / dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(120):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    # Shortcut by removing intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors for optimality\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt to connect the two trees incrementally\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    curr = nearest_in_b\n                    connected = False\n                    while True:\n                        next_pos = steer(curr.position, new_node.position)\n                        if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                            break\n                        new_connect_node = Node(next_pos, parent=curr, cost=curr.cost + dist(curr.position, next_pos))\n                        curr.add_child(new_connect_node)\n                        tree_b.append(new_connect_node)\n                        edges.append((curr, new_connect_node))\n                        curr = new_connect_node\n                        if dist(curr.position, new_node.position) <= self.step_size:\n                            final_node = Node(new_node.position, parent=curr, cost=curr.cost + dist(curr.position, new_node.position))\n                            curr.add_child(final_node)\n                            tree_b.append(final_node)\n                            edges.append((curr, final_node))\n                            connected = True\n                            nearest_in_b = final_node\n                            break\n                    if connected:\n                        path = extract_path(new_node, nearest_in_b)\n                        path = smooth_path(path)\n                        extracted_path = path\n                        success_state = True\n                        nodes = nodes_start + nodes_goal\n                        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        nodes = nodes_start + nodes_goal\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 37.12243,
    "time_improvement": -91.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.025053858757019043,
            "num_nodes_avg": 119.4,
            "path_length_avg": 177.65655500719816,
            "smoothness_avg": 0.03118327607717299,
            "success_improvement": -9.999999999999998,
            "time_improvement": -153.48567376023388,
            "length_improvement": 11.208961352812317,
            "smoothness_improvement": 199.63282327306203,
            "objective_score": -92.80574574114239
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03168380260467529,
            "num_nodes_avg": 288.0,
            "path_length_avg": 246.72057497131763,
            "smoothness_avg": 0.08176053201522178,
            "success_improvement": 0.0,
            "time_improvement": -108.78672854732332,
            "length_improvement": 18.12976629598296,
            "smoothness_improvement": 1045.3864834955466,
            "objective_score": -23.78313288752267
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030788064002990723,
            "num_nodes_avg": 304.2,
            "path_length_avg": 128.25836452153484,
            "smoothness_avg": 0.12233453676478494,
            "success_improvement": 0.0,
            "time_improvement": -10.864192019395627,
            "length_improvement": 21.24163776990588,
            "smoothness_improvement": 846.5018083588582,
            "objective_score": 5.221578989956779
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This planner is a tuned hybrid bidirectional RRT* variant integrating adaptive radius rewiring, goal and informed sampling bias, and dynamic neighborhood scaling. It balances exploration-exploitation to achieve faster convergence, improved path quality, higher success rate, and smooth paths by shortcutting.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points biased by goal and an informed ellipsoid around the best path cost to accelerate convergence. It extends nodes towards samples respecting step size and map bounds while checking collisions. Each new node selects the best parent from neighbors in an adaptive radius to minimize cost, rewires neighbors through itself if beneficial, and attempts tree connection. Once connected, it extracts and shortcuts the path before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 min_radius: float=8.0, max_radius: float=20.0, collision_resolution: float=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def adaptive_radius(iteration):\n            scale = min(1.0, iteration / (self.max_iter * 0.6))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(r, self.min_radius)\n\n        def informed_sample(best_cost):\n            if best_cost == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            start = np.array(start_position)\n            goal = np.array(goal_position)\n            c_min = distance(start_position, goal_position)\n            c_best = max(best_cost, c_min + 1e-6)\n            center = (start + goal) / 2\n\n            while True:\n                direction = np.random.normal(0,1,dim)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction /= norm\n                radius = random.uniform(0,1) ** (1/dim)\n                point_ball = radius * direction\n\n                a1 = (goal - start) / c_min\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n                sample = U @ L @ point_ball + center\n                sample = np.clip(sample, [0]*dim, bounds)\n                sample_tuple = tuple(float(v) for v in sample)\n                if not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                    return sample_tuple\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        # Remove old parent-child edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-assign parent\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b, edges):\n            nearest_b = find_nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d, self.collision_resolution):\n                return None\n            curr = nearest_b\n            while True:\n                new_pos = steer(curr.position, node_from_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                edges.append((curr, new_node))\n                if distance(new_pos, node_from_a.position) < self.step_size * 1.01:\n                    final_node = Node(node_from_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_from_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start[::-1] + path_goal if node_start.parent is None else path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.collision_resolution):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        # Initialize trees\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: list = []\n        best_path_cost = float(\"inf\")\n        best_path = []\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree growth in each iteration for balance\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_count % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]:\n                # Goal biasing and informed sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    if best_path_cost < float(\"inf\") and random.random() < 0.7:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                # Boundary check\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    continue\n\n                tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                curr_radius = adaptive_radius(iter_count)\n                neighbors = find_near(tree_a, new_node, curr_radius)\n\n                # Choose best parent from neighbors\n                min_cost = tentative_cost\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_node.position)\n                    cost = node.cost + edge_cost\n                    if cost + 1e-7 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d, self.collision_resolution):\n                            min_cost = cost\n                            min_node = node\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                rewire(tree_a, new_node, neighbors, edges)\n\n                connect_node = attempt_connect(new_node, tree_b, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n\n                    path_cost = 0.0\n                    for i in range(len(extracted_path) - 1):\n                        path_cost += distance(extracted_path[i], extracted_path[i+1])\n                    if path_cost < best_path_cost:\n                        best_path_cost = path_cost\n                        best_path = extracted_path\n\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 111.54078,
    "time_improvement": -290.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05381948947906494,
            "num_nodes_avg": 98.2,
            "path_length_avg": 162.84677912022795,
            "smoothness_avg": 0.045071937290447395,
            "success_improvement": 0.0,
            "time_improvement": -444.5256830232008,
            "length_improvement": 18.610744997006485,
            "smoothness_improvement": 333.08572798126266,
            "objective_score": -127.97012726765263
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.06212804317474365,
            "num_nodes_avg": 244.9,
            "path_length_avg": 233.06320331339316,
            "smoothness_avg": 0.10447919344099994,
            "success_improvement": -9.999999999999998,
            "time_improvement": -309.40511615191974,
            "length_improvement": 22.661744261529137,
            "smoothness_improvement": 1363.6530979465556,
            "objective_score": -131.47092050353731
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.05959320068359375,
            "num_nodes_avg": 240.7,
            "path_length_avg": 119.42364952210964,
            "smoothness_avg": 0.11275177778790549,
            "success_improvement": -9.999999999999998,
            "time_improvement": -114.58809631532996,
            "length_improvement": 26.666684991738716,
            "smoothness_improvement": 772.3600415238496,
            "objective_score": -75.18129168863197
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified informed bidirectional RRT* variant that balances exploration efficiency and path quality by growing two trees from start and goal with goal biasing and adaptive rewiring within a dynamically computed neighborhood radius. It employs collision and edge checks to ensure safe expansion and attempts incremental connection of the trees. After a successful connection, the final path is shortcut-smoothed to improve path smoothness and length, achieving robust and efficient planning in 2D and 3D environments.",
    "planning_mechanism": "The planner alternately samples nodes biased towards the goal, extends the nearest nodes in both start and goal trees by incremental steering within bounds and collision-free space, rewires nearby nodes to optimize cost, and continuously tries connecting the two trees when new nodes approach each other. Upon successful connection, it extracts and smooths the combined path, returning the final solution promptly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, base_radius: float=15.0, goal_sample_rate: float=0.15, collision_resolution: float=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        import random\n        import math\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1 / dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            return node_start.path_from_root() + node_goal.path_from_root()[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and \\\n                   not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Try connecting trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    # Incremental connection\n                    curr = nearest_in_b\n                    connected = False\n                    while True:\n                        next_pos = steer(curr.position, new_node.position)\n                        if self._is_in_obstacle(next_pos, obstacles, is_3d) or \\\n                           self._is_edge_in_obstacle(curr.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                            break\n                        new_connect_node = Node(next_pos, parent=curr, cost=curr.cost + dist(curr.position, next_pos))\n                        curr.add_child(new_connect_node)\n                        tree_b.append(new_connect_node)\n                        edges.append((curr, new_connect_node))\n                        curr = new_connect_node\n                        if dist(curr.position, new_node.position) <= self.step_size:\n                            final_node = Node(new_node.position, parent=curr, cost=curr.cost + dist(curr.position, new_node.position))\n                            curr.add_child(final_node)\n                            tree_b.append(final_node)\n                            edges.append((curr, final_node))\n                            connected = True\n                            nearest_in_b = final_node\n                            break\n                    if connected:\n                        extracted_path = smooth_path(extract_path(new_node, nearest_in_b))\n                        success_state = True\n                        return PlannerResult(success_state, extracted_path, nodes_start + nodes_goal, edges)\n\n        return PlannerResult(success_state, extracted_path, nodes_start + nodes_goal, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 50.84281,
    "time_improvement": -84.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.021970224380493165,
            "num_nodes_avg": 107.7,
            "path_length_avg": 175.04074089223428,
            "smoothness_avg": 0.03005827609266127,
            "success_improvement": -9.999999999999998,
            "time_improvement": -122.28660198671344,
            "length_improvement": 12.51632010558227,
            "smoothness_improvement": 188.82296093829103,
            "objective_score": -83.23860177020612
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.0300417423248291,
            "num_nodes_avg": 284.8,
            "path_length_avg": 236.55150352629008,
            "smoothness_avg": 0.09859264996167927,
            "success_improvement": -9.999999999999998,
            "time_improvement": -97.96604524158907,
            "length_improvement": 21.504208236441468,
            "smoothness_improvement": 1281.1882806375454,
            "objective_score": -68.68303052200069
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03694727420806885,
            "num_nodes_avg": 308.6,
            "path_length_avg": 129.74908240561822,
            "smoothness_avg": 0.14839800856260238,
            "success_improvement": 0.0,
            "time_improvement": -33.04278248865256,
            "length_improvement": 20.32624718672247,
            "smoothness_improvement": 1048.1547825813066,
            "objective_score": -0.6068113963447423
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates the strengths of bidirectional RRT* with adaptive radius rewiring, goal biasing, and iterative shortcut smoothing for enhanced path quality and success rate. It alternates tree expansions, utilizes dynamic neighborhood radius decreasing with iterations, enforces rigorous collision checks, and applies progressive shortcut smoothing for smoother, shorter paths. Adaptive balancing of exploration and exploitation with efficient rewiring reduces search time and improves robustness and optimality in 2D/3D environments with obstacles.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points with goal biasing and steering within step size constraints. New nodes are collision-checked for validity, and edges are verified to avoid obstacles. It rewires neighbors within an adaptive radius to minimize path costs dynamically. Upon connecting the trees, it extracts the concatenated path and applies iterative shortcut smoothing to enhance path smoothness and reduce length, returning a collision-free, optimized route.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 20.0, goal_sample_rate: float = 0.12, smooth_iter: int = 50, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        edges = []\n        success = False\n        path = []\n\n        import math\n        import random\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.base_radius\n            gamma = self.base_radius\n            r = gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim)\n            return min(r, self.base_radius)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # For faster rejection, mark nodes in spatial index could be implemented (optional)\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal biasing sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not collision_free_node(new_pos):\n                continue\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                if n == nearest_node:\n                    continue\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors to new node where cheaper\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, n.position)\n                if new_cost < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Try connect trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_connect = dist(new_node.position, nearest_in_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    path = shortcut_smooth(path)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # If no connection after max_iter\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 9.62493,
    "time_improvement": -52.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014689040184020997,
            "num_nodes_avg": 115.5,
            "path_length_avg": 168.54000177658935,
            "smoothness_avg": 0.024743471431160916,
            "success_improvement": 0.0,
            "time_improvement": -48.61827409698133,
            "length_improvement": 15.765327033748399,
            "smoothness_improvement": 137.75424314452695,
            "objective_score": -10.743645606622085
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021230125427246095,
            "num_nodes_avg": 252.5,
            "path_length_avg": 246.92508543790282,
            "smoothness_avg": 0.055716171628438796,
            "success_improvement": 0.0,
            "time_improvement": -39.90014045694068,
            "length_improvement": 18.061902804272982,
            "smoothness_improvement": 680.5300225229797,
            "objective_score": -4.95501146361271
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04679288864135742,
            "num_nodes_avg": 417.9,
            "path_length_avg": 134.13341490846713,
            "smoothness_avg": 0.11233766839957926,
            "success_improvement": 0.0,
            "time_improvement": -68.49568037060473,
            "length_improvement": 17.634002913339643,
            "smoothness_improvement": 769.1560788876664,
            "objective_score": -13.176123134075159
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements an improved hybrid bidirectional RRT* algorithm with adaptive rewiring, dynamic neighborhood radius, goal biasing, and incremental tree connection. It integrates efficient exploration with incremental path optimization and advanced smoothing to produce shorter, smoother, and collision-free paths in 2D/3D obstacle environments. The planner balances exploration and exploitation by alternating growth from start and goal, adjusting rewiring based on local node density, and verifying collision checks on nodes and edges rigorously. Shortcut smoothing is applied after path extraction to enhance smoothness and path quality.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal positions by sampling points biased toward the opposing goal. Each new node chooses its parent to minimize path cost considering neighbors within an adaptively computed radius related to the logarithm of the node count and problem dimension. After attaching the new node, nearby nodes are rewired if a lower cost path via the new node is found without collision. The two trees attempt connection incrementally within step size constraints. Upon successful connection, the path is reconstructed and refined using iterative shortcut smoothing, and the final path is returned promptly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children = []\n        self.valid = True                 # For collision checks etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, base_radius: float=15.0,\n                 goal_sample_rate: float=0.15, collision_resolution: float=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * ((math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)), self.base_radius)\n\n        def is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connecting node at junction\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start + path_goal[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Sampling with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_within_bounds(sample):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not is_within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_parent = neighbor\n\n            new_node = Node(new_pos, parent=None, cost=0.0)\n            new_node.update_parent(min_parent, min_cost)\n            tree_a.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in neighbors:\n                if neighbor is min_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                    # Update parent in tree structure and edges\n                    if neighbor.parent and (neighbor.parent, neighbor) in edges:\n                        edges.remove((neighbor.parent, neighbor))\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection between trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            d_connect = dist(new_node.position, nearest_in_b.position)\n            if d_connect <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(new_node.position, obstacles, is_3d)):\n                    # Incrementally extend from nearest_in_b to new_node.position\n                    curr_node = nearest_in_b\n                    connected = False\n                    while True:\n                        next_pos = steer(curr_node.position, new_node.position)\n                        if not is_within_bounds(next_pos):\n                            break\n                        if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_node.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                            break\n                        new_connect_node = Node(next_pos, parent=curr_node, cost=curr_node.cost + dist(curr_node.position, next_pos))\n                        curr_node.add_child(new_connect_node)\n                        tree_b.append(new_connect_node)\n                        edges.append((curr_node, new_connect_node))\n                        curr_node = new_connect_node\n                        if dist(curr_node.position, new_node.position) <= self.step_size:\n                            final_node = Node(new_node.position, parent=curr_node, cost=curr_node.cost + dist(curr_node.position, new_node.position))\n                            curr_node.add_child(final_node)\n                            tree_b.append(final_node)\n                            edges.append((curr_node, final_node))\n                            nearest_in_b = final_node\n                            connected = True\n                            break\n                    if connected:\n                        path = extract_path(new_node, nearest_in_b)\n                        path = smooth_path(path)\n                        extracted_path = path\n                        success_state = True\n                        nodes = nodes_start + nodes_goal\n                        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        nodes = nodes_start + nodes_goal\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 28.17359,
    "time_improvement": -62.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02235884666442871,
            "num_nodes_avg": 126.6,
            "path_length_avg": 173.761895975651,
            "smoothness_avg": 0.0317489635590035,
            "success_improvement": 0.0,
            "time_improvement": -126.2185384774963,
            "length_improvement": 13.155474503276778,
            "smoothness_improvement": 205.06838228397632,
            "objective_score": -34.20912473117365
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.026564908027648926,
            "num_nodes_avg": 263.3,
            "path_length_avg": 239.97385313218496,
            "smoothness_avg": 0.08554837000002619,
            "success_improvement": -9.999999999999998,
            "time_improvement": -75.05475306915697,
            "length_improvement": 20.368556853965416,
            "smoothness_improvement": 1098.4504536352986,
            "objective_score": -62.95046228177751
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02365736961364746,
            "num_nodes_avg": 243.3,
            "path_length_avg": 131.17687485005507,
            "smoothness_avg": 0.12421184124014457,
            "success_improvement": 0.0,
            "time_improvement": 14.812598568508385,
            "length_improvement": 19.44949661417429,
            "smoothness_improvement": 861.0265053721351,
            "objective_score": 12.63881142024805
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This improved planner is a hybrid bidirectional RRT* approach featuring adaptive neighborhood rewiring, goal biasing, incremental tree connection, and enhanced shortcut smoothing. Key refinements include dynamic step size and base radius tuning, increased goal bias rate, finer collision resolution, and smarter tree connection attempts to boost planning efficiency, path quality, smoothness, and overall success rate in 2D/3D environments with obstacles.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal with goal-biased sampling. Each newly sampled point is steered, collision-checked, and connected by choosing the best parent within an adaptive radius neighborhood. Nearby nodes are rewired to reduce costs, and an incremental connection from one tree to the other is attempted within step size distance. Upon successful connection, the combined path is shortcut-smoothed repeatedly, improving robustness and path length before returning the solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.5, base_radius: float = 12.0,\n                 goal_sample_rate: float = 0.25, collision_resolution: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import random\n        import math\n        from math import log\n\n        success_state = False\n        extracted_path = []\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1 / dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(120):  # Increased smoothing attempts for higher path quality\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal biased sampling towards tree opposite to growing tree for better convergence\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors to reduce cost\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt incremental tree connection - refined to extend gradually for better bridging\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_btwn = dist(new_node.position, nearest_in_b.position)\n            if dist_btwn <= self.step_size * 3:  # Slightly extended connection radius for more opportunities\n                direction = tuple(new_node.position[d] - nearest_in_b.position[d] for d in range(dim))\n                length = math.sqrt(sum(x*x for x in direction))\n                if length == 0:\n                    continue\n                step_vector = tuple((direction[d] / length) * min(self.step_size, dist_btwn) for d in range(dim))\n\n                curr = nearest_in_b\n                connected = False\n                max_connect_steps = int(dist_btwn / self.step_size)\n                for _ in range(max_connect_steps):\n                    next_pos = tuple(curr.position[d] + step_vector[d] for d in range(dim))\n                    if any(next_pos[d] < 0 or next_pos[d] > bounds[d] for d in range(dim)):\n                        break\n                    if self._is_in_obstacle(next_pos, obstacles, is_3d) or \\\n                       self._is_edge_in_obstacle(curr.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                        break\n                    new_connect_node = Node(next_pos, parent=curr, cost=curr.cost + dist(curr.position, next_pos))\n                    curr.add_child(new_connect_node)\n                    tree_b.append(new_connect_node)\n                    edges.append((curr, new_connect_node))\n                    curr = new_connect_node\n                    if dist(curr.position, new_node.position) <= self.step_size:\n                        final_node = Node(new_node.position, parent=curr, cost=curr.cost + dist(curr.position, new_node.position))\n                        curr.add_child(final_node)\n                        tree_b.append(final_node)\n                        edges.append((curr, final_node))\n                        connected = True\n                        nearest_in_b = final_node\n                        break\n\n                if connected:\n                    path = extract_path(new_node, nearest_in_b)\n                    path = smooth_path(path)\n                    extracted_path = path\n                    success_state = True\n                    nodes = nodes_start + nodes_goal\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        nodes = nodes_start + nodes_goal\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.15):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 101.65899,
    "time_improvement": -142.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03353111743927002,
            "num_nodes_avg": 83.3,
            "path_length_avg": 164.85422918737984,
            "smoothness_avg": 0.03205679887619029,
            "success_improvement": -9.999999999999998,
            "time_improvement": -239.25544078696626,
            "length_improvement": 17.607440748043864,
            "smoothness_improvement": 208.02630001409437,
            "objective_score": -117.21501258641064
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04566261768341064,
            "num_nodes_avg": 304.5,
            "path_length_avg": 238.5715477003768,
            "smoothness_avg": 0.08861140083445754,
            "success_improvement": 0.0,
            "time_improvement": -200.90291503140642,
            "length_improvement": 20.833889238343538,
            "smoothness_improvement": 1141.3605721217414,
            "objective_score": -50.397293801144514
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.023705124855041504,
            "num_nodes_avg": 192.5,
            "path_length_avg": 125.56051895794576,
            "smoothness_avg": 0.10762523730343712,
            "success_improvement": -30.000000000000004,
            "time_improvement": 14.640637569228678,
            "length_improvement": 22.89827746690066,
            "smoothness_improvement": 732.6960188570226,
            "objective_score": -137.3646731415662
        }
    ],
    "success_rate": 0.8666666666666666
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a generalized bidirectional RRT* planner that grows two trees from start and goal positions. It balances exploration and path quality using adaptive neighborhood radius rewiring and goal-biased sampling. The planner incrementally extends toward random free samples, checks collision for nodes and edges, rewires locally to optimize costs, and attempts to connect the two trees. Upon successful connection, it extracts and shortcut-smooths the final path to enhance smoothness and length, ensuring efficient, robust planning in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates growing start and goal trees by steering towards sampled points biased towards the goals. It dynamically adjusts neighborhood radius for rewiring to improve path costs, avoids collisions through node and edge checks, and incrementally attempts to connect the trees. Once connected, the combined path is smoothed by shortcutting collision-free segments, delivering an optimized feasible path efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, base_radius: float=15.0, goal_sample_rate: float=0.15, resolution: float=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.resolution = resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        import math\n        import random\n        from math import log\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n):\n            if n == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n + 1) / (n + 1))**(1/dim), self.base_radius)\n\n        def extract_path(node_s, node_g):\n            return node_s.path_from_root() + node_g.path_from_root()[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path)-2)\n                j = random.randint(i+1, len(path)-1)\n                if j == i+1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors for cost optimization\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt incremental connection between trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.resolution):\n                    curr = nearest_in_b\n                    connected = False\n                    while True:\n                        next_pos = steer(curr.position, new_node.position)\n                        if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr.position, next_pos, obstacles, is_3d, self.resolution):\n                            break\n                        new_connect_node = Node(next_pos, parent=curr, cost=curr.cost + dist(curr.position, next_pos))\n                        curr.add_child(new_connect_node)\n                        tree_b.append(new_connect_node)\n                        edges.append((curr, new_connect_node))\n                        curr = new_connect_node\n                        if dist(curr.position, new_node.position) <= self.step_size:\n                            final_node = Node(new_node.position, parent=curr, cost=curr.cost + dist(curr.position, new_node.position))\n                            curr.add_child(final_node)\n                            tree_b.append(final_node)\n                            edges.append((curr, final_node))\n                            connected = True\n                            nearest_in_b = final_node\n                            break\n                    if connected:\n                        path = extract_path(new_node, nearest_in_b)\n                        smooth_path = shortcut_smooth(path)\n                        return PlannerResult(True, smooth_path, nodes_start + nodes_goal, edges)\n\n        return PlannerResult(False, [], nodes_start + nodes_goal, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 15.19604,
    "time_improvement": -76.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02285010814666748,
            "num_nodes_avg": 138.3,
            "path_length_avg": 170.9212079165824,
            "smoothness_avg": 0.030129831036826288,
            "success_improvement": 0.0,
            "time_improvement": -131.1889404034215,
            "length_improvement": 14.575223091935067,
            "smoothness_improvement": 189.51051569957556,
            "objective_score": -35.49408492414155
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.034113621711730956,
            "num_nodes_avg": 292.7,
            "path_length_avg": 242.4404968858283,
            "smoothness_avg": 0.10324708301126699,
            "success_improvement": 0.0,
            "time_improvement": -124.79850556328888,
            "length_improvement": 19.550041006234384,
            "smoothness_improvement": 1346.3924148564888,
            "objective_score": -26.79758139345735
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.019724082946777344,
            "num_nodes_avg": 218.3,
            "path_length_avg": 130.38451048580114,
            "smoothness_avg": 0.11693300811241225,
            "success_improvement": 0.0,
            "time_improvement": 28.975900563101437,
            "length_improvement": 19.936056066658583,
            "smoothness_improvement": 804.7102033666969,
            "objective_score": 16.703532399095632
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements a Bidirectional Hybrid RRT* with Intelligent Informed Sampling and Adaptive Neighborhood Rewiring combined with Lazy Edge Validation and Graph Pruning. It adaptively adjusts sampling and rewiring radius based on the current best path found, uses informed sampling within a dynamically shrinking ellipsoidal subset to focus exploration, and delays costly collision checks until necessary. The bidirectional trees aggressively attempt connections each iteration, with pruning of nodes unlikely to improve the best path to enhance performance. After a path is found, an advanced smoothing using iterative shortcutting combined with curvature-based shortcut acceptance is applied to improve path smoothness and reduce length while preserving feasibility and robustness. This results in faster convergence, higher success rate, better path quality, and improved computational efficiency.",
    "planning_mechanism": "The planner maintains two trees growing from start and goal positions. At each iteration, it samples either uniformly or within an adaptive ellipsoidal informed region surrounding the current best path. It extends each tree towards the sample with step constraints and delayed collision checking of edges. Nodes are rewired inside an adaptively adjusted radius to minimize cost. The algorithm aggressively attempts to connect the two trees at close nodes, updating the best path if a better connection is found. Pruning removes nodes and branches that cannot possibly yield better paths based on cost and heuristic estimates. Finally, a curvature-aware shortcut smoothing improves path quality by removing unnecessary waypoints while ensuring collision-free and smooth connections.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []                # List of child nodes\n        self.valid = True                 # Lazy collision validity for edges\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance_to(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\n\n    def is_ancestor_of(self, node):\n        cur = node\n        while cur:\n            if cur == self:\n                return True\n            cur = cur.parent\n        return False\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=5.0,\n                 radius_max: float=25.0, collision_resolution: float=0.3,\n                 informed_sampling_rate: float=0.9, smooth_iter: int=70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max                # Maximum rewiring radius\n        self.collision_resolution = collision_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success = False\n        extracted_path = []\n\n        start_tree = [Node(start_pos, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_pos, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        collision_edge_cache = dict()\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            distance = dist(from_pos, to_pos)\n            if distance <= max_step:\n                return to_pos\n            ratio = max_step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_node_collision_free(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def lazy_edge_collision_free(a, b):\n            key = tuple(sorted([a, b]))\n            if key in collision_edge_cache:\n                return collision_edge_cache[key]\n            # Perform edge check\n            collides = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            collision_edge_cache[key] = (not collides)\n            return not collides\n\n        def informed_sample(c_max, start, goal):\n            # Uniform fallback if no solution found yet\n            if math.isinf(c_max):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                c_max = c_min + 1e-6\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n\n            if c_min == 0:\n                unit_vec = tuple(0.0 for _ in range(dim))\n            else:\n                unit_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s], [s, c]])\n                elif dim == 3:\n                    x_axis = np.array(vec)\n                    norm_x = np.linalg.norm(x_axis)\n                    if norm_x < 1e-12:\n                        return np.eye(3)\n                    x_axis /= norm_x\n                    if abs(x_axis[0]) < 1e-6 and abs(x_axis[1]) < 1e-6:\n                        temp = np.array([0,1,0])\n                    else:\n                        temp = np.array([0,0,1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= np.linalg.norm(y_axis)\n                    z_axis = np.cross(x_axis, y_axis)\n                    R = np.stack((x_axis, y_axis, z_axis), axis=1)\n                    return R\n                else:\n                    return np.eye(dim)\n\n            L = np.diag([c_max / 2] + [math.sqrt(c_max**2 - c_min**2) / 2] * (dim - 1))\n            R = rotation_matrix(unit_vec)\n\n            attempt_limit = 100\n            for _ in range(attempt_limit):\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-12:\n                    continue\n                x_ball /= norm_x\n                r = np.random.uniform() ** (1/dim)\n                sample_ball = x_ball * r\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                p = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n                if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback to uniform\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def rewire(tree, new_node, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if tentative_cost < neighbor.cost:\n                    if lazy_edge_collision_free(new_node.position, neighbor.position):\n                        # Remove old edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-parent\n                        new_node.add_child(neighbor)\n                        neighbor.cost = tentative_cost\n                        if (new_node, neighbor) not in edges:\n                            edges.append((new_node, neighbor))\n\n        def curvature_between(a, b, c):\n            # Return angle in radians between vector (b->a) and (b->c)\n            import numpy as np\n            v1 = np.array(a) - np.array(b)\n            v2 = np.array(c) - np.array(b)\n            if np.linalg.norm(v1) < 1e-12 or np.linalg.norm(v2) < 1e-12:\n                return 0\n            v1 /= np.linalg.norm(v1)\n            v2 /= np.linalg.norm(v2)\n            dot = np.clip(np.dot(v1, v2), -1.0, 1.0)\n            angle = np.arccos(dot)\n            return angle\n\n        def shortcut_smooth(path):\n            # Curvature-aware iterative shortcutting\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) -1)\n                if j - i <= 1:\n                    continue\n                p1, p2 = path[i], path[j]\n\n                # Collision check edge\n                if lazy_edge_collision_free(p1, p2):\n                    # Curvature check:\n                    left_ok = True\n                    if i > 0 and j < len(path) -1:\n                        angle = curvature_between(path[i-1], p1, p2)\n                        angle2 = curvature_between(p1, p2, path[j+1])\n                        max_curvature = math.pi / 2.8  # ~64 degrees max allowed\n                        left_ok = (angle <= max_curvature) and (angle2 <= max_curvature)\n                    if left_ok:\n                        path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(tree, best_cost):\n            # Prune nodes with cost + heuristic > best_cost (using dist to opposite root as heuristic)\n            # Heuristic: euclidean dist from node to opposite root\n            # Removes nodes and descendants irreversibly\n            opposite_root = goal_pos if tree is start_tree else start_pos\n            surviving_nodes = []\n            def node_cost_plus_heuristic(node):\n                return node.cost + dist(node.position, opposite_root)\n            for node in tree:\n                if node_cost_plus_heuristic(node) <= best_cost:\n                    surviving_nodes.append(node)\n            # Disconnect and remove pruned nodes and their children\n            surviving_set = set(surviving_nodes)\n            for node in tree:\n                if node not in surviving_set:\n                    # Disconnect from parent\n                    if node.parent and node in node.parent.children:\n                        node.parent.remove_child(node)\n                    node.valid = False\n            return surviving_nodes\n\n        for iteration in range(self.max_iter):\n            # Adaptive rewiring radius using RRT* formula\n            n_nodes = len(nodes)\n            if n_nodes < 2:\n                radius = self.radius_max\n            else:\n                radius = min(self.radius_max * (math.log(n_nodes) / n_nodes) ** (1/dim), self.radius_max)\n            # Sampling with informed bias\n            if random.random() < self.informed_sampling_rate:\n                sample = informed_sample(best_cost, start_pos, goal_pos)\n            else:\n                # Uniform sampling fallback\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate growth: first start_tree then goal_tree\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not is_node_collision_free(new_pos):\n                    continue\n                if not lazy_edge_collision_free(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n\n                # Find best parent within radius for new node\n                near_nodes = near(tree_a, new_pos, radius)\n                best_parent = nearest_node\n                best_cost_to_new = new_cost\n                for near_node in near_nodes:\n                    cost_through = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_through < best_cost_to_new and lazy_edge_collision_free(near_node.position, new_pos):\n                        best_parent = near_node\n                        best_cost_to_new = cost_through\n\n                new_node = Node(new_pos, parent=best_parent, cost=best_cost_to_new)\n                best_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors within radius in tree_a\n                rewire(tree_a, new_node, radius)\n\n                # Try connect to other tree aggressively\n                nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                dist_between = dist(new_node.position, nearest_other.position)\n                if dist_between <= self.step_size and lazy_edge_collision_free(new_node.position, nearest_other.position):\n                    total_path_cost = new_node.cost + dist_between + nearest_other.cost\n                    if total_path_cost < best_cost:\n                        best_cost = total_path_cost\n                        best_connection = (new_node, nearest_other)\n\n            # Prune the trees periodically every 200 iterations to remove stale nodes\n            if iteration % 200 == 0 and best_cost < math.inf:\n                start_tree = prune_nodes(start_tree, best_cost)\n                goal_tree = prune_nodes(goal_tree, best_cost)\n                # Remove pruned nodes from global nodes\n                nodes = [n for n in nodes if n.valid]\n                edges = [e for e in edges if e[0].valid and e[1].valid]\n\n            if best_connection is not None:\n                success = True\n                node_s, node_g = best_connection\n                extracted_path = extract_path(node_s, node_g)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 36.75265,
    "time_improvement": -127.0,
    "length_improvement": 6.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024940347671508788,
            "num_nodes_avg": 139.7,
            "path_length_avg": 187.58671473113588,
            "smoothness_avg": 0.013195420867223898,
            "success_improvement": 0.0,
            "time_improvement": -152.33721059258863,
            "length_improvement": 6.245962966486656,
            "smoothness_improvement": 26.79171998919155,
            "objective_score": -44.3180119845333
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028617286682128908,
            "num_nodes_avg": 293.1,
            "path_length_avg": 285.77993088402684,
            "smoothness_avg": 0.008633688783600376,
            "success_improvement": 0.0,
            "time_improvement": -88.57931103828159,
            "length_improvement": 5.168550567324574,
            "smoothness_improvement": 20.949683076938747,
            "objective_score": -25.435334782634868
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.066742205619812,
            "num_nodes_avg": 447.7,
            "path_length_avg": 151.1744798814293,
            "smoothness_avg": 0.017078419986710176,
            "success_improvement": 0.0,
            "time_improvement": -140.33082102577353,
            "length_improvement": 7.169762448915364,
            "smoothness_improvement": 32.135665273442356,
            "objective_score": -40.504615491581774
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates bidirectional RRT* with adaptive informed sampling, dynamic neighbor radius scaling, incremental rewiring, and iterative path smoothing. It alternately grows two trees from start and goal with goal bias and informed sampling focused near the current best path. New nodes select parents to minimize cost within an adaptive radius and locally rewire neighbors to enhance path quality. Early and frequent tree connections are attempted, with collision checks for node placement and edge feasibility. Once connected, the path is reconstructed and optimized by shortcutting, balancing exploration, optimality, efficiency, and robustness.",
    "planning_mechanism": "The planner maintains two trees grown alternately using goal-biased and informed samples. Adaptive neighborhood radius and step size guide incremental node growth. Each new node selects a minimal-cost parent from neighbors and rewires surrounding nodes to improve paths locally. The trees attempt to connect frequently, and upon success, the best path is extracted and smoothed for length and smoothness improvements, leading to efficient, high-quality, and collision-free trajectories.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5,\n                 goal_sample_rate: float = 0.1, min_radius: float = 6.0, max_radius: float = 20.0,\n                 collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize trees with root nodes\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path = []\n        best_cost = float('inf')\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            dist = distance(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def adaptive_radius(iter_idx):\n            scale = min(1.0, iter_idx / (self.max_iter / 2))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r)\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            steps = max(1, int(dist / self.collision_resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample():\n            # If no best path, sample uniformly in bounds\n            if best_cost == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle(p):\n                        return p\n\n            import numpy as np\n            start_np = np.array(start_pos)\n            goal_np = np.array(goal_pos)\n            c_min = distance(start_pos, goal_pos)\n            c_best = max(best_cost, c_min + 1e-6)\n            center = (start_np + goal_np) / 2\n            a1 = (goal_np - start_np) / c_min\n\n            while True:\n                # sample unit ball\n                dir = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(dir)\n                if norm == 0:\n                    continue\n                dir /= norm\n                r = random.uniform(0, 1) ** (1/dim)\n                point_ball = r * dir\n\n                # create rotation matrix via SVD\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                L_diag = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2)/2] * (dim -1)\n                L = np.diag(L_diag)\n                sample = U @ L @ point_ball + center\n                sample = np.clip(sample, [0]*dim, bounds)\n                sample_t = tuple(float(v) for v in sample)\n                if not _is_in_obstacle(sample_t):\n                    return sample_t\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, nbr.position)\n                if new_cost + 1e-9 < nbr.cost:\n                    if not _is_edge_in_obstacle(new_node.position, nbr.position):\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                            if (nbr.parent, nbr) in edges:\n                                edges.remove((nbr.parent, nbr))\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        def try_connect(node_from, other_tree):\n            nearest_other = find_nearest(other_tree, node_from.position)\n\n            dist_to_nearest = distance(node_from.position, nearest_other.position)\n            if dist_to_nearest > self.step_size * 5:\n                return None  # Optimize: connect only if reasonably close\n\n            if _is_edge_in_obstacle(node_from.position, nearest_other.position):\n                return None\n\n            # Create a chain from nearest_other towards node_from by stepping\n            curr = nearest_other\n            prev_cost = curr.cost\n            while True:\n                new_pos = steer(curr.position, node_from.position, self.step_size)\n                if _is_in_obstacle(new_pos) or _is_edge_in_obstacle(curr.position, new_pos):\n                    return None\n                new_cost = prev_cost + distance(curr.position, new_pos)\n                new_node = Node(new_pos, parent=curr, cost=new_cost)\n                curr.add_child(new_node)\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n\n                dist_new_to_from = distance(new_pos, node_from.position)\n                if dist_new_to_from <= self.step_size * 1.01:\n                    final_cost = new_cost + dist_new_to_from\n                    if _is_edge_in_obstacle(new_pos, node_from.position):\n                        return None\n                    final_node = Node(node_from.position, parent=new_node,\n                                      cost=final_cost)\n                    new_node.add_child(final_node)\n                    other_tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n                prev_cost = new_cost\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # exclude duplicate connecting node in goal path\n            return path_start + path_goal[-2::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not _is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        for iter_idx in range(self.max_iter):\n            # Alternate tree order\n            if iter_idx % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sample point - goal bias + informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is tree_start else start_pos\n            else:\n                # 60% chance informed sample if best path known\n                if best_cost < float('inf') and random.random() < 0.6:\n                    sample = informed_sample()\n                else:\n                    while True:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not _is_in_obstacle(sample):\n                            break\n\n            nearest = find_nearest(tree_a, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_within_bounds(new_pos):\n                continue\n            if _is_in_obstacle(new_pos):\n                continue\n            if _is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=tentative_cost)\n\n            radius = adaptive_radius(iter_idx)\n            neighbors = find_near(tree_a, new_node, radius)\n\n            # Choose best parent minimizing cost + collision check on edge\n            min_cost = tentative_cost\n            min_parent = nearest\n            for n in neighbors:\n                edge_dist = distance(n.position, new_node.position)\n                c = n.cost + edge_dist\n                if c + 1e-9 < min_cost and not _is_edge_in_obstacle(n.position, new_node.position):\n                    min_cost = c\n                    min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            connect_node = try_connect(new_node, tree_b)\n            if connect_node:\n                success_state = True\n                if tree_a is tree_start:\n                    path = extract_path(new_node, connect_node)\n                else:\n                    path = extract_path(connect_node, new_node)\n\n                # Compute path cost\n                path_cost = 0.0\n                for i in range(len(path) - 1):\n                    path_cost += distance(path[i], path[i+1])\n\n                # Keep best path found so far\n                if path_cost + 1e-6 < best_cost:\n                    best_cost = path_cost\n                    best_path = path\n\n                extracted_path = shortcut_path(best_path)\n                # Return immediately upon first successful path found (can be modified to continue searching)\n                return PlannerResult(\n                    success=success_state,\n                    path=extracted_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # After max_iter if best path was found\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 90.59875,
    "time_improvement": -161.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03613345623016358,
            "num_nodes_avg": 130.5,
            "path_length_avg": 176.8134765298889,
            "smoothness_avg": 0.04825284085718609,
            "success_improvement": -9.999999999999998,
            "time_improvement": -265.58494188935583,
            "length_improvement": 11.6303238725254,
            "smoothness_improvement": 363.6502880968358,
            "objective_score": -125.53116635181749
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.04078893661499024,
            "num_nodes_avg": 304.9,
            "path_length_avg": 228.24014233359725,
            "smoothness_avg": 0.08338102082592284,
            "success_improvement": -19.999999999999996,
            "time_improvement": -168.78682281372647,
            "length_improvement": 24.26219906604036,
            "smoothness_improvement": 1068.0879744800625,
            "objective_score": -140.44316715850954
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04133074283599854,
            "num_nodes_avg": 296.4,
            "path_length_avg": 118.4565124290087,
            "smoothness_avg": 0.10014549025619116,
            "success_improvement": 0.0,
            "time_improvement": -48.827136699121496,
            "length_improvement": 27.2605654282214,
            "smoothness_improvement": 674.8252466817274,
            "objective_score": -5.82190169068353
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner incorporating adaptive step sizing, dynamic nearest-neighbor radius, and goal-biased sampling with incremental rewiring and efficient collision checking. It integrates adaptive step size decay for better exploitation in later iterations, prioritizes parent selection based on cost and collision feasibility, and performs iterative shortcut smoothing to produce smooth, collision-free, near-optimal paths. Robust checks ensure nodes and edges do not violate obstacle constraints or map boundaries, boosting planning success rate, path quality, and efficiency.",
    "planning_mechanism": "The planner grows two trees simultaneously from the start and goal positions by sampling the free space with a bias towards the goal. It extends the trees using adaptive step sizes that shrink over time to balance exploration and refinement. For each new sample, it selects the best parent node within a dynamically calculated radius to minimize path cost while avoiding collisions. It rewires neighbors to reduce costs incrementally. When the trees connect, the path is reconstructed and smoothed via iterative shortcutting. The process repeats until a path is found or maximum iterations are reached, ensuring efficient, smooth, and feasible paths respecting all constraints.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position                      # Tuple[float, ...]\n        self.parent = parent                          # Node or None\n        self.cost = cost                              # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                             # For collision or validity status\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 initial_step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 collision_resolution: float = 0.4,\n                 radius_constant: float = 22.0):\n        self.max_iter = max_iter\n        self.initial_step_size = initial_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def _near_nodes(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def _steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def _can_connect(parent_node: Node, new_pos: Tuple[float, ...]) -> bool:\n            if (not _is_within_bounds(new_pos)\n                or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                or self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree: List[Node], new_pos: Tuple[float, ...], nearest_node: Node, near_nodes: List[Node]) -> Tuple[Node, float]:\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree: List[Node], new_node: Node, near_nodes: List[Node]):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-9 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a: Node, node_b: Node) -> List[Tuple[float, ...]]:\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            for _ in range(150):  # increased iterations for better smoothness\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample = _sample_free()\n            # Adaptive step size: decays after half iterations for better refinement\n            step_decay = 1.0\n            if i > self.max_iter // 2:\n                step_decay = max(0.25, 1.0 - (i - self.max_iter // 2) / (self.max_iter // 2))\n            step_size = self.initial_step_size * step_decay\n\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            radius = min(\n                self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim),\n                step_size * 5)\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, step_size)\n            if not _can_connect(nearest_node_a, new_pos_a):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n\n            if dist <= step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution) and \\\n               not self._is_in_obstacle(new_node_a.position, obstacles, is_3d):\n\n                connecting_node_b = nearest_node_b\n                if nearest_node_b.position != new_node_a.position:\n                    connecting_node_b = Node(new_node_a.position)\n                    connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                    tree_b.append(connecting_node_b)\n                    nodes.append(connecting_node_b)\n                    edges.append((nearest_node_b, connecting_node_b))\n\n                near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                extracted_path = _smooth_path(extracted_path)\n                success_state = True\n                break\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, step_size)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 32.94341,
    "time_improvement": -79.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.027234625816345216,
            "num_nodes_avg": 178.1,
            "path_length_avg": 169.54027575211984,
            "smoothness_avg": 0.04090994693578219,
            "success_improvement": -9.999999999999998,
            "time_improvement": -175.54986805096559,
            "length_improvement": 15.265399714908376,
            "smoothness_improvement": 293.09413385506133,
            "objective_score": -98.1464098030327
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026295232772827148,
            "num_nodes_avg": 294.7,
            "path_length_avg": 238.87404625621576,
            "smoothness_avg": 0.09042932793066333,
            "success_improvement": 0.0,
            "time_improvement": -73.27767425930173,
            "length_improvement": 20.733509983534564,
            "smoothness_improvement": 1166.8279837524137,
            "objective_score": -12.002460362321536
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.024811291694641115,
            "num_nodes_avg": 318.4,
            "path_length_avg": 126.39997758675437,
            "smoothness_avg": 0.1071436506102271,
            "success_improvement": 0.0,
            "time_improvement": 10.657461072682917,
            "length_improvement": 22.38279929897356,
            "smoothness_improvement": 728.9699845901723,
            "objective_score": 11.318648104550448
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an optimized bidirectional RRT* planner with adaptive neighborhood radius, enhanced goal biasing, and refined collision checking resolution. It balances exploration and exploitation by growing two trees from start and goal, applying rewiring to improve path optimality and incorporating post-processing shortcut smoothing for smoother, shorter paths. Parameters and sampling strategies are tuned to boost efficiency, success rate, path quality, and robustness in both 2D and 3D environments.",
    "planning_mechanism": "The planner simultaneously grows two trees bidirectionally, sampling with adaptive goal biasing and smoothly steering new nodes within a step size limit. Each new node is connected with minimal cost parent within an adaptive radius and rewiring optimizes the local tree structure. After joining the two trees through collision-checked connections, the extracted path is further refined by shortcut smoothing to remove unnecessary detours, resulting in a high-quality trajectory with reduced planning time and improved success rate.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 7000,\n                 step_size: float = 4.0,\n                 base_radius: float = 12.0,\n                 goal_sample_rate: float = 0.2,\n                 collision_resolution: float = 0.3,\n                 shortcut_iters: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_position)]\n        nodes_goal = [Node(goal_position)]\n\n        edges: List[Tuple[Node, Node]] = []\n\n        success = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            # adaptive radius shrinks with node count, capped by base_radius\n            if n_nodes <= 1:\n                return self.base_radius\n            return min(self.base_radius * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            path_g.reverse()\n            return path_s + path_g\n\n        def is_valid_position(p):\n            if any(p[d] < 0 or p[d] > bounds[d] for d in range(dim)):\n                return False\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return False\n            return True\n\n        def is_valid_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.shortcut_iters):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if is_valid_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if sample_from_start else start_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_valid_position(sample):\n                    continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not is_valid_position(new_pos):\n                continue\n\n            if not is_valid_edge(nearest_node.position, new_pos):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose parent with minimal cost + collision-free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for neighbor in neighbors:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost and is_valid_edge(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    min_node = neighbor\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors through new_node\n            for neighbor in neighbors:\n                if neighbor == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and is_valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection from new_node in tree_a to nearest tree_b node\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size and is_valid_edge(new_node.position, nearest_in_b.position):\n                # Connect trees for final path\n                success = True\n                extracted_path = extract_path(new_node, nearest_in_b)\n                # Shortcut smoothing for path refinement\n                extracted_path = shortcut_path(extracted_path)\n                all_nodes = nodes_start + nodes_goal\n                return PlannerResult(success, extracted_path, all_nodes, edges)\n\n        # No connection found within max_iter\n        all_nodes = nodes_start + nodes_goal\n        return PlannerResult(success, extracted_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 39.59394,
    "time_improvement": -99.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.021851778030395508,
            "num_nodes_avg": 136.4,
            "path_length_avg": 162.6090834924915,
            "smoothness_avg": 0.03100526794789038,
            "success_improvement": -9.999999999999998,
            "time_improvement": -121.08820563786622,
            "length_improvement": 18.7295429871384,
            "smoothness_improvement": 197.9223846966115,
            "objective_score": -81.59094117044913
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03464512825012207,
            "num_nodes_avg": 343.9,
            "path_length_avg": 238.9315539907252,
            "smoothness_avg": 0.06070351598895871,
            "success_improvement": 0.0,
            "time_improvement": -128.30097377194446,
            "length_improvement": 20.714426971651083,
            "smoothness_improvement": 750.3979242877791,
            "objective_score": -30.59541711581423
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04098501205444336,
            "num_nodes_avg": 366.5,
            "path_length_avg": 127.25064638884221,
            "smoothness_avg": 0.09841329701888502,
            "success_improvement": 0.0,
            "time_improvement": -47.58220087757631,
            "length_improvement": 21.860437409340815,
            "smoothness_improvement": 661.4232747211062,
            "objective_score": -6.595456407799201
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined bidirectional RRT*-inspired planner that grows two trees from start and goal simultaneously. It incorporates goal biasing for faster convergence and rewiring in a local neighborhood to improve path quality. The planner alternates tree expansions by sampling, steering, and validating new nodes and edges with collision checks, ensuring paths avoid obstacles. Upon successfully connecting the trees, it extracts and returns the optimized path.",
    "planning_mechanism": "The planner grows two trees from start and goal by alternately sampling points with goal biasing and steering towards them with a fixed step size. For each new node, it finds neighbors within a search radius to rewire and reduce path cost. It ensures new nodes and edges do not collide with obstacles and stay within bounds. After each addition, it attempts to connect to the opposite tree directly. The process terminates early upon successful path connection or after max iterations, yielding efficient, robust, and smooth paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, search_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_pos, radius):\n            return [node for node in tree if distance(node.position, new_pos) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def connect_trees(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if distance(node_a.position, connect_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                    return connect_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        for _ in range(self.max_iter):\n            for tree_a, tree_b, sample_goal in [(start_tree, goal_tree, goal_position), (goal_tree, start_tree, start_position)]:\n                # Goal biasing sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = sample_goal\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                # Check bounds\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                neighbors = find_near(tree_a, new_pos, self.search_radius)\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for neighbor in neighbors:\n                    edge_cost = distance(neighbor.position, new_pos)\n                    cost_through_neighbor = neighbor.cost + edge_cost\n                    if cost_through_neighbor < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_neighbor\n                        min_node = neighbor\n\n                new_node = Node(new_pos, parent=min_node, cost=min_cost)\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                rewire(tree_a, new_node, neighbors)\n\n                connect_node = connect_trees(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_path(connect_node, new_node)\n                    return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.27647,
    "time_improvement": -15.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009584951400756835,
            "num_nodes_avg": 195.8,
            "path_length_avg": 164.8209406208743,
            "smoothness_avg": 0.024110203822310102,
            "success_improvement": 0.0,
            "time_improvement": 3.02300785904853,
            "length_improvement": 17.624078053630388,
            "smoothness_improvement": 131.6693224627564,
            "objective_score": 5.090064580754419
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0228224515914917,
            "num_nodes_avg": 540.8,
            "path_length_avg": 240.89105735046527,
            "smoothness_avg": 0.017094892205199688,
            "success_improvement": 0.0,
            "time_improvement": -50.39309090109255,
            "length_improvement": 20.064197463940282,
            "smoothness_improvement": 139.48301198680733,
            "objective_score": -10.407672717605672
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02728226184844971,
            "num_nodes_avg": 559.2,
            "path_length_avg": 123.68675223120654,
            "smoothness_avg": 0.033845292972254026,
            "success_improvement": 0.0,
            "time_improvement": 1.7597885987195976,
            "length_improvement": 24.048883114725268,
            "smoothness_improvement": 161.86089267879785,
            "objective_score": 6.147017665954922
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner merges heuristic-guided informed sampling within an ellipsoidal region, goal biasing, and adaptive rewiring with bidirectional tree growth strategies. It utilizes an adaptive neighborhood radius for efficient rewiring, alternates expansion between start and goal trees with informed and goal-biased sampling, incrementally attempts to connect the trees, and applies iterative shortcut smoothing to enhance path quality. The design targets faster convergence, improved success rates, smoother and shorter paths, and robustness in complex 2D/3D obstacle environments.",
    "planning_mechanism": "The planner initializes two trees and progressively expands them by sampling points guided alternately by informed ellipsoidal sampling and goal biasing. Each new node is connected via rewiring with an adaptive neighborhood radius ensuring path cost improvement and collision avoidance. Connection attempts between trees occur incrementally within step-size distance, creating a more efficient and robust path search that continuously refines path quality. Path smoothing enhances final path smoothness and reduces unnecessary waypoints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 base_radius: float=20.0, smooth_iter: int=60,\n                 collision_resolution: float=0.3, informed_sampling_rate: float=0.85,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # (W,H) or (W,H,D)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step=None):\n            d = dist(from_pos, to_pos)\n            step = max_step if max_step is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            # Adaptive neighborhood radius for rewiring based on number nodes and dimension\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            val = gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)\n            return min(val, self.base_radius)\n\n        def informed_sample(c_max, start, goal):\n            # If no solution yet, sample uniformly\n            if math.isinf(c_max):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                c_max = c_min + 1e-6\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            if c_min == 0.0:\n                unit_vec = tuple(0 for _ in range(dim))\n            else:\n                unit_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s], [s, c]])\n                elif dim == 3:\n                    x_axis = np.array(vec)\n                    norm_x = np.linalg.norm(x_axis)\n                    if norm_x < 1e-9:\n                        return np.eye(3)\n                    x_axis /= norm_x\n                    if abs(x_axis[0]) < 1e-6 and abs(x_axis[1]) < 1e-6:\n                        temp = np.array([0,1,0])\n                    else:\n                        temp = np.array([0,0,1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= (np.linalg.norm(y_axis) + 1e-12)\n                    z_axis = np.cross(x_axis, y_axis)\n                    return np.stack((x_axis, y_axis, z_axis), axis=1)\n                else:\n                    return np.eye(dim)\n\n            L = np.diag([c_max/2] + [math.sqrt(c_max**2 - c_min**2)/2]*(dim-1))\n            R = rotation_matrix(unit_vec)\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball /= norm_x\n                u = random.uniform(0,1)\n                r = u**(1/dim)\n                sample_ball = x_ball * r\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                p = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        nodes_start = [Node(start_position, cost=0.0)]\n        nodes_goal = [Node(goal_position, cost=0.0)]\n        nodes = nodes_start + nodes_goal\n        edges = []\n\n        best_path_cost = math.inf\n        best_connect_nodes = None\n\n        # Main planning loop\n        for iter in range(self.max_iter):\n            sample_from_start = (iter % 2 == 0)\n\n            # Sampling strategy: informed sampling combined with goal biasing\n            sample = None\n            if random.random() < self.informed_sampling_rate and best_path_cost != math.inf:\n                sample = informed_sample(best_path_cost, start_position, goal_position)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if sample_from_start else start_position\n                else:\n                    for _ in range(10):\n                        candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if within_bounds(candidate) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                            sample = candidate\n                            break\n                    if sample is None:\n                        continue  # failed to find a valid sample this iteration\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors for potential cost improvement\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt to connect trees incrementally within step size\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_to_b = dist(new_node.position, nearest_in_b.position)\n            if dist_to_b <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    # Incrementally extend tree_b towards new_node.position\n                    curr = nearest_in_b\n                    connected = False\n                    while True:\n                        next_pos = steer(curr.position, new_node.position, self.step_size)\n                        if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                            break\n                        new_connect_node = Node(next_pos, parent=curr, cost=curr.cost + dist(curr.position, next_pos))\n                        curr.add_child(new_connect_node)\n                        tree_b.append(new_connect_node)\n                        nodes.append(new_connect_node)\n                        edges.append((curr, new_connect_node))\n                        curr = new_connect_node\n                        if dist(curr.position, new_node.position) <= self.step_size:\n                            final_node = Node(new_node.position, parent=curr, cost=curr.cost + dist(curr.position, new_node.position))\n                            curr.add_child(final_node)\n                            tree_b.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((curr, final_node))\n                            connected = True\n                            nearest_in_b = final_node\n                            break\n\n                    if connected:\n                        # Extract path and smooth it\n                        if sample_from_start:\n                            path = new_node.path_from_root() + nearest_in_b.path_from_root()[::-1]\n                        else:\n                            path = nearest_in_b.path_from_root() + new_node.path_from_root()[::-1]\n                        path = shortcut_smooth(path)\n                        success_state = True\n                        best_connect_nodes = (new_node, nearest_in_b)\n                        extracted_path = path\n                        best_path_cost = extracted_path and sum(dist(extracted_path[i], extracted_path[i+1]) for i in range(len(extracted_path)-1))\n                        break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 19.17882,
    "time_improvement": -87.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02994358539581299,
            "num_nodes_avg": 166.2,
            "path_length_avg": 174.27456799969065,
            "smoothness_avg": 0.03369798223098324,
            "success_improvement": 0.0,
            "time_improvement": -202.9581188457957,
            "length_improvement": 12.899245953207275,
            "smoothness_improvement": 223.79604790358388,
            "objective_score": -57.188606223579335
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026856517791748045,
            "num_nodes_avg": 277.7,
            "path_length_avg": 243.26690745679716,
            "smoothness_avg": 0.08304917159332359,
            "success_improvement": 0.0,
            "time_improvement": -76.97637369715974,
            "length_improvement": 19.275810020072992,
            "smoothness_improvement": 1063.4390856310172,
            "objective_score": -13.920554676978236
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.022138810157775878,
            "num_nodes_avg": 251.7,
            "path_length_avg": 128.40288458411752,
            "smoothness_avg": 0.09714097053222641,
            "success_improvement": 0.0,
            "time_improvement": 20.280752301470038,
            "length_improvement": 21.152893745445077,
            "smoothness_improvement": 651.5792899209619,
            "objective_score": 13.572700889134834
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a refined bidirectional RRT* planner that synergizes strengths of both existing approaches through adaptive step sizing with decay, dynamic nearest neighbor radius, robust bidirectional tree growth, and meticulous collision checking. It incrementally extends start and goal trees towards sampled points (with goal bias), selects optimal parent nodes based on cost and collision feasibility, rewires neighbors for local path improvements, and attempts to connect the two trees efficiently. Path extraction includes iterative shortcut smoothing to yield smooth, near-optimal paths. The structure ensures improved path quality, planning efficiency, robustness, and higher success rates across 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal. It samples free space biased to goals and adapts step size for exploration/refinement phases. Each sample leads to a carefully chosen parent node minimizing cost with collision checks. Local rewiring improves costs incrementally. Upon tree connection, the combined path is reconstructed and refined through iterative shortcut smoothing, ensuring smoothness and feasibility while strictly respecting obstacle and boundary constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, initial_step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 collision_resolution: float = 0.35, radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.initial_step_size = initial_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        import math\n        import random\n\n        def _is_within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def _near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def _steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def _can_connect(parent_node, new_pos):\n            if (not _is_within_bounds(new_pos)\n                or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                or self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-9 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(150):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start, tree_goal = [start_root], [goal_root]\n\n        for i in range(self.max_iter):\n            sample = _sample_free()\n\n            # Adaptive step size decaying after half iterations to refine path\n            step_decay = 1.0\n            if i > self.max_iter // 2:\n                step_decay = max(0.25, 1.0 - (i - self.max_iter // 2) / (self.max_iter // 2))\n            step_size = self.initial_step_size * step_decay\n\n            n_nodes = len(nodes)\n            radius = min(\n                self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim),\n                step_size * 5)\n\n            # Alternate growth between start and goal trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, step_size)\n\n            if not _can_connect(nearest_node_a, new_pos_a):\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist_db = math.dist(nearest_node_b.position, new_node_a.position)\n\n            if dist_db <= step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution) and \\\n               not self._is_in_obstacle(new_node_a.position, obstacles, is_3d):\n\n                connecting_node_b = nearest_node_b\n                if nearest_node_b.position != new_node_a.position:\n                    connecting_node_b = Node(new_node_a.position)\n                    connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist_db)\n                    tree_b.append(connecting_node_b)\n                    nodes.append(connecting_node_b)\n                    edges.append((nearest_node_b, connecting_node_b))\n\n                near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                extracted_path = _smooth_path(extracted_path)\n                success_state = True\n                break\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, step_size)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.35):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 35.61047,
    "time_improvement": -90.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.022124075889587404,
            "num_nodes_avg": 125.9,
            "path_length_avg": 163.03573224850382,
            "smoothness_avg": 0.03988372853198069,
            "success_improvement": -9.999999999999998,
            "time_improvement": -123.84321463548777,
            "length_improvement": 18.51630803961659,
            "smoothness_improvement": 283.2334406788588,
            "objective_score": -82.03353557932871
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026583647727966307,
            "num_nodes_avg": 293.6,
            "path_length_avg": 242.8829081449597,
            "smoothness_avg": 0.09991215843427242,
            "success_improvement": 0.0,
            "time_improvement": -75.17824205726997,
            "length_improvement": 19.403233983015554,
            "smoothness_improvement": 1299.6733263205244,
            "objective_score": -12.174459188975256
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04744341373443604,
            "num_nodes_avg": 432.2,
            "path_length_avg": 126.52359864651669,
            "smoothness_avg": 0.12063203256743849,
            "success_improvement": 0.0,
            "time_improvement": -70.83814460692362,
            "length_improvement": 22.306888521221566,
            "smoothness_improvement": 833.3295403784329,
            "objective_score": -12.623417975940608
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This improved planner is an advanced bidirectional RRT* variant enhanced for better efficiency, path quality, and robustness. It applies an adaptive step size that decays to balance exploration and exploitation, dynamically calculates the nearest neighbor radius based on the number of nodes, employs rigorous collision and boundary checks for both nodes and edges, and performs incremental rewiring for cost minimization. Extensive shortcut smoothing is used to improve path smoothness and reduce length. The planner alternates growth between two trees rooted at start and goal until a collision-free connecting path is found or maximum iterations are reached.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal with goal-biased sampling. It adapts step size over time to refine the search, selects parent nodes within a dynamic radius for optimal cost and collision feasibility, and rewires neighbors to continuously improve path quality. Upon tree connection, it reconstructs and smooths the path iteratively to ensure smooth, short, and collision-free navigation.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 6000,\n                 initial_step_size: float = 5.0,\n                 goal_sample_rate: float = 0.12,\n                 collision_resolution: float = 0.35,\n                 radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.initial_step_size = initial_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def _near_nodes(tree, point, radius):\n            radsq = radius * radius\n            return [n for n in tree if (sum((n.position[d] - point[d]) ** 2 for d in range(len(point))) <= radsq)]\n\n        def _steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def _can_connect(parent_node, new_pos):\n            if (not _is_within_bounds(new_pos)\n                or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                or self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-10 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid duplicating connection node position\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(200):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample = _sample_free()\n\n            step_decay = 1.0\n            if i > self.max_iter // 2:\n                step_decay = max(0.3, 1.0 - (i - self.max_iter // 2) / (self.max_iter // 2))\n            step_size = self.initial_step_size * step_decay\n\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            radius = min(\n                self.radius_constant * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)),\n                step_size * 4.5)\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, step_size)\n            if not _can_connect(nearest_node_a, new_pos_a):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist_nodes = math.dist(nearest_node_b.position, new_node_a.position)\n\n            # Try to directly connect if within step_size and collision-free\n            if (dist_nodes <= step_size and\n                not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution) and\n                not self._is_in_obstacle(new_node_a.position, obstacles, is_3d)):\n\n                connecting_node_b = nearest_node_b\n                if nearest_node_b.position != new_node_a.position:\n                    connecting_node_b = Node(new_node_a.position)\n                    cost_b = nearest_node_b.cost + dist_nodes\n                    connecting_node_b.update_parent(nearest_node_b, cost_b)\n                    tree_b.append(connecting_node_b)\n                    nodes.append(connecting_node_b)\n                    edges.append((nearest_node_b, connecting_node_b))\n\n                near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                extracted_path = _smooth_path(extracted_path)\n                success_state = True\n                break\n\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, step_size)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.35):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 22.40487,
    "time_improvement": -103.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02703697681427002,
            "num_nodes_avg": 115.7,
            "path_length_avg": 165.10607276351112,
            "smoothness_avg": 0.04253163348492442,
            "success_improvement": 0.0,
            "time_improvement": -173.550128571911,
            "length_improvement": 17.481571749287177,
            "smoothness_improvement": 308.67654148859197,
            "objective_score": -47.0253415142729
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031609177589416504,
            "num_nodes_avg": 249.2,
            "path_length_avg": 238.60190620914136,
            "smoothness_avg": 0.09295922054197961,
            "success_improvement": 0.0,
            "time_improvement": -108.29497214427788,
            "length_improvement": 20.823815258061398,
            "smoothness_improvement": 1202.2693480668906,
            "objective_score": -22.312381851336628
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03494007587432861,
            "num_nodes_avg": 249.8,
            "path_length_avg": 127.03374441608352,
            "smoothness_avg": 0.1542954706446976,
            "success_improvement": 0.0,
            "time_improvement": -25.81509771213745,
            "length_improvement": 21.993628287009326,
            "smoothness_improvement": 1093.7834224817743,
            "objective_score": 2.123113456169502
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined bidirectional RRT* planner designed for both 2D and 3D environments that balances exploration and exploitation through adaptive step sizing, dynamic neighborhood radius, and goal-biased sampling. It ensures path quality via incremental rewiring and collision checks, and improves final path smoothness with shortcut smoothing while maintaining computational efficiency and robustness.",
    "planning_mechanism": "The planner alternates growth between two trees starting from the start and goal points. At each iteration, it samples the free space with goal biasing and attempts to extend the nearest node towards the sample using adaptive step size. It dynamically selects the best parent within a radius and rewires neighbors to optimize path costs. When the two trees connect collision-free, the planner reconstructs and then smooths the path by shortcutting, returning the resulting feasible and near-optimal path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, resolution: float = 0.5,\n                 radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.resolution = resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def _near_nodes(tree, point, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, point) ** 2) <= r_sq]\n\n        def _steer(from_p, to_p, max_step):\n            dist = math.dist(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def _can_connect(parent_node, new_pos):\n            if not _within_bounds(new_pos):\n                return False\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.resolution):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.resolution):\n                    min_cost = cost\n                    best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-9 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample = _sample_free()\n\n            # Adaptive step size decay to refine towards the end\n            step_decay = 1.0\n            if i > self.max_iter // 2:\n                step_decay = max(0.3, 1.0 - (i - self.max_iter // 2) / (self.max_iter // 2))\n            cur_step = self.step_size * step_decay\n\n            n_nodes = len(nodes)\n            radius = min(self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim), cur_step * 5)\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, cur_step)\n            if not _can_connect(nearest_node_a, new_pos_a):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist_ab = math.dist(nearest_node_b.position, new_node_a.position)\n\n            if dist_ab <= cur_step and \\\n               not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.resolution) and \\\n               not self._is_in_obstacle(new_node_a.position, obstacles, is_3d):\n\n                connecting_node_b = nearest_node_b\n                if nearest_node_b.position != new_node_a.position:\n                    connecting_node_b = Node(new_node_a.position)\n                    connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist_ab)\n                    tree_b.append(connecting_node_b)\n                    nodes.append(connecting_node_b)\n                    edges.append((nearest_node_b, connecting_node_b))\n\n                near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                extracted_path = _smooth_path(extracted_path)\n                success_state = True\n                break\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, cur_step)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 10.51996,
    "time_improvement": -59.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01734476089477539,
            "num_nodes_avg": 142.2,
            "path_length_avg": 177.50425279865928,
            "smoothness_avg": 0.029797323664993835,
            "success_improvement": 0.0,
            "time_improvement": -75.48787371488393,
            "length_improvement": 11.285080532787862,
            "smoothness_improvement": 186.31552995353988,
            "objective_score": -19.45776835813991
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02369396686553955,
            "num_nodes_avg": 310.5,
            "path_length_avg": 253.01464114803835,
            "smoothness_avg": 0.09288292492641985,
            "success_improvement": 0.0,
            "time_improvement": -56.13611440170684,
            "length_improvement": 16.04118220081141,
            "smoothness_improvement": 1201.2005198112738,
            "objective_score": -7.626595281293401
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04001119136810303,
            "num_nodes_avg": 379.1,
            "path_length_avg": 124.77295632266768,
            "smoothness_avg": 0.1181540062399004,
            "success_improvement": 0.0,
            "time_improvement": -44.075587290167675,
            "length_improvement": 23.381888368532763,
            "smoothness_improvement": 814.1570608628131,
            "objective_score": -4.4755132090296845
        }
    ],
    "success_rate": 1.0
}
