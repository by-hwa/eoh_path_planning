[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.47449114023227,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012044763565063477,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": -21.86446156592386,
                    "length_improvement": 12.401486536989607,
                    "smoothness_improvement": 60.71897053377777,
                    "objective_score": -3.7754463097103477
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017744064331054688,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": -16.928046454483464,
                    "length_improvement": 14.190408824541839,
                    "smoothness_improvement": 52.81399740357816,
                    "objective_score": -1.9762621844187802
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009687995910644532,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.11466785256512,
                    "length_improvement": 11.655572158065754,
                    "smoothness_improvement": 61.933425488650386,
                    "objective_score": 22.175181914825938
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -1.486610468143649,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008508419990539551,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 13.914954384712244,
                    "length_improvement": 5.9265718433081265,
                    "smoothness_improvement": 7.497776338222911,
                    "objective_score": 5.397289565766413
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017635869979858398,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": -16.21507822540353,
                    "length_improvement": 0.3867603104208941,
                    "smoothness_improvement": 0.5583282013809732,
                    "objective_score": -4.784379764529976
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024777650833129883,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 10.77859785250502,
                    "length_improvement": 2.8534839845313615,
                    "smoothness_improvement": 8.529090107346295,
                    "objective_score": 3.84692160319451
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT planner optimized for enhanced efficiency, path quality, and robustness. It alternates growth of two trees from start and goal, samples points with goal bias, and ensures strict collision checking for newly added nodes and connecting edges. Upon connection, it reconstructs the path and applies shortcut smoothing to reduce unnecessary detours and improve smoothness. The design balances exploration depth and computational effort for improved success rates and faster convergence.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal by sampling free configurations biased toward the goal. It extends each tree by steering towards sampled points within step size, validating new nodes and edges via collision-free checks. When the two trees connect, the planner reconstructs the full path and performs iterative shortcut smoothing to optimize path quality before returning the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 3.0, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                         \n        start_position = map.start                 \n        goal_position = map.goal                   \n        obstacles = map.obstacles                  \n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, target_node):\n            current = _nearest(tree, target_node.position)\n            while True:\n                next_pos = _steer(current.position, target_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, target_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(40):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if not new_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.98769,
          "time_improvement": -24.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01088719367980957,
                    "num_nodes_avg": 134.1,
                    "path_length_avg": 175.03233523134534,
                    "smoothness_avg": 0.013335379012390985,
                    "success_improvement": 0.0,
                    "time_improvement": -10.152597731537979,
                    "length_improvement": 12.52052117410358,
                    "smoothness_improvement": 28.136545147160557,
                    "objective_score": -0.4009923589048745
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023423933982849122,
                    "num_nodes_avg": 412.5,
                    "path_length_avg": 250.35117199926208,
                    "smoothness_avg": 0.021827263057035733,
                    "success_improvement": 0.0,
                    "time_improvement": -54.356678931773125,
                    "length_improvement": 16.925011373547015,
                    "smoothness_improvement": 205.77897991876952,
                    "objective_score": -11.893106505228687
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029634523391723632,
                    "num_nodes_avg": 463.6,
                    "path_length_avg": 126.67064640606554,
                    "smoothness_avg": 0.03621107325015106,
                    "success_improvement": 0.0,
                    "time_improvement": -6.710428151123073,
                    "length_improvement": 22.216592338552495,
                    "smoothness_improvement": 180.16492496948817,
                    "objective_score": 3.3310146472210187
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planning algorithm combines bidirectional search from the dual-tree RRT with asymptotically optimal rewiring from RRT*. It grows two trees from start and goal, alternately extending towards random samples and attempting connections. Each extension uses rewiring within a neighborhood radius to optimize paths locally. The goal biasing accelerates convergence. Collision and edge checks ensure validity. The hybrid approach improves planning efficiency, path quality, robustness, success rate, and smoothness by leveraging complementary strengths of both methods.",
          "planning_mechanism": "The planner maintains start and goal trees, grows them bidirectionally by sampling points and steering towards them. For each new node added, it finds neighbors within a radius to rewire and minimize cost. After each extension, it attempts to connect the two trees directly. If a connection is found without collision, the path is extracted. Goal biasing increases attempts towards the goal to speed up convergence. The algorithm terminates early upon a successful path or after max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, search_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-assign parent\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            # Try building connection backward from connect_node towards node_a\n            curr = connect_node\n            connection_chain = []\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                connection_chain.append(new_node)\n                if distance(new_pos, node_a.position) < self.step_size:\n                    # Final connect node\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_from_start, node_from_goal):\n            path_start = []\n            node = node_from_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_from_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree selection for expanding\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing on sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                # Boundary check\n                out_of_bounds = any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds)))\n                if out_of_bounds:\n                    continue\n\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Find neighbors for rewiring\n                neighbors = find_near(tree_a, new_node, self.search_radius)\n                # Choose best parent\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = cost\n                            min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors through new_node if better\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt to connect the other tree directly\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.2445,
          "time_improvement": -28.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013188529014587402,
                    "num_nodes_avg": 194.0,
                    "path_length_avg": 173.0342779839435,
                    "smoothness_avg": 0.021996203295678553,
                    "success_improvement": 0.0,
                    "time_improvement": -33.436657226802765,
                    "length_improvement": 13.519130982034183,
                    "smoothness_improvement": 111.35638469997163,
                    "objective_score": -6.770389048134134
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024630069732666016,
                    "num_nodes_avg": 484.0,
                    "path_length_avg": 244.14905520536445,
                    "smoothness_avg": 0.015383195714505082,
                    "success_improvement": 0.0,
                    "time_improvement": -62.30475071249689,
                    "length_improvement": 18.9830835527118,
                    "smoothness_improvement": 115.50378905411706,
                    "objective_score": -14.317289557936123
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024231910705566406,
                    "num_nodes_avg": 405.4,
                    "path_length_avg": 130.81419641767454,
                    "smoothness_avg": 0.028347178181784644,
                    "success_improvement": 0.0,
                    "time_improvement": 12.743743770384414,
                    "length_improvement": 19.672203019772287,
                    "smoothness_improvement": 119.32200113298974,
                    "objective_score": 8.354173740734732
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner with optimized parameters to improve efficiency, path quality, and success rate. It features reduced step size for finer expansions, increased maximum iterations for deeper search, and a goal bias sampling probability to accelerate convergence. Collision checking is precise with a refined resolution, and post-planning path smoothing via shortcutting reduces unnecessary detours and improves smoothness.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions, alternately expanding each towards sampled points biased towards the goal. Each new node and edge is strictly checked for collision-free feasibility. When the trees connect, the planner reconstructs the path, smooths it by iteratively shortcutting, and returns the optimized trajectory along with explored graph data.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.6782,
          "time_improvement": -33.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010827350616455077,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 163.9683475002103,
                    "smoothness_avg": 0.014173695614508616,
                    "success_improvement": 0.0,
                    "time_improvement": -9.547127756576938,
                    "length_improvement": 18.050195900642194,
                    "smoothness_improvement": 36.19173375747664,
                    "objective_score": 0.9268595219427409
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03178107738494873,
                    "num_nodes_avg": 498.6,
                    "path_length_avg": 249.62854531281232,
                    "smoothness_avg": 0.0401662199932736,
                    "success_improvement": 0.0,
                    "time_improvement": -109.42774008867326,
                    "length_improvement": 17.164803355659895,
                    "smoothness_improvement": 462.6901432691145,
                    "objective_score": -27.081910639124423
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02228260040283203,
                    "num_nodes_avg": 378.2,
                    "path_length_avg": 125.71203140928696,
                    "smoothness_avg": 0.05507350730124254,
                    "success_improvement": 0.0,
                    "time_improvement": 19.762980565745675,
                    "length_improvement": 22.805239694513528,
                    "smoothness_improvement": 326.10349972973546,
                    "objective_score": 12.120459607275086
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm improves bidirectional RRT by tuning key parameters: reducing step size for finer node expansions, increasing maximum iterations for thorough search, and biasing sampling towards the goal to enhance convergence speed. It also integrates a goal bias sampling with a certain probability to direct growth towards the goal, and employs shortened collision checking resolution to enhance accuracy. Additionally, path smoothing is applied post planning to improve path quality and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal simultaneously, alternately expanding each tree towards sampled points. Sampling is biased towards the goal to increase success and convergence speed. Collision checks are strictly enforced for nodes and edges before insertion. When trees connect, the path is reconstructed and then smoothed by shortcutting to reduce unnecessary detours, resulting in improved path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            # Shortcut smoothing with max trials = 50\n            if len(path) <= 2:\n                return path\n            import random\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    # shortcut possible\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.82017,
          "time_improvement": -50.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.008735418319702148,
                    "num_nodes_avg": 121.9,
                    "path_length_avg": 158.79688158358158,
                    "smoothness_avg": 0.017264620570270624,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 11.618269272519385,
                    "length_improvement": 20.634844860245124,
                    "smoothness_improvement": 65.89171039649618,
                    "objective_score": -42.05809169421266
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026499056816101076,
                    "num_nodes_avg": 449.3,
                    "path_length_avg": 240.15460051249525,
                    "smoothness_avg": 0.04002816589212556,
                    "success_improvement": 0.0,
                    "time_improvement": -74.62081339337057,
                    "length_improvement": 20.308578758222435,
                    "smoothness_improvement": 460.75613797892566,
                    "objective_score": -16.020747576472054
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.052319788932800294,
                    "num_nodes_avg": 571.0,
                    "path_length_avg": 128.29426974238464,
                    "smoothness_avg": 0.06187473290802109,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -88.39739731919414,
                    "length_improvement": 21.219589801337207,
                    "smoothness_improvement": 378.7245543077222,
                    "objective_score": -70.38167846395218
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 43.98048200212903,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.002286410331726074,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 76.86694616382907,
                    "length_improvement": 14.547294318234119,
                    "smoothness_improvement": 6.939088459328463,
                    "objective_score": 26.004238155092185
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.007691335678100586,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 49.31641146656528,
                    "length_improvement": 8.292841453028517,
                    "smoothness_improvement": 4.557864045526364,
                    "objective_score": -133.5237189491971
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.00499422550201416,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 82.01638222560287,
                    "length_improvement": 4.825184687042764,
                    "smoothness_improvement": 1.6166365256828326,
                    "objective_score": -24.421965212282167
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 52.752541255711016,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0051594734191894535,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 47.79835678825919,
                    "length_improvement": 21.158844301429212,
                    "smoothness_improvement": 158.83369146092565,
                    "objective_score": 19.365444354068227
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.021558094024658202,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -42.06135485959018,
                    "length_improvement": 27.333600643728058,
                    "smoothness_improvement": 213.19280910618096,
                    "objective_score": -106.08572228360053
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.008537554740905761,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 69.25727099697029,
                    "length_improvement": 31.694181530357035,
                    "smoothness_improvement": 269.3273114473463,
                    "objective_score": -71.53734583760075
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This simplified hybrid RRT* planner integrates goal bias sampling, dynamic neighbor searching with rewiring to incrementally improve path cost and quality. It ensures collision-free node and edge expansions within map bounds, balancing exploration and exploitation to efficiently find smooth, robust paths with reduced planning time.",
          "planning_mechanism": "The planner grows a tree from the start position by iteratively sampling states with goal bias. For each sampled point, it steers a fixed step size towards the sample from the nearest existing node. New nodes are added only if collision-free and within bounds. For each new node, neighbors within a dynamically scaled radius are found to select the best parent minimizing path cost. The planner then rewires neighbors via the new node to improve costs. When a node reaches near the goal, a final connection is attempted. The solution path is extracted by backtracking from the goal node once found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Dynamic neighbor radius based on node count & dimension\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            gamma = self.neighbor_factor\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim)))\n\n            # Find neighbor nodes within radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            # Choose parent minimizing cost + collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                c = near_node.cost + math.dist(near_node.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = near_node\n\n            # Connect new node to best parent\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if beneficial and collision-free\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge & update parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new node can connect directly to goal\n            dist_goal = math.dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 132.8663,
          "time_improvement": -452.0,
          "length_improvement": 14.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04421133995056152,
                    "num_nodes_avg": 277.1,
                    "path_length_avg": 175.4057816503535,
                    "smoothness_avg": 0.014822768672657066,
                    "success_improvement": 0.0,
                    "time_improvement": -347.31398080829035,
                    "length_improvement": 12.333876243262361,
                    "smoothness_improvement": 42.42852531337951,
                    "objective_score": -101.51527636726773
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14756877422332765,
                    "num_nodes_avg": 975.3,
                    "path_length_avg": 271.0520755830754,
                    "smoothness_avg": 0.006851663576418842,
                    "success_improvement": 0.0,
                    "time_improvement": -872.4338328405295,
                    "length_improvement": 10.055751221700547,
                    "smoothness_improvement": -4.014777589414016,
                    "objective_score": -259.7390734957658
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06594605445861816,
                    "num_nodes_avg": 520.3,
                    "path_length_avg": 133.0968329704542,
                    "smoothness_avg": 0.019142422483870408,
                    "success_improvement": 0.0,
                    "time_improvement": -137.46397447113193,
                    "length_improvement": 18.270526668026136,
                    "smoothness_improvement": 48.104844114373854,
                    "objective_score": -37.34456278716248
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm integrates the exploration efficiency of a basic RRT with the path optimality improvements of RRT*\u2014including goal biasing, neighbor rewiring, and adaptive steering\u2014combined with a dynamic neighbor radius scaling based on node density. It performs rigorous collision checking for nodes and edges, ensures nodes stay within bounds, and incrementally improves path cost while promoting path smoothness and robustness. The planner balances exploration and exploitation via goal sampling and rewiring neighbors to progressively shorten path length and increase success rate.",
          "planning_mechanism": "The planner samples points with goal bias, steers towards them from the nearest nodes with fixed step size, rejects samples in collision or out of bounds, and adds valid nodes. It selects the best parent among neighbors within a dynamically scaled radius to minimize cost, adds edges only if collision-free, and rewires neighbors to improve paths. Once within step size of goal, it attempts final connection. The path is traced back from goal node if successful.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_factor: float = 50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_factor = neighbor_factor  # factor to scale neighbor search radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_idx in range(1, self.max_iter + 1):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + (direction[d] / dist) * scale for d in range(len(bounds)))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Dynamic neighbor radius based on iteration and nodes count\n            n_nodes = len(nodes)\n            gamma = self.neighbor_factor\n            dim = len(bounds)\n            # Radius scaling as per RRT* theoretical bound:\n            radius = min(self.step_size * 3, gamma * ((math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)))\n\n            # Find neighbors within radius\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= radius]\n\n            # Choose best parent minimizing cost + edge validity\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_node\n\n            # Connect new_node to best parent\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to potentially improve their cost through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge and update parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new node can connect directly to goal\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path if success\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 177.31653,
          "time_improvement": -604.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05419919490814209,
                    "num_nodes_avg": 284.2,
                    "path_length_avg": 165.482775399497,
                    "smoothness_avg": 0.016891900008800545,
                    "success_improvement": 0.0,
                    "time_improvement": -448.3674020754835,
                    "length_improvement": 17.293299392497616,
                    "smoothness_improvement": 62.310325494896546,
                    "objective_score": -130.74000911667105
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.15224525928497315,
                    "num_nodes_avg": 933.7,
                    "path_length_avg": 259.50582756375985,
                    "smoothness_avg": 0.007024509778030356,
                    "success_improvement": 0.0,
                    "time_improvement": -903.2504626909287,
                    "length_improvement": 13.887186941464913,
                    "smoothness_improvement": -1.5933684061602176,
                    "objective_score": -268.2056682610164
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15545496940612794,
                    "num_nodes_avg": 883.6,
                    "path_length_avg": 124.91386658373274,
                    "smoothness_avg": 0.019892198189482964,
                    "success_improvement": 0.0,
                    "time_improvement": -459.77503414752243,
                    "length_improvement": 23.295360979661872,
                    "smoothness_improvement": 53.9058556683744,
                    "objective_score": -133.00390876998247
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 188.97047424566063,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.034190583229064944,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -245.92767166641744,
                    "length_improvement": 8.639069807597604,
                    "smoothness_improvement": -38.9355540051658,
                    "objective_score": -72.24516530843155
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23241231441497803,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -1431.5272414194005,
                    "length_improvement": -1.1692154216563917,
                    "smoothness_improvement": -45.85769819397494,
                    "objective_score": -429.92130400112126
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08899827003479004,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -220.4722874933787,
                    "length_improvement": 7.95110876006046,
                    "smoothness_improvement": -38.697786285519925,
                    "objective_score": -64.74495342742911
               }
          ]
     },
     {
          "operator": "e1",
          "algorithm_description": "This Planner implements RRT* (Rapidly-exploring Random Tree Star), an asymptotically optimal sampling-based path planner that incrementally builds a tree towards the goal while rewiring nodes within a neighborhood radius to reduce path cost. This improves path quality, smoothness, success rate, and efficiency over naive RRT.",
          "planning_mechanism": "The planner samples random points, connects them by the lowest-cost parent within a radius if free of collisions, and rewires neighbors to shorten paths. It terminates when the goal is reached or max iterations expire, then extracts the optimal path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, search_radius: float=15.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        def distance(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            new_pos = tuple(from_pos[d] + direction[d]*self.step_size for d in range(len(from_pos)))\n            return new_pos\n\n        def find_nearest(nodes, sample):\n            return min(nodes, key=lambda n: distance(n.position, sample))\n\n        def find_near(nodes, new_node, radius):\n            return [node for node in nodes if distance(node.position, new_node.position) <= radius]\n\n        for _ in range(self.max_iter):\n            # Sample point (goal biasing)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = find_nearest(nodes, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            # Check bounds\n            out_of_bounds = any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds)))\n            if out_of_bounds:\n                continue\n\n            # Check collision for new node pos\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            \n            # Find neighbors within radius\n            neighbors = find_near(nodes, new_node, self.search_radius)\n\n            # Choose parent with minimum cost + edge cost, check collision\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for node in neighbors:\n                edge_cost = distance(node.position, new_pos)\n                cost = node.cost + edge_cost\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_node = node\n            \n            new_node.parent = min_node\n            new_node.cost = min_cost\n            min_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors to new node if cheaper and collision free\n            for node in neighbors:\n                if node == min_node:\n                    continue\n                edge_cost = distance(new_node.position, node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        # Rewire\n                        if node.parent:\n                            node.parent.remove_child(node)\n                            edges.remove((node.parent, node))\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n            # Check if goal can be connected to new node directly (within step size)\n            if distance(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node,\n                                     cost=new_node.cost + distance(new_node.position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 203.21722,
          "time_improvement": -695.0,
          "length_improvement": 24.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08516473770141601,
                    "num_nodes_avg": 382.4,
                    "path_length_avg": 166.63575379732103,
                    "smoothness_avg": 0.020723393476121822,
                    "success_improvement": 0.0,
                    "time_improvement": -761.6653077765501,
                    "length_improvement": 16.71705187111335,
                    "smoothness_improvement": 99.12625215137012,
                    "objective_score": -224.6605506979855
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2160618782043457,
                    "num_nodes_avg": 907.3,
                    "path_length_avg": 224.7715692277033,
                    "smoothness_avg": 0.01672571524002643,
                    "success_improvement": 0.0,
                    "time_improvement": -1323.7827850694584,
                    "length_improvement": 25.41318896962671,
                    "smoothness_improvement": 134.31119747551438,
                    "objective_score": -391.38064173953455
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02791097164154053,
                    "num_nodes_avg": 283.3,
                    "path_length_avg": 115.64457953157512,
                    "smoothness_avg": 0.03213987081764254,
                    "success_improvement": 0.0,
                    "time_improvement": -0.5041213119173451,
                    "length_improvement": 28.987261620933317,
                    "smoothness_improvement": 148.66604847500068,
                    "objective_score": 6.3895461729864635
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a hybrid informed bidirectional RRT* variant that leverages heuristic-informed sampling within an ellipsoidal subset of the space defined by start and goal positions to focus exploration and improve planning efficiency. It maintains two growing trees from start and goal, rewiring nodes for cost optimization (RRT*), and performs path pruning and smoothing via shortcutting to enhance path quality and smoothness while ensuring robustness via strict collision and boundary checks.",
          "planning_mechanism": "The planner alternately expands bidirectional RRT* trees. Sampling is biased: with a high probability, samples are drawn from an ellipsoid encapsulating possible better paths (informed sampling), and otherwise uniformly over space. Each new node considers rewiring nearby nodes to optimize path cost. Trees attempt connection after each expansion to rapidly find feasible paths. Once connected, the path is extracted, then iteratively smoothed by shortcutting collision-free edges to reduce detours and path length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag for collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        from math import dist\n        return dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=10.0, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n        self.neighbor_radius = neighbor_radius    # Radius to consider for rewiring in RRT*\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def is_collision_free_edge(from_pos, to_pos):\n            return (not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, self.collision_resolution))\n\n        # Informed sampling within ellipse defined by current best cost\n        def sample_in_ellipse(best_cost):\n            if best_cost == math.inf:\n                # No solution yet, uniform random sample\n                return sample_free_uniform()\n            c_min = dist(start_position, goal_position)\n            if best_cost < c_min:\n                # Numerical inaccuracies, fallback uniform\n                return sample_free_uniform()\n            a1 = tuple((goal_position[i] - start_position[i]) / c_min for i in range(len(bounds)))\n\n            # Construct rotation matrix to align x-axis with a1\n            def build_rotation_matrix(a):\n                # Handle 2D & 3D cases\n                import numpy as np\n                dim = len(a)\n                a = np.array(a)\n                e1 = np.zeros(dim)\n                e1[0] = 1.0\n                v = np.cross(e1, a) if dim == 3 else (0,)\n                s = np.linalg.norm(v)\n                c = np.dot(e1, a)\n                if dim == 2:\n                    # 2D rotation matrix\n                    theta = math.acos(c)\n                    rot = np.array([\n                        [math.cos(theta), -math.sin(theta)],\n                        [math.sin(theta), math.cos(theta)]\n                    ])\n                    return rot\n                elif dim == 3:\n                    if s == 0:\n                        return np.eye(3)\n                    vx = np.array([[0, -v[2], v[1]],\n                                   [v[2], 0, -v[0]],\n                                   [-v[1], v[0], 0]])\n                    rot = np.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                    return rot\n                # fallback\n                return np.eye(dim)\n\n            import numpy as np\n            rot = build_rotation_matrix(a1)\n\n            r1 = best_cost / 2.0\n            rn = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            # Radii for other axes\n            dim = len(bounds)\n            if dim == 2:\n                lengths = [r1, rn]\n            elif dim == 3:\n                lengths = [r1, rn, rn]\n            else:\n                lengths = [r1] + [rn]*(dim-1)\n\n            while True:\n                # Sample uniformly in unit ball\n                if dim == 2:\n                    theta = random.uniform(0, 2 * math.pi)\n                    r = random.uniform(0, 1) ** 0.5\n                    unit = np.array([r * math.cos(theta), r * math.sin(theta)])\n                elif dim == 3:\n                    phi = random.uniform(0, 2 * math.pi)\n                    costheta = random.uniform(-1, 1)\n                    u = random.uniform(0, 1)\n                    sintheta = math.sqrt(1 - costheta**2)\n                    r = u ** (1.0 / 3.0)\n                    unit = np.array([\n                        r * sintheta * math.cos(phi),\n                        r * sintheta * math.sin(phi),\n                        r * costheta\n                    ])\n                else:\n                    # Higher dims uniform sampling skipped for simplicity - fallback uniform\n                    return sample_free_uniform()\n\n                # Scale by radii\n                sample_vec = np.multiply(unit, lengths)\n                # Rotate to world frame\n                sample_rot = rot @ sample_vec\n                center = np.array([(start_position[i] + goal_position[i]) / 2.0 for i in range(dim)])\n                sample_point = tuple((sample_rot + center).tolist())\n                if in_bounds(sample_point) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    return sample_point\n\n        def sample_free_uniform():\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        # Find neighbors within radius in given tree\n        def find_neighbors(tree, new_pos):\n            neighbors = []\n            for node in tree:\n                if dist(node.position, new_pos) <= self.neighbor_radius:\n                    neighbors.append(node)\n            return neighbors\n\n        # Rewire near nodes for cost optimization (RRT*)\n        def rewire(tree, new_node, neighbors):\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                edge_free = is_collision_free_edge(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if edge_free and new_cost < near_node.cost:\n                    # Rewire near_node to new_node\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    new_node.add_child(near_node)\n                    near_node.cost = new_cost\n\n        # Attempt to connect two trees (bidirectional)\n        def connect_trees(node_from, tree_to):\n            nearest = nearest_node(tree_to, node_from.position)\n            # Try extending from nearest towards node_from position with step_size increments\n            current = nearest\n            while True:\n                new_pos = steer(current.position, node_from.position)\n                if (not in_bounds(new_pos)\n                    or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                    or not is_collision_free_edge(current.position, new_pos)):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                current = new_node\n                if dist(new_pos, node_from.position) <= self.step_size:\n                    # connect final node\n                    final_new_node = Node(node_from.position, parent=current, cost=current.cost + dist(new_pos, node_from.position))\n                    current.add_child(final_new_node)\n                    tree_to.append(final_new_node)\n                    nodes.append(final_new_node)\n                    edges.append((current, final_new_node))\n                    return final_new_node\n\n        # Nearest node search\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        # Extract full path from start to goal via connecting nodes\n        def extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        # Smooth path by shortcutting via random checks\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = math.inf\n        best_nodes = (None, None)\n\n        for _ in range(self.max_iter):\n            # Sampling with goal bias and informed sampling if solution found\n            if random.random() < self.goal_sample_rate:\n                sample_point = goal_position\n            else:\n                if best_cost < math.inf:\n                    sample_point = sample_in_ellipse(best_cost)\n                else:\n                    sample_point = sample_free_uniform()\n\n            # Alternate expansions between the two trees\n            for tree, other_tree in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = nearest_node(tree, sample_point)\n                new_pos = steer(nearest.position, sample_point)\n\n                if (not in_bounds(new_pos)\n                    or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                    or not is_collision_free_edge(nearest.position, new_pos)):\n                    continue\n\n                new_cost = nearest.cost + dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                neighbors = find_neighbors(tree, new_node.position)\n                rewire(tree, new_node, neighbors)\n\n                # Try to connect new_node to other_tree\n                connect_node = connect_trees(new_node, other_tree)\n                if connect_node:\n                    # Reconstruct path\n                    path = extract_path(new_node, connect_node)\n                    path_cost = sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        success_state = True\n                        extracted_path = smooth_path(path)\n                        best_nodes = (new_node, connect_node)\n\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 229.14492,
          "time_improvement": -515.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.027021265029907225,
                    "num_nodes_avg": 105.2,
                    "path_length_avg": 160.88171807961118,
                    "smoothness_avg": 0.02966770978592918,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -173.39116255059653,
                    "length_improvement": 19.592863617928842,
                    "smoothness_improvement": 185.0701004347362,
                    "objective_score": -97.1734255394195
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.06624782085418701,
                    "num_nodes_avg": 333.9,
                    "path_length_avg": 227.72438609382203,
                    "smoothness_avg": 0.0931158151292383,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -336.5532118134656,
                    "length_improvement": 24.433344435207932,
                    "smoothness_improvement": 1204.4630877504983,
                    "objective_score": -190.05697921824557
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.31507723331451415,
                    "num_nodes_avg": 613.8,
                    "path_length_avg": 113.62318167299891,
                    "smoothness_avg": 0.11934226504222545,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -1034.5560049416251,
                    "length_improvement": 30.228521677154852,
                    "smoothness_improvement": 823.3506143346463,
                    "objective_score": -400.2043440753833
               }
          ],
          "success_rate": 0.8333333333333334
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT with adaptive sampling and dynamic step size adjustment for improved planning efficiency, success rate, and path quality. It introduces informed sampling biased towards the current best path, dynamically adjusts step size based on local obstacle density, and applies aggressive path smoothing via shortcutting and spline interpolation for smooth and short paths. Robust collision checking and edge validation ensure safe expansions and better convergence.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansions. Sampling is dynamically biased towards the goal and regions near the current best path for efficient exploration. Each extension step adapts the step size based on obstacle proximity. When the two trees connect, the path is reconstructed, extensively smoothed with shortcutting and cubic spline interpolation to improve smoothness and reduce length, then returned as the final path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float=3.0, goal_sample_rate: float=0.15, collision_resolution: float=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n        best_connect = None\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free() -> Tuple[float, ...]:\n            # With probability goal_sample_rate, sample goal directly for bias\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            # With small probability sample near current best path if exists for informed sampling\n            if best_connect is not None and random.random() < 0.2:\n                path = best_connect.path_from_root()\n                if len(path) > 2:\n                    idx = random.randint(0, len(path) - 2)\n                    p1, p2 = path[idx], path[idx+1]\n                    alpha = random.uniform(0,1)\n                    sample = tuple(p1[d] + alpha*(p2[d] - p1[d]) for d in range(len(p1)))\n                    if _is_within_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Uniform random sample in free space\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            # Return node in tree nearest to point\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _dynamic_step_size(pos: Tuple[float, ...]) -> float:\n            # Estimate obstacle density nearby and reduce step size in cluttered areas\n            check_range = self.step_size * 2\n            cnt = 0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    cx, cy, cz = x + w/2, y + h/2, z + d/2\n                    dist_to_obs = math.dist(pos, (cx, cy, cz))\n                    if dist_to_obs < check_range + max(w,h,d)/2:\n                        cnt += 1\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    cx, cy = x + w_/2, y + h_/2\n                    dist_to_obs = math.dist(pos, (cx, cy))\n                    if dist_to_obs < check_range + max(w_,h_)/2:\n                        cnt += 1\n            if cnt == 0:\n                return self.step_size\n            else:\n                return max(self.step_size / (1 + cnt), self.step_size * 0.2)\n\n        def _extend_tree(tree: List[Node], point: Tuple[float, ...]):\n            nearest_node = _nearest(tree, point)\n            dynamic_step = _dynamic_step_size(nearest_node.position)\n            new_pos = _steer(nearest_node.position, point, dynamic_step)\n\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree: List[Node], new_node: Node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                dynamic_step = _dynamic_step_size(current.position)\n                next_pos = _steer(current.position, new_node.position, dynamic_step)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= dynamic_step:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a: Node, node_b: Node) -> List[Tuple[float, ...]]:\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _shortcut_smooth(path: List[Tuple[float, ...]], trials: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            for _ in range(trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def _cubic_spline_smooth(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            try:\n                import numpy as np\n                from scipy.interpolate import CubicSpline\n            except ImportError:\n                # Fallback: no spline smoothing if libs unavailable\n                return path\n            if len(path) < 4:\n                return path\n\n            dims = len(path[0])\n            path_np = np.array(path)\n            num_points = len(path)\n\n            # Parameter t: cumulative distance along path\n            dist = np.zeros(num_points)\n            dist[1:] = np.cumsum(np.linalg.norm(np.diff(path_np, axis=0), axis=1))\n            cs_funcs = [CubicSpline(dist, path_np[:, d]) for d in range(dims)]\n\n            smoothed_path = []\n            resolution = max(dist[-1]/(num_points*5), 0.01)  # denser interpolation\n            ts = np.arange(0, dist[-1], resolution)\n            for t in ts:\n                pt = tuple(cs(t) for cs in cs_funcs)\n                if (not _is_within_bounds(pt) or self._is_in_obstacle(pt, obstacles, is_3d) \n                    or self._is_edge_in_obstacle(smoothed_path[-1] if smoothed_path else pt, pt, obstacles, is_3d, self.collision_resolution)):\n                    return path  # Abort smoothing if obstacle detected\n                smoothed_path.append(pt)\n            return smoothed_path if smoothed_path else path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_start = _extend_tree(tree_start, rand_point)\n            if new_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_goal = _connect_trees(tree_goal, new_start)\n            if new_goal is not None:\n                candidate_path = _reconstruct_path(new_start, new_goal)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if candidate_cost < best_path_cost:\n                    best_path_cost = candidate_cost\n                    best_connect = new_start\n                    extracted_path = candidate_path\n                    success_state = True\n                    # Aggressive smoothing on candidate path\n                    extracted_path = _shortcut_smooth(extracted_path, trials=150)\n                    extracted_path = _cubic_spline_smooth(extracted_path)\n                    break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 256.55061,
          "time_improvement": -672.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02612292766571045,
                    "num_nodes_avg": 236.2,
                    "path_length_avg": 149.55670683106166,
                    "smoothness_avg": 0.01981247787287812,
                    "success_improvement": 0.0,
                    "time_improvement": -164.3021174563507,
                    "length_improvement": 25.252995389644518,
                    "smoothness_improvement": 90.37347668005924,
                    "objective_score": -43.788168775576
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.15865614414215087,
                    "num_nodes_avg": 1280.6,
                    "path_length_avg": 230.71969094734158,
                    "smoothness_avg": 0.08375590703309015,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -945.4962654793288,
                    "length_improvement": 23.439400949136978,
                    "smoothness_improvement": 1073.3397699852385,
                    "objective_score": -323.59430060404503
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.279067325592041,
                    "num_nodes_avg": 1624.2,
                    "path_length_avg": 121.86693114793975,
                    "smoothness_avg": 0.379060520513509,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -904.8885687573564,
                    "length_improvement": 25.166362887717565,
                    "smoothness_improvement": 2832.7896899084412,
                    "objective_score": -402.2693496001212
               }
          ],
          "success_rate": 0.8666666666666666
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the informed bidirectional RRT* approach with dynamic neighbor rewiring and adaptive step sizing from single-tree RRT* variants. It employs informed ellipsoidal sampling biased by the current best solution to focus search, while growing two trees (from start and goal) that attempt to connect for faster convergence. Dynamic neighborhood rewiring improves path optimality, and local shortcut smoothing enhances final path smoothness. Efficiency is improved by adaptive radius scaling and pruning unreachable branches. The planner maintains strict collision checks on nodes and edges and respects map bounds.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling mostly within an informed ellipsoid based on the current best solution cost to reduce search space and focus on promising regions. Each extension chooses parents among neighbors minimizing costs, rewires neighbors for improved paths, and tries to connect both trees to form a complete path. After connection, a local shortcut smoothing procedure refines the path to reduce unnecessary waypoints while ensuring collision-free shortcuts. The process adapts step sizes and neighbor search radius dynamically for balance between exploration and efficient convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root of the tree\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 neighbor_factor: float = 30.0, smooth_iter: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor  # Used to scale rewiring radius dynamically\n        self.smooth_iter = smooth_iter           # Number of local shortcut smoothing iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []    # Stores nodes that are expansions beyond roots\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = _distance(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def _steer(from_p, to_p, max_step):\n            dist = _distance(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: _distance(n.position, point))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_a)) + path_b\n\n        def _local_shortcut(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not _is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def _informed_sample(c_best):\n            # Sample uniformly in map if no solution found yet\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle(pt):\n                        return pt\n\n            c_min = _distance(start_pos, goal_pos)\n            if c_best < c_min:\n                c_min = c_best  # numerical safeguard\n\n            center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n            direction_vec = tuple((g - s) / c_min for s, g in zip(start_pos, goal_pos))\n\n            # Gram-Schmidt orthonormal basis\n            basis = [direction_vec]\n            for _ in range(dim - 1):\n                vec = [random.gauss(0, 1) for __ in range(dim)]\n                for b in basis:\n                    proj = sum(vec[d] * b[d] for d in range(dim))\n                    vec = [vec[d] - proj * b[d] for d in range(dim)]\n                norm = math.sqrt(sum(x * x for x in vec))\n                if norm > 1e-9:\n                    basis.append(tuple(x / norm for x in vec))\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n            radii = [r1] + [r_other] * (dim - 1)\n\n            while True:\n                while True:\n                    sample = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in sample))\n                    if 1e-9 < norm <= 1.0:\n                        sample = [x / norm for x in sample]\n                        break\n                u = random.uniform(0, 1) ** (1.0 / dim)\n                sample_scaled = [radii[i] * u * sample[i] for i in range(dim)]\n\n                new_point = list(center)\n                for i in range(dim):\n                    for d in range(dim):\n                        new_point[d] += basis[i][d] * sample_scaled[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n\n                if not _is_in_obstacle(new_point):\n                    return new_point\n\n        def _rewire(tree, new_node, radius):\n            near_nodes = _near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not _is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old connection\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, new_cost)\n                        edges.append((new_node, near_node))\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            c_best = best_cost\n            sample = _informed_sample(c_best)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = _nearest(tree_a, sample)\n                new_pos = _steer(nearest_node.position, sample, self.step_size)\n\n                # Check bounds\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                    continue\n                if _is_in_obstacle(new_pos):\n                    continue\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                # Create new node and find best parent among neighbors\n                new_node = Node(new_pos)\n                n_nodes = len(tree_a)\n                # Adaptive radius for neighbors used in rewiring:\n                radius = min(self.step_size * 3,\n                             self.neighbor_factor * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)))\n\n                near_nodes = _near(tree_a, new_pos, radius)\n                min_cost = nearest_node.cost + _distance(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if _is_edge_in_obstacle(near_node.position, new_pos):\n                        continue\n                    cost = near_node.cost + _distance(near_node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = near_node\n\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for cost improvement\n                _rewire(tree_a, new_node, radius)\n\n                # Attempt to connect new_node to other tree\n                nearest_other = _nearest(tree_b, new_node.position)\n                dist_connect = _distance(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and not _is_edge_in_obstacle(new_node.position, nearest_other.position):\n                    candidate_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_path = _extract_path(new_node, nearest_other)\n\n            # Early stop if sufficiently good path found (after minimum iterations)\n            if success_state and iter_count > self.max_iter // 10:\n                break\n\n        # If a path was found, perform local shortcut smoothing to improve smoothness & length\n        if success_state and best_path:\n            path = best_path\n            for _ in range(self.smooth_iter):\n                path = _local_shortcut(path)\n            extracted_path = path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree + nodes,\n            edges=edges\n        )",
          "objective": 272.55385,
          "time_improvement": -939.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.21923460960388183,
                    "num_nodes_avg": 1175.8,
                    "path_length_avg": 157.15636338715737,
                    "smoothness_avg": 0.04699571723321052,
                    "success_improvement": 0.0,
                    "time_improvement": -2118.1346700309246,
                    "length_improvement": 21.45476008698255,
                    "smoothness_improvement": 351.5708805412327,
                    "objective_score": -629.3915945891747
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08462791442871094,
                    "num_nodes_avg": 1002.0,
                    "path_length_avg": 234.63384451840466,
                    "smoothness_avg": 0.1070944461728982,
                    "success_improvement": 0.0,
                    "time_improvement": -457.67249966221203,
                    "length_improvement": 22.14055237254947,
                    "smoothness_improvement": 1400.2902755212244,
                    "objective_score": -125.87218804654759
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09444963932037354,
                    "num_nodes_avg": 1253.2,
                    "path_length_avg": 121.54117811921726,
                    "smoothness_avg": 0.13078905994266155,
                    "success_improvement": 0.0,
                    "time_improvement": -240.10202618649225,
                    "length_improvement": 25.366394871045777,
                    "smoothness_improvement": 911.9144194521435,
                    "objective_score": -62.3977567844778
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a hybrid informed bidirectional RRT* with adaptive sampling and path smoothing. It grows two trees from start and goal while focusing sampling in an informed ellipsoidal region to bias exploration towards the optimal path region. It adaptively adjusts step sizes for efficient expansion and performs local shortcut smoothing on the found path to improve path quality and smoothness.",
          "planning_mechanism": "The planner alternately expands two trees towards samples drawn mostly within an ellipsoidal informed set computed from the current best solution cost. Each extension attempts rewiring for path cost improvement. Once the trees connect, the path is extracted and locally smoothed via shortcutting to reduce unnecessary waypoints and ensure collision-free shortcuts, resulting in better path quality and faster convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0, smooth_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        def informed_sample(c_best):\n            # If no solution yet, sample whole space uniformly\n            if c_best == float('inf'):\n                while True:\n                    point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(point, obstacles, is_3d):\n                        return point\n\n            # Informed sampling in ellipsoid around start & goal\n            c_min = math.dist(start_position, goal_position)\n            if c_best < c_min:\n                c_min = c_best  # numerical safeguard\n\n            # Ellipsoid center\n            center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n            # Unit vector from start to goal\n            direction = tuple((g - s) / c_min for s, g in zip(start_position, goal_position))\n\n            # Create orthonormal basis via Gram-Schmidt\n            def ortho_basis(vec):\n                basis = [vec]\n                for _ in range(dim - 1):\n                    v = [random.gauss(0,1) for __ in range(dim)]\n                    # Subtract projections\n                    for b in basis:\n                        proj = sum(v[d]*b[d] for d in range(dim))\n                        v = [v[d] - proj*b[d] for d in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in v))\n                    if norm > 1e-6:\n                        basis.append(tuple(x/norm for x in v))\n                return basis\n\n            basis = ortho_basis(direction)\n            # Radii of the ellipsoid\n            r1 = c_best / 2.0\n            r_others = math.sqrt(c_best*c_best - c_min*c_min)/2.0 if c_best > c_min else 0.0\n            radii = [r1] + [r_others]*(dim-1)\n\n            while True:\n                # sample uniformly in unit n-ball\n                while True:\n                    sample = [random.gauss(0,1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in sample))\n                    if norm <= 1.0 and norm > 1e-6:\n                        sample = [x / norm for x in sample]\n                        break\n                # scale with radii and random radius^(1/dim)\n                u = random.uniform(0,1) ** (1.0/dim)\n                sample = [radii[i]*u*sample[i] for i in range(dim)]\n\n                # rotate and translate to ellipsoid space\n                new_point = [center[d] for d in range(dim)]\n                for i in range(dim):\n                    for d in range(dim):\n                        new_point[d] += basis[i][d]*sample[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n                if not self._is_in_obstacle(new_point, obstacles, is_3d):\n                    return new_point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if self._distance(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos, max_step):\n            dist = self._distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_a)) + path_b\n\n        def reconstruct_path(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def local_shortcut(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                dist = self._distance(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    # Connect new edge\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            c_best = best_cost\n            sample = informed_sample(c_best)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree_a, new_pos, self.radius)\n                min_cost = nearest_node.cost + self._distance(nearest_node.position, new_pos)\n                min_parent = nearest_node\n\n                for near_node in near_nodes:\n                    cost = near_node.cost + self._distance(near_node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near_node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nearby nodes for optimality\n                rewire(tree_a, new_node)\n\n                # Try connecting to other tree\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = self._distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    candidate_cost = new_node.cost + dist_connect + connect_node.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_path = extract_path(new_node, connect_node)\n\n            # Early break if solution found with good cost\n            if success_state and iter_count > self.max_iter // 10:\n                break\n\n        if success_state and best_path:\n            # Path smoothing via local shortcutting\n            path = best_path\n            for _ in range(self.smooth_iter):\n                path = local_shortcut(path)\n            extracted_path = path\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=start_tree + goal_tree + nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 293.42562,
          "time_improvement": -1007.0,
          "length_improvement": 26.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.22914626598358154,
                    "num_nodes_avg": 1232.2,
                    "path_length_avg": 151.05556807923077,
                    "smoothness_avg": 0.04946771756942938,
                    "success_improvement": 0.0,
                    "time_improvement": -2218.4171422782074,
                    "length_improvement": 24.503878944109687,
                    "smoothness_improvement": 375.3237549358324,
                    "objective_score": -658.747748119961
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09055137634277344,
                    "num_nodes_avg": 1009.0,
                    "path_length_avg": 225.45937519639352,
                    "smoothness_avg": 0.08516524523696775,
                    "success_improvement": 0.0,
                    "time_improvement": -496.7063318742989,
                    "length_improvement": 25.184951679703754,
                    "smoothness_improvement": 1093.0832438791554,
                    "objective_score": -138.50949300695316
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11305840015411377,
                    "num_nodes_avg": 1205.2,
                    "path_length_avg": 115.90098836757991,
                    "smoothness_avg": 0.09945529687228734,
                    "success_improvement": 0.0,
                    "time_improvement": -307.1099820655753,
                    "length_improvement": 28.82981114929822,
                    "smoothness_improvement": 669.4852233060038,
                    "objective_score": -83.01960627328293
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a simplified and generalized RRT* variant designed to efficiently find smooth and collision-free paths in both 2D and 3D environments. It uses fixed step sizes, goal biasing for faster convergence, adaptive neighbor radius for rewiring, and rigorous collision checks to maintain robustness and path quality. The rewiring step helps reduce path length and improve smoothness while ensuring no invalid nodes or edges are added.",
          "planning_mechanism": "The planner incrementally samples points within map bounds with a fixed probability of sampling the goal. For each sample, it finds the nearest tree node and steers toward it by a fixed step size. It accepts new nodes only if they and the connecting edges are collision-free and within bounds. Neighboring nodes within a dynamically adjusted radius are considered to choose the parent with the minimum cost and to rewire for path improvement. The process continues until the goal is connected or max iterations are reached, finally extracting and returning the optimized path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children: List[Node] = []\n        self.valid = True               # For collision or other validation\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n\n            # Adaptive neighbor radius: shrink over iterations for faster convergence & refinement\n            neighbor_radius = max(self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.5), self.step_size * 1.5)\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node in tree to sample\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + direction[d] / dist * scale for d in range(len(bounds)))\n\n            # Check bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision check for node position and edge from nearest\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within radius for rewiring and parent selection\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= neighbor_radius]\n\n            # Choose best parent minimizing cost and with collision-free connection\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if reduces cost and edge is collision free\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect goal if within step size and collision free\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            node = nodes[-1]\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 294.68541,
          "time_improvement": -999.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.10493555068969726,
                    "num_nodes_avg": 278.6,
                    "path_length_avg": 162.4528117599165,
                    "smoothness_avg": 0.020614816246580923,
                    "success_improvement": 0.0,
                    "time_improvement": -961.6990790102133,
                    "length_improvement": 18.807646097074123,
                    "smoothness_improvement": 98.08295888898189,
                    "objective_score": -284.25777968920426
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2624242305755615,
                    "num_nodes_avg": 909.4,
                    "path_length_avg": 234.3150377697144,
                    "smoothness_avg": 0.01053129730459921,
                    "success_improvement": 0.0,
                    "time_improvement": -1629.2967412104435,
                    "length_improvement": 22.24634323747723,
                    "smoothness_improvement": 47.533354896899375,
                    "objective_score": -484.10208694115306
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1408143997192383,
                    "num_nodes_avg": 493.3,
                    "path_length_avg": 115.77530303340964,
                    "smoothness_avg": 0.02944454172251948,
                    "success_improvement": 0.0,
                    "time_improvement": -407.05606718412366,
                    "length_improvement": 28.90698951589068,
                    "smoothness_improvement": 127.8122983393269,
                    "objective_score": -115.69636076036232
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced RRT* variant utilizing adaptive neighbor radius and goal biasing along with efficient rewiring for path optimization. It incorporates stricter collision checks, adaptive step sizes based on environment scale, and path shortcut smoothing to improve success rate, planning efficiency, and path quality in 2D and 3D spaces.",
          "planning_mechanism": "The planner incrementally samples within map bounds with increased goal sampling rate for faster convergence. It chooses the best parent among neighbors within a dynamically shrinking radius, adds new collision-free nodes and edges, and rewires neighbors to improve paths. After goal connection, it applies shortcut smoothing to reduce path length and improve smoothness before returning the optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.25, base_neighbor_radius: float = 25.0, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                      # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: list[tuple] = []\n        nodes: list[Node] = []\n        edges: list[tuple] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for iter_count in range(1, self.max_iter + 1):\n\n            # Adaptive neighbor radius shrinks over iterations for refinement; min radius at least step_size*1.5\n            neighbor_radius = max(self.base_neighbor_radius * (1.0 - (iter_count / self.max_iter) ** 0.6), self.step_size * 1.5)\n\n            # Goal biased sampling for faster convergence\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node to the sampled point\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            vec = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            scale = min(self.step_size, dist)\n            new_pos = tuple(nearest_node.position[d] + vec[d] / dist * scale for d in range(len(bounds)))\n\n            # Check map bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision check for new node and edge from nearest_node\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            # Find neighbors within radius for choosing best parent and rewiring\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= neighbor_radius]\n\n            # Choose best parent minimizing cost + collision free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                tentative_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                        min_cost = tentative_cost\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if it improves cost and edge collision free\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if within step size to goal -> attempt to connect goal directly\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d, resolution=0.5)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path from root to goal_node\n                    extracted_path = goal_node.path_from_root()\n                    # Apply shortcut smoothing to improve path quality\n                    extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d)\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_smooth(self, path: list[tuple], obstacles, is_3d) -> list[tuple]:\n        if len(path) <= 2:\n            return path\n        for _ in range(self.smoothing_iterations):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 2)\n            j = random.randint(i + 1, len(path) - 1)\n            if j == i + 1:\n                continue\n            p1, p2 = path[i], path[j]\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 336.17542,
          "time_improvement": -1089.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.09235446453094483,
                    "num_nodes_avg": 290.1,
                    "path_length_avg": 159.81901204229115,
                    "smoothness_avg": 0.037590065664500086,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -834.4083038639114,
                    "length_improvement": 20.12399388118572,
                    "smoothness_improvement": 261.1941694066883,
                    "objective_score": -294.9917215359028
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2949181795120239,
                    "num_nodes_avg": 1182.0,
                    "path_length_avg": 222.56755575730185,
                    "smoothness_avg": 0.047154646119450146,
                    "success_improvement": 0.0,
                    "time_improvement": -1843.422090388912,
                    "length_improvement": 26.14455520420016,
                    "smoothness_improvement": 560.5912775760627,
                    "objective_score": -544.9947596879533
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.19163918495178223,
                    "num_nodes_avg": 759.9,
                    "path_length_avg": 114.08652126478816,
                    "smoothness_avg": 0.07735457180805323,
                    "success_improvement": 0.0,
                    "time_improvement": -590.0701322717482,
                    "length_improvement": 29.944003255749635,
                    "smoothness_improvement": 498.49200428103046,
                    "objective_score": -168.5397790089694
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 349.28087629035116,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04928519725799561,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "smoothness_avg": 0.014115946270353475,
                    "success_improvement": 0.0,
                    "time_improvement": -398.649391876571,
                    "length_improvement": 21.16112596316623,
                    "smoothness_improvement": 35.636833785179014,
                    "objective_score": -115.18440820141214
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.42683241367340086,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "smoothness_avg": 0.011462143624438778,
                    "success_improvement": 0.0,
                    "time_improvement": -2712.6972131709017,
                    "length_improvement": 25.195979140247676,
                    "smoothness_improvement": 60.57361731541344,
                    "objective_score": -808.467100036644
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1480414628982544,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "smoothness_avg": 0.020633789931938304,
                    "success_improvement": 0.0,
                    "time_improvement": -433.07987043258106,
                    "length_improvement": 27.173113785558407,
                    "smoothness_improvement": 59.64354793304998,
                    "objective_score": -124.19112063299738
               }
          ]
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates the strengths of both informed bidirectional RRT* with dynamic neighbor rewiring and adaptive step sizing, and enhanced bidirectional RRT with adaptive sampling and spline-based smoothing. It adaptively samples within an informed ellipsoid and around the current best path, dynamically adjusts step sizes based on local obstacle density, uses dual-tree growth with rewiring for path optimality, and applies aggressive smoothing via shortcutting and cubic spline interpolation to produce efficient, smooth, and short collision-free paths.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling primarily inside an informed ellipsoid based on the current best solution cost and occasionally near the best path for focused exploration. Each extension step dynamically adjusts its step size according to local obstacle density to safely navigate cluttered areas. The planner selects parents among neighbors optimizing cost and rewires nearby nodes to improve connectivity. Upon connection of both trees, it reconstructs the path and applies multiple rounds of local shortcut smoothing and cubic spline interpolation to refine path smoothness while ensuring safety through strict collision checks on nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0,\n                 neighbor_factor: float = 25.0,\n                 shortcut_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor  # Radius scaling for rewiring\n        self.shortcut_trials = shortcut_trials  # Shortcut smoothing attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n        best_connect = None\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            dist = _distance(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def _steer(from_p, to_p, max_step):\n            dist = _distance(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: _distance(n.position, point))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _path_cost(path):\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += _distance(path[i], path[i+1])\n            return total\n\n        def _extract_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _informed_ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle(pt):\n                        return pt\n\n            c_min = _distance(start_pos, goal_pos)\n            if c_best < c_min:\n                c_min = c_best  # safeguard\n\n            center = tuple((s + g) / 2 for s, g in zip(start_pos, goal_pos))\n            direction = tuple((g - s) / c_min for s, g in zip(start_pos, goal_pos))\n\n            basis = [direction]\n            for _ in range(dim - 1):\n                vec = [random.gauss(0, 1) for __ in range(dim)]\n                for b in basis:\n                    proj = sum(vec[d] * b[d] for d in range(dim))\n                    vec = [vec[d] - proj * b[d] for d in range(dim)]\n                norm = math.sqrt(sum(x * x for x in vec))\n                if norm > 1e-9:\n                    basis.append(tuple(x / norm for x in vec))\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n            radii = [r1] + [r_other] * (dim - 1)\n\n            while True:\n                while True:\n                    sample = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in sample))\n                    if 1e-9 < norm <= 1.0:\n                        sample = [x / norm for x in sample]\n                        break\n                u = random.uniform(0, 1) ** (1.0/dim)\n                sample_scaled = [radii[i] * u * sample[i] for i in range(dim)]\n\n                new_point = [center[d] for d in range(dim)]\n                for i in range(dim):\n                    for d in range(dim):\n                        new_point[d] += basis[i][d] * sample_scaled[i]\n                new_point = tuple(max(0.0, min(bounds[d], new_point[d])) for d in range(dim))\n\n                if not _is_in_obstacle(new_point):\n                    return new_point\n\n        def _sample_near_path(best_path):\n            if not best_path or len(best_path) < 2:\n                return None\n            idx = random.randint(0, len(best_path) - 2)\n            p1, p2 = best_path[idx], best_path[idx + 1]\n            alpha = random.uniform(0, 1)\n            candidate = tuple(p1[d] + alpha*(p2[d] - p1[d]) for d in range(dim))\n            if not _is_in_obstacle(candidate):\n                return candidate\n            return None\n\n        def _dynamic_step_size(pos):\n            check_range = self.step_size * 2\n            cnt = 0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    cx, cy, cz = x + w/2, y + h/2, z + d/2\n                    dist_to_obs = _distance(pos, (cx, cy, cz))\n                    if dist_to_obs < check_range + max(w, h, d)/2:\n                        cnt += 1\n                else:\n                    x, y, w_, h_ = obs\n                    cx, cy = x + w_/2, y + h_/2\n                    dist_to_obs = _distance(pos, (cx, cy))\n                    if dist_to_obs < check_range + max(w_, h_)/2:\n                        cnt += 1\n            if cnt == 0:\n                return self.step_size\n            else:\n                return max(self.step_size / (1 + cnt), self.step_size * 0.25)\n\n        def _rewire(tree, new_node, radius):\n            near_nodes = _near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + _distance(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not _is_edge_in_obstacle(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, new_cost)\n                        edges.append((new_node, near_node))\n\n        def _local_shortcut(path):\n            if len(path) < 3:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not _is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def _shortcut_smooth(path, trials):\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                if not _is_edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def _cubic_spline_smooth(path):\n            try:\n                import numpy as np\n                from scipy.interpolate import CubicSpline\n            except ImportError:\n                return path\n            if len(path) < 4:\n                return path\n            dims = len(path[0])\n            path_np = np.array(path)\n            dist_arr = np.zeros(len(path))\n            dist_arr[1:] = np.cumsum(np.linalg.norm(np.diff(path_np, axis=0), axis=1))\n            cs_funcs = [CubicSpline(dist_arr, path_np[:, d]) for d in range(dims)]\n            resolution = max(dist_arr[-1] / (len(path) * 5), 0.01)\n            smoothed_path = []\n            ts = np.arange(0, dist_arr[-1] + resolution, resolution)\n            for t in ts:\n                pt = tuple(cs(t) for cs in cs_funcs)\n                if (not _is_within_bounds(pt) or _is_in_obstacle(pt) or\n                    (len(smoothed_path) > 0 and _is_edge_in_obstacle(smoothed_path[-1], pt))):\n                    return path\n                smoothed_path.append(pt)\n            return smoothed_path if smoothed_path else path\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n\n            # Sampling with mixed strategies\n            sample = None\n            prob = random.random()\n            if prob < 0.1 and best_path:\n                sample = _sample_near_path(best_path)\n            if sample is None:\n                sample = _informed_ellipsoid_sample(best_cost)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = _nearest(tree_a, sample)\n                dynamic_step = _dynamic_step_size(nearest_node.position)\n                new_pos = _steer(nearest_node.position, sample, dynamic_step)\n\n                if (not _is_within_bounds(new_pos) or\n                    _is_in_obstacle(new_pos) or\n                    _is_edge_in_obstacle(nearest_node.position, new_pos)):\n                    continue\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree_a)\n                radius = min(dynamic_step * 3,\n                             self.neighbor_factor * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)))\n\n                near_nodes = _near(tree_a, new_pos, radius)\n                min_cost = nearest_node.cost + _distance(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if _is_edge_in_obstacle(near_node.position, new_pos):\n                        continue\n                    cost = near_node.cost + _distance(near_node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = near_node\n\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                _rewire(tree_a, new_node, radius)\n\n                nearest_other = _nearest(tree_b, new_node.position)\n                dist_conn = _distance(new_node.position, nearest_other.position)\n                if dist_conn <= dynamic_step and not _is_edge_in_obstacle(new_node.position, nearest_other.position):\n                    candidate_cost = new_node.cost + dist_conn + nearest_other.cost\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        success_state = True\n                        best_connect = new_node\n                        best_path = _extract_path(new_node, nearest_other)\n\n            if success_state and iter_count > self.max_iter // 15:\n                break\n\n        if success_state and best_path:\n            path = best_path\n            for _ in range(5):  # multiple shortcut smoothing passes\n                path = _shortcut_smooth(path, self.shortcut_trials)\n            path = _cubic_spline_smooth(path)\n            extracted_path = path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 374.10064,
          "time_improvement": -1219.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.12344834804534913,
                    "num_nodes_avg": 473.3,
                    "path_length_avg": 158.6134230158977,
                    "smoothness_avg": 0.044058863591475525,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -1149.004713499327,
                    "length_improvement": 20.726535689062096,
                    "smoothness_improvement": 323.35133920647866,
                    "objective_score": -388.93935021595325
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.25077497959136963,
                    "num_nodes_avg": 1077.8,
                    "path_length_avg": 233.77348081209502,
                    "smoothness_avg": 0.10015584105794609,
                    "success_improvement": 0.0,
                    "time_improvement": -1552.5316813669886,
                    "length_improvement": 22.42605015770263,
                    "smoothness_improvement": 1303.087085704656,
                    "objective_score": -454.75885895003273
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2932645082473755,
                    "num_nodes_avg": 1099.2,
                    "path_length_avg": 131.32967945221947,
                    "smoothness_avg": 0.12481426927881571,
                    "success_improvement": 0.0,
                    "time_improvement": -956.0109512456658,
                    "length_improvement": 19.355665383341243,
                    "smoothness_improvement": 865.6874886323623,
                    "objective_score": -278.6037148538697
               }
          ],
          "success_rate": 0.9666666666666667
     }
]