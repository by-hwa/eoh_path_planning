[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.47449114023227,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012044763565063477,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": -21.86446156592386,
                    "length_improvement": 12.401486536989607,
                    "smoothness_improvement": 60.71897053377777,
                    "objective_score": -3.7754463097103477
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017744064331054688,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": -16.928046454483464,
                    "length_improvement": 14.190408824541839,
                    "smoothness_improvement": 52.81399740357816,
                    "objective_score": -1.9762621844187802
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009687995910644532,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.11466785256512,
                    "length_improvement": 11.655572158065754,
                    "smoothness_improvement": 61.933425488650386,
                    "objective_score": 22.175181914825938
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -1.486610468143649,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008508419990539551,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 13.914954384712244,
                    "length_improvement": 5.9265718433081265,
                    "smoothness_improvement": 7.497776338222911,
                    "objective_score": 5.397289565766413
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017635869979858398,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": -16.21507822540353,
                    "length_improvement": 0.3867603104208941,
                    "smoothness_improvement": 0.5583282013809732,
                    "objective_score": -4.784379764529976
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024777650833129883,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 10.77859785250502,
                    "length_improvement": 2.8534839845313615,
                    "smoothness_improvement": 8.529090107346295,
                    "objective_score": 3.84692160319451
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm combines bidirectional growth of two trees with asymptotic optimality via rewiring, incorporating goal biasing and adaptive neighborhood sampling to efficiently find smooth, short, and collision-free paths in 2D or 3D environments containing obstacles. It balances exploration and exploitation to improve success rate, path quality, and planning speed.",
          "planning_mechanism": "The planner grows two trees\u2014one from start and one from goal\u2014by sampling free space with a bias towards the goal. Each extension considers a neighborhood for rewiring to optimize costs. After each new node insertion, the planner attempts to connect the two trees with collision-checked edges, extracting the best path upon success. Adaptive radius and collision checks ensure robustness and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision and validity checks\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        success = False\n        path: list[tuple] = []\n\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            while node_start:\n                path_s.append(node_start.position)\n                node_start = node_start.parent\n            while node_goal:\n                path_g.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_s[::-1] + path_g\n\n        def adaptive_radius(n_nodes):\n            # Radius adaptively shrinks with number of nodes, capped by base_radius\n            gamma = self.base_radius\n            return min(gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        for i in range(self.max_iter):\n            # Goal biasing sampling alternating between trees\n            sample_from_start = (i % 2 == 0)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    # Rewire\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt connection from new_node in tree_a to nearest in tree_b\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d):\n                    # Connect both trees with minimal cost\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # No connection found\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1.22143,
          "time_improvement": -7.0,
          "length_improvement": 4.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008090043067932129,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 185.6649117391287,
                    "smoothness_avg": 0.010914094873855713,
                    "success_improvement": 0.0,
                    "time_improvement": 18.14793730129248,
                    "length_improvement": 7.2064616304885325,
                    "smoothness_improvement": 4.870990861583404,
                    "objective_score": 6.9100284707933675
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014984416961669921,
                    "num_nodes_avg": 248.6,
                    "path_length_avg": 303.9601784431043,
                    "smoothness_avg": 0.006630449936174837,
                    "success_improvement": 0.0,
                    "time_improvement": 1.2571995965398015,
                    "length_improvement": -0.8642706379259195,
                    "smoothness_improvement": -7.113768107885172,
                    "objective_score": 0.16873691083733064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.038583230972290036,
                    "num_nodes_avg": 419.1,
                    "path_length_avg": 155.2327737852811,
                    "smoothness_avg": 0.01296368234295665,
                    "success_improvement": 0.0,
                    "time_improvement": -38.93367010102172,
                    "length_improvement": 4.6777255162124165,
                    "smoothness_improvement": 0.2999570284091653,
                    "objective_score": -10.743056141921985
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT planner optimized for enhanced efficiency, path quality, and robustness. It alternates growth of two trees from start and goal, samples points with goal bias, and ensures strict collision checking for newly added nodes and connecting edges. Upon connection, it reconstructs the path and applies shortcut smoothing to reduce unnecessary detours and improve smoothness. The design balances exploration depth and computational effort for improved success rates and faster convergence.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal by sampling free configurations biased toward the goal. It extends each tree by steering towards sampled points within step size, validating new nodes and edges via collision-free checks. When the two trees connect, the planner reconstructs the full path and performs iterative shortcut smoothing to optimize path quality before returning the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 3.0, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                         \n        start_position = map.start                 \n        goal_position = map.goal                   \n        obstacles = map.obstacles                  \n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, target_node):\n            current = _nearest(tree, target_node.position)\n            while True:\n                next_pos = _steer(current.position, target_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, target_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(40):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if not new_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.98769,
          "time_improvement": -24.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01088719367980957,
                    "num_nodes_avg": 134.1,
                    "path_length_avg": 175.03233523134534,
                    "smoothness_avg": 0.013335379012390985,
                    "success_improvement": 0.0,
                    "time_improvement": -10.152597731537979,
                    "length_improvement": 12.52052117410358,
                    "smoothness_improvement": 28.136545147160557,
                    "objective_score": -0.4009923589048745
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023423933982849122,
                    "num_nodes_avg": 412.5,
                    "path_length_avg": 250.35117199926208,
                    "smoothness_avg": 0.021827263057035733,
                    "success_improvement": 0.0,
                    "time_improvement": -54.356678931773125,
                    "length_improvement": 16.925011373547015,
                    "smoothness_improvement": 205.77897991876952,
                    "objective_score": -11.893106505228687
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029634523391723632,
                    "num_nodes_avg": 463.6,
                    "path_length_avg": 126.67064640606554,
                    "smoothness_avg": 0.03621107325015106,
                    "success_improvement": 0.0,
                    "time_improvement": -6.710428151123073,
                    "length_improvement": 22.216592338552495,
                    "smoothness_improvement": 180.16492496948817,
                    "objective_score": 3.3310146472210187
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planning algorithm combines bidirectional search from the dual-tree RRT with asymptotically optimal rewiring from RRT*. It grows two trees from start and goal, alternately extending towards random samples and attempting connections. Each extension uses rewiring within a neighborhood radius to optimize paths locally. The goal biasing accelerates convergence. Collision and edge checks ensure validity. The hybrid approach improves planning efficiency, path quality, robustness, success rate, and smoothness by leveraging complementary strengths of both methods.",
          "planning_mechanism": "The planner maintains start and goal trees, grows them bidirectionally by sampling points and steering towards them. For each new node added, it finds neighbors within a radius to rewire and minimize cost. After each extension, it attempts to connect the two trees directly. If a connection is found without collision, the path is extracted. Goal biasing increases attempts towards the goal to speed up convergence. The algorithm terminates early upon a successful path or after max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, search_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-assign parent\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            # Try building connection backward from connect_node towards node_a\n            curr = connect_node\n            connection_chain = []\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                connection_chain.append(new_node)\n                if distance(new_pos, node_a.position) < self.step_size:\n                    # Final connect node\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_from_start, node_from_goal):\n            path_start = []\n            node = node_from_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_from_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree selection for expanding\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing on sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                # Boundary check\n                out_of_bounds = any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds)))\n                if out_of_bounds:\n                    continue\n\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Find neighbors for rewiring\n                neighbors = find_near(tree_a, new_node, self.search_radius)\n                # Choose best parent\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = cost\n                            min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors through new_node if better\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt to connect the other tree directly\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.2445,
          "time_improvement": -28.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013188529014587402,
                    "num_nodes_avg": 194.0,
                    "path_length_avg": 173.0342779839435,
                    "smoothness_avg": 0.021996203295678553,
                    "success_improvement": 0.0,
                    "time_improvement": -33.436657226802765,
                    "length_improvement": 13.519130982034183,
                    "smoothness_improvement": 111.35638469997163,
                    "objective_score": -6.770389048134134
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024630069732666016,
                    "num_nodes_avg": 484.0,
                    "path_length_avg": 244.14905520536445,
                    "smoothness_avg": 0.015383195714505082,
                    "success_improvement": 0.0,
                    "time_improvement": -62.30475071249689,
                    "length_improvement": 18.9830835527118,
                    "smoothness_improvement": 115.50378905411706,
                    "objective_score": -14.317289557936123
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024231910705566406,
                    "num_nodes_avg": 405.4,
                    "path_length_avg": 130.81419641767454,
                    "smoothness_avg": 0.028347178181784644,
                    "success_improvement": 0.0,
                    "time_improvement": 12.743743770384414,
                    "length_improvement": 19.672203019772287,
                    "smoothness_improvement": 119.32200113298974,
                    "objective_score": 8.354173740734732
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner with optimized parameters to improve efficiency, path quality, and success rate. It features reduced step size for finer expansions, increased maximum iterations for deeper search, and a goal bias sampling probability to accelerate convergence. Collision checking is precise with a refined resolution, and post-planning path smoothing via shortcutting reduces unnecessary detours and improves smoothness.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions, alternately expanding each towards sampled points biased towards the goal. Each new node and edge is strictly checked for collision-free feasibility. When the trees connect, the planner reconstructs the path, smooths it by iteratively shortcutting, and returns the optimized trajectory along with explored graph data.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.6782,
          "time_improvement": -33.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010827350616455077,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 163.9683475002103,
                    "smoothness_avg": 0.014173695614508616,
                    "success_improvement": 0.0,
                    "time_improvement": -9.547127756576938,
                    "length_improvement": 18.050195900642194,
                    "smoothness_improvement": 36.19173375747664,
                    "objective_score": 0.9268595219427409
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03178107738494873,
                    "num_nodes_avg": 498.6,
                    "path_length_avg": 249.62854531281232,
                    "smoothness_avg": 0.0401662199932736,
                    "success_improvement": 0.0,
                    "time_improvement": -109.42774008867326,
                    "length_improvement": 17.164803355659895,
                    "smoothness_improvement": 462.6901432691145,
                    "objective_score": -27.081910639124423
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02228260040283203,
                    "num_nodes_avg": 378.2,
                    "path_length_avg": 125.71203140928696,
                    "smoothness_avg": 0.05507350730124254,
                    "success_improvement": 0.0,
                    "time_improvement": 19.762980565745675,
                    "length_improvement": 22.805239694513528,
                    "smoothness_improvement": 326.10349972973546,
                    "objective_score": 12.120459607275086
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements an enhanced Bidirectional Informed RRT* planner that combines bidirectional search with heuristic-informed sampling within an ellipsoidal subset of the space defined by the current best path cost to the goal. The planner alternately grows trees from the start and goal positions, selectively sampling points that are likely to improve the current solution, while performing rewiring in a local neighborhood to optimize path cost. Once a feasible path is found, we apply a path smoothing step using iterative shortcutting. This approach focuses search efforts, improves path quality and smoothness, increases success rates, and reduces planning time by avoiding unnecessary exploration outside promising regions.",
          "planning_mechanism": "The planner begins by initializing two trees, one from the start and one from the goal. It maintains the best path cost found so far and limits random sampling to an informed ellipsoidal region determined by this cost, progressively guiding the search towards optimality. Each iteration samples a node, extends the trees towards the sample with step limits and collision checks, and rewires nearby nodes to improve costs. When the two trees connect, the path is extracted and smoothed by attempting shortcuts that skip unnecessary waypoints, balancing efficiency with path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, radius: float=15.0, smooth_iter: int=40, collision_resolution: float=0.5, informed_sampling_rate: float=0.9):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_path_cost = math.inf\n        best_connect_nodes = None\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            # ensure edge is within bounds and free of obstacles\n            if not within_bounds(b):\n                return False\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution):\n                return False\n            return True\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def rewire(tree, new_node):\n            for near_node in near(tree, new_node.position, self.radius):\n                if near_node == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if tentative_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    # Remove old edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    # Re-parent\n                    near_node.parent = new_node\n                    near_node.cost = tentative_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        def informed_sample(c_max, start, goal):\n            # If no solution yet, sample uniformly\n            if math.isinf(c_max):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Define ellipsoid parameters\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                # Safety fallback\n                c_max = c_min + 1e-6\n\n            # Center of ellipse - midpoint\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n\n            # Unit vector from start to goal\n            if c_min == 0.0:\n                unit_vec = tuple(0 for _ in range(dim))\n            else:\n                unit_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            # Create rotation matrix that aligns the x-axis with unit_vec\n            # For 2D and 3D, implement accordingly:\n            import numpy as np\n\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s], [s, c]])\n                elif dim == 3:\n                    # Create orthonormal basis using unit_vec as x-axis\n                    x_axis = np.array(vec)\n                    x_axis /= np.linalg.norm(x_axis)\n                    # Pick y_axis arbitrarily perpendicular to x_axis\n                    if abs(x_axis[0]) < 1e-6 and abs(x_axis[1]) < 1e-6:\n                        temp = np.array([0,1,0])\n                    else:\n                        temp = np.array([0,0,1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= np.linalg.norm(y_axis)\n                    z_axis = np.cross(x_axis, y_axis)\n                    rot = np.stack((x_axis, y_axis, z_axis), axis=1)\n                    return rot\n                else:\n                    return np.eye(dim)\n\n            L = np.diag([c_max / 2] + [math.sqrt(c_max ** 2 - c_min ** 2) / 2] * (dim - 1))\n            R = rotation_matrix(unit_vec)\n\n            while True:\n                # Sample uniformly in unit n-ball\n                x_ball = np.random.normal(0,1,dim)\n                x_ball /= np.linalg.norm(x_ball)\n                u = np.random.uniform(0,1)\n                r = u ** (1/dim)\n                sample_ball = x_ball * r\n\n                # Map to ellipse\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                p = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        for iter in range(self.max_iter):\n            if random.random() < self.informed_sampling_rate:\n                sample = informed_sample(best_path_cost, start_position, goal_position)\n            else:\n                # Uniform sampling fallback\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                # Try to connect trees\n                nearest_to_new = nearest(tree_b, new_node.position)\n                dist_between = dist(new_node.position, nearest_to_new.position)\n                if dist_between <= self.step_size and collision_free_edge(new_node.position, nearest_to_new.position):\n                    # Candidate path found\n                    total_cost = new_node.cost + dist_between + nearest_to_new.cost\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connect_nodes = (new_node, nearest_to_new)\n\n            if best_connect_nodes is not None:\n                success_state = True\n                node_a, node_b = best_connect_nodes\n                extracted_path = extract_path(node_a, node_b)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.19606,
          "time_improvement": -55.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021587777137756347,
                    "num_nodes_avg": 157.9,
                    "path_length_avg": 183.3875957340989,
                    "smoothness_avg": 0.021361840675895825,
                    "success_improvement": 0.0,
                    "time_improvement": -118.41714227820741,
                    "length_improvement": 8.344642281386934,
                    "smoothness_improvement": 105.26094231367485,
                    "objective_score": -33.329909515616464
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023389148712158202,
                    "num_nodes_avg": 258.6,
                    "path_length_avg": 240.93696232439032,
                    "smoothness_avg": 0.0498137605068275,
                    "success_improvement": 0.0,
                    "time_improvement": -54.12745446147175,
                    "length_improvement": 20.048964640557564,
                    "smoothness_improvement": 597.8429147939263,
                    "objective_score": -9.23922883636038
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025303339958190917,
                    "num_nodes_avg": 266.2,
                    "path_length_avg": 128.69703998265706,
                    "smoothness_avg": 0.06774769573343979,
                    "success_improvement": 0.0,
                    "time_improvement": 8.885653232875372,
                    "length_improvement": 20.972264610522455,
                    "smoothness_improvement": 424.1636435599348,
                    "objective_score": 8.980967109766777
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional search strategy from the enhanced bidirectional RRT with the incremental rewiring and local path optimization of RRT*. It grows two trees from start and goal, alternately expanding toward sampled points with goal bias. New nodes choose parents through cost minimization within a neighbor radius, and rewire nearby nodes to reduce path costs. Upon connecting the two trees, the solution path is reconstructed and smoothed via iterative shortcutting to improve path quality and smoothness, balancing exploration, optimality, and efficiency.",
          "planning_mechanism": "The planner alternates growing two trees towards random samples biased to the goal. Each new node chooses the best parent within a neighborhood to minimize cost, rewires neighbors for better paths, and checks collision at nodes and edges. When the two trees connect, the path is extracted and smoothed by shortcutting to yield a high-quality trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start/goal root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=8.0, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # list of obstacle boxes\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        # Helper functions\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _near_nodes(tree, point):\n            return [node for node in tree if math.dist(node.position, point) <= self.neighbor_radius]\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def _can_connect(parent_node, new_pos, tree):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            import math\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        edges.remove((node.parent, node))\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # node_b path from root is from goal to connecting point, reverse it excluding connecting node to avoid duplication\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n\n        # Main loop - alternate between tree expansions\n        for i in range(self.max_iter):\n            # Sample point (goal bias applied inside _sample_free)\n            sample = _sample_free()\n\n            # Extend tree_a towards sample\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample)\n            if not _can_connect(nearest_node_a, new_pos_a, tree_a):\n                tree_a, tree_b = tree_b, tree_a  # swap trees if extension fails\n                continue\n\n            # Determine neighbors and best parent for new node in tree_a\n            near_nodes_a = _near_nodes(tree_a, new_pos_a)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.parent = None\n            new_node_a.cost = 0\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            # Rewire neighbors in tree_a via new_node_a\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            # Try connecting tree_b to new_node_a\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n            if dist <= self.step_size:\n                if (not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(new_node_a.position, obstacles, is_3d)):\n                    # Connected, create connecting node in tree_b if needed\n                    connecting_node_b = None\n                    if nearest_node_b.position != new_node_a.position:\n                        connecting_node_b = Node(new_node_a.position)\n                        connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                        tree_b.append(connecting_node_b)\n                        nodes.append(connecting_node_b)\n                        edges.append((nearest_node_b, connecting_node_b))\n                    else:\n                        connecting_node_b = nearest_node_b\n\n                    # Rewire tree_b neighbors around connecting_node_b\n                    near_nodes_b = _near_nodes(tree_b, connecting_node_b.position)\n                    _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                    # Reconstruct full path from start_root to goal_root\n                    success_state = True\n                    extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                    extracted_path = _smooth_path(extracted_path)\n                    break\n            else:\n                # If not connected yet, try to extend tree_b toward new_node_a\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position)\n                if _can_connect(nearest_node_b, new_pos_b, tree_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.parent = None\n                    new_node_b.cost = 0\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a  # swap trees for next iteration\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 13.19292,
          "time_improvement": -68.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01825902462005615,
                    "num_nodes_avg": 139.7,
                    "path_length_avg": 170.53916823025477,
                    "smoothness_avg": 0.03657085421153936,
                    "success_improvement": 0.0,
                    "time_improvement": -84.73805583832261,
                    "length_improvement": 14.766162855188394,
                    "smoothness_improvement": 251.40080438605742,
                    "objective_score": -21.21118015852882
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03545658588409424,
                    "num_nodes_avg": 388.8,
                    "path_length_avg": 234.62398934310326,
                    "smoothness_avg": 0.07992438153248214,
                    "success_improvement": 0.0,
                    "time_improvement": -133.64823549004393,
                    "length_improvement": 22.143822653129895,
                    "smoothness_improvement": 1019.6637797318008,
                    "objective_score": -30.567387217728196
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02384152412414551,
                    "num_nodes_avg": 283.0,
                    "path_length_avg": 121.90768417505406,
                    "smoothness_avg": 0.08857985352242485,
                    "success_improvement": 0.0,
                    "time_improvement": 14.14947986734191,
                    "length_improvement": 25.14133807406572,
                    "smoothness_improvement": 585.3419627879955,
                    "objective_score": 12.199821388955696
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner is a simplified yet efficient bidirectional RRT* inspired algorithm combining bidirectional tree growth, goal biasing, adaptive sampling, and local rewiring within a dynamically scaled neighborhood radius. It balances exploration and exploitation by sampling near the current best path and the goal, connects trees early when possible, and improves path quality through rewiring and shortcutting.",
          "planning_mechanism": "The algorithm grows two trees alternately from start and goal positions, sampling points with goal bias and informed sampling near the best path found so far. Each new node picks the best parent from nearby nodes within an adaptive radius to minimize cost, then locally rewires neighbors to optimize paths. The trees attempt to connect after each extension. Upon success, the path is extracted and smoothed by shortcutting, providing efficient and high-quality trajectories while guaranteeing collision-free and boundary-adherent paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, min_radius: float = 10.0, max_radius: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            dist = distance(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def adaptive_radius(iter_idx):\n            scale = min(1.0, iter_idx / (self.max_iter / 2))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r)\n\n        def informed_sample():\n            # If no best path, sample uniformly\n            if best_cost == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            import numpy as np\n            dim = len(bounds)\n            start_np = np.array(start_pos)\n            goal_np = np.array(goal_pos)\n            c_min = distance(start_pos, goal_pos)\n            c_best = max(best_cost, c_min + 1e-6)\n            center = (start_np + goal_np) / 2\n            a1 = (goal_np - start_np) / c_min\n\n            while True:\n                # Sample unit ball\n                direction = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction /= norm\n                radius = random.uniform(0, 1) ** (1 / dim)\n                point_ball = radius * direction\n\n                # Create orthonormal basis\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1))\n                sample = U @ L @ point_ball + center\n                sample = np.clip(sample, [0] * dim, bounds)\n                sample_t = tuple(float(v) for v in sample)\n                if not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                    return sample_t\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i + 1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def attempt_connect(node_from, other_tree):\n            nearest_other = find_nearest(other_tree, node_from.position)\n            if self._is_edge_in_obstacle(node_from.position, nearest_other.position, obstacles, is_3d):\n                return None\n\n            curr = nearest_other\n            while True:\n                new_pos = steer(curr.position, node_from.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n\n                if distance(new_pos, node_from.position) < self.step_size * 1.01:\n                    final_node = Node(node_from.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_from.position))\n                    new_node.add_child(final_node)\n                    other_tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iter_idx in range(self.max_iter):\n            # Alternate tree growth order every iteration\n            growing_orders = [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_idx % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            for tree_a, tree_b in growing_orders:\n                # Sampling with goal bias and informed sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    if best_cost < float('inf') and random.random() < 0.6:\n                        sample = informed_sample()\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                radius = adaptive_radius(iter_idx)\n                neighbors = find_near(tree_a, new_node, radius)\n\n                # Select minimal cost parent from neighbors\n                min_cost = tentative_cost\n                min_parent = nearest\n                for n in neighbors:\n                    edge_c = distance(n.position, new_node.position)\n                    c = n.cost + edge_c\n                    if c + 1e-7 < min_cost and not self._is_edge_in_obstacle(n.position, new_node.position, obstacles, is_3d):\n                        min_cost = c\n                        min_parent = n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors)\n\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, connect_node)\n                    else:\n                        path = extract_path(connect_node, new_node)\n\n                    path_cost = 0.0\n                    for i in range(len(path) - 1):\n                        path_cost += distance(path[i], path[i + 1])\n\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = path\n\n                    extracted_path = shortcut_path(best_path)\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 21.2552,
          "time_improvement": -99.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023629164695739745,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 168.44793223574646,
                    "smoothness_avg": 0.04471091512583583,
                    "success_improvement": 0.0,
                    "time_improvement": -139.07114634040437,
                    "length_improvement": 15.811342505335576,
                    "smoothness_improvement": 329.61675024528,
                    "objective_score": -36.91099164982779
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031334757804870605,
                    "num_nodes_avg": 226.0,
                    "path_length_avg": 231.10272343163825,
                    "smoothness_avg": 0.08920429874467865,
                    "success_improvement": 0.0,
                    "time_improvement": -106.48662831071465,
                    "length_improvement": 23.312297812281674,
                    "smoothness_improvement": 1149.6665020823436,
                    "objective_score": -21.53519642034634
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041659760475158694,
                    "num_nodes_avg": 289.0,
                    "path_length_avg": 117.51014688918721,
                    "smoothness_avg": 0.11931802799898128,
                    "success_improvement": 0.0,
                    "time_improvement": -50.01189046350488,
                    "length_improvement": 27.84169087969108,
                    "smoothness_improvement": 823.1630924306397,
                    "objective_score": -5.319413500960049
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm integrates the adaptive bidirectional anytime RRT*-like planner with heuristic-informed ellipsoid sampling, dynamic tree pruning, local dense resampling, and progressive shortcut smoothing, together with the direct connection attempts, adaptive neighborhood rewiring, and balanced tree growth from classic bidirectional RRT*. It combines exploration and exploitation phases, dynamically focuses sampling around promising areas, prunes non-useful nodes, and performs local rewiring with an adaptive radius to efficiently produce high-quality, smooth paths with improved success rate and reduced search time, suitable for both 2D and 3D environments.",
          "planning_mechanism": "The planner alternates extending two trees from start and goal, performing adaptive sampling among uniform random, informed ellipsoid around the current best path, and dense local resampling on high-cost branches. Each new node is collision-checked and rewired locally with an adaptive radius scaled by iteration and rewire factor for path improvement. The trees attempt direct incremental connections after each extension with collision checks. Dynamic pruning removes unpromising leaf nodes. Progressive shortcut smoothing is applied whenever a better path is found. Early termination occurs on finding near-optimal solutions or after a set number of iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 min_radius: float=6.0, max_radius: float=20.0, rewire_factor: float=1.5,\n                 pruning_threshold_factor: float=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.rewire_factor = rewire_factor\n        self.pruning_threshold_factor = pruning_threshold_factor\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, new_node, radius):\n            radius_sq = radius * radius\n            px = new_node.position\n            return [node for node in tree if sum((px[d]-node.position[d])**2 for d in range(dim)) <= radius_sq]\n\n        def adaptive_radius(iteration):\n            scale = min(1.0, iteration / (self.max_iter * 0.75))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r) * self.rewire_factor\n\n        def informed_sample(c_best):\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min + 1e-7\n            center = (np.array(start_pos) + np.array(goal_pos)) * 0.5\n            a1 = (np.array(goal_pos) - np.array(start_pos)) / c_min\n\n            while True:\n                sample_dir = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(sample_dir)\n                if norm_dir == 0:\n                    continue\n                unit_dir = sample_dir / norm_dir\n                radius = random.uniform(0, 1) ** (1 / dim)\n                unit_ball_sample = radius * unit_dir\n\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                r1 = c_best / 2.0\n                if dim == 2:\n                    r_rest = math.sqrt(c_best**2 - c_min**2) / 2.0\n                    L = np.diag([r1, r_rest])\n                elif dim == 3:\n                    r_rest = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r_rest, r_rest])\n                else:\n                    L = np.diag([c_best/2.0]*dim)\n\n                sample_transf = U @ L @ unit_ball_sample + center\n                sample = tuple(np.clip(sample_transf, [0]*dim, bounds))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def dynamic_prune(tree, best_cost):\n            threshold = best_cost * self.pruning_threshold_factor\n            to_remove = [node for node in tree if node.cost > threshold and len(node.children) == 0]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                tree.remove(node)\n\n        def dense_resample_on_branch(tree, best_cost, fraction=0.1, samples_per_branch=5):\n            sorted_nodes = sorted(tree, key=lambda n: n.cost, reverse=True)\n            count = max(1, int(len(tree) * fraction))\n            samples = []\n            radius = self.step_size * 2.5\n            for node in sorted_nodes[:count]:\n                center = np.array(node.position)\n                for _ in range(samples_per_branch):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_np = center + offset\n                    sample_clipped = tuple(np.clip(sample_np, [0]*dim, bounds))\n                    if not self._is_in_obstacle(sample_clipped, obstacles, is_3d):\n                        samples.append(sample_clipped)\n            return samples\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.remove_child(neighbor)\n                            if (old_parent, neighbor) in edges:\n                                edges.remove((old_parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b, nodes, edges):\n            nearest_b = nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n            current = nearest_b\n            while True:\n                new_pos = steer(current.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n                new_cost = current.cost + dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_cost = new_node.cost + dist(new_pos, node_from_a.position)\n                    final_node = Node(node_from_a.position, parent=new_node, cost=final_cost)\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                current = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) -1\n                shortcut_made = False\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i+1] + path[j:]\n                        shortcut_made = True\n                        break\n                    j -= 1\n                if not shortcut_made:\n                    i += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        best_path_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        for iter_count in range(self.max_iter):\n            # Alternate extension order\n            if iter_count % 2 == 0:\n                trees_sequence = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            else:\n                trees_sequence = [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            dense_samples = []\n            if best_path_cost < float(\"inf\") and (iter_count % 25 == 0) and len(start_tree) > 10:\n                dense_samples = dense_resample_on_branch(start_tree, best_path_cost, fraction=0.1, samples_per_branch=5)\n\n            for tree_a, tree_b in trees_sequence:\n                sample = None\n                prob_goal_bias = self.goal_sample_rate\n                prob_informed = 0.6 if best_path_cost < float(\"inf\") else 0.0\n\n                if dense_samples and random.random() < 0.4:\n                    sample = dense_samples.pop(random.randint(0, len(dense_samples)-1))\n                else:\n                    r = random.random()\n                    if r < prob_goal_bias:\n                        sample = goal_pos if tree_a is start_tree else start_pos\n                    elif r < prob_goal_bias + prob_informed:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n\n                curr_radius = adaptive_radius(iter_count)\n                neighbors = near(tree_a, new_node, curr_radius)\n\n                # Select best parent minimizing cost\n                min_cost = tentative_cost\n                min_parent = nearest_node\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_cand = node.cost + edge_c\n                    if cost_cand + 1e-9 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost_cand\n                            min_parent = node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors, edges)\n\n                connect_node = attempt_connect(new_node, tree_b, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path_candidate = extract_path(new_node, connect_node)\n                    else:\n                        path_candidate = extract_path(connect_node, new_node)\n\n                    path_len = 0.0\n                    for i in range(len(path_candidate) - 1):\n                        path_len += dist(path_candidate[i], path_candidate[i + 1])\n\n                    # Accept if strictly better path found\n                    if path_len + 1e-9 < best_path_cost:\n                        best_path_cost = path_len\n                        best_path = shortcut_path(path_candidate)\n\n                        dynamic_prune(start_tree, best_path_cost)\n                        dynamic_prune(goal_tree, best_path_cost)\n\n                        # Early termination if near direct line path length\n                        if best_path_cost <= 1.05 * dist(start_pos, goal_pos):\n                            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n                        # Return improved path for anytime\n                        return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            # If no direct connection found but have best path\n            if success_state and best_path:\n                best_path = shortcut_path(best_path)\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n        # No path found\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 24.74971,
          "time_improvement": -110.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02072300910949707,
                    "num_nodes_avg": 74.3,
                    "path_length_avg": 162.6673111912633,
                    "smoothness_avg": 0.04583645824146655,
                    "success_improvement": 0.0,
                    "time_improvement": -109.66773930537397,
                    "length_improvement": 18.700441342947585,
                    "smoothness_improvement": 340.43183140023496,
                    "objective_score": -27.4580743660215
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0507392168045044,
                    "num_nodes_avg": 270.2,
                    "path_length_avg": 228.05133634833987,
                    "smoothness_avg": 0.08817866346254657,
                    "success_improvement": 0.0,
                    "time_improvement": -234.35617617762307,
                    "length_improvement": 24.32485127953952,
                    "smoothness_improvement": 1135.2983373921786,
                    "objective_score": -59.76539091041811
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023832297325134276,
                    "num_nodes_avg": 162.5,
                    "path_length_avg": 121.81081351558946,
                    "smoothness_avg": 0.10803576440072118,
                    "success_improvement": 0.0,
                    "time_improvement": 14.182704483777888,
                    "length_improvement": 25.200822494563692,
                    "smoothness_improvement": 735.8722653221298,
                    "objective_score": 12.974337170656755
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner merges bidirectional tree growth, goal biasing, and asymptotically optimal rewiring from RRT* principles combined with adaptive sampling and dynamic neighborhood radius scaling. It grows two trees simultaneously from start and goal, extends alternately towards biased random samples or via informed sampling near the current best paths, locally rewires nodes to optimize path cost, and attempts timely direct tree connections. It leverages adaptive radius for efficient rewiring, early stopping upon connection, and path smoothing via short-cutting to improve smoothness and path length while respecting collision and boundary constraints.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling points either randomly biased towards the goal or informed around the best path area to accelerate convergence. Each extension includes rewiring neighbors within a dynamically scaled radius to locally optimize paths. After extension, it tries to directly connect the two trees, checking collision validity. When a connection is found, the path is extracted and refined by shortcutting to improve smoothness and path quality. The planning terminates early upon success or after reaching max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 min_search_radius: float = 10.0, max_search_radius: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_search_radius = min_search_radius\n        self.max_search_radius = max_search_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-assign parent\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b):\n            nearest_b = find_nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n            # Attempt to connect with small incremental steps\n            curr = nearest_b\n            while True:\n                new_pos = steer(curr.position, node_from_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                if distance(new_pos, node_from_a.position) < self.step_size * 1.01:\n                    # Final connect node to node_from_a\n                    final_node = Node(node_from_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_from_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Attempt to shortcut the path by removing unnecessary intermediate nodes\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        # Shortcut is possible; remove intermediate nodes between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        # Initialize trees\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path: list = []\n\n        best_path_cost = float(\"inf\")\n        best_path = []\n\n        # For adaptive radius based on iteration count\n        def adaptive_radius(iteration):\n            scale = min(1.0, iteration / (self.max_iter/2))\n            r = self.max_search_radius - (self.max_search_radius - self.min_search_radius) * scale\n            return r if r > self.min_search_radius else self.min_search_radius\n\n        # Informed sampling around the current best path cost ellipsoid if any, else uniform\n        def informed_sample():\n            if best_path_cost == float(\"inf\"):\n                # Uniform sampling\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                return sample\n            else:\n                # Informed sampling ellipsoid around start-goal with best cost\n                # Simplified: sample around the line segment start-goal with Gaussian noise proportional to cost\n                import numpy as np\n                dim = len(bounds)\n                start = np.array(start_position)\n                goal = np.array(goal_position)\n                center = (start + goal) / 2\n                c_best = best_path_cost\n                c_min = distance(start_position, goal_position)\n                if c_best < c_min:\n                    c_best = c_min + 1e-3  # Avoid degenerate case\n\n                # Sampling in prolate hyperspheroid\n                while True:\n                    # Sample unit ball\n                    direction = np.random.normal(0,1,dim)\n                    norm = np.linalg.norm(direction)\n                    if norm == 0:\n                        continue\n                    direction /= norm\n                    radius = random.uniform(0,1) ** (1/dim)\n                    point_ball = radius * direction\n\n                    # Stretch and translate the sample to ellipsoid\n                    a1 = (goal - start) / c_min\n                    I = np.eye(dim)\n                    M = np.outer(a1, a1)\n                    U, _, _ = np.linalg.svd(M)\n                    L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n                    sample = U @ L @ point_ball + center\n                    sample = np.clip(sample, [0]*dim, bounds)\n                    sample_tuple = tuple(float(v) for v in sample)\n\n                    if not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                        return sample_tuple\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree growth: start_tree first on even, goal_tree first on odd to balance\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_count % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]:\n                # Goal biasing and sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    # With probability, use informed sampling around best path\n                    if best_path_cost < float(\"inf\") and random.random() < 0.6:\n                        sample = informed_sample()\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                # Boundary check\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n\n                # Collision checks for new node and edge\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node with tentative cost\n                tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                # Adaptive neighborhood radius for rewiring\n                curr_radius = adaptive_radius(iter_count)\n\n                neighbors = find_near(tree_a, new_node, curr_radius)\n\n                # Choose best parent from neighbors for minimal cost path\n                min_cost = tentative_cost\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_node.position)\n                    cost = node.cost + edge_cost\n                    if cost + 1e-7 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost\n                            min_node = node\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors with new_node as better parent candidate\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt connecting the other tree\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n\n                    # Save best path cost found so far\n                    path_cost = 0.0\n                    for i in range(len(extracted_path) - 1):\n                        path_cost += distance(extracted_path[i], extracted_path[i+1])\n                    if path_cost < best_path_cost:\n                        best_path_cost = path_cost\n                        best_path = extracted_path\n\n                    # Perform path shortcutting to smooth path\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n        # If no path found, but best path may have been updated by heuristic sampling and rewiring (unlikely)\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 27.10239,
          "time_improvement": -120.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020557212829589843,
                    "num_nodes_avg": 84.2,
                    "path_length_avg": 163.18597505252896,
                    "smoothness_avg": 0.04818481693406371,
                    "success_improvement": 0.0,
                    "time_improvement": -107.99027388470499,
                    "length_improvement": 18.441218130223056,
                    "smoothness_improvement": 362.9966620927936,
                    "objective_score": -26.89385522890292
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04085087776184082,
                    "num_nodes_avg": 225.1,
                    "path_length_avg": 226.58193071270148,
                    "smoothness_avg": 0.09811354338078526,
                    "success_improvement": 0.0,
                    "time_improvement": -169.19499633932136,
                    "length_improvement": 24.812449781649452,
                    "smoothness_improvement": 1274.4764578499003,
                    "objective_score": -39.42362665621702
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.050639772415161134,
                    "num_nodes_avg": 311.6,
                    "path_length_avg": 118.95801706398773,
                    "smoothness_avg": 0.12470345444191666,
                    "success_improvement": 0.0,
                    "time_improvement": -82.34785572446405,
                    "length_improvement": 26.952611371196777,
                    "smoothness_improvement": 864.8301146945379,
                    "objective_score": -14.989683869627171
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm leverages a bidirectional RRT* approach with enhanced adaptive radius sampling, goal biasing, and dynamic rewiring to efficiently explore the free space. It balances exploration and exploitation through alternate tree expansions and adaptive neighborhood calculations. Post path finding, iterative shortcut smoothing is applied to improve path quality and smoothness, ensuring collision-free paths respecting obstacle and boundary constraints, thus improving success rate, planning speed, and path optimality.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately by sampling points with a goal bias. Each sampled point is steered towards from the nearest node with step size constraints. New nodes are only added if collision checks pass for nodes and edges. Neighborhood rewiring optimizes path costs dynamically by considering nearby nodes within an adaptive radius that shrinks as the number of samples grows. Upon successful connection of the trees, the path is extracted and progressively shortcut smoothed by checking collision-free shortcuts for path segments to reduce path length and increase smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.5, base_radius: float = 18.0, goal_sample_rate: float = 0.15, smooth_iter: int = 40, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        edges = []\n        success = False\n        path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(\n                gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim),\n                self.base_radius\n            )\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)  # Alternate tree expansion\n\n            # Goal biasing sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                if n == nearest_node:\n                    continue\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors to new node if cost improves\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, n.position)\n                if new_cost < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt connection of trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            connect_dist = dist(new_node.position, nearest_in_b.position)\n            if connect_dist <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    path = shortcut_smooth(path)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # Failed to connect trees\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 27.53384,
          "time_improvement": -52.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.015524744987487793,
                    "num_nodes_avg": 131.4,
                    "path_length_avg": 175.48337423281686,
                    "smoothness_avg": 0.019028266188653168,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -57.07362611384765,
                    "length_improvement": 12.295096216328036,
                    "smoothness_improvement": 82.83816960050406,
                    "objective_score": -64.24887774288617
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02864375114440918,
                    "num_nodes_avg": 324.7,
                    "path_length_avg": 252.29524147321936,
                    "smoothness_avg": 0.04127327668749704,
                    "success_improvement": 0.0,
                    "time_improvement": -88.75370388409004,
                    "length_improvement": 16.279903351290535,
                    "smoothness_improvement": 478.19894369852864,
                    "objective_score": -20.979135776476262
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03086709976196289,
                    "num_nodes_avg": 315.7,
                    "path_length_avg": 130.35972856993104,
                    "smoothness_avg": 0.06413054224228673,
                    "success_improvement": 0.0,
                    "time_improvement": -11.14879047801381,
                    "length_improvement": 19.95127365589056,
                    "smoothness_improvement": 396.177741859333,
                    "objective_score": 2.6265062970706343
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is a tuned bidirectional RRT* variant with goal biasing, adaptive step size, and dynamic neighbor radius to balance exploration, path optimality, and planning efficiency. It grows two trees from start and goal, incrementally choosing parents minimizing cost and rewiring neighbors to improve paths. Upon connecting the trees, the path is reconstructed and smoothed with shortcutting to yield a short and smooth trajectory. Enhanced collision checking resolution and early pruning improve robustness and reduce search time.",
          "planning_mechanism": "The algorithm alternates expanding two trees toward randomly sampled points (biased toward the goal), steering with adaptive step size, and dynamically selecting neighbor nodes within a radius that scales with the logarithm of nodes to enable efficient rewiring. New nodes pick parents with minimal cumulative cost respecting obstacle constraints. Trees rewire neighbors for incremental path improvement. Upon connection, the final path is extracted and shortcut-smoothed to improve path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 initial_step_size: float = 6.0,\n                 goal_sample_rate: float = 0.15,\n                 collision_resolution: float = 0.3,\n                 radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.initial_step_size = initial_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # list of obstacle boxes\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _near_nodes(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def _steer(from_pos, to_pos, step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def _can_connect(parent_node, new_pos):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample = _sample_free()\n\n            # Adapt step_size decreasing linearly to 30% of initial after max_iter/2\n            step_size_ratio = 1.0\n            if i > self.max_iter // 2:\n                step_size_ratio = max(0.3, 1.0 - (i - self.max_iter // 2) / (self.max_iter // 2))\n            step_size = self.initial_step_size * step_size_ratio\n\n            # Dynamic neighbor radius per RRT* theory: gamma * (log(n)/n)^{1/dimension}\n            n_nodes = len(nodes)\n            dim = 3 if is_3d else 2\n            radius = min(self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), step_size * 5)\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, step_size)\n            if not _can_connect(nearest_node_a, new_pos_a):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.parent = None\n            new_node_a.cost = 0\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n\n            if dist <= step_size:\n                if (not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(new_node_a.position, obstacles, is_3d)):\n                    connecting_node_b = None\n                    if nearest_node_b.position != new_node_a.position:\n                        connecting_node_b = Node(new_node_a.position)\n                        connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                        tree_b.append(connecting_node_b)\n                        nodes.append(connecting_node_b)\n                        edges.append((nearest_node_b, connecting_node_b))\n                    else:\n                        connecting_node_b = nearest_node_b\n\n                    near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                    _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                    success_state = True\n                    extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                    extracted_path = _smooth_path(extracted_path)\n                    break\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, step_size)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.parent = None\n                    new_node_b.cost = 0\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 29.56767,
          "time_improvement": -67.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021631383895874025,
                    "num_nodes_avg": 112.3,
                    "path_length_avg": 170.0891743830483,
                    "smoothness_avg": 0.032969526437711734,
                    "success_improvement": 0.0,
                    "time_improvement": -118.85833932370693,
                    "length_improvement": 14.991065454907773,
                    "smoothness_improvement": 216.79648616967935,
                    "objective_score": -31.575306275282127
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0254561185836792,
                    "num_nodes_avg": 258.2,
                    "path_length_avg": 242.09503903305935,
                    "smoothness_avg": 0.08772703018891094,
                    "success_improvement": 0.0,
                    "time_improvement": -67.74816416179884,
                    "length_improvement": 19.66467560914243,
                    "smoothness_improvement": 1128.9713892379912,
                    "objective_score": -10.74665718052121
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.03165559768676758,
                    "num_nodes_avg": 295.0,
                    "path_length_avg": 129.75892265782096,
                    "smoothness_avg": 0.10989612270192795,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -13.988078629875215,
                    "length_improvement": 20.320204679083222,
                    "smoothness_improvement": 750.2658498556063,
                    "objective_score": -46.38105340386789
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner designed to improve planning efficiency, path quality, robustness, and success rate by tuning parameters such as reduced step size for finer node expansion, increased max iterations, goal bias sampling, and a shorter collision checking resolution. It alternates growth of two trees from the start and goal, extending towards sampled points with a goal bias. After connecting the trees, the path is reconstructed and smoothed through shortcutting to yield high-quality, smooth paths while maintaining strict collision and boundary checks.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately extending each tree towards either the goal (with a bias) or a randomly sampled free point. It carefully checks node and edge collisions, attempts to connect the two trees when nodes get close, and upon success, reconstructs and smooths the path using shortcutting to eliminate unnecessary detours, resulting in efficient, robust, and smooth path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 2.5, goal_sample_rate: float = 0.2, collision_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):  # Increased smoothing attempts for better quality\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 29.59367,
          "time_improvement": -121.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012711930274963378,
                    "num_nodes_avg": 121.2,
                    "path_length_avg": 156.51037510281344,
                    "smoothness_avg": 0.016563812396447348,
                    "success_improvement": 0.0,
                    "time_improvement": -28.614607505897894,
                    "length_improvement": 21.77761882258332,
                    "smoothness_improvement": 59.15780818635535,
                    "objective_score": -3.933069446320927
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048055505752563475,
                    "num_nodes_avg": 607.8,
                    "path_length_avg": 239.61838345230382,
                    "smoothness_avg": 0.06947459962334016,
                    "success_improvement": 0.0,
                    "time_improvement": -216.67132761659968,
                    "length_improvement": 20.48651371982447,
                    "smoothness_improvement": 873.2723771907903,
                    "objective_score": -56.537733655061054
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.060466766357421875,
                    "num_nodes_avg": 670.2,
                    "path_length_avg": 127.86634277088353,
                    "smoothness_avg": 0.08306683969289017,
                    "success_improvement": 0.0,
                    "time_improvement": -117.7337034114899,
                    "length_improvement": 21.482362740593366,
                    "smoothness_improvement": 542.6877974381493,
                    "objective_score": -28.31019948813755
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm integrates the advantages of bidirectional RRT* with adaptive radius rewiring and post-processing path smoothing. It employs goal biasing to guide search, adaptive neighborhood radius to balance exploration and exploitation dynamically, rigorous collision checking for nodes and edges, and iterative path shortcutting to improve path smoothness and length, resulting in enhanced planning efficiency, higher success rate, shorter and smoother paths, and robustness in 2D/3D obstacle-laden environments.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with goal biasing. New nodes are added only after verifying collision-free state and edges. An adaptive radius is computed to determine neighbors for rewiring, optimizing path costs incrementally. Upon successfully connecting trees, the path is extracted and further smoothed by iterative shortcutting to remove unnecessary detours, resulting in improved path quality and reduced planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0, base_radius: float = 20.0, goal_sample_rate: float = 0.12, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        dim = len(bounds)\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            gamma = self.base_radius\n            return min(gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        def is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_start = [Node(start_position, cost=0.0)]\n        nodes_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(nodes_start + nodes_goal)\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if sample_from_start else start_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not is_within_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not is_within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors to new_node\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    # Rewire n to new_node\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt to connect the two trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution) and\n                    not self._is_in_obstacle(nearest_in_b.position, obstacles, is_3d)):\n                    success_state = True\n                    extracted_path = extract_path(new_node, nearest_in_b)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 30.26564,
          "time_improvement": -70.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.02046186923980713,
                    "num_nodes_avg": 146.7,
                    "path_length_avg": 167.455292779483,
                    "smoothness_avg": 0.030418477933329684,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -107.02562271742644,
                    "length_improvement": 16.307454164825106,
                    "smoothness_improvement": 192.2840563729249,
                    "objective_score": -77.88477570039828
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03411951065063477,
                    "num_nodes_avg": 345.6,
                    "path_length_avg": 238.48210542085388,
                    "smoothness_avg": 0.08873898954788373,
                    "success_improvement": 0.0,
                    "time_improvement": -124.83731189924809,
                    "length_improvement": 20.863569212656234,
                    "smoothness_improvement": 1143.14796738695,
                    "objective_score": -27.56273989030843
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021352696418762206,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 132.9119138657559,
                    "smoothness_avg": 0.11736740911570517,
                    "success_improvement": 0.0,
                    "time_improvement": 23.111455281125757,
                    "length_improvement": 18.384078138025167,
                    "smoothness_improvement": 808.0711621445129,
                    "objective_score": 14.650608022665326
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm integrates the asymptotic optimality and rewiring benefits of RRT* with bidirectional tree growth, goal biasing, adaptive neighborhood radius, and refined collision checking resolution. It alternates growth between two trees from start and goal, applies rewiring for path cost optimization, and includes path shortcut smoothing at the end to improve path quality and smoothness. The design prioritizes planning efficiency, robustness, path length minimization, and success rate in 2D/3D obstacle environments.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately towards random samples or biased goal samples. New nodes are added only if collision checks for nodes and edges pass. After node insertion, neighbors within an adaptive radius are rewired if a lower cost path is found. Connection attempts join the two trees when nodes are close enough. Once connected, the planner reconstructs and shortcut-smoothes the path for length and smoothness improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 3.0, base_radius: float = 12.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n\n        edges = []\n        success = False\n        path = []\n\n        import math\n        import random\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative = n.cost + dist(n.position, new_pos)\n                if tentative < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt to connect trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    path = _smooth_path(path)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # No connection found\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = 0\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 30.50714,
          "time_improvement": -124.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019741010665893555,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 169.44487688253477,
                    "smoothness_avg": 0.021828820906992442,
                    "success_improvement": 0.0,
                    "time_improvement": -99.73224236167061,
                    "length_improvement": 15.313079153001063,
                    "smoothness_improvement": 109.74804638541839,
                    "objective_score": -26.30831664597388
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04752800464630127,
                    "num_nodes_avg": 463.9,
                    "path_length_avg": 242.8552035826887,
                    "smoothness_avg": 0.06588403727118823,
                    "success_improvement": 0.0,
                    "time_improvement": -213.19525400082324,
                    "length_improvement": 19.412427294064138,
                    "smoothness_improvement": 822.9720490870404,
                    "objective_score": -55.96123049599893
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04435839653015137,
                    "num_nodes_avg": 416.9,
                    "path_length_avg": 123.73078853416737,
                    "smoothness_avg": 0.11277190523314992,
                    "success_improvement": 0.0,
                    "time_improvement": -59.729361031388265,
                    "length_improvement": 24.021842171915793,
                    "smoothness_improvement": 772.5157674850157,
                    "objective_score": -9.251861037608244
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner synergizes bidirectional RRT* tree growth with adaptive neighborhood rewiring and goal biasing from the first algorithm, combined with efficient sampling, strict collision checks, and iterative shortcut smoothing from the second. It dynamically adjusts the rewiring radius based on node count for efficiency and integrates shortcut smoothing on the final path to improve path quality and smoothness, aiming for higher success rates and faster planning.",
          "planning_mechanism": "The planner initializes two trees rooted at start and goal, alternately grows them by sampling with goal bias, steering towards samples with collision checks, and rewiring nearby nodes to optimize cost using an adaptively shrinking radius. Upon tree connection, it extracts the path and applies iterative shortcut smoothing to reduce path length and improve smoothness while ensuring collision-free shortcuts. The approach balances exploration, optimality, smoothness, and computational efficiency for robust 2D/3D path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, base_radius: float=15.0, goal_sample_rate: float=0.1, smooth_iter: int=40, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_point(sample_from_start):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if sample_from_start else start_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.base_radius\n            return min(self.base_radius * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)), self.base_radius)\n\n        def connect_trees(node_a, tree_b):\n            nearest_node = nearest(tree_b, node_a.position)\n            if dist(node_a.position, nearest_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(node_a.position, nearest_node.position, obstacles, is_3d, self.collision_resolution):\n                    return node_a, nearest_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if within_bounds(p1) and within_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n        success = False\n        final_path = []\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n            sample = sample_point(sample_from_start)\n\n            tree_a = tree_start if sample_from_start else tree_goal\n            tree_b = tree_goal if sample_from_start else tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors for better cost\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    # Remove old edge\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    # Add new edge\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            connected = connect_trees(new_node, tree_b)\n            if connected:\n                node_a, node_b = connected\n                success = True\n                raw_path = extract_path(node_a, node_b)\n                smooth_path = shortcut_smooth(raw_path)\n                final_path = smooth_path\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 35.38829,
          "time_improvement": -24.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.011202740669250488,
                    "num_nodes_avg": 100.9,
                    "path_length_avg": 172.11689242156672,
                    "smoothness_avg": 0.02063229592515603,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -13.345185428195109,
                    "length_improvement": 13.9776314686617,
                    "smoothness_improvement": 98.25091704156351,
                    "objective_score": -50.71677474951837
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014852499961853028,
                    "num_nodes_avg": 249.6,
                    "path_length_avg": 252.82699559532767,
                    "smoothness_avg": 0.04761391857922263,
                    "success_improvement": 0.0,
                    "time_improvement": 2.126492944159725,
                    "length_improvement": 16.103449343532393,
                    "smoothness_improvement": 567.025243386941,
                    "objective_score": 6.693763968889101
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.0442486047744751,
                    "num_nodes_avg": 408.3,
                    "path_length_avg": 135.6412762492805,
                    "smoothness_avg": 0.07281177215273024,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -59.33401385131685,
                    "length_improvement": 16.708085214984802,
                    "smoothness_improvement": 463.34438201110305,
                    "objective_score": -62.14186520234258
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT planner with optimized parameters and advanced path smoothing to improve planning efficiency, robustness, and path quality. It grows two trees simultaneously from start and goal with goal-biased sampling, fine collision checking resolution, and rigorous node/edge validation. Post planning, a shortcut smoothing technique refines the path to reduce length and unnecessary detours.",
          "planning_mechanism": "The planner alternates expanding two trees, each extension biased towards sampled points with a probability of sampling the goal to guide growth. It performs strict collision checking on nodes and edges. When the two trees connect, the path is reconstructed and smoothed via shortcutting to improve smoothness and reduce path length, balancing exploration and exploitation for improved success rates and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 10000,\n        step_size: float = 2.5,\n        goal_sample_rate: float = 0.2,\n        collision_resolution: float = 0.25,\n        smoothing_trials: int = 100,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (\n                        random.uniform(0, bounds[0]),\n                        random.uniform(0, bounds[1]),\n                        random.uniform(0, bounds[2]),\n                    )\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (\n                not _is_within_bounds(new_pos)\n                or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)\n            ):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (\n                    not _is_within_bounds(next_pos)\n                    or self._is_in_obstacle(next_pos, obstacles, is_3d)\n                    or self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)\n                ):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + math.dist(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Remove duplicated connecting node position to avoid repetition\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smoothing_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if (\n                    not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n                    and self._is_within_bounds(p1, bounds)\n                    and self._is_within_bounds(p2, bounds)\n                ):\n                    # shortcut possible, splice path\n                    path = path[: i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _is_within_bounds(self, pos, bounds):\n        for i, coord in enumerate(pos):\n            if coord < 0 or coord > bounds[i]:\n                return False\n        return True",
          "objective": 35.90885,
          "time_improvement": -90.0,
          "length_improvement": 24.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.019858360290527344,
                    "num_nodes_avg": 132.1,
                    "path_length_avg": 153.60459036753133,
                    "smoothness_avg": 0.02175630533123696,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -100.91954244802848,
                    "length_improvement": 23.229902104336634,
                    "smoothness_improvement": 109.05126113934247,
                    "objective_score": -75.08462600784449
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043272757530212404,
                    "num_nodes_avg": 578.7,
                    "path_length_avg": 232.53440407362814,
                    "smoothness_avg": 0.07092289878811679,
                    "success_improvement": 0.0,
                    "time_improvement": -185.15445550154442,
                    "length_improvement": 22.83721773935766,
                    "smoothness_improvement": 893.561656706293,
                    "objective_score": -46.51108481906033
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023084235191345216,
                    "num_nodes_avg": 379.4,
                    "path_length_avg": 119.94329094844231,
                    "smoothness_avg": 0.1043484649215158,
                    "success_improvement": 0.0,
                    "time_improvement": 16.876388115031,
                    "length_improvement": 26.347593852244266,
                    "smoothness_improvement": 707.3436444001499,
                    "objective_score": 13.869153426958901
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm introduces an adaptive bidirectional Anytime RRT*-like planner with heuristic-guided informed sampling focusing on promising regions, combined with dynamic tree pruning and local dense re-sampling in high-cost branches. It interleaves exploration and exploitation phases: broadly exploring early, then exploiting promising paths by biasing samples around the current best path ellipsoid and dynamically pruning non-promising nodes to improve efficiency. In addition, it employs an adaptive rewiring radius and integrates shortcut smoothing progressively during the search to improve path quality and smoothness without waiting for full convergence. This approach significantly enhances planning efficiency, success rate, solution quality, and path smoothness, while reducing search time and ensuring robustness in complex environments.",
          "planning_mechanism": "The planner grows two trees bidirectionally, alternating between start and goal expansions. Sampling is adaptively switched between uniform random, heuristic-informed ellipsoid around the best path, and local dense resampling on high-cost branches, guided by the current best path cost. After adding new nodes, neighborhood rewiring optimizes local paths with an adaptive radius. Dynamic pruning removes nodes unlikely to improve the best path. Each extension attempts connection to the other tree with collision checks. Progressive shortcut smoothing is integrated to maintain path quality along the search. Early termination occurs on finding a sufficiently good path, balancing exploration/exploitation and ensuring success and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, min_radius: float = 6.0,\n                 max_radius: float = 20.0, rewire_factor: float = 1.5,\n                 pruning_threshold_factor: float = 1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.rewire_factor = rewire_factor\n        self.pruning_threshold_factor = pruning_threshold_factor\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            distance_val = dist(from_pos, to_pos)\n            if distance_val <= max_step:\n                return to_pos\n            ratio = max_step / distance_val\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, new_node, radius):\n            radius_sq = radius * radius\n            px = new_node.position\n            return [node for node in tree if (sum((px[d]-node.position[d])**2 for d in range(dim)) <= radius_sq)]\n\n        def adaptive_radius(iteration):\n            # Linear interpolation shrinking radius as iterations grow\n            scale = min(1.0, iteration / (self.max_iter*0.75))\n            r = self.max_radius - (self.max_radius - self.min_radius)*scale\n            return max(self.min_radius, r)\n\n        def informed_sample(c_best):\n            # If no solution yet, uniform random sampling\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min + 1e-7  # numeric stability\n            center = (np.array(start_pos) + np.array(goal_pos)) * 0.5\n            a1 = (np.array(goal_pos) - np.array(start_pos)) / c_min\n\n            while True:\n                # Sample unit n-ball\n                dir_random = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(dir_random)\n                if norm_dir == 0:\n                    continue\n                unit_dir = dir_random / norm_dir\n                radius = random.uniform(0, 1) ** (1/dim)\n                sample_ball = radius * unit_dir\n\n                # Rotation matrix: align ellipsoid to line start-goal\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                r1 = c_best / 2.0\n                if dim == 2:\n                    r_rest = math.sqrt(c_best**2 - c_min**2)/2.0\n                    L = np.diag([r1, r_rest])\n                elif dim == 3:\n                    r_rest = math.sqrt(c_best**2 - c_min**2)/2.0\n                    L = np.diag([r1, r_rest, r_rest])\n                else:\n                    # Higher dims fallback: isotropic ellipsoid\n                    L = np.diag([c_best/2.0]*dim)\n\n                sample_transf = U @ L @ sample_ball + center\n                sample = tuple(np.clip(sample_transf, [0]*dim, bounds))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old edge\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.remove_child(neighbor)\n                            if (old_parent, neighbor) in edges:\n                                edges.remove((old_parent, neighbor))\n                        # Insert new edge\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def dynamic_prune(tree, best_cost):\n            # Remove nodes with cost worse than threshold * best_cost and no children to reduce search scope\n            threshold = best_cost * self.pruning_threshold_factor\n            to_remove = [node for node in tree if node.cost > threshold and len(node.children) == 0]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                tree.remove(node)\n\n        def attempt_connect(node_from_a, tree_b, nodes, edges):\n            nearest_b = nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n\n            current = nearest_b\n            while True:\n                new_pos = steer(current.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n                new_cost = current.cost + dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_cost = new_node.cost + dist(new_pos, node_from_a.position)\n                    final_node = Node(node_from_a.position, parent=new_node, cost=final_cost)\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                current = new_node\n\n        def extract_path(node_start, node_goal):\n            # Extract path from root to node_start, and root to node_goal then concatenate\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortcut_made = False\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i+1] + path[j:]\n                        shortcut_made = True\n                        break\n                    j -= 1\n                if not shortcut_made:\n                    i += 1\n            return path\n\n        def dense_resample_on_branch(tree, best_cost, fraction=0.1, samples_per_branch=5):\n            # Identify highest cost nodes (fraction from top) and resample densely around them\n            sorted_nodes = sorted(tree, key=lambda n: n.cost, reverse=True)\n            count = max(1, int(len(tree) * fraction))\n            samples = []\n            radius = self.step_size * 2.5\n            for node in sorted_nodes[:count]:\n                center = np.array(node.position)\n                for _ in range(samples_per_branch):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_np = center + offset\n                    sample_clipped = tuple(np.clip(sample_np, [0]*dim, bounds))\n                    if not self._is_in_obstacle(sample_clipped, obstacles, is_3d):\n                        samples.append(sample_clipped)\n            return samples\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        best_path_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        for iter_count in range(self.max_iter):\n            # Alternate growth order each iteration\n            if iter_count % 2 == 0:\n                trees_sequence = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            else:\n                trees_sequence = [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            # Progressive dense resampling phase every 25 iterations if a path exists\n            dense_samples = []\n            if best_path_cost < float(\"inf\") and (iter_count % 25 == 0) and len(start_tree) > 10:\n                dense_samples = dense_resample_on_branch(start_tree, best_path_cost, fraction=0.1, samples_per_branch=5)\n\n            for tree_a, tree_b in trees_sequence:\n                # Sample selection strategy\n                sample = None\n                prob_goal_bias = self.goal_sample_rate\n                prob_informed = 0.6 if best_path_cost < float(\"inf\") else 0.0\n\n                # If dense resamples available, select one with priority\n                if dense_samples and random.random() < 0.4:\n                    sample = dense_samples.pop(random.randint(0, len(dense_samples)-1))\n                else:\n                    if random.random() < prob_goal_bias:\n                        sample = goal_pos if tree_a is start_tree else start_pos\n                    elif random.random() < prob_informed:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n\n                curr_radius = adaptive_radius(iter_count)*self.rewire_factor\n                neighbors = near(tree_a, new_node, curr_radius)\n\n                # Choose best parent minimizing cost\n                min_cost = tentative_cost\n                min_parent = nearest_node\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_cand = node.cost + edge_c\n                    if cost_cand + 1e-9 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost_cand\n                            min_parent = node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors, edges)\n\n                connect_node = attempt_connect(new_node, tree_b, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, connect_node)\n                    else:\n                        path = extract_path(connect_node, new_node)\n\n                    path_len = 0.0\n                    for i in range(len(path)-1):\n                        path_len += dist(path[i], path[i+1])\n\n                    # Accept path only if better than current best by threshold\n                    if path_len + 1e-9 < best_path_cost:\n                        best_path_cost = path_len\n                        best_path = path\n                        # Progressive smoothing after each improvement\n                        best_path = shortcut_path(best_path)\n\n                        # Prune nodes unlikely to improve solution\n                        dynamic_prune(start_tree, best_path_cost)\n                        dynamic_prune(goal_tree, best_path_cost)\n\n                        # Early termination if path is close enough to direct dist\n                        if best_path_cost <= 1.05 * dist(start_pos, goal_pos):\n                            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n                        # Return path at first improvement for anytime planning\n                        return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            # After full iteration, if no connection but best path found, yield best known\n            if success_state and best_path:\n                # Continue smoothing progressively\n                best_path = shortcut_path(best_path)\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n        # Return failure if no path found\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.10981,
          "time_improvement": -170.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03076789379119873,
                    "num_nodes_avg": 104.2,
                    "path_length_avg": 164.06481454932924,
                    "smoothness_avg": 0.04761889990524928,
                    "success_improvement": 0.0,
                    "time_improvement": -211.2981662220121,
                    "length_improvement": 18.001982596685288,
                    "smoothness_improvement": 357.5588974184752,
                    "objective_score": -58.00125886017419
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04348978996276855,
                    "num_nodes_avg": 247.8,
                    "path_length_avg": 230.22395471615914,
                    "smoothness_avg": 0.11080137668549299,
                    "success_improvement": 0.0,
                    "time_improvement": -186.58463394784553,
                    "length_improvement": 23.60390300214643,
                    "smoothness_improvement": 1452.2208097255862,
                    "objective_score": -43.99350553529644
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05870811939239502,
                    "num_nodes_avg": 285.5,
                    "path_length_avg": 120.20631556796214,
                    "smoothness_avg": 0.11240615199909001,
                    "success_improvement": 0.0,
                    "time_improvement": -111.40102283741659,
                    "length_improvement": 26.186080890989434,
                    "smoothness_improvement": 769.6859362157281,
                    "objective_score": -24.33466099194845
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional RRT* framework with adaptive goal-biased sampling, local rewiring for optimality, and iterative shortcut smoothing to obtain high-quality, smooth, and efficient paths. It grows two trees from start and goal, alternately extending them by sampling points biased towards the goal. Each extension performs rewiring in a dynamic neighborhood to reduce path costs, and the trees are connected when feasible. Final paths undergo shortcut smoothing to enhance smoothness and reduce length, while strict collision and edge checks ensure safety and robustness. This approach balances exploration, exploitation, and path optimization to improve success rate, path quality, and planning speed.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal positions via goal-biased sampling. For each new node, it finds near neighbors within a radius to connect and rewire for local optimality. Upon connection of the two trees, the path is reconstructed and shortcut smoothing is applied to improve smoothness and reduce path length. Continuous collision and edge checks guarantee valid paths, and dynamic rewiring enables improvements during growth, yielding efficient, smooth, and robust paths with high success rate.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root (start or goal)\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0,\n                 goal_sample_rate: float = 0.1, smooth_iter: int = 30, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_point(tree_id):\n            # tree_id=0 for start tree, 1 for goal tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if tree_id == 0 else start_position\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def rewire(tree, new_node):\n            neighbors = near(tree, new_node.position, self.radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if tentative_cost < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    # Remove old parent-child edge\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = tentative_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def connect_trees(node_a, tree_b):\n            connect_candidate = nearest(tree_b, node_a.position)\n            if distance(node_a.position, connect_candidate.position) <= self.step_size and collision_free_edge(node_a.position, connect_candidate.position):\n                return node_a, connect_candidate\n            # Attempt multi-step connect stepping from connect_candidate towards node_a\n            curr = connect_candidate\n            connection_chain = []\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if not collision_free_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                new_cost = curr.cost + distance(curr.position, new_pos)\n                new_node = Node(new_pos, parent=curr, cost=new_cost)\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                connection_chain.append(new_node)\n                if distance(new_pos, node_a.position) <= self.step_size:\n                    # Final connection node\n                    if collision_free_edge(new_pos, node_a.position):\n                        final_cost = new_node.cost + distance(new_pos, node_a.position)\n                        final_node = Node(node_a.position, parent=new_node, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree_b.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return node_a, final_node\n                    else:\n                        return None\n                curr = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_position, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_position, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path: list = []\n\n        for iter_idx in range(self.max_iter):\n            for tree_idx, (tree_a, tree_b) in enumerate([(start_tree, goal_tree), (goal_tree, start_tree)]):\n                sample = sample_point(tree_idx)\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                # Choose best parent among near neighbors (including nearest_node)\n                neighbors = near(tree_a, new_pos, self.radius)\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                min_node = nearest_node\n                for n in neighbors:\n                    edge_cost = distance(n.position, new_pos)\n                    cost_through_n = n.cost + edge_cost\n                    if cost_through_n < min_cost and collision_free_edge(n.position, new_pos):\n                        min_cost = cost_through_n\n                        min_node = n\n\n                new_node = Node(new_pos, parent=min_node, cost=min_cost)\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire around new_node\n                rewire(tree_a, new_node)\n\n                # Attempt to connect trees\n                connected = connect_trees(new_node, tree_b)\n                if connected is not None:\n                    node_a, node_b = connected\n                    success_state = True\n                    extracted_path = extract_path(node_a, node_b)\n                    extracted_path = shortcut_smooth(extracted_path)\n                    break\n            if success_state:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 42.41565,
          "time_improvement": -48.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.019983386993408202,
                    "num_nodes_avg": 96.8,
                    "path_length_avg": 166.77313349849555,
                    "smoothness_avg": 0.02015511633976813,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -102.18451637181161,
                    "length_improvement": 16.648390816890878,
                    "smoothness_improvement": 93.6658097544331,
                    "objective_score": -76.85734769939313
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.025251436233520507,
                    "num_nodes_avg": 204.1,
                    "path_length_avg": 246.50859252054116,
                    "smoothness_avg": 0.037164962057354575,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -66.39936904354164,
                    "length_improvement": 18.20010924483608,
                    "smoothness_improvement": 420.6454037284594,
                    "objective_score": -64.17656184545297
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02065930366516113,
                    "num_nodes_avg": 180.7,
                    "path_length_avg": 127.40998736268537,
                    "smoothness_avg": 0.05821271331541609,
                    "success_improvement": 0.0,
                    "time_improvement": 25.608280913702707,
                    "length_improvement": 21.762592452539355,
                    "smoothness_improvement": 350.39152376451136,
                    "objective_score": 13.78696038344124
               }
          ],
          "success_rate": 0.9333333333333332
     }
]