[
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the rapid exploration and bidirectional growth of dual-tree RRT with the optimization and rewiring capabilities of RRT*. It uses goal-biased sampling with adaptive neighborhood radius and incorporates incremental rewiring when adding nodes to improve path quality progressively. The planner grows two trees simultaneously from start and goal, attempts frequent connections, and applies rewiring locally to shorten paths, ensuring collision-free nodes and edges at all steps. Such integration enhances planning efficiency, success rate, and path smoothness while reducing overall search time.",
          "planning_mechanism": "The planner alternates expansions between start and goal trees. Each iteration samples (with goal bias), extends the nearest node towards the sample by a fixed step size, checks collisions on node and edge, then connects the new node to the best parent in its neighborhood to minimize cost. Afterwards, neighbors are rewired if lower-cost paths through the new node exist without collision. It attempts direct connections between the two trees after each expansion, terminating early once a connection is found. The final path is extracted bidirectionally and returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from start node\n        self.children = []\n        self.valid = True               # Validity flag for collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, max_radius: float=20.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            curr = connect_node\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                if distance(new_pos, node_a.position) < self.step_size:\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        # Adaptive radius function decreases with iterations, but not below a minimum radius\n        def adaptive_radius(iter_num):\n            gamma = self.max_radius *  (math.log(iter_num + 1 + 1) / (iter_num + 1))**0.5\n            return max(min(gamma, self.max_radius), self.step_size)\n\n        for iter_num in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal bias sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                radius = adaptive_radius(iter_num)\n                neighbors = find_near(tree_a, new_node, radius)\n\n                # Choose best parent minimizing cost for the new node\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors to possibly improve their path costs\n                rewire(tree_a, new_node, neighbors)\n\n                # Try connecting the two trees\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.79662,
          "time_improvement": 21.0,
          "length_improvement": 8.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008672499656677246,
                    "num_nodes_avg": 171.6,
                    "path_length_avg": 178.58706890783012,
                    "smoothness_avg": 0.01287433619980249,
                    "success_improvement": 0.0,
                    "time_improvement": 12.254857027070063,
                    "length_improvement": 10.743899448907847,
                    "smoothness_improvement": 23.706492344377313,
                    "objective_score": 5.943769459624475
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01442580223083496,
                    "num_nodes_avg": 417.4,
                    "path_length_avg": 285.20214147412014,
                    "smoothness_avg": 0.006810454997463837,
                    "success_improvement": 0.0,
                    "time_improvement": 4.938302639145074,
                    "length_improvement": 5.360280641017321,
                    "smoothness_improvement": -4.592070180053407,
                    "objective_score": 2.5305865690467195
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015455484390258789,
                    "num_nodes_avg": 416.6,
                    "path_length_avg": 150.10711452935692,
                    "smoothness_avg": 0.014126727627698357,
                    "success_improvement": 0.0,
                    "time_improvement": 44.346621176700864,
                    "length_improvement": 7.825189074258418,
                    "smoothness_improvement": 9.298433618285387,
                    "objective_score": 14.91551633595337
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.47449114023227,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012044763565063477,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": -21.86446156592386,
                    "length_improvement": 12.401486536989607,
                    "smoothness_improvement": 60.71897053377777,
                    "objective_score": -3.7754463097103477
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017744064331054688,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": -16.928046454483464,
                    "length_improvement": 14.190408824541839,
                    "smoothness_improvement": 52.81399740357816,
                    "objective_score": -1.9762621844187802
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009687995910644532,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 65.11466785256512,
                    "length_improvement": 11.655572158065754,
                    "smoothness_improvement": 61.933425488650386,
                    "objective_score": 22.175181914825938
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -1.486610468143649,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008508419990539551,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 13.914954384712244,
                    "length_improvement": 5.9265718433081265,
                    "smoothness_improvement": 7.497776338222911,
                    "objective_score": 5.397289565766413
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017635869979858398,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": -16.21507822540353,
                    "length_improvement": 0.3867603104208941,
                    "smoothness_improvement": 0.5583282013809732,
                    "objective_score": -4.784379764529976
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024777650833129883,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 10.77859785250502,
                    "length_improvement": 2.8534839845313615,
                    "smoothness_improvement": 8.529090107346295,
                    "objective_score": 3.84692160319451
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm combines bidirectional growth of two trees with asymptotic optimality via rewiring, incorporating goal biasing and adaptive neighborhood sampling to efficiently find smooth, short, and collision-free paths in 2D or 3D environments containing obstacles. It balances exploration and exploitation to improve success rate, path quality, and planning speed.",
          "planning_mechanism": "The planner grows two trees\u2014one from start and one from goal\u2014by sampling free space with a bias towards the goal. Each extension considers a neighborhood for rewiring to optimize costs. After each new node insertion, the planner attempts to connect the two trees with collision-checked edges, extracting the best path upon success. Adaptive radius and collision checks ensure robustness and efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision and validity checks\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        success = False\n        path: list[tuple] = []\n\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            while node_start:\n                path_s.append(node_start.position)\n                node_start = node_start.parent\n            while node_goal:\n                path_g.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_s[::-1] + path_g\n\n        def adaptive_radius(n_nodes):\n            # Radius adaptively shrinks with number of nodes, capped by base_radius\n            gamma = self.base_radius\n            return min(gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        for i in range(self.max_iter):\n            # Goal biasing sampling alternating between trees\n            sample_from_start = (i % 2 == 0)\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    # Rewire\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt connection from new_node in tree_a to nearest in tree_b\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d):\n                    # Connect both trees with minimal cost\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # No connection found\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1.22143,
          "time_improvement": -7.0,
          "length_improvement": 4.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008090043067932129,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 185.6649117391287,
                    "smoothness_avg": 0.010914094873855713,
                    "success_improvement": 0.0,
                    "time_improvement": 18.14793730129248,
                    "length_improvement": 7.2064616304885325,
                    "smoothness_improvement": 4.870990861583404,
                    "objective_score": 6.9100284707933675
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014984416961669921,
                    "num_nodes_avg": 248.6,
                    "path_length_avg": 303.9601784431043,
                    "smoothness_avg": 0.006630449936174837,
                    "success_improvement": 0.0,
                    "time_improvement": 1.2571995965398015,
                    "length_improvement": -0.8642706379259195,
                    "smoothness_improvement": -7.113768107885172,
                    "objective_score": 0.16873691083733064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.038583230972290036,
                    "num_nodes_avg": 419.1,
                    "path_length_avg": 155.2327737852811,
                    "smoothness_avg": 0.01296368234295665,
                    "success_improvement": 0.0,
                    "time_improvement": -38.93367010102172,
                    "length_improvement": 4.6777255162124165,
                    "smoothness_improvement": 0.2999570284091653,
                    "objective_score": -10.743056141921985
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT planner optimized for enhanced efficiency, path quality, and robustness. It alternates growth of two trees from start and goal, samples points with goal bias, and ensures strict collision checking for newly added nodes and connecting edges. Upon connection, it reconstructs the path and applies shortcut smoothing to reduce unnecessary detours and improve smoothness. The design balances exploration depth and computational effort for improved success rates and faster convergence.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal by sampling free configurations biased toward the goal. It extends each tree by steering towards sampled points within step size, validating new nodes and edges via collision-free checks. When the two trees connect, the planner reconstructs the full path and performs iterative shortcut smoothing to optimize path quality before returning the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 3.0, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                         \n        start_position = map.start                 \n        goal_position = map.goal                   \n        obstacles = map.obstacles                  \n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, target_node):\n            current = _nearest(tree, target_node.position)\n            while True:\n                next_pos = _steer(current.position, target_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, target_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(40):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if not new_a:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.98769,
          "time_improvement": -24.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01088719367980957,
                    "num_nodes_avg": 134.1,
                    "path_length_avg": 175.03233523134534,
                    "smoothness_avg": 0.013335379012390985,
                    "success_improvement": 0.0,
                    "time_improvement": -10.152597731537979,
                    "length_improvement": 12.52052117410358,
                    "smoothness_improvement": 28.136545147160557,
                    "objective_score": -0.4009923589048745
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023423933982849122,
                    "num_nodes_avg": 412.5,
                    "path_length_avg": 250.35117199926208,
                    "smoothness_avg": 0.021827263057035733,
                    "success_improvement": 0.0,
                    "time_improvement": -54.356678931773125,
                    "length_improvement": 16.925011373547015,
                    "smoothness_improvement": 205.77897991876952,
                    "objective_score": -11.893106505228687
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029634523391723632,
                    "num_nodes_avg": 463.6,
                    "path_length_avg": 126.67064640606554,
                    "smoothness_avg": 0.03621107325015106,
                    "success_improvement": 0.0,
                    "time_improvement": -6.710428151123073,
                    "length_improvement": 22.216592338552495,
                    "smoothness_improvement": 180.16492496948817,
                    "objective_score": 3.3310146472210187
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a streamlined, robust bidirectional RRT* planner integrating adaptive step sizing, goal-biased sampling, and dynamic neighbor radius to efficiently explore the space while ensuring collision-free connections. It incrementally rewires nodes to improve path costs and applies iterative shortcut smoothing to enhance path quality. The simplification ensures clarity and generalization while maintaining high performance and path smoothness in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling points with a goal bias. It extends each tree towards samples using adaptive step sizes, selects optimal parents within a dynamic radius, rewires neighbors for cost reduction, and attempts connections between trees. Upon successful connection, the path is reconstructed and smoothed via shortcutting, producing efficient, smooth, and collision-free paths while respecting map boundaries and obstacle constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.4, radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def _near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def _steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def _can_connect(parent_node, new_pos):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = cost\n                    best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-9 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid repeating connection node\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for iteration in range(self.max_iter):\n            sample = _sample_free()\n\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            radius = min(self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim), self.step_size * 5)\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, self.step_size)\n            if not _can_connect(nearest_node_a, new_pos_a):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n\n            if dist <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution) and \\\n               not self._is_in_obstacle(new_node_a.position, obstacles, is_3d):\n                connecting_node_b = nearest_node_b\n                # Add connecting node if positions different\n                if nearest_node_b.position != new_node_a.position:\n                    connecting_node_b = Node(new_node_a.position)\n                    connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                    tree_b.append(connecting_node_b)\n                    nodes.append(connecting_node_b)\n                    edges.append((nearest_node_b, connecting_node_b))\n\n                near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                extracted_path = _smooth_path(extracted_path)\n                success_state = True\n                break\n\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, self.step_size)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3.05605,
          "time_improvement": -32.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01565694808959961,
                    "num_nodes_avg": 103.0,
                    "path_length_avg": 167.61993628715476,
                    "smoothness_avg": 0.029103129540041062,
                    "success_improvement": 0.0,
                    "time_improvement": -58.411208190006604,
                    "length_improvement": 16.225166922161304,
                    "smoothness_improvement": 179.6451805956212,
                    "objective_score": -13.380103169591612
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026642584800720216,
                    "num_nodes_avg": 319.5,
                    "path_length_avg": 248.92646848226113,
                    "smoothness_avg": 0.06676181421792608,
                    "success_improvement": 0.0,
                    "time_improvement": -75.56661963820555,
                    "length_improvement": 17.39777620035306,
                    "smoothness_improvement": 835.2688605868769,
                    "objective_score": -15.014086348456665
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017498159408569337,
                    "num_nodes_avg": 237.1,
                    "path_length_avg": 127.75970477863079,
                    "smoothness_avg": 0.11164852095134119,
                    "success_improvement": 0.0,
                    "time_improvement": 36.9911890377653,
                    "length_improvement": 21.547844891817284,
                    "smoothness_improvement": 763.8241479118915,
                    "objective_score": 19.226046429252506
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planning algorithm combines bidirectional search from the dual-tree RRT with asymptotically optimal rewiring from RRT*. It grows two trees from start and goal, alternately extending towards random samples and attempting connections. Each extension uses rewiring within a neighborhood radius to optimize paths locally. The goal biasing accelerates convergence. Collision and edge checks ensure validity. The hybrid approach improves planning efficiency, path quality, robustness, success rate, and smoothness by leveraging complementary strengths of both methods.",
          "planning_mechanism": "The planner maintains start and goal trees, grows them bidirectionally by sampling points and steering towards them. For each new node added, it finds neighbors within a radius to rewire and minimize cost. After each extension, it attempts to connect the two trees directly. If a connection is found without collision, the path is extracted. Goal biasing increases attempts towards the goal to speed up convergence. The algorithm terminates early upon a successful path or after max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, search_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        # Re-assign parent\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            # Try building connection backward from connect_node towards node_a\n            curr = connect_node\n            connection_chain = []\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                connection_chain.append(new_node)\n                if distance(new_pos, node_a.position) < self.step_size:\n                    # Final connect node\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_from_start, node_from_goal):\n            path_start = []\n            node = node_from_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_from_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        for iter_count in range(self.max_iter):\n            # Alternate tree selection for expanding\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Goal biasing on sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                # Boundary check\n                out_of_bounds = any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds)))\n                if out_of_bounds:\n                    continue\n\n                # Collision checks\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Find neighbors for rewiring\n                neighbors = find_near(tree_a, new_node, self.search_radius)\n                # Choose best parent\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = cost\n                            min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                # Rewire neighbors through new_node if better\n                rewire(tree_a, new_node, neighbors)\n\n                # Attempt to connect the other tree directly\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n        return PlannerResult(success_state, extracted_path, start_tree + goal_tree + nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.2445,
          "time_improvement": -28.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013188529014587402,
                    "num_nodes_avg": 194.0,
                    "path_length_avg": 173.0342779839435,
                    "smoothness_avg": 0.021996203295678553,
                    "success_improvement": 0.0,
                    "time_improvement": -33.436657226802765,
                    "length_improvement": 13.519130982034183,
                    "smoothness_improvement": 111.35638469997163,
                    "objective_score": -6.770389048134134
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024630069732666016,
                    "num_nodes_avg": 484.0,
                    "path_length_avg": 244.14905520536445,
                    "smoothness_avg": 0.015383195714505082,
                    "success_improvement": 0.0,
                    "time_improvement": -62.30475071249689,
                    "length_improvement": 18.9830835527118,
                    "smoothness_improvement": 115.50378905411706,
                    "objective_score": -14.317289557936123
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024231910705566406,
                    "num_nodes_avg": 405.4,
                    "path_length_avg": 130.81419641767454,
                    "smoothness_avg": 0.028347178181784644,
                    "success_improvement": 0.0,
                    "time_improvement": 12.743743770384414,
                    "length_improvement": 19.672203019772287,
                    "smoothness_improvement": 119.32200113298974,
                    "objective_score": 8.354173740734732
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT planner with optimized parameters to improve efficiency, path quality, and success rate. It features reduced step size for finer expansions, increased maximum iterations for deeper search, and a goal bias sampling probability to accelerate convergence. Collision checking is precise with a refined resolution, and post-planning path smoothing via shortcutting reduces unnecessary detours and improves smoothness.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions, alternately expanding each towards sampled points biased towards the goal. Each new node and edge is strictly checked for collision-free feasibility. When the trees connect, the planner reconstructs the path, smooths it by iteratively shortcutting, and returns the optimized trajectory along with explored graph data.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            import math\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _steer(from_pos, to_pos):\n            import math\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[i]:\n                    return False\n            return True\n\n        def _extend_tree(tree, point):\n            nearest_node = _nearest(tree, point)\n            new_pos = _steer(nearest_node.position, point)\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._distance(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def _connect_trees(tree, new_node):\n            nearest_node = _nearest(tree, new_node.position)\n            current = nearest_node\n            while True:\n                next_pos = _steer(current.position, new_node.position)\n                if (not _is_within_bounds(next_pos) or\n                    self._is_in_obstacle(next_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, next_pos, obstacles, is_3d, self.collision_resolution)):\n                    return None\n                next_node = Node(next_pos, parent=current, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if self._distance(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def _smooth_path(path):\n            import random\n            if len(path) <= 2:\n                return path\n            for _ in range(50):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = _sample_free()\n\n            new_a = _extend_tree(tree_a, rand_point)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = _connect_trees(tree_b, new_a)\n            if new_b:\n                success_state = True\n                extracted_path = _reconstruct_path(new_a, new_b)\n                extracted_path = _smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 4.6782,
          "time_improvement": -33.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010827350616455077,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 163.9683475002103,
                    "smoothness_avg": 0.014173695614508616,
                    "success_improvement": 0.0,
                    "time_improvement": -9.547127756576938,
                    "length_improvement": 18.050195900642194,
                    "smoothness_improvement": 36.19173375747664,
                    "objective_score": 0.9268595219427409
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03178107738494873,
                    "num_nodes_avg": 498.6,
                    "path_length_avg": 249.62854531281232,
                    "smoothness_avg": 0.0401662199932736,
                    "success_improvement": 0.0,
                    "time_improvement": -109.42774008867326,
                    "length_improvement": 17.164803355659895,
                    "smoothness_improvement": 462.6901432691145,
                    "objective_score": -27.081910639124423
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02228260040283203,
                    "num_nodes_avg": 378.2,
                    "path_length_avg": 125.71203140928696,
                    "smoothness_avg": 0.05507350730124254,
                    "success_improvement": 0.0,
                    "time_improvement": 19.762980565745675,
                    "length_improvement": 22.805239694513528,
                    "smoothness_improvement": 326.10349972973546,
                    "objective_score": 12.120459607275086
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a Bidirectional Adaptive Informed RRT* with Dynamic Neighborhood and Lazy Collision Checking. It dynamically adjusts the rewiring radius based on the current best path cost and tree density, employs informed sampling within an ellipsoidal heuristic region to focus exploration, and delays expensive collision checks on edges until absolutely necessary (lazy collision checking). It also alternates growth between start and goal trees, aggressively tries to connect trees whenever possible, and applies an efficient iterative shortcut smoothing to improve path quality and reduce runtimes. These strategies improve planning efficiency, path optimality, success rate, and robustness.",
          "planning_mechanism": "The planner initializes bidirectional trees from start and goal, samples points inside an informed ellipsoid computed from the best cost found so far, and progressively reduces the search space. It adaptively adjusts the neighbor radius for rewiring to balance exploration and exploitation. Nodes are lazily checked for edges' collisions only when rewiring or connection is attempted to save computation. Once the trees connect, a smooth path is extracted and refined using iterative shortcutting. This combination accelerates convergence to high-quality, collision-free paths with fewer samples and lower computational overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For lazy collision validation\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, radius_max: float=30.0,\n                 smooth_iter: int=50, collision_resolution: float=0.5, informed_sampling_rate: float=0.85):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max               # Max neighbor radius for rewiring\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def lazy_collision_free_edge(a, b, cache):\n            # cache is a dict storing edges checked: keys as (a_pos, b_pos) sorted tuple of positions\n            key = tuple(sorted([a, b]))\n            if key in cache:\n                return cache[key]\n            collision = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            cache[key] = not collision\n            return not collision\n\n        # Ellipsoidal informed sampling around start and goal with max cost c_max\n        def informed_sample(c_max, start, goal):\n            if math.isinf(c_max):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                c_max = c_min + 1e-6\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            if c_min == 0:\n                unit_vec = tuple(0 for _ in range(dim))\n            else:\n                unit_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s],[s, c]])\n                elif dim == 3:\n                    x_axis = np.array(vec)\n                    if np.linalg.norm(x_axis) < 1e-12:\n                        return np.eye(3)\n                    x_axis /= np.linalg.norm(x_axis)\n                    if abs(x_axis[0]) < 1e-6 and abs(x_axis[1]) < 1e-6:\n                        temp = np.array([0,1,0])\n                    else:\n                        temp = np.array([0,0,1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= np.linalg.norm(y_axis)\n                    z_axis = np.cross(x_axis, y_axis)\n                    return np.stack((x_axis, y_axis, z_axis), axis=1)\n                else:\n                    return np.eye(dim)\n\n            L = np.diag([c_max/2] + [math.sqrt(c_max**2 - c_min**2)/2]*(dim-1))\n            R = rotation_matrix(unit_vec)\n\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-12:\n                    continue\n                x_ball /= norm_x\n                r = np.random.uniform(0,1) ** (1/dim)\n                sample_ball = x_ball * r\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                p = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        # Iterative shortcut smoothing for path improvement\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i+1, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if lazy_collision_free_edge(p1, p2, collision_edge_cache):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Extract path from two connected nodes in start and goal trees\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        start_tree = [Node(start_position, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_position, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        best_path_cost = math.inf\n        best_nodes_pair = None\n\n        collision_edge_cache = dict()\n\n        def rewire(tree, new_node, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if tentative_cost < neighbor.cost:\n                    if lazy_collision_free_edge(new_node.position, neighbor.position, collision_edge_cache):\n                        # Remove old edge\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = tentative_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        # Main iteration loop\n        for iter in range(self.max_iter):\n            # Adaptive radius for rewiring based on log(n)/n (RRT* radius formula variant)\n            n = len(nodes)\n            gamma = self.radius_max\n            radius = min(gamma * (math.log(n + 1) / (n + 1)) ** (1/dim), self.radius_max)\n\n            # Adaptive informed sampling with probability\n            if random.random() < self.informed_sampling_rate:\n                sample = informed_sample(best_path_cost, start_position, goal_position)\n            else:\n                # Uniform random sample\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate growing start and goal trees each iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not collision_free_node(new_pos):\n                    continue\n                if not lazy_collision_free_edge(nearest_node.position, new_pos, collision_edge_cache):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                # Check nearby nodes in tree_a to choose best parent\n                neighbors = near(tree_a, new_pos, radius)\n                min_cost = new_cost\n                min_node = nearest_node\n                for neighbor in neighbors:\n                    cost_thru_neighbor = neighbor.cost + dist(neighbor.position, new_pos)\n                    if cost_thru_neighbor < min_cost and lazy_collision_free_edge(neighbor.position, new_pos, collision_edge_cache):\n                        min_cost = cost_thru_neighbor\n                        min_node = neighbor\n\n                new_node = Node(new_pos, parent=min_node, cost=min_cost)\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                rewire(tree_a, new_node, radius)\n\n                # Attempt to connect to other tree\n                nearest_in_other = nearest(tree_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_in_other.position)\n                if dist_to_other <= self.step_size:\n                    if lazy_collision_free_edge(new_node.position, nearest_in_other.position, collision_edge_cache):\n                        total_cost = new_node.cost + dist_to_other + nearest_in_other.cost\n                        if total_cost < best_path_cost:\n                            best_path_cost = total_cost\n                            best_nodes_pair = (new_node, nearest_in_other)\n\n            if best_nodes_pair is not None:\n                success_state = True\n                node_a, node_b = best_nodes_pair\n                extracted_path = extract_path(node_a, node_b)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 9.25217,
          "time_improvement": -48.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016823577880859374,
                    "num_nodes_avg": 124.7,
                    "path_length_avg": 181.0057098000428,
                    "smoothness_avg": 0.023313968234768005,
                    "success_improvement": 0.0,
                    "time_improvement": -70.21473680147821,
                    "length_improvement": 9.53508597773914,
                    "smoothness_improvement": 124.01848050197957,
                    "objective_score": -18.53731144238574
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019853615760803224,
                    "num_nodes_avg": 252.3,
                    "path_length_avg": 247.37377785996983,
                    "smoothness_avg": 0.03602037059660371,
                    "success_improvement": 0.0,
                    "time_improvement": -30.829355814823085,
                    "length_improvement": 17.913011478690922,
                    "smoothness_improvement": 404.610777290065,
                    "objective_score": -3.6431505622584157
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.039774298667907715,
                    "num_nodes_avg": 346.6,
                    "path_length_avg": 131.1930172650993,
                    "smoothness_avg": 0.10347192686467346,
                    "success_improvement": 0.0,
                    "time_improvement": -43.22256457981163,
                    "length_improvement": 19.4395841989017,
                    "smoothness_improvement": 700.5618730554656,
                    "objective_score": -5.57604316888582
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates the strengths of bidirectional RRT* with adaptive radius rewiring, goal biasing, and iterative shortcut smoothing for enhanced path quality and success rate. It alternates tree expansions, utilizes dynamic neighborhood radius decreasing with iterations, enforces rigorous collision checks, and applies progressive shortcut smoothing for smoother, shorter paths. Adaptive balancing of exploration and exploitation with efficient rewiring reduces search time and improves robustness and optimality in 2D/3D environments with obstacles.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points with goal biasing and steering within step size constraints. New nodes are collision-checked for validity, and edges are verified to avoid obstacles. It rewires neighbors within an adaptive radius to minimize path costs dynamically. Upon connecting the trees, it extracts the concatenated path and applies iterative shortcut smoothing to enhance path smoothness and reduce length, returning a collision-free, optimized route.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 20.0, goal_sample_rate: float = 0.12, smooth_iter: int = 50, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        edges = []\n        success = False\n        path = []\n\n        import math\n        import random\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.base_radius\n            gamma = self.base_radius\n            r = gamma * (math.log(n_nodes + 1) / (n_nodes + 1))**(1 / dim)\n            return min(r, self.base_radius)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            return within_bounds(b) and not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # For faster rejection, mark nodes in spatial index could be implemented (optional)\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal biasing sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample) or self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not collision_free_node(new_pos):\n                continue\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                if n == nearest_node:\n                    continue\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors to new node where cheaper\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, n.position)\n                if new_cost < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Try connect trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_connect = dist(new_node.position, nearest_in_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    success = True\n                    path = extract_path(new_node, nearest_in_b)\n                    path = shortcut_smooth(path)\n                    nodes_all = nodes_start + nodes_goal\n                    return PlannerResult(success, path, nodes_all, edges)\n\n        # If no connection after max_iter\n        nodes_all = nodes_start + nodes_goal\n        return PlannerResult(success, path, nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 9.62493,
          "time_improvement": -52.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014689040184020997,
                    "num_nodes_avg": 115.5,
                    "path_length_avg": 168.54000177658935,
                    "smoothness_avg": 0.024743471431160916,
                    "success_improvement": 0.0,
                    "time_improvement": -48.61827409698133,
                    "length_improvement": 15.765327033748399,
                    "smoothness_improvement": 137.75424314452695,
                    "objective_score": -10.743645606622085
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021230125427246095,
                    "num_nodes_avg": 252.5,
                    "path_length_avg": 246.92508543790282,
                    "smoothness_avg": 0.055716171628438796,
                    "success_improvement": 0.0,
                    "time_improvement": -39.90014045694068,
                    "length_improvement": 18.061902804272982,
                    "smoothness_improvement": 680.5300225229797,
                    "objective_score": -4.95501146361271
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04679288864135742,
                    "num_nodes_avg": 417.9,
                    "path_length_avg": 134.13341490846713,
                    "smoothness_avg": 0.11233766839957926,
                    "success_improvement": 0.0,
                    "time_improvement": -68.49568037060473,
                    "length_improvement": 17.634002913339643,
                    "smoothness_improvement": 769.1560788876664,
                    "objective_score": -13.176123134075159
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a simplified yet robust bidirectional RRT* planner combining key strengths from enhanced RRT and RRT* variants. It balances exploration and path optimality using adaptive step sizes, goal-biased sampling, dynamic nearest-neighbor radius, and incremental rewiring. It ensures collision-free node additions and edge connections, reconstructs the path on successful tree connection, and applies iterative shortcut smoothing to yield efficient, smooth, and relatively short trajectories.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling free points with goal bias. New nodes choose optimal parents within a dynamic radius based on cost and collision checks, and neighbors are rewired incrementally for cost improvement. When the trees connect, the algorithm reconstructs and smooths the path, delivering high-quality results efficiently while respecting bounds and obstacle constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 initial_step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 collision_resolution: float = 0.4,\n                 radius_constant: float = 25.0):\n        self.max_iter = max_iter\n        self.initial_step_size = initial_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n        self.radius_constant = radius_constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def _near_nodes(tree, point, radius):\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def _steer(from_pos, to_pos, step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def _can_connect(parent_node, new_pos):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = cost\n                    best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid repeating connecting node\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample = _sample_free()\n\n            step_size_ratio = 1.0\n            if i > self.max_iter // 2:\n                step_size_ratio = max(0.3, 1.0 - (i - self.max_iter // 2) / (self.max_iter // 2))\n            step_size = self.initial_step_size * step_size_ratio\n\n            n_nodes = len(nodes)\n            dim = len(bounds)\n            radius = min(\n                self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim),\n                step_size * 5)\n\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample, step_size)\n            if not _can_connect(nearest_node_a, new_pos_a):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            near_nodes_a = _near_nodes(tree_a, new_pos_a, radius)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.parent = None\n            new_node_a.cost = 0\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n\n            if dist <= step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution) and \\\n               not self._is_in_obstacle(new_node_a.position, obstacles, is_3d):\n                connecting_node_b = None\n                if nearest_node_b.position != new_node_a.position:\n                    connecting_node_b = Node(new_node_a.position)\n                    connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                    tree_b.append(connecting_node_b)\n                    nodes.append(connecting_node_b)\n                    edges.append((nearest_node_b, connecting_node_b))\n                else:\n                    connecting_node_b = nearest_node_b\n\n                near_nodes_b = _near_nodes(tree_b, connecting_node_b.position, radius)\n                _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                extracted_path = _smooth_path(extracted_path)\n                success_state = True\n                break\n\n            else:\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position, step_size)\n                if _can_connect(nearest_node_b, new_pos_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b, radius)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.parent = None\n                    new_node_b.cost = 0\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 10.568,
          "time_improvement": -59.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01592907905578613,
                    "num_nodes_avg": 118.3,
                    "path_length_avg": 167.28860831423978,
                    "smoothness_avg": 0.02976413116325912,
                    "success_improvement": 0.0,
                    "time_improvement": -61.16452862594497,
                    "length_improvement": 16.390761458466454,
                    "smoothness_improvement": 185.99659094977213,
                    "objective_score": -14.141223341341338
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02226698398590088,
                    "num_nodes_avg": 270.4,
                    "path_length_avg": 242.10591955888017,
                    "smoothness_avg": 0.08075792718660424,
                    "success_improvement": 0.0,
                    "time_improvement": -46.732726467178004,
                    "length_improvement": 19.661065082570513,
                    "smoothness_improvement": 1031.3409533273707,
                    "objective_score": -4.930900157002443
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04722607135772705,
                    "num_nodes_avg": 453.6,
                    "path_length_avg": 133.22746545091334,
                    "smoothness_avg": 0.13562652951431517,
                    "success_improvement": 0.0,
                    "time_improvement": -70.05552030865412,
                    "length_improvement": 18.19031045559119,
                    "smoothness_improvement": 949.3419016541206,
                    "objective_score": -12.631884493207393
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements an enhanced Bidirectional Informed RRT* planner that combines bidirectional search with heuristic-informed sampling within an ellipsoidal subset of the space defined by the current best path cost to the goal. The planner alternately grows trees from the start and goal positions, selectively sampling points that are likely to improve the current solution, while performing rewiring in a local neighborhood to optimize path cost. Once a feasible path is found, we apply a path smoothing step using iterative shortcutting. This approach focuses search efforts, improves path quality and smoothness, increases success rates, and reduces planning time by avoiding unnecessary exploration outside promising regions.",
          "planning_mechanism": "The planner begins by initializing two trees, one from the start and one from the goal. It maintains the best path cost found so far and limits random sampling to an informed ellipsoidal region determined by this cost, progressively guiding the search towards optimality. Each iteration samples a node, extends the trees towards the sample with step limits and collision checks, and rewires nearby nodes to improve costs. When the two trees connect, the path is extracted and smoothed by attempting shortcuts that skip unnecessary waypoints, balancing efficiency with path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, radius: float=15.0, smooth_iter: int=40, collision_resolution: float=0.5, informed_sampling_rate: float=0.9):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.smooth_iter = smooth_iter\n        self.collision_resolution = collision_resolution\n        self.informed_sampling_rate = informed_sampling_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_path_cost = math.inf\n        best_connect_nodes = None\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def collision_free_node(pos):\n            return within_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(a, b):\n            # ensure edge is within bounds and free of obstacles\n            if not within_bounds(b):\n                return False\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution):\n                return False\n            return True\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def rewire(tree, new_node):\n            for near_node in near(tree, new_node.position, self.radius):\n                if near_node == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if tentative_cost < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    # Remove old edge\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    # Re-parent\n                    near_node.parent = new_node\n                    near_node.cost = tentative_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        def informed_sample(c_max, start, goal):\n            # If no solution yet, sample uniformly\n            if math.isinf(c_max):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # Define ellipsoid parameters\n            c_min = dist(start, goal)\n            if c_max < c_min:\n                # Safety fallback\n                c_max = c_min + 1e-6\n\n            # Center of ellipse - midpoint\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n\n            # Unit vector from start to goal\n            if c_min == 0.0:\n                unit_vec = tuple(0 for _ in range(dim))\n            else:\n                unit_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            # Create rotation matrix that aligns the x-axis with unit_vec\n            # For 2D and 3D, implement accordingly:\n            import numpy as np\n\n            def rotation_matrix(vec):\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    c, s = math.cos(angle), math.sin(angle)\n                    return np.array([[c, -s], [s, c]])\n                elif dim == 3:\n                    # Create orthonormal basis using unit_vec as x-axis\n                    x_axis = np.array(vec)\n                    x_axis /= np.linalg.norm(x_axis)\n                    # Pick y_axis arbitrarily perpendicular to x_axis\n                    if abs(x_axis[0]) < 1e-6 and abs(x_axis[1]) < 1e-6:\n                        temp = np.array([0,1,0])\n                    else:\n                        temp = np.array([0,0,1])\n                    y_axis = np.cross(temp, x_axis)\n                    y_axis /= np.linalg.norm(y_axis)\n                    z_axis = np.cross(x_axis, y_axis)\n                    rot = np.stack((x_axis, y_axis, z_axis), axis=1)\n                    return rot\n                else:\n                    return np.eye(dim)\n\n            L = np.diag([c_max / 2] + [math.sqrt(c_max ** 2 - c_min ** 2) / 2] * (dim - 1))\n            R = rotation_matrix(unit_vec)\n\n            while True:\n                # Sample uniformly in unit n-ball\n                x_ball = np.random.normal(0,1,dim)\n                x_ball /= np.linalg.norm(x_ball)\n                u = np.random.uniform(0,1)\n                r = u ** (1/dim)\n                sample_ball = x_ball * r\n\n                # Map to ellipse\n                sample_ellipsoid = center + R.dot(L.dot(sample_ball))\n                p = tuple(float(sample_ellipsoid[i]) for i in range(dim))\n\n                if within_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(self.smooth_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if collision_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        for iter in range(self.max_iter):\n            if random.random() < self.informed_sampling_rate:\n                sample = informed_sample(best_path_cost, start_position, goal_position)\n            else:\n                # Uniform sampling fallback\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            # Alternate tree expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if not collision_free_node(new_pos):\n                    continue\n                if not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                # Try to connect trees\n                nearest_to_new = nearest(tree_b, new_node.position)\n                dist_between = dist(new_node.position, nearest_to_new.position)\n                if dist_between <= self.step_size and collision_free_edge(new_node.position, nearest_to_new.position):\n                    # Candidate path found\n                    total_cost = new_node.cost + dist_between + nearest_to_new.cost\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connect_nodes = (new_node, nearest_to_new)\n\n            if best_connect_nodes is not None:\n                success_state = True\n                node_a, node_b = best_connect_nodes\n                extracted_path = extract_path(node_a, node_b)\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 11.19606,
          "time_improvement": -55.0,
          "length_improvement": 16.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021587777137756347,
                    "num_nodes_avg": 157.9,
                    "path_length_avg": 183.3875957340989,
                    "smoothness_avg": 0.021361840675895825,
                    "success_improvement": 0.0,
                    "time_improvement": -118.41714227820741,
                    "length_improvement": 8.344642281386934,
                    "smoothness_improvement": 105.26094231367485,
                    "objective_score": -33.329909515616464
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023389148712158202,
                    "num_nodes_avg": 258.6,
                    "path_length_avg": 240.93696232439032,
                    "smoothness_avg": 0.0498137605068275,
                    "success_improvement": 0.0,
                    "time_improvement": -54.12745446147175,
                    "length_improvement": 20.048964640557564,
                    "smoothness_improvement": 597.8429147939263,
                    "objective_score": -9.23922883636038
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025303339958190917,
                    "num_nodes_avg": 266.2,
                    "path_length_avg": 128.69703998265706,
                    "smoothness_avg": 0.06774769573343979,
                    "success_improvement": 0.0,
                    "time_improvement": 8.885653232875372,
                    "length_improvement": 20.972264610522455,
                    "smoothness_improvement": 424.1636435599348,
                    "objective_score": 8.980967109766777
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the bidirectional search strategy from the enhanced bidirectional RRT with the incremental rewiring and local path optimization of RRT*. It grows two trees from start and goal, alternately expanding toward sampled points with goal bias. New nodes choose parents through cost minimization within a neighbor radius, and rewire nearby nodes to reduce path costs. Upon connecting the two trees, the solution path is reconstructed and smoothed via iterative shortcutting to improve path quality and smoothness, balancing exploration, optimality, and efficiency.",
          "planning_mechanism": "The planner alternates growing two trees towards random samples biased to the goal. Each new node chooses the best parent within a neighborhood to minimize cost, rewires neighbors for better paths, and checks collision at nodes and edges. When the two trees connect, the path is extracted and smoothed by shortcutting to yield a high-quality trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start/goal root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float=4.0, goal_sample_rate: float=0.1, neighbor_radius: float=8.0, collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # list of obstacle boxes\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        # Helper functions\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def _near_nodes(tree, point):\n            return [node for node in tree if math.dist(node.position, point) <= self.neighbor_radius]\n\n        def _steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def _is_within_bounds(pos):\n            for i, c in enumerate(pos):\n                if c < 0 or c > bounds[i]:\n                    return False\n            return True\n\n        def _can_connect(parent_node, new_pos, tree):\n            if (not _is_within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d, self.collision_resolution)):\n                return False\n            return True\n\n        def _choose_parent(tree, new_pos, nearest_node, near_nodes):\n            import math\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node == nearest_node:\n                    continue\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def _rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.collision_resolution):\n                        edges.remove((node.parent, node))\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n        def _reconstruct_path(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # node_b path from root is from goal to connecting point, reverse it excluding connecting node to avoid duplication\n            return path_a + path_b[-2::-1]\n\n        def _smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n\n        # Main loop - alternate between tree expansions\n        for i in range(self.max_iter):\n            # Sample point (goal bias applied inside _sample_free)\n            sample = _sample_free()\n\n            # Extend tree_a towards sample\n            nearest_node_a = _nearest(tree_a, sample)\n            new_pos_a = _steer(nearest_node_a.position, sample)\n            if not _can_connect(nearest_node_a, new_pos_a, tree_a):\n                tree_a, tree_b = tree_b, tree_a  # swap trees if extension fails\n                continue\n\n            # Determine neighbors and best parent for new node in tree_a\n            near_nodes_a = _near_nodes(tree_a, new_pos_a)\n            best_parent_a, best_cost_a = _choose_parent(tree_a, new_pos_a, nearest_node_a, near_nodes_a)\n\n            new_node_a = Node(new_pos_a)\n            new_node_a.parent = None\n            new_node_a.cost = 0\n            new_node_a.update_parent(best_parent_a, best_cost_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((best_parent_a, new_node_a))\n\n            # Rewire neighbors in tree_a via new_node_a\n            _rewire(tree_a, new_node_a, near_nodes_a)\n\n            # Try connecting tree_b to new_node_a\n            nearest_node_b = _nearest(tree_b, new_node_a.position)\n            dist = math.dist(nearest_node_b.position, new_node_a.position)\n            if dist <= self.step_size:\n                if (not self._is_edge_in_obstacle(nearest_node_b.position, new_node_a.position, obstacles, is_3d, self.collision_resolution)\n                    and not self._is_in_obstacle(new_node_a.position, obstacles, is_3d)):\n                    # Connected, create connecting node in tree_b if needed\n                    connecting_node_b = None\n                    if nearest_node_b.position != new_node_a.position:\n                        connecting_node_b = Node(new_node_a.position)\n                        connecting_node_b.update_parent(nearest_node_b, nearest_node_b.cost + dist)\n                        tree_b.append(connecting_node_b)\n                        nodes.append(connecting_node_b)\n                        edges.append((nearest_node_b, connecting_node_b))\n                    else:\n                        connecting_node_b = nearest_node_b\n\n                    # Rewire tree_b neighbors around connecting_node_b\n                    near_nodes_b = _near_nodes(tree_b, connecting_node_b.position)\n                    _rewire(tree_b, connecting_node_b, near_nodes_b)\n\n                    # Reconstruct full path from start_root to goal_root\n                    success_state = True\n                    extracted_path = _reconstruct_path(new_node_a, connecting_node_b)\n                    extracted_path = _smooth_path(extracted_path)\n                    break\n            else:\n                # If not connected yet, try to extend tree_b toward new_node_a\n                new_pos_b = _steer(nearest_node_b.position, new_node_a.position)\n                if _can_connect(nearest_node_b, new_pos_b, tree_b):\n                    near_nodes_b = _near_nodes(tree_b, new_pos_b)\n                    best_parent_b, best_cost_b = _choose_parent(tree_b, new_pos_b, nearest_node_b, near_nodes_b)\n\n                    new_node_b = Node(new_pos_b)\n                    new_node_b.parent = None\n                    new_node_b.cost = 0\n                    new_node_b.update_parent(best_parent_b, best_cost_b)\n                    tree_b.append(new_node_b)\n                    nodes.append(new_node_b)\n                    edges.append((best_parent_b, new_node_b))\n\n                    _rewire(tree_b, new_node_b, near_nodes_b)\n\n            tree_a, tree_b = tree_b, tree_a  # swap trees for next iteration\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 13.19292,
          "time_improvement": -68.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01825902462005615,
                    "num_nodes_avg": 139.7,
                    "path_length_avg": 170.53916823025477,
                    "smoothness_avg": 0.03657085421153936,
                    "success_improvement": 0.0,
                    "time_improvement": -84.73805583832261,
                    "length_improvement": 14.766162855188394,
                    "smoothness_improvement": 251.40080438605742,
                    "objective_score": -21.21118015852882
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03545658588409424,
                    "num_nodes_avg": 388.8,
                    "path_length_avg": 234.62398934310326,
                    "smoothness_avg": 0.07992438153248214,
                    "success_improvement": 0.0,
                    "time_improvement": -133.64823549004393,
                    "length_improvement": 22.143822653129895,
                    "smoothness_improvement": 1019.6637797318008,
                    "objective_score": -30.567387217728196
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02384152412414551,
                    "num_nodes_avg": 283.0,
                    "path_length_avg": 121.90768417505406,
                    "smoothness_avg": 0.08857985352242485,
                    "success_improvement": 0.0,
                    "time_improvement": 14.14947986734191,
                    "length_improvement": 25.14133807406572,
                    "smoothness_improvement": 585.3419627879955,
                    "objective_score": 12.199821388955696
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a streamlined bidirectional RRT* planner that grows two trees from start and goal positions, alternately sampling and extending nodes while rewiring neighbor connections to optimize path costs. It integrates goal biasing, adaptive neighborhood radius, and collision checking to ensure validity and improves path quality by shortcut smoothing once a connection is found.",
          "planning_mechanism": "The planner alternately expands two trees toward random or goal-biased samples, adding new nodes only if they and their connecting edges are collision-free. It rewires neighbors within an adaptive radius to maintain near-optimal paths and attempts to connect the two trees when nodes are proximal. Upon successful connection, the shortest path is extracted and smoothed for improved length and navigation feasibility.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, base_radius: float = 15.0, goal_sample_rate: float = 0.1, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import math\n        import random\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1/dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(75):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        success = False\n        final_path = []\n\n        for i in range(self.max_iter):\n            expand_start_tree = (i % 2 == 0)\n            tree_a = nodes_start if expand_start_tree else nodes_goal\n            tree_b = nodes_goal if expand_start_tree else nodes_start\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if expand_start_tree else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative = n.cost + dist(n.position, new_pos)\n                if tentative < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt connection\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    success = True\n                    final_path = extract_path(new_node, nearest_in_b)\n                    final_path = smooth_path(final_path)\n                    all_nodes = nodes_start + nodes_goal\n                    return PlannerResult(success, final_path, all_nodes, edges)\n\n        all_nodes = nodes_start + nodes_goal\n        return PlannerResult(success, final_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 13.86995,
          "time_improvement": -68.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01863260269165039,
                    "num_nodes_avg": 142.8,
                    "path_length_avg": 171.92176789776113,
                    "smoothness_avg": 0.024019109485770608,
                    "success_improvement": 0.0,
                    "time_improvement": -88.51778055452367,
                    "length_improvement": 14.075152830220997,
                    "smoothness_improvement": 130.79401823962203,
                    "objective_score": -23.086333509114787
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029965639114379883,
                    "num_nodes_avg": 345.7,
                    "path_length_avg": 237.0964916805226,
                    "smoothness_avg": 0.06793544900345658,
                    "success_improvement": 0.0,
                    "time_improvement": -97.46454797688587,
                    "length_improvement": 21.32336272909728,
                    "smoothness_improvement": 851.7103560954502,
                    "objective_score": -20.716140066769054
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03295423984527588,
                    "num_nodes_avg": 374.8,
                    "path_length_avg": 128.09774808117234,
                    "smoothness_avg": 0.10401656939575891,
                    "success_improvement": 0.0,
                    "time_improvement": -18.664336078585244,
                    "length_improvement": 21.34026593998561,
                    "smoothness_improvement": 704.7757700809042,
                    "objective_score": 2.1926312148260703
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a generalized bidirectional RRT* planner that grows two trees from start and goal positions. It balances exploration and path quality using adaptive neighborhood radius rewiring and goal-biased sampling. The planner incrementally extends toward random free samples, checks collision for nodes and edges, rewires locally to optimize costs, and attempts to connect the two trees. Upon successful connection, it extracts and shortcut-smooths the final path to enhance smoothness and length, ensuring efficient, robust planning in both 2D and 3D environments.",
          "planning_mechanism": "The planner alternates growing start and goal trees by steering towards sampled points biased towards the goals. It dynamically adjusts neighborhood radius for rewiring to improve path costs, avoids collisions through node and edge checks, and incrementally attempts to connect the trees. Once connected, the combined path is smoothed by shortcutting collision-free segments, delivering an optimized feasible path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, base_radius: float=15.0, goal_sample_rate: float=0.15, resolution: float=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.resolution = resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        import math\n        import random\n        from math import log\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n):\n            if n == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n + 1) / (n + 1))**(1/dim), self.base_radius)\n\n        def extract_path(node_s, node_g):\n            return node_s.path_from_root() + node_g.path_from_root()[::-1]\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path)-2)\n                j = random.randint(i+1, len(path)-1)\n                if j == i+1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors for cost optimization\n            for n in neighbors:\n                if n == min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Attempt incremental connection between trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.resolution):\n                    curr = nearest_in_b\n                    connected = False\n                    while True:\n                        next_pos = steer(curr.position, new_node.position)\n                        if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr.position, next_pos, obstacles, is_3d, self.resolution):\n                            break\n                        new_connect_node = Node(next_pos, parent=curr, cost=curr.cost + dist(curr.position, next_pos))\n                        curr.add_child(new_connect_node)\n                        tree_b.append(new_connect_node)\n                        edges.append((curr, new_connect_node))\n                        curr = new_connect_node\n                        if dist(curr.position, new_node.position) <= self.step_size:\n                            final_node = Node(new_node.position, parent=curr, cost=curr.cost + dist(curr.position, new_node.position))\n                            curr.add_child(final_node)\n                            tree_b.append(final_node)\n                            edges.append((curr, final_node))\n                            connected = True\n                            nearest_in_b = final_node\n                            break\n                    if connected:\n                        path = extract_path(new_node, nearest_in_b)\n                        smooth_path = shortcut_smooth(path)\n                        return PlannerResult(True, smooth_path, nodes_start + nodes_goal, edges)\n\n        return PlannerResult(False, [], nodes_start + nodes_goal, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 15.19604,
          "time_improvement": -76.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02285010814666748,
                    "num_nodes_avg": 138.3,
                    "path_length_avg": 170.9212079165824,
                    "smoothness_avg": 0.030129831036826288,
                    "success_improvement": 0.0,
                    "time_improvement": -131.1889404034215,
                    "length_improvement": 14.575223091935067,
                    "smoothness_improvement": 189.51051569957556,
                    "objective_score": -35.49408492414155
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034113621711730956,
                    "num_nodes_avg": 292.7,
                    "path_length_avg": 242.4404968858283,
                    "smoothness_avg": 0.10324708301126699,
                    "success_improvement": 0.0,
                    "time_improvement": -124.79850556328888,
                    "length_improvement": 19.550041006234384,
                    "smoothness_improvement": 1346.3924148564888,
                    "objective_score": -26.79758139345735
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019724082946777344,
                    "num_nodes_avg": 218.3,
                    "path_length_avg": 130.38451048580114,
                    "smoothness_avg": 0.11693300811241225,
                    "success_improvement": 0.0,
                    "time_improvement": 28.975900563101437,
                    "length_improvement": 19.936056066658583,
                    "smoothness_improvement": 804.7102033666969,
                    "objective_score": 16.703532399095632
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a simplified yet effective bidirectional RRT* variant that balances rapid exploration with path quality optimization. It grows two trees from the start and goal positions, incrementally extending them towards sampled points with goal biasing. Each new node connects to the best parent within a neighborhood radius to minimize cost, followed by rewiring neighbors to improve local paths. Collision and edge checks ensure all expansions are valid. The planner terminates early upon successfully connecting the two trees, providing an optimized, smooth path.",
          "planning_mechanism": "The planner alternately grows the start and goal trees by sampling free points (biased towards the goal), steering towards them with a fixed step size without crossing obstacles or boundaries. It rewires neighbors within a specified radius to improve path costs, and attempts to directly connect the two trees after each extension. The output is the lowest-cost feasible path between start and goal.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from start node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, search_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_a, tree_b):\n            connect_node = find_nearest(tree_b, node_a.position)\n            if self._is_edge_in_obstacle(node_a.position, connect_node.position, obstacles, is_3d):\n                return None\n            # Extend backward from connect_node toward node_a until close enough\n            curr = connect_node\n            while True:\n                new_pos = steer(curr.position, node_a.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                if distance(new_pos, node_a.position) < self.step_size:\n                    final_node = Node(node_a.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_a.position))\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def extract_bidirectional_path(node_from_start, node_from_goal):\n            path_start = []\n            node = node_from_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_from_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        for _ in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position if tree_a is start_tree else start_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                neighbors = find_near(tree_a, new_node, self.search_radius)\n\n                min_cost = nearest.cost + distance(nearest.position, new_pos)\n                min_node = nearest\n                for node in neighbors:\n                    edge_cost = distance(node.position, new_pos)\n                    cost = node.cost + edge_cost\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_node = node\n\n                new_node.parent = min_node\n                new_node.cost = min_cost\n                min_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_node, new_node))\n\n                rewire(tree_a, new_node, neighbors)\n\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        extracted_path = extract_bidirectional_path(new_node, connect_node)\n                    else:\n                        extracted_path = extract_bidirectional_path(connect_node, new_node)\n                    return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 16.34412,
          "time_improvement": -68.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011444926261901855,
                    "num_nodes_avg": 168.2,
                    "path_length_avg": 169.95961264646039,
                    "smoothness_avg": 0.02059908963009557,
                    "success_improvement": 0.0,
                    "time_improvement": -15.795529653555382,
                    "length_improvement": 15.05581916557219,
                    "smoothness_improvement": 97.93184550094732,
                    "objective_score": -1.23783583544744
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02688333988189697,
                    "num_nodes_avg": 494.8,
                    "path_length_avg": 246.73029177810767,
                    "smoothness_avg": 0.014413332321784414,
                    "success_improvement": 0.0,
                    "time_improvement": -77.15312320304668,
                    "length_improvement": 18.12654193075582,
                    "smoothness_improvement": 101.91693493907081,
                    "objective_score": -19.011043900067484
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.058880853652954104,
                    "num_nodes_avg": 659.8,
                    "path_length_avg": 128.2792857011045,
                    "smoothness_avg": 0.027857580387390345,
                    "success_improvement": 0.0,
                    "time_improvement": -112.02301856371788,
                    "length_improvement": 21.22879090533705,
                    "smoothness_improvement": 115.53398500918892,
                    "objective_score": -28.783477463002008
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates the strengths of enhanced bidirectional RRT* with adaptive rewiring, goal biasing, and shortcut smoothing alongside the efficient dual-tree expansion strategy of bidirectional RRT. It uses adaptive neighborhood radius for rewiring to optimize path cost, goal biasing for directed sampling, and incremental tree connection attempts to efficiently find shorter, smoother, and collision-free paths. The combined approach improves planning efficiency, robustness, and path quality in 2D/3D obstacle-laden environments.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions, sampling points with a goal bias to guide exploration. Each new node is added after collision and edge checks, selecting the best parent in an adaptive neighborhood and rewiring neighbors to reduce costs. After node addition, the algorithm tries to connect the two trees within step-size distance. Upon successful connection, it reconstructs the path by joining both trees and performs shortcut smoothing to improve path smoothness and length, returning the final plan promptly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 15.0,\n                 goal_sample_rate: float = 0.15, collision_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        import random\n        import math\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1 / dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            # Find nearest node & steer towards sample\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            # Adaptive radius neighbors\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose parent with lowest cost + collision-free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewire neighbors to reduce cost\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Try to connect trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    # Connect the two trees via incremental extension from nearest_in_b towards new_node.position\n                    curr = nearest_in_b\n                    connected = False\n                    while True:\n                        next_pos = steer(curr.position, new_node.position)\n                        if self._is_in_obstacle(next_pos, obstacles, is_3d) or \\\n                           self._is_edge_in_obstacle(curr.position, next_pos, obstacles, is_3d, self.collision_resolution):\n                            break\n                        new_connect_node = Node(next_pos, parent=curr, cost=curr.cost + dist(curr.position, next_pos))\n                        curr.add_child(new_connect_node)\n                        tree_b.append(new_connect_node)\n                        edges.append((curr, new_connect_node))\n                        curr = new_connect_node\n                        if dist(curr.position, new_node.position) <= self.step_size:\n                            final_node = Node(new_node.position, parent=curr, cost=curr.cost + dist(curr.position, new_node.position))\n                            curr.add_child(final_node)\n                            tree_b.append(final_node)\n                            edges.append((curr, final_node))\n                            connected = True\n                            nearest_in_b = final_node\n                            break\n                    if connected:\n                        path = extract_path(new_node, nearest_in_b)\n                        path = smooth_path(path)\n                        extracted_path = path\n                        success_state = True\n                        nodes = nodes_start + nodes_goal\n                        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        nodes = nodes_start + nodes_goal\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 19.92914,
          "time_improvement": -90.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028511476516723634,
                    "num_nodes_avg": 162.5,
                    "path_length_avg": 176.83102139908817,
                    "smoothness_avg": 0.03305597602327,
                    "success_improvement": 0.0,
                    "time_improvement": -188.46857104261446,
                    "length_improvement": 11.62155511553206,
                    "smoothness_improvement": 217.6271600644781,
                    "objective_score": -53.128124489355535
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03005070686340332,
                    "num_nodes_avg": 286.5,
                    "path_length_avg": 242.17380898117318,
                    "smoothness_avg": 0.08015368382182168,
                    "success_improvement": 0.0,
                    "time_improvement": -98.0251188542233,
                    "length_improvement": 19.638537075452316,
                    "smoothness_improvement": 1022.8760844510899,
                    "objective_score": -20.365447818921073
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02315089702606201,
                    "num_nodes_avg": 243.1,
                    "path_length_avg": 126.78895527027764,
                    "smoothness_avg": 0.12372883090734614,
                    "success_improvement": 0.0,
                    "time_improvement": 16.63634670016029,
                    "length_improvement": 22.14394356888038,
                    "smoothness_improvement": 857.289456411638,
                    "objective_score": 13.706140005882354
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner is a simplified yet efficient bidirectional RRT* inspired algorithm combining bidirectional tree growth, goal biasing, adaptive sampling, and local rewiring within a dynamically scaled neighborhood radius. It balances exploration and exploitation by sampling near the current best path and the goal, connects trees early when possible, and improves path quality through rewiring and shortcutting.",
          "planning_mechanism": "The algorithm grows two trees alternately from start and goal positions, sampling points with goal bias and informed sampling near the best path found so far. Each new node picks the best parent from nearby nodes within an adaptive radius to minimize cost, then locally rewires neighbors to optimize paths. The trees attempt to connect after each extension. Upon success, the path is extracted and smoothed by shortcutting, providing efficient and high-quality trajectories while guaranteeing collision-free and boundary-adherent paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, min_radius: float = 10.0, max_radius: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            dist = distance(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            ratio = max_step / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def find_near(tree, new_node, radius):\n            return [node for node in tree if distance(node.position, new_node.position) <= radius]\n\n        def adaptive_radius(iter_idx):\n            scale = min(1.0, iter_idx / (self.max_iter / 2))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r)\n\n        def informed_sample():\n            # If no best path, sample uniformly\n            if best_cost == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            import numpy as np\n            dim = len(bounds)\n            start_np = np.array(start_pos)\n            goal_np = np.array(goal_pos)\n            c_min = distance(start_pos, goal_pos)\n            c_best = max(best_cost, c_min + 1e-6)\n            center = (start_np + goal_np) / 2\n            a1 = (goal_np - start_np) / c_min\n\n            while True:\n                # Sample unit ball\n                direction = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(direction)\n                if norm == 0:\n                    continue\n                direction /= norm\n                radius = random.uniform(0, 1) ** (1 / dim)\n                point_ball = radius * direction\n\n                # Create orthonormal basis\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1))\n                sample = U @ L @ point_ball + center\n                sample = np.clip(sample, [0] * dim, bounds)\n                sample_t = tuple(float(v) for v in sample)\n                if not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                    return sample_t\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i + 1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def attempt_connect(node_from, other_tree):\n            nearest_other = find_nearest(other_tree, node_from.position)\n            if self._is_edge_in_obstacle(node_from.position, nearest_other.position, obstacles, is_3d):\n                return None\n\n            curr = nearest_other\n            while True:\n                new_pos = steer(curr.position, node_from.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=curr, cost=curr.cost + distance(curr.position, new_pos))\n                curr.add_child(new_node)\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n\n                if distance(new_pos, node_from.position) < self.step_size * 1.01:\n                    final_node = Node(node_from.position, parent=new_node, cost=new_node.cost + distance(new_pos, node_from.position))\n                    new_node.add_child(final_node)\n                    other_tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                curr = new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                edge_cost = distance(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iter_idx in range(self.max_iter):\n            # Alternate tree growth order every iteration\n            growing_orders = [(start_tree, goal_tree), (goal_tree, start_tree)] if iter_idx % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            for tree_a, tree_b in growing_orders:\n                # Sampling with goal bias and informed sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    if best_cost < float('inf') and random.random() < 0.6:\n                        sample = informed_sample()\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = find_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest.cost + distance(nearest.position, new_pos)\n                new_node = Node(new_pos, cost=tentative_cost)\n\n                radius = adaptive_radius(iter_idx)\n                neighbors = find_near(tree_a, new_node, radius)\n\n                # Select minimal cost parent from neighbors\n                min_cost = tentative_cost\n                min_parent = nearest\n                for n in neighbors:\n                    edge_c = distance(n.position, new_node.position)\n                    c = n.cost + edge_c\n                    if c + 1e-7 < min_cost and not self._is_edge_in_obstacle(n.position, new_node.position, obstacles, is_3d):\n                        min_cost = c\n                        min_parent = n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors)\n\n                connect_node = attempt_connect(new_node, tree_b)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, connect_node)\n                    else:\n                        path = extract_path(connect_node, new_node)\n\n                    path_cost = 0.0\n                    for i in range(len(path) - 1):\n                        path_cost += distance(path[i], path[i + 1])\n\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = path\n\n                    extracted_path = shortcut_path(best_path)\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        if best_path:\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 21.2552,
          "time_improvement": -99.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023629164695739745,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 168.44793223574646,
                    "smoothness_avg": 0.04471091512583583,
                    "success_improvement": 0.0,
                    "time_improvement": -139.07114634040437,
                    "length_improvement": 15.811342505335576,
                    "smoothness_improvement": 329.61675024528,
                    "objective_score": -36.91099164982779
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031334757804870605,
                    "num_nodes_avg": 226.0,
                    "path_length_avg": 231.10272343163825,
                    "smoothness_avg": 0.08920429874467865,
                    "success_improvement": 0.0,
                    "time_improvement": -106.48662831071465,
                    "length_improvement": 23.312297812281674,
                    "smoothness_improvement": 1149.6665020823436,
                    "objective_score": -21.53519642034634
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041659760475158694,
                    "num_nodes_avg": 289.0,
                    "path_length_avg": 117.51014688918721,
                    "smoothness_avg": 0.11931802799898128,
                    "success_improvement": 0.0,
                    "time_improvement": -50.01189046350488,
                    "length_improvement": 27.84169087969108,
                    "smoothness_improvement": 823.1630924306397,
                    "objective_score": -5.319413500960049
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is an enhanced bidirectional RRT* algorithm with adaptive neighborhood rewiring, goal biasing, and refined collision checks designed to achieve efficient and robust path planning in 2D/3D spaces with obstacles. It balances planning efficiency, path quality, success rate, and smoothness by adaptively adjusting parameters, performing rewiring to minimize costs, and shortcut smoothing the discovered path.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points with goal bias. For each new node, it picks the lowest-cost parent in a neighborhood, rewires neighbors to improve paths, and tries connecting the trees. Once connected, it reconstructs and smooths the path before returning. All node and edge insertions are checked for collisions and map bounds.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4500, step_size: float = 4.0, base_radius: float = 10.0, goal_sample_rate: float = 0.2, collision_resolution: float = 0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        import random\n        import math\n        from math import log\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def near(nodes, point, radius):\n            if radius <= 0:\n                return []\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_radius\n            gamma = self.base_radius\n            return min(gamma * (log(n_nodes + 1) / (n_nodes + 1))**(1 / dim), self.base_radius)\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            return path_s + path_g[::-1]\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            for _ in range(100):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 2)\n                j = random.randint(i + 1, len(path) - 1)\n                if j == i + 1:\n                    continue\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample_from_start = (i % 2 == 0)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if sample_from_start else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                # Enforce map bounds\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            tree_a = nodes_start if sample_from_start else nodes_goal\n            tree_b = nodes_goal if sample_from_start else nodes_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_node = nearest_node\n            for n in neighbors:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = tentative_cost\n                    min_node = n\n\n            new_node = Node(new_pos, parent=min_node, cost=min_cost)\n            min_node.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((min_node, new_node))\n\n            # Rewiring neighbors to reduce cost\n            for n in neighbors:\n                if n is min_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.collision_resolution):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            nearest_in_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d, self.collision_resolution):\n                    path = extract_path(new_node, nearest_in_b)\n                    path = smooth_path(path)\n                    all_nodes = nodes_start + nodes_goal\n                    return PlannerResult(True, path, all_nodes, edges)\n\n        all_nodes = nodes_start + nodes_goal\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 24.40837,
          "time_improvement": -105.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025393080711364747,
                    "num_nodes_avg": 145.7,
                    "path_length_avg": 165.83660060267044,
                    "smoothness_avg": 0.02499972032676858,
                    "success_improvement": 0.0,
                    "time_improvement": -156.9177959928019,
                    "length_improvement": 17.116460956741335,
                    "smoothness_improvement": 140.2164789872752,
                    "objective_score": -42.95096421155592
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0363203763961792,
                    "num_nodes_avg": 362.7,
                    "path_length_avg": 241.68974884753135,
                    "smoothness_avg": 0.07866395509901483,
                    "success_improvement": 0.0,
                    "time_improvement": -139.3403551329628,
                    "length_improvement": 19.799164604277838,
                    "smoothness_improvement": 1002.00641664046,
                    "objective_score": -32.832241535830974
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03338453769683838,
                    "num_nodes_avg": 302.1,
                    "path_length_avg": 124.60489761811304,
                    "smoothness_avg": 0.11439085101128206,
                    "success_improvement": 0.0,
                    "time_improvement": -20.213787958265762,
                    "length_improvement": 23.485086537156004,
                    "smoothness_improvement": 785.0415443192653,
                    "objective_score": 2.558088641547799
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm integrates the adaptive bidirectional anytime RRT*-like planner with heuristic-informed ellipsoid sampling, dynamic tree pruning, local dense resampling, and progressive shortcut smoothing, together with the direct connection attempts, adaptive neighborhood rewiring, and balanced tree growth from classic bidirectional RRT*. It combines exploration and exploitation phases, dynamically focuses sampling around promising areas, prunes non-useful nodes, and performs local rewiring with an adaptive radius to efficiently produce high-quality, smooth paths with improved success rate and reduced search time, suitable for both 2D and 3D environments.",
          "planning_mechanism": "The planner alternates extending two trees from start and goal, performing adaptive sampling among uniform random, informed ellipsoid around the current best path, and dense local resampling on high-cost branches. Each new node is collision-checked and rewired locally with an adaptive radius scaled by iteration and rewire factor for path improvement. The trees attempt direct incremental connections after each extension with collision checks. Dynamic pruning removes unpromising leaf nodes. Progressive shortcut smoothing is applied whenever a better path is found. Early termination occurs on finding near-optimal solutions or after a set number of iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 min_radius: float=6.0, max_radius: float=20.0, rewire_factor: float=1.5,\n                 pruning_threshold_factor: float=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.rewire_factor = rewire_factor\n        self.pruning_threshold_factor = pruning_threshold_factor\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, new_node, radius):\n            radius_sq = radius * radius\n            px = new_node.position\n            return [node for node in tree if sum((px[d]-node.position[d])**2 for d in range(dim)) <= radius_sq]\n\n        def adaptive_radius(iteration):\n            scale = min(1.0, iteration / (self.max_iter * 0.75))\n            r = self.max_radius - (self.max_radius - self.min_radius) * scale\n            return max(self.min_radius, r) * self.rewire_factor\n\n        def informed_sample(c_best):\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                c_best = c_min + 1e-7\n            center = (np.array(start_pos) + np.array(goal_pos)) * 0.5\n            a1 = (np.array(goal_pos) - np.array(start_pos)) / c_min\n\n            while True:\n                sample_dir = np.random.normal(0, 1, dim)\n                norm_dir = np.linalg.norm(sample_dir)\n                if norm_dir == 0:\n                    continue\n                unit_dir = sample_dir / norm_dir\n                radius = random.uniform(0, 1) ** (1 / dim)\n                unit_ball_sample = radius * unit_dir\n\n                M = np.outer(a1, a1)\n                U, _, _ = np.linalg.svd(M)\n                r1 = c_best / 2.0\n                if dim == 2:\n                    r_rest = math.sqrt(c_best**2 - c_min**2) / 2.0\n                    L = np.diag([r1, r_rest])\n                elif dim == 3:\n                    r_rest = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                    L = np.diag([r1, r_rest, r_rest])\n                else:\n                    L = np.diag([c_best/2.0]*dim)\n\n                sample_transf = U @ L @ unit_ball_sample + center\n                sample = tuple(np.clip(sample_transf, [0]*dim, bounds))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def dynamic_prune(tree, best_cost):\n            threshold = best_cost * self.pruning_threshold_factor\n            to_remove = [node for node in tree if node.cost > threshold and len(node.children) == 0]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                tree.remove(node)\n\n        def dense_resample_on_branch(tree, best_cost, fraction=0.1, samples_per_branch=5):\n            sorted_nodes = sorted(tree, key=lambda n: n.cost, reverse=True)\n            count = max(1, int(len(tree) * fraction))\n            samples = []\n            radius = self.step_size * 2.5\n            for node in sorted_nodes[:count]:\n                center = np.array(node.position)\n                for _ in range(samples_per_branch):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_np = center + offset\n                    sample_clipped = tuple(np.clip(sample_np, [0]*dim, bounds))\n                    if not self._is_in_obstacle(sample_clipped, obstacles, is_3d):\n                        samples.append(sample_clipped)\n            return samples\n\n        def rewire(tree, new_node, neighbors, edges):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            old_parent.remove_child(neighbor)\n                            if (old_parent, neighbor) in edges:\n                                edges.remove((old_parent, neighbor))\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connect(node_from_a, tree_b, nodes, edges):\n            nearest_b = nearest(tree_b, node_from_a.position)\n            if self._is_edge_in_obstacle(node_from_a.position, nearest_b.position, obstacles, is_3d):\n                return None\n            current = nearest_b\n            while True:\n                new_pos = steer(current.position, node_from_a.position, self.step_size)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n                new_cost = current.cost + dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_pos, node_from_a.position) <= self.step_size * 1.01:\n                    final_cost = new_node.cost + dist(new_pos, node_from_a.position)\n                    final_node = Node(node_from_a.position, parent=new_node, cost=final_cost)\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                current = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) -1\n                shortcut_made = False\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        path = path[:i+1] + path[j:]\n                        shortcut_made = True\n                        break\n                    j -= 1\n                if not shortcut_made:\n                    i += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        best_path_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        for iter_count in range(self.max_iter):\n            # Alternate extension order\n            if iter_count % 2 == 0:\n                trees_sequence = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            else:\n                trees_sequence = [(goal_tree, start_tree), (start_tree, goal_tree)]\n\n            dense_samples = []\n            if best_path_cost < float(\"inf\") and (iter_count % 25 == 0) and len(start_tree) > 10:\n                dense_samples = dense_resample_on_branch(start_tree, best_path_cost, fraction=0.1, samples_per_branch=5)\n\n            for tree_a, tree_b in trees_sequence:\n                sample = None\n                prob_goal_bias = self.goal_sample_rate\n                prob_informed = 0.6 if best_path_cost < float(\"inf\") else 0.0\n\n                if dense_samples and random.random() < 0.4:\n                    sample = dense_samples.pop(random.randint(0, len(dense_samples)-1))\n                else:\n                    r = random.random()\n                    if r < prob_goal_bias:\n                        sample = goal_pos if tree_a is start_tree else start_pos\n                    elif r < prob_goal_bias + prob_informed:\n                        sample = informed_sample(best_path_cost)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                if not in_bounds(sample):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                tentative_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n\n                curr_radius = adaptive_radius(iter_count)\n                neighbors = near(tree_a, new_node, curr_radius)\n\n                # Select best parent minimizing cost\n                min_cost = tentative_cost\n                min_parent = nearest_node\n                for node in neighbors:\n                    edge_c = dist(node.position, new_node.position)\n                    cost_cand = node.cost + edge_c\n                    if cost_cand + 1e-9 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_node.position, obstacles, is_3d):\n                            min_cost = cost_cand\n                            min_parent = node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, neighbors, edges)\n\n                connect_node = attempt_connect(new_node, tree_b, nodes, edges)\n                if connect_node:\n                    success_state = True\n                    if tree_a is start_tree:\n                        path_candidate = extract_path(new_node, connect_node)\n                    else:\n                        path_candidate = extract_path(connect_node, new_node)\n\n                    path_len = 0.0\n                    for i in range(len(path_candidate) - 1):\n                        path_len += dist(path_candidate[i], path_candidate[i + 1])\n\n                    # Accept if strictly better path found\n                    if path_len + 1e-9 < best_path_cost:\n                        best_path_cost = path_len\n                        best_path = shortcut_path(path_candidate)\n\n                        dynamic_prune(start_tree, best_path_cost)\n                        dynamic_prune(goal_tree, best_path_cost)\n\n                        # Early termination if near direct line path length\n                        if best_path_cost <= 1.05 * dist(start_pos, goal_pos):\n                            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n                        # Return improved path for anytime\n                        return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            # If no direct connection found but have best path\n            if success_state and best_path:\n                best_path = shortcut_path(best_path)\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n        # No path found\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 24.74971,
          "time_improvement": -110.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02072300910949707,
                    "num_nodes_avg": 74.3,
                    "path_length_avg": 162.6673111912633,
                    "smoothness_avg": 0.04583645824146655,
                    "success_improvement": 0.0,
                    "time_improvement": -109.66773930537397,
                    "length_improvement": 18.700441342947585,
                    "smoothness_improvement": 340.43183140023496,
                    "objective_score": -27.4580743660215
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0507392168045044,
                    "num_nodes_avg": 270.2,
                    "path_length_avg": 228.05133634833987,
                    "smoothness_avg": 0.08817866346254657,
                    "success_improvement": 0.0,
                    "time_improvement": -234.35617617762307,
                    "length_improvement": 24.32485127953952,
                    "smoothness_improvement": 1135.2983373921786,
                    "objective_score": -59.76539091041811
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023832297325134276,
                    "num_nodes_avg": 162.5,
                    "path_length_avg": 121.81081351558946,
                    "smoothness_avg": 0.10803576440072118,
                    "success_improvement": 0.0,
                    "time_improvement": 14.182704483777888,
                    "length_improvement": 25.200822494563692,
                    "smoothness_improvement": 735.8722653221298,
                    "objective_score": 12.974337170656755
               }
          ],
          "success_rate": 1.0
     }
]