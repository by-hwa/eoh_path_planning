[
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner enhanced with adaptive neighbor radius, ellipsoidal informed sampling after first solution, incremental extend-and-rewire steps, and progressive bidirectional tree connection attempts. It maintains consistent and dynamic parent-child cost propagation, rigorous collision checking for nodes and edges, and applies randomized shortcut path smoothing. The planner runs under a strict 30-second time limit and returns the best path found if time expires.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions. It samples points with goal bias and informed ellipsoidal sampling once a feasible path is found. Each extension rewires neighbors adaptively to optimize path costs. Incremental connection tries to link the two trees. On a successful connection, the combined path is smoothed and returned early. If no exact solution is found in time, the best available path is returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...] e.g. 2D or 3D\n        self.parent = None                    # Node or None\n        self.cost = 0.0                      # Cost from root to this node\n        self.children = []\n        self.valid = True                    # Validity flag (collision, pruning)\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs to maintain consistency\n        for ch in self.children:\n            ch.update_parent(self, self.cost + self._distance(self.position, ch.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1, p2):\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 35.0\n            base_radius = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            factor = min(1.0, iteration / self.max_iter)\n            radius = base_radius * (1.0 - 0.5 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree_nodes if (math.dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_uniform():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            for _ in range(100):\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if collision_free_node(clamped):\n                    # Introduce small goal bias on informed sampling\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return clamped\n\n            return sample_uniform()\n\n        def extend_and_rewire(tree: list, sample: tuple, iteration: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iteration)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors through new_node if cheaper\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple, iteration: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iteration)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = math.dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = [(node, c) for node in nodes_all for c in node.children]\n                    return PlannerResult(True, smoothed, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = [(node, c) for node in nodes_all for c in node.children]\n                    return PlannerResult(True, smoothed, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = len(best_path) > 0\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success else []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = [(node, c) for node in nodes_all for c in node.children]\n\n        return PlannerResult(success, smoothed_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.65268,
          "time_improvement": 63.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1481.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01572568416595459,
                    "num_nodes_avg": 57.8,
                    "path_length_avg": 159.79226543957935,
                    "smoothness_avg": 0.03845847248883305,
                    "success_improvement": 0.0,
                    "time_improvement": 36.65274707121851,
                    "length_improvement": 12.415327242086036,
                    "smoothness_improvement": 501.9586083599331,
                    "objective_score": 15.988682611582426
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033181285858154295,
                    "num_nodes_avg": 209.3,
                    "path_length_avg": 235.77412678789224,
                    "smoothness_avg": 0.0992244015920287,
                    "success_improvement": 0.0,
                    "time_improvement": 79.21482468065952,
                    "length_improvement": 21.291810096243143,
                    "smoothness_improvement": 2453.1153214105884,
                    "objective_score": 40.288386030499424
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013629579544067382,
                    "num_nodes_avg": 118.9,
                    "path_length_avg": 123.46492916467116,
                    "smoothness_avg": 0.12491934125030824,
                    "success_improvement": 0.0,
                    "time_improvement": 72.12020481187945,
                    "length_improvement": 18.00047281697062,
                    "smoothness_improvement": 1488.9648001172857,
                    "objective_score": 32.680980007544385
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive informed sampling after finding an initial path solution. It incrementally grows two trees from the start and goal positions, rewiring locally to optimize path costs, dynamically adjusting neighborhood radii. The planner incorporates robust collision checking for nodes and edges, enforces a strict 30-second runtime limit, and smooths the final path to improve quality and feasibility.",
          "planning_mechanism": "The planner alternates growth between the start and goal trees, sampling configurations biased towards the goal or within an informed ellipsoidal subset after the first solution. Each extension involves steering towards samples, rewiring neighbors to minimize costs, and incrementally attempting to connect the two trees. Upon successful connection, the combined path is smoothed and returned. The process terminates upon time expiration or max iterations, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            new_pt = tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(min(max(new_pt[d], 0.0), bounds[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        success_state = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        success_state = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.50914,
          "time_improvement": 56.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1622.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016451644897460937,
                    "num_nodes_avg": 69.2,
                    "path_length_avg": 150.5392184768476,
                    "smoothness_avg": 0.04309586299929125,
                    "success_improvement": 0.0,
                    "time_improvement": 33.72838348933654,
                    "length_improvement": 17.487068906271332,
                    "smoothness_improvement": 574.5438401032775,
                    "objective_score": 16.488648028571614
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029997587203979492,
                    "num_nodes_avg": 204.9,
                    "path_length_avg": 237.67032959361413,
                    "smoothness_avg": 0.11983256957008481,
                    "success_improvement": 0.0,
                    "time_improvement": 81.209133610514,
                    "length_improvement": 20.658803020521642,
                    "smoothness_improvement": 2983.37832694939,
                    "objective_score": 43.41139232200548
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02251169681549072,
                    "num_nodes_avg": 181.7,
                    "path_length_avg": 128.67739794773527,
                    "smoothness_avg": 0.11060146419662706,
                    "success_improvement": 0.0,
                    "time_improvement": 53.951514459876705,
                    "length_improvement": 14.538599242350195,
                    "smoothness_improvement": 1306.842460830212,
                    "objective_score": 25.627386490584115
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of bidirectional RRT* variants with adaptive neighbor radius, ellipsoidal informed sampling, incremental extend-and-rewire, rigorous collision checking, and dynamic path smoothing. It grows two trees alternately from start and goal, applying adaptive rewiring and incremental connections to continuously improve the path cost and smoothness, while enforcing a strict 30-second timeout to ensure efficient and robust planning.",
          "planning_mechanism": "The planner alternately samples points using goal biasing or ellipsoidal informed sampling (once a path is found) within map bounds, extends the active tree towards the sample with steering and collision checks, rewires neighbors to optimize local costs, then incrementally connects to the opposite tree using iterative extend-and-rewire steps. Upon connection, it extracts and smooths the combined path. The process stops early upon timeout or when a better path is identified, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True                   # For collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = (2.0 * (1.5 * (math.log(n_nodes) / n_nodes)) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            attempts = 30\n            for _ in range(attempts):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback if sampling repeatedly fails\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                # Arbitrary vector not colinear with v\n                if abs(vx) < 0.9:\n                    arbitrary = (1.0, 0.0, 0.0)\n                else:\n                    arbitrary = (0.0, 1.0, 0.0)\n                # w = v cross arbitrary\n                wx = vy * arbitrary[2] - vz * arbitrary[1]\n                wy = vz * arbitrary[0] - vx * arbitrary[2]\n                wz = vx * arbitrary[1] - vy * arbitrary[0]\n                norm_w = math.sqrt(wx * wx + wy * wy + wz * wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n                # u = v\n                ux, uy, uz = vx, vy, vz\n                # v_ = w\n                vx_, vy_, vz_ = wx, wy, wz\n                # w_ = u cross v_\n                wx_, wy_, wz_ = (uy * wz - uz * vy_), (uz * vx_ - ux * wz), (ux * vy_ - uy * vx_)\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            current = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n                rewire(tree, new_node, neighbors)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                # Check time constraint early\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else \\\n                        (goal_pos if (random.random() < self.goal_sample_rate and grow_start) else\n                         start_pos if (random.random() < self.goal_sample_rate and not grow_start) else uniform_sample())\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    total_cost = 0.0\n                    for i in range(len(combined_path) - 1):\n                        total_cost += dist_func(combined_path[i], combined_path[i + 1])\n\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    total_cost = 0.0\n                    for i in range(len(combined_path) - 1):\n                        total_cost += dist_func(combined_path[i], combined_path[i + 1])\n\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.01366,
          "time_improvement": 56.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1696.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017095541954040526,
                    "num_nodes_avg": 76.4,
                    "path_length_avg": 162.9755091837044,
                    "smoothness_avg": 0.04408547935958829,
                    "success_improvement": 0.0,
                    "time_improvement": 31.134594292453656,
                    "length_improvement": 10.670540904206065,
                    "smoothness_improvement": 590.0334851282482,
                    "objective_score": 14.424653894218551
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028893470764160156,
                    "num_nodes_avg": 205.0,
                    "path_length_avg": 236.34419864473517,
                    "smoothness_avg": 0.1019632230802231,
                    "success_improvement": 0.0,
                    "time_improvement": 81.90076605275016,
                    "length_improvement": 21.101503701820373,
                    "smoothness_improvement": 2523.5871709952116,
                    "objective_score": 41.40846641116518
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022553205490112305,
                    "num_nodes_avg": 194.1,
                    "path_length_avg": 134.15414536765348,
                    "smoothness_avg": 0.16301389685813333,
                    "success_improvement": 0.0,
                    "time_improvement": 53.86660697294812,
                    "length_improvement": 10.901204380727625,
                    "smoothness_improvement": 1973.5247356012178,
                    "objective_score": 28.207846646036046
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* planner enhanced with adaptive neighbor radius, dynamic rewiring with recursive cost propagation, and ellipsoidal informed sampling to accelerate convergence. It employs robust collision checking for node positions and edges, enforces strict map bounds, and integrates iterative path shortcut smoothing for improved path quality. Time management halts planning after 30 seconds, returning the best feasible path found to ensure planning efficiency and robustness.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, alternating expansion steps. Sampling mixes uniform, goal-biased, and ellipsoidal informed strategies (after an initial path is found) to bias growth toward promising regions. New nodes are connected to minimum-cost parents within an adaptive radius, triggering rewiring of neighbors to maintain optimal subtrees. Incremental connection attempts join the trees for path completion. Upon a successful connection, the path is smoothed via randomized shortcuts. The process respects a strict 30-second timeout, returning the best solution discovered by then.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = 0.0                # Cost from root to this node\n        self.children = []             # List[Node]\n        self.valid = True              # For collision checking etc.\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5.0)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                trials += 1\n                if trials > 1000:\n                    return start_pos if random.random() < 0.5 else goal_pos\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            for _ in range(100):\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(d * radius_sample for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_clamped):\n                    return sample_clamped\n            return uniform_sample()\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = None) -> list:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sample\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            # Extend tree\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if len(path_goal) > 0 and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if len(path_start) > 0 and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Return best found path on timeout or iteration exhaustion\n        success_state = (len(best_path) > 0)\n        final_path = path_smoothing(best_path) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.74864,
          "time_improvement": 54.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1665.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020201230049133302,
                    "num_nodes_avg": 72.2,
                    "path_length_avg": 163.9503975902586,
                    "smoothness_avg": 0.04282688162226332,
                    "success_improvement": 0.0,
                    "time_improvement": 18.624053752432243,
                    "length_improvement": 10.136189120478328,
                    "smoothness_improvement": 570.3336974503814,
                    "objective_score": 10.466122437077244
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03457667827606201,
                    "num_nodes_avg": 231.5,
                    "path_length_avg": 239.2705510587059,
                    "smoothness_avg": 0.10687321445237918,
                    "success_improvement": 0.0,
                    "time_improvement": 78.34073329765899,
                    "length_improvement": 20.12460303565299,
                    "smoothness_improvement": 2649.924785524626,
                    "objective_score": 40.77676452405143
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01682701110839844,
                    "num_nodes_avg": 136.4,
                    "path_length_avg": 124.58414871428647,
                    "smoothness_avg": 0.147448505181393,
                    "success_improvement": 0.0,
                    "time_improvement": 65.57974354134936,
                    "length_improvement": 17.25714048362393,
                    "smoothness_improvement": 1775.5341023907822,
                    "objective_score": 32.0030216710835
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional, adaptive informed RRT* path planner for 2D/3D environments, utilizing ellipsoidal informed sampling after an initial solution is found, adaptive neighbor radius with min/max limits, rigorous collision checking, parent-child node management with efficient rewiring, and randomized shortcutting for path smoothing. It enforces a strict 30-second planning time limit and returns the best feasible path found with improved path quality, efficiency, and robustness.",
          "planning_mechanism": "The planner grows two trees alternately from the start and goal locations. Uniform and goal-biased sampling is used initially, switching to ellipsoidal informed sampling once a solution is found, focusing exploration within a prolate hyperspheroid defined by the current best path cost. Nodes are extended toward sampled points with adaptive neighbor radius rewiring, and incremental connection attempts join the two trees. Parent-child relationships are managed recursively to maintain cost consistency. After a connection, the path is extracted and smoothed by random shortcutting, and the planner halts immediately if a better path is found or after 30 seconds, returning the best result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...] (2D or 3D)\n        self.parent = None                    # Parent node or None\n        self.cost = cost                      # Cost from root to this node\n        self.children = []                    # List[Node]\n        self.valid = True                     # For collision validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Avoid redundant updates\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = self._dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 9000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 34.0\n            base_radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.5 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos)**2) <= r_sq]\n\n        def uniform_sample():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B): \n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree: list, sample: tuple, iter_num: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cand_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple, iter_num:int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cand_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def random_path_smoothing(path: list, trials: int) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i+2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iter_num in range(1, self.max_iter+1):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling_active:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iter_num)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined_path, self.smoothing_trials)\n                        informed_sampling_active = True\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(n, c) for n in nodes_all for c in n.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iter_num)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined_path, self.smoothing_trials)\n                        informed_sampling_active = True\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(n, c) for n in nodes_all for c in n.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        success = len(best_path) > 0\n        smoothed_path = random_path_smoothing(best_path, self.smoothing_trials) if success else []\n        nodes_all = tree_start + tree_goal\n        edges_all = [(n, c) for n in nodes_all for c in n.children]\n\n        return PlannerResult(success, smoothed_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.43898,
          "time_improvement": 53.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1669.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017316627502441406,
                    "num_nodes_avg": 61.9,
                    "path_length_avg": 159.36579723017758,
                    "smoothness_avg": 0.03979549899375149,
                    "success_improvement": 0.0,
                    "time_improvement": 30.244002696841587,
                    "length_improvement": 12.64908122548038,
                    "smoothness_improvement": 522.8859765614327,
                    "objective_score": 14.217446936955715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03868398666381836,
                    "num_nodes_avg": 243.6,
                    "path_length_avg": 240.35139522012236,
                    "smoothness_avg": 0.11700321368875002,
                    "success_improvement": 0.0,
                    "time_improvement": 75.76786359950852,
                    "length_improvement": 19.76378614419795,
                    "smoothness_improvement": 2910.576962219977,
                    "objective_score": 41.23600111979203
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023127269744873048,
                    "num_nodes_avg": 183.1,
                    "path_length_avg": 126.52572184885214,
                    "smoothness_avg": 0.13148302590676803,
                    "success_improvement": 0.0,
                    "time_improvement": 52.692337891807085,
                    "length_improvement": 15.96764005542287,
                    "smoothness_improvement": 1572.4543844666491,
                    "objective_score": 26.863501300959943
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, informed ellipsoidal sampling after the first solution, incremental connection between trees, and randomized path smoothing. It enforces strict collision checking on nodes and edges while respecting boundary limits and ensures robust parent-child management in the search trees. The planner runs until a path is found or a 30-second time limit is reached, always returning the best feasible and smooth path found.",
          "planning_mechanism": "The planner alternately grows two trees from the start and goal positions, sampling points using a combination of goal bias, uniform, and ellipsoidal informed distributions to focus search in promising regions. Nodes are connected via steering with a fixed step size and rewired adaptively using a radius dependent on node density for path cost minimization. Trees attempt incremental connections each iteration to bridge the paths. Upon connection, the combined path is smoothed through randomized shortcutting to improve quality before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=8.0, neighbor_radius_max=25.0, smoothing_trials=120,\n                 max_planning_time=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 35.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                trials += 1\n                if trials > 1000:\n                    return start_pos if random.random() < 0.5 else goal_pos\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample = informed_sample(best_cost) if informed_sampling_active else (\n                goal_pos if (random.random() < self.goal_sample_rate) else uniform_sample()\n            )\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connecting_node = incremental_connect(tree_goal, new_node.position)\n                if connecting_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connecting_node.cost + dist_func(new_node.position, connecting_node.position)\n\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling_active = True\n                        best_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connecting_node = incremental_connect(tree_start, new_node.position)\n                if connecting_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connecting_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connecting_node.cost + dist_func(new_node.position, connecting_node.position)\n\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling_active = True\n                        best_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = len(best_path) > 0\n        if success:\n            best_path = path_smoothing(best_path, self.smoothing_trials)\n        nodes_all = tree_start + tree_goal\n        edges_all = [(node, child) for node in nodes_all for child in node.children]\n        return PlannerResult(success, best_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.40365,
          "time_improvement": 56.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016196298599243163,
                    "num_nodes_avg": 69.2,
                    "path_length_avg": 157.37355636007882,
                    "smoothness_avg": 0.04151361559978314,
                    "success_improvement": 0.0,
                    "time_improvement": 34.75698652923788,
                    "length_improvement": 13.741060015458292,
                    "smoothness_improvement": 549.7782323957539,
                    "objective_score": 15.924199123841792
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03973178863525391,
                    "num_nodes_avg": 278.6,
                    "path_length_avg": 235.6629231311264,
                    "smoothness_avg": 0.09197871984809777,
                    "success_improvement": 0.0,
                    "time_improvement": 75.11150724944603,
                    "length_improvement": 21.328933077691367,
                    "smoothness_improvement": 2266.678711285633,
                    "objective_score": 38.13263234680025
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01999962329864502,
                    "num_nodes_avg": 172.9,
                    "path_length_avg": 123.94980026152447,
                    "smoothness_avg": 0.11621774730538599,
                    "success_improvement": 0.0,
                    "time_improvement": 59.090051193215984,
                    "length_improvement": 17.67844452152115,
                    "smoothness_improvement": 1378.2811674227285,
                    "objective_score": 28.154110099382667
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT* variant with adaptive neighbor radius bounded between minimum and maximum values, ellipsoidal informed sampling after discovering an initial path, recursive parent-child cost propagation, robust incremental extend-and-rewire steps with collision and boundary checking, randomized path smoothing, and early stopping upon improvement or timeout within a strict 30-second limit.",
          "planning_mechanism": "The algorithm grows two trees simultaneously from start and goal positions, alternating expansions with a goal bias initially and switching to informed ellipsoidal sampling after a solution is found. Each iteration extends one tree toward a sampled point with adaptive neighbor rewiring, then tries to incrementally connect the opposite tree. Successful connections trigger early termination with path extraction and smoothing. The planner enforces collision-free sampling, edge checking, and clamps points to map bounds, ensuring robustness, efficiency, and high path quality.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position                  # Tuple[float, ...]\n        self.parent = None                        # Parent Node\n        self.cost = 0.0                          # Cost from root\n        self.children: List['Node'] = []          # Children nodes\n        self.valid = True                         # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # propagate cost update recursively to children\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_active = False\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_node: Node) -> Node:\n            if not tree or target_node is None:\n                return None\n            current = min(tree, key=lambda n: dist_func(n.position, target_node.position))\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist_func(new_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            sample_pt = (informed_sample(best_cost) if informed_sampling_active else\n                         (goal_pos if random.random() < self.goal_sample_rate else uniform_sample()))\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node)\n                if connected_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node)\n                if connected_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = len(best_path) > 0\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        if distance < 1e-12:\n            return self._is_in_obstacle(from_pos, obstacles, is_3d)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.39818,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1448.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017297840118408202,
                    "num_nodes_avg": 83.3,
                    "path_length_avg": 164.67627631792016,
                    "smoothness_avg": 0.038341806161273535,
                    "success_improvement": 0.0,
                    "time_improvement": 30.31968329398839,
                    "length_improvement": 9.738323487562527,
                    "smoothness_improvement": 500.13252698864153,
                    "objective_score": 13.544232320652231
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04122128486633301,
                    "num_nodes_avg": 268.5,
                    "path_length_avg": 233.7294523968397,
                    "smoothness_avg": 0.09533108063843972,
                    "success_improvement": 0.0,
                    "time_improvement": 74.178468052809,
                    "length_improvement": 21.974381260665655,
                    "smoothness_improvement": 2352.9373690290095,
                    "objective_score": 38.41310351312087
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017633056640625,
                    "num_nodes_avg": 167.1,
                    "path_length_avg": 123.43583671527881,
                    "smoothness_avg": 0.12506303671525865,
                    "success_improvement": 0.0,
                    "time_improvement": 63.93094841321514,
                    "length_improvement": 18.019794636623445,
                    "smoothness_improvement": 1490.792595824959,
                    "objective_score": 30.237206430414027
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This is a bidirectional informed RRT* planner with adaptive neighbor radius, goal bias and ellipsoidal informed sampling, incremental connections between two trees grown from start and goal, dynamic rewiring for cost improvement, strict collision checks for nodes and edges, and randomized path smoothing. The planner runs up to 30 seconds, returning the best feasible and smoothed path found.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points using a mix of uniform, goal-biased, and informed ellipsoidal sampling once a solution is found. New nodes connect with steering and are rewired within an adaptive radius to improve path cost. Incremental connection attempts bridge the two trees gradually. Upon a successful connection, the combined path is extracted, smoothed by random shortcutting, and returned immediately or after the time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # 2D or 3D coordinate\n        self.parent = None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 6.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 120,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(min(max(0.0, pos[d]), bounds[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(src: Tuple[float, ...], tgt: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 32.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            tries = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                tries += 1\n                if tries > 1000:\n                    # fallback to start or goal if stuck\n                    return start_pos if random.random() < 0.5 else goal_pos\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B): \n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s): \n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B): \n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            sample = informed_sample(best_cost) if informed_sampling_active else (\n                goal_pos if random.random() < self.goal_sample_rate else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_smoothing(candidate_path, self.smoothing_trials)\n                        informed_sampling_active = True\n                        # Early return upon better solution\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(n, c) for n in nodes_all for c in n.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_smoothing(candidate_path, self.smoothing_trials)\n                        informed_sampling_active = True\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(n, c) for n in nodes_all for c in n.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = len(best_path) > 0\n        final_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = [(n, c) for n in all_nodes for c in n.children]\n\n        return PlannerResult(success_state, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.1945,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1587.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013717579841613769,
                    "num_nodes_avg": 64.5,
                    "path_length_avg": 154.46364109614237,
                    "smoothness_avg": 0.04322348079327672,
                    "success_improvement": 0.0,
                    "time_improvement": 44.741927242902065,
                    "length_improvement": 15.336030682179972,
                    "smoothness_improvement": 576.5413357056252,
                    "objective_score": 19.37249098783474
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03647317886352539,
                    "num_nodes_avg": 279.5,
                    "path_length_avg": 233.78375974357678,
                    "smoothness_avg": 0.10222989704142948,
                    "success_improvement": 0.0,
                    "time_improvement": 77.1527414467051,
                    "length_improvement": 21.95625190517451,
                    "smoothness_improvement": 2530.4488840945423,
                    "objective_score": 40.18931723551914
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031883621215820314,
                    "num_nodes_avg": 267.8,
                    "path_length_avg": 125.55698348849032,
                    "smoothness_avg": 0.13781858267575234,
                    "success_improvement": 0.0,
                    "time_improvement": 34.780906008241054,
                    "length_improvement": 16.611029948011595,
                    "smoothness_improvement": 1653.0421989259735,
                    "objective_score": 22.0216887867045
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is an improved bidirectional RRT* variant with adaptive neighbor radius, informed ellipsoidal sampling after the first solution, incremental extend-and-rewire steps with recursive parent-child cost propagation, randomized path smoothing for reducing path length and sharp turns, and strict 30-second runtime limit enforcement. It balances exploration-exploitation efficiently to optimize planning speed, success rate, and path quality.",
          "planning_mechanism": "The planner alternately grows two trees rooted at start and goal, using goal bias initially, then switching to ellipsoidal informed sampling. Each iteration extends one tree towards a sample, rewires within an adaptive radius while maintaining cost consistency, and incrementally tries to connect the other tree to the newly added node. Upon a successful connection, the combined path is smoothed and returned early. The search stops if the maximum time or iteration limit is reached, returning the best available solution.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # float: cost from root\n        self.children: List[Node] = []\n        self.valid = True                   # For collision checking etc.\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        # Recursively update children cost and parents\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                   # Tuple[int,...]\n        start_pos = map.start               # Tuple[float, ...]\n        goal_pos = map.goal                 # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction: Tuple[float, ...]):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K,sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random()**(1.0/n)\n                sample_unit = tuple(radius_sample*d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.08501,
          "time_improvement": 54.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1513.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0180403470993042,
                    "num_nodes_avg": 62.8,
                    "path_length_avg": 162.34888059945655,
                    "smoothness_avg": 0.03969256812454978,
                    "success_improvement": 0.0,
                    "time_improvement": 27.328667003451734,
                    "length_improvement": 11.014005960797645,
                    "smoothness_improvement": 521.2748849404659,
                    "objective_score": 13.00777571789738
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03461320400238037,
                    "num_nodes_avg": 216.0,
                    "path_length_avg": 235.71539227290282,
                    "smoothness_avg": 0.09811209324860407,
                    "success_improvement": 0.0,
                    "time_improvement": 78.31785312271823,
                    "length_improvement": 21.31141736792589,
                    "smoothness_improvement": 2424.4948265709563,
                    "objective_score": 39.880113543255426
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020733904838562012,
                    "num_nodes_avg": 161.0,
                    "path_length_avg": 127.0043495525471,
                    "smoothness_avg": 0.13303190646649876,
                    "success_improvement": 0.0,
                    "time_improvement": 57.58805189256887,
                    "length_improvement": 15.649758324430746,
                    "smoothness_improvement": 1592.1560308599535,
                    "objective_score": 28.367147386956574
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a time-limited bidirectional RRT* planner with adaptive neighbor radius, goal-biased plus ellipsoidal informed sampling after an initial path is found, incremental extend-and-rewire steps with robust collision checking, and path smoothing. It maintains consistent parent-child relationships with recursive cost propagation for efficient rewiring and uses early termination upon timeout or improved solution to ensure fast convergence, improved path quality, and high success rates.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately. Sampling is biased towards the goal and switches to ellipsoidal informed sampling after a feasible path is found. Each new node is connected to the best parent within an adaptive neighborhood radius, neighbors are rewired to minimize costs, and incremental connections attempt to link the two trees progressively. Robust collision checks prevent invalid expansions. The process is time-limited to 30 seconds, and the best solution found is smoothed before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.2, \n                 neighbor_radius_min: float = 8.0, neighbor_radius_max: float = 30.0, max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best):\n            c_min = dist_func(start_pos, goal_pos)\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for child in node.children:\n                                all_edges.append((node, child))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for child in node.children:\n                                all_edges.append((node, child))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for child in node.children:\n                all_edges.append((node, child))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.68729,
          "time_improvement": 52.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1549.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02027289867401123,
                    "num_nodes_avg": 86.6,
                    "path_length_avg": 158.36715628450975,
                    "smoothness_avg": 0.041536845017126366,
                    "success_improvement": 0.0,
                    "time_improvement": 18.335353403417926,
                    "length_improvement": 13.19645215227936,
                    "smoothness_improvement": 550.1418232206626,
                    "objective_score": 10.890605567584561
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03168988227844238,
                    "num_nodes_avg": 230.2,
                    "path_length_avg": 243.08345474180896,
                    "smoothness_avg": 0.10659969060215416,
                    "success_improvement": 0.0,
                    "time_improvement": 80.14905866449972,
                    "length_improvement": 18.85174603788583,
                    "smoothness_improvement": 2642.88681984707,
                    "objective_score": 41.02950090616243
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02078251838684082,
                    "num_nodes_avg": 182.7,
                    "path_length_avg": 123.25061227958604,
                    "smoothness_avg": 0.12211748536728033,
                    "success_improvement": 0.0,
                    "time_improvement": 57.48861113102528,
                    "length_improvement": 18.142811887370772,
                    "smoothness_improvement": 1453.325400096659,
                    "objective_score": 28.141772717265034
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner enhanced with adaptive informed sampling within an ellipsoidal subset, adaptive neighbor radius for efficient rewiring, incremental tree connection, and dedicated path smoothing. It maintains robust collision checking and enforces a strict 30-second planning timeout to ensure timely and high-quality solutions.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending them towards samples drawn from a uniform distribution initially and later from an informed ellipsoidal region around the best solution. Each extension attempts incremental rewiring of nearby nodes to minimize path costs. Upon successful connection of trees, the combined path is extracted and smoothed. The process concludes either when a time or iteration limit is reached, delivering the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...], 2D or 3D\n        self.parent = None                  # Parent Node or None\n        self.cost = cost                    # Cost from root to this node\n        self.children = []                  # List of child nodes\n        self.valid = True                   # For obstacle validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0, max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    normed = tuple(x / math.sqrt(norm_sq) for x in pt)\n                    return normed\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.68288,
          "time_improvement": 54.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1405.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01598813533782959,
                    "num_nodes_avg": 70.3,
                    "path_length_avg": 160.07310344541804,
                    "smoothness_avg": 0.04324016794566805,
                    "success_improvement": 0.0,
                    "time_improvement": 35.595523703969775,
                    "length_improvement": 12.26139548092287,
                    "smoothness_improvement": 576.8025258772809,
                    "objective_score": 16.01494883676191
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040297436714172366,
                    "num_nodes_avg": 257.0,
                    "path_length_avg": 231.7466873890371,
                    "smoothness_avg": 0.08312651221825451,
                    "success_improvement": 0.0,
                    "time_improvement": 74.75717816950535,
                    "length_improvement": 22.636285290996536,
                    "smoothness_improvement": 2038.9050329823299,
                    "objective_score": 37.14893567396256
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022991228103637695,
                    "num_nodes_avg": 180.8,
                    "path_length_avg": 127.98573904981842,
                    "smoothness_avg": 0.13355395998673397,
                    "success_improvement": 0.0,
                    "time_improvement": 52.97061596211985,
                    "length_improvement": 14.997966149089132,
                    "smoothness_improvement": 1598.796513103363,
                    "objective_score": 26.884760583970596
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive informed sampling, dynamic neighbor radius scaling, incremental extend-and-rewire, and rigorous collision checks. It alternates growth between two trees seeded at start and goal, focusing sampling within an ellipsoidal region once a feasible path is found. The planner maintains consistent parent-child relationships with recursive cost updates and applies randomized path smoothing to improve solution quality, all within a strict 30-second planning time limit.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points using goal bias, uniform, or informed ellipsoidal distributions based on the current best cost. It extends and rewires nodes using an adaptive radius based on node density and iteration progress. Incremental connect attempts bridge the two trees iteratively, and upon finding a path, the planner applies randomized shortcut smoothing. The process halts early if time runs out or a satisfactory path is found, returning the best solution discovered.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Node coordinate tuple, 2D or 3D\n        self.parent = None                    # Parent Node or None\n        self.cost = cost                      # Cost from root\n        self.children: List[Node] = []       # Children nodes list\n        self.valid = True                     # Collision validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from current parent if any\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update descendants' costs and parents\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, \n                 max_iter: int = 15000, \n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)  # Reduce radius over time\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            rad_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= rad_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                point = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in point)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in point)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0],\n                            [0, 1, 0],\n                            [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = clamp(sample_pt)\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors toward new_node if cheaper\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_shortcut(path: List[Tuple[float, ...]], trials: int = self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n        c_min = dist(start_pos, goal_pos)\n\n        grow_start = True\n        iteration = 0\n        t_start = time.perf_counter()\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_uniform()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(other_tree, new_node.position, iteration)\n            if connected_node is not None:\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n\n                # Avoid duplicated middle node\n                if path_from_goal and path_from_goal[0] == new_node.position:\n                    path_from_goal = path_from_goal[1:]\n                combined_path = path_from_start + path_from_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    smoothed = path_shortcut(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, [(n, c) for n in all_nodes for c in n.children])\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed = path_shortcut(best_path) if success else []\n\n        edges = [(n, c) for n in all_nodes for c in n.children]\n\n        return PlannerResult(success, smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.66086,
          "time_improvement": 56.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1382.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019427227973937988,
                    "num_nodes_avg": 53.3,
                    "path_length_avg": 167.32838520346422,
                    "smoothness_avg": 0.036634018904249666,
                    "success_improvement": 0.0,
                    "time_improvement": 21.74194068869344,
                    "length_improvement": 8.284660582041207,
                    "smoothness_improvement": 473.40194789683244,
                    "objective_score": 10.546524062500437
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03835971355438232,
                    "num_nodes_avg": 218.6,
                    "path_length_avg": 244.07150961036504,
                    "smoothness_avg": 0.10085907257140406,
                    "success_improvement": 0.0,
                    "time_improvement": 75.97099235888778,
                    "length_improvement": 18.521904883179296,
                    "smoothness_improvement": 2495.176583115832,
                    "objective_score": 38.971561599881355
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01450345516204834,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 124.36167150818252,
                    "smoothness_avg": 0.10037330833942,
                    "success_improvement": 0.0,
                    "time_improvement": 70.33266080361206,
                    "length_improvement": 17.404899250692054,
                    "smoothness_improvement": 1176.7410732904711,
                    "objective_score": 30.464483457674383
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an advanced bidirectional informed RRT* planner that adaptively samples within an ellipsoidal region after an initial solution is found, uses adaptive neighbor radius for efficient rewiring with recursive cost propagation, performs incremental connection attempts between trees with rewiring, applies rigorous collision and boundary checks, and performs randomized path smoothing to produce high-quality, smooth, and efficient paths. It enforces a strict 30-second planning time limit, terminating early if time is exceeded or an improved solution is found, returning the best available path.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, initially sampling uniformly with goal bias, switching to informed ellipsoidal sampling post-solution. Each extension rewires neighbor nodes adaptively to minimize path cost. Incremental connections attempt to join the two trees efficiently, triggering rewiring. Upon connection, the path is extracted, smoothed by shortcutting, and returned. Planning halts when time limit is reached or upon finding a better path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = None             # Node or None\n        self.cost = 0.0                # Cost from root node\n        self.children = []             # List[Node]\n        self.valid = True              # Collision validity flag\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for c in self.children:\n            c.update_parent(self, self.cost + dist_func(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=5.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            res = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, res)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 2.5 * (1 + 1/dim) ** (1 / dim)\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n\n                # Construct orthonormal basis u=direction, v,w arbitrary orthogonal vectors\n                if abs(vx) < 0.9:\n                    arb = (1.0,0.0,0.0)\n                else:\n                    arb = (0.0,1.0,0.0)\n\n                wx = vy*arb[2] - vz*arb[1]\n                wy = vz*arb[0] - vx*arb[2]\n                wz = vx*arb[1] - vy*arb[0]\n\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-14:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w; wy /= norm_w; wz /= norm_w\n\n                # v = w x u\n                vx2 = wy * vz - wz * vy\n                vy2 = wz * vx - wx * vz\n                vz2 = wx * vy - wy * vx\n\n                return [[vx, vx2, wx], [vy, vy2, wy], [vz, vz2, wz]]\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                rewire(tree, new_node, neighbors)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            for _ in range(trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path)-3)\n                j = random.randint(i+2, len(smoothed_path)-1)\n                if collision_free_edge(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n            return smoothed_path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        grow_start = True\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            opposite_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connected_node = incremental_connect(opposite_tree, new_node.position)\n            if connected_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n\n                # Remove overlap on connection point\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = 0.0\n                for i in range(len(combined_path)-1):\n                    total_cost += dist_func(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-14 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n\n                    # Gather edges\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.5813,
          "time_improvement": 51.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1654.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01635730266571045,
                    "num_nodes_avg": 76.7,
                    "path_length_avg": 161.15983880979687,
                    "smoothness_avg": 0.03717784391649352,
                    "success_improvement": 0.0,
                    "time_improvement": 34.10841917830849,
                    "length_improvement": 11.665738607283002,
                    "smoothness_improvement": 481.9139902733644,
                    "objective_score": 14.97524342631597
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03572168350219727,
                    "num_nodes_avg": 254.6,
                    "path_length_avg": 244.2543114898976,
                    "smoothness_avg": 0.12461836399454304,
                    "success_improvement": 0.0,
                    "time_improvement": 77.62348760475484,
                    "length_improvement": 18.46088035413097,
                    "smoothness_improvement": 3106.5202645590925,
                    "objective_score": 42.51182367504811
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028421854972839354,
                    "num_nodes_avg": 210.1,
                    "path_length_avg": 129.2611748795124,
                    "smoothness_avg": 0.11585048940853751,
                    "success_improvement": 0.0,
                    "time_improvement": 41.86207337157828,
                    "length_improvement": 14.15088240073408,
                    "smoothness_improvement": 1373.6096740829742,
                    "objective_score": 22.25684686203517
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after the first solution, dynamic rewiring with recursive cost propagation, and multi-trial randomized shortcut path smoothing. It enforces strict collision checks for both nodes and edges, ensures samples remain within map bounds, alternates growth between start and goal trees, and terminates upon timeout or path convergence. The planner balances exploration and exploitation to efficiently find a smooth, low-cost path with high success and robustness within a 30-second planning window.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Initial sampling is uniform random; once a path is found, sampling is biased inside an ellipsoidal informed set to focus search on promising regions. New nodes are added via constrained steering, with parent selection from neighbors within an adaptively computed radius to minimize cost. Rewiring neighbors dynamically updates parents and propagates cost changes to descendants, optimizing path costs. Incremental connection attempts between trees trigger potential path updates. Shortcut smoothing prunes redundant waypoints. The process stops early on timeout or successful path discovery, returning the best available solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] (x,y) or (x,y,z)\n        self.parent = None                  # Node or None\n        self.cost = cost                    # Cost from root\n        self.children = []\n        self.valid = True                   # For collision or pruning flags\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + self._distance(self.position, c.position))\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float =5.0,\n                 goal_sample_rate: float=0.1,\n                 neighbor_radius_min: float=5.0,\n                 neighbor_radius_max: float=30.0,\n                 smoothing_trials: int=150,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        t_start = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist_val = math.dist(from_pos, to_pos)\n            if dist_val <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_val\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 35.0\n            base = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim))\n            shrink = min(1.0, iter_num/self.max_iter)\n            r = base * (1 - 0.5 * shrink)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree_nodes if (math.dist(n.position, pos)**2) <= r_sq]\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return random.choice([start_pos, goal_pos])\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0.0, 1 - cos_t*cos_t))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B): return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s): return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1-cos_t))\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        rotation_mat = None\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                r_sample = random.random() ** (1.0/dim)\n                unit_pt = tuple(r_sample * d for d in dir_sample)\n                scaled = tuple(unit_pt[d]*radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = rotation_mat[0][0]*scaled[0] + rotation_mat[0][1]*scaled[1]\n                    y_rot = rotation_mat[1][0]*scaled[0] + rotation_mat[1][1]*scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i]*scaled[i] for i in range(dim))\n                    y_rot = sum(rotation_mat[1][i]*scaled[i] for i in range(dim))\n                    z_rot = sum(rotation_mat[2][i]*scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pts = tuple(center[d] + rotated[d] for d in range(dim))\n                pts_clamped = clamp(pts)\n                if collision_free_node(pts_clamped):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return pts_clamped\n            return sample_uniform()\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes+1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            # Rewire neighbors for improvement\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target.position))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes+1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = math.dist(new_node.position, target.position)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target.position):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def shortcut_path(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) -1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connected_node = incremental_connect(other_tree, new_node, iteration)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                candidate_path = path_start + path_goal[::-1]\n                candidate_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                if candidate_cost + 1e-12 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    informed_sampling = True\n                    best_path = shortcut_path(best_path, self.smoothing_trials)\n\n                    # Prepare nodes and edges for return\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for n in nodes_all:\n                        for c in n.children:\n                            edges_all.append((n, c))\n\n                    return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = len(best_path) > 0\n        smoothed = shortcut_path(best_path, self.smoothing_trials) if success else []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for n in nodes_all:\n            for c in n.children:\n                edges_all.append((n, c))\n\n        return PlannerResult(success, smoothed, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.4688,
          "time_improvement": 51.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1528.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020235300064086914,
                    "num_nodes_avg": 70.8,
                    "path_length_avg": 154.5624175507092,
                    "smoothness_avg": 0.03977280929930181,
                    "success_improvement": 0.0,
                    "time_improvement": 18.486810639078467,
                    "length_improvement": 15.281889742218805,
                    "smoothness_improvement": 522.530833571835,
                    "objective_score": 11.215075308026478
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03416416645050049,
                    "num_nodes_avg": 217.8,
                    "path_length_avg": 236.9615138983604,
                    "smoothness_avg": 0.10177976720857998,
                    "success_improvement": 0.0,
                    "time_improvement": 78.59913590002499,
                    "length_improvement": 20.895426101725892,
                    "smoothness_improvement": 2518.8667192799107,
                    "objective_score": 40.35315958675223
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021622991561889647,
                    "num_nodes_avg": 155.0,
                    "path_length_avg": 125.06894790820198,
                    "smoothness_avg": 0.12925113333672425,
                    "success_improvement": 0.0,
                    "time_improvement": 55.76939302119956,
                    "length_improvement": 16.935159942682105,
                    "smoothness_improvement": 1544.0648757168653,
                    "objective_score": 27.838174273480615
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This simplified bidirectional RRT* planner grows two trees from start and goal, employing goal-biased and adaptive informed sampling once a path is found. It uses adaptive neighbor radius for rewiring to optimize paths, performing robust collision checks for nodes and edges to guarantee validity. Incremental extensions and rewiring improve tree quality while enforcing a 30-second planning time limit. Path smoothing is applied before returning the best found path, ensuring efficiency, solution quality, and robustness.",
          "planning_mechanism": "The planner alternately grows trees from start and goal. Sampling switches from uniform goal-biased to ellipsoidal informed after an initial solution. Extensions find optimal parents in an adaptive neighborhood and rewire neighbors to minimize cost. Incremental connection attempts bridge trees progressively. Timing enforces early termination with the best available path returned, applying path smoothing on completion.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = None             # Node or None\n        self.cost = cost               # Path cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0,1-cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best/2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best/2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = [a1, a_minor, a_minor]\n            n_ = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n_)\n                r_sample = random.random() ** (1/n_)\n                sample_unit = tuple(r_sample * ds for ds in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n_))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n_))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n_))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, tries=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(tries):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path = []\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if informed:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed = True\n                    grow_start = not grow_start\n                    break\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed = True\n                    grow_start = not grow_start\n                    break\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        extracted_path = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = [(node, child) for node in all_nodes for child in node.children]\n\n        return PlannerResult(success_state, extracted_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.44803,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1542.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01830923557281494,
                    "num_nodes_avg": 80.1,
                    "path_length_avg": 159.66330926763604,
                    "smoothness_avg": 0.04347436047652111,
                    "success_improvement": 0.0,
                    "time_improvement": 26.245512467129846,
                    "length_improvement": 12.486010163369478,
                    "smoothness_improvement": 580.4681475423519,
                    "objective_score": 13.273196510524608
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0373302698135376,
                    "num_nodes_avg": 241.1,
                    "path_length_avg": 233.81434209429435,
                    "smoothness_avg": 0.09833497031214453,
                    "success_improvement": 0.0,
                    "time_improvement": 76.61584888211975,
                    "length_improvement": 21.94604263624083,
                    "smoothness_improvement": 2430.2296139477126,
                    "objective_score": 39.525111261622655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024415230751037596,
                    "num_nodes_avg": 176.2,
                    "path_length_avg": 124.58525164500907,
                    "smoothness_avg": 0.13486176545922535,
                    "success_improvement": 0.0,
                    "time_improvement": 50.05776732812575,
                    "length_improvement": 17.256407969553898,
                    "smoothness_improvement": 1615.4317021812947,
                    "objective_score": 26.545770303254976
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive informed sampling and dynamic neighborhood radius scaling. It grows two trees from start and goal, alternately extending and rewiring them with efficient collision checking and cost updates. The planner focuses sampling within informed ellipsoidal regions after initial feasible path discovery, aggressively smooths paths through randomized shortcutting, and halts within a 30-second time limit, returning the best path found.",
          "planning_mechanism": "The planner iteratively samples points biased by goal and informed ellipsoidal regions to extend one tree towards the sample, rewiring nearby nodes to optimize costs. It then incrementally connects the opposite tree to the new node with rewiring. Adaptive neighbor radius scales with tree size and iteration progress to optimize rewiring locality. Upon tree connection, the combined path is shortcut-smoothed. The process alternates tree growth, enforcing strict collision checks and bounds, and exits early if time limit or max iteration reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] e.g. (x,y) or (x,y,z)\n        self.parent = None                  # type: Node or None\n        self.cost = cost                    # cost from root to this node\n        self.children = []\n        self.valid = True                   # valid node flag\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 7000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pt = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            return tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_via_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_via_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, trials=self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sampling strategy\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        smoothed = path_smoothing(best_path) if success_state else []\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for node in nodes_all:\n            for c in node.children:\n                edges_all.append((node, c))\n\n        return PlannerResult(success_state, smoothed, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.35583,
          "time_improvement": 52.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1481.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019919705390930176,
                    "num_nodes_avg": 80.1,
                    "path_length_avg": 166.04426582975003,
                    "smoothness_avg": 0.04062840638195663,
                    "success_improvement": 0.0,
                    "time_improvement": 19.758110213231042,
                    "length_improvement": 8.98850675894757,
                    "smoothness_improvement": 535.9227858741857,
                    "objective_score": 10.404748345129754
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03934195041656494,
                    "num_nodes_avg": 242.6,
                    "path_length_avg": 235.24097549030694,
                    "smoothness_avg": 0.09376449938916415,
                    "success_improvement": 0.0,
                    "time_improvement": 75.35570681893434,
                    "length_improvement": 21.469791345286342,
                    "smoothness_improvement": 2312.6281051222845,
                    "objective_score": 38.46381084034899
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01874575614929199,
                    "num_nodes_avg": 155.1,
                    "path_length_avg": 122.42925069245436,
                    "smoothness_avg": 0.1330951623004038,
                    "success_improvement": 0.0,
                    "time_improvement": 61.65488154649649,
                    "length_improvement": 18.688321144507835,
                    "smoothness_improvement": 1592.9606403981657,
                    "objective_score": 30.198931894841344
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planner integrates bidirectional RRT* with adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, recursive parent-child cost updates, incremental extend-and-rewire connection attempts, and randomized path smoothing. It enforces collision and edge-validity checks, clamps samples within workspace bounds, alternates tree growth between start and goal, and terminates early on success or exceeding a strict 30-second limit, returning the best found path.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, initially sampling uniformly with goal bias, then switches to ellipsoidal informed sampling after the first solution. Each iteration extends one tree using adaptive radius rewiring and attempts incremental connection to the opposite tree. Upon connection, the path is extracted and smoothed by shortcutting random segments respecting collision constraints. The algorithm tracks the best solution and respects the maximum planning time, terminating early if the time limit is reached or an improved solution is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []              # List[Node]\n        self.valid = True               # Collision validity flag\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for c in self.children:\n            c.update_parent(self, self.cost + dist_func(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                new_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if new_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = new_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    new_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if new_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = new_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                # Check time limit mid-connect\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        # Prepare nodes and edges for return\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.34917,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1411.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015734434127807617,
                    "num_nodes_avg": 63.5,
                    "path_length_avg": 158.05171398045536,
                    "smoothness_avg": 0.0379325535853074,
                    "success_improvement": 0.0,
                    "time_improvement": 36.61749988955243,
                    "length_improvement": 13.369351077634741,
                    "smoothness_improvement": 493.7268354685786,
                    "objective_score": 16.12775435973557
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03369519710540771,
                    "num_nodes_avg": 218.6,
                    "path_length_avg": 236.11343562232028,
                    "smoothness_avg": 0.10381260037547893,
                    "success_improvement": 0.0,
                    "time_improvement": 78.89290420360489,
                    "length_improvement": 21.17853904084778,
                    "smoothness_improvement": 2571.172980854768,
                    "objective_score": 40.75944397352487
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02763652801513672,
                    "num_nodes_avg": 165.5,
                    "path_length_avg": 125.8846182366874,
                    "smoothness_avg": 0.09970293140216517,
                    "success_improvement": 0.0,
                    "time_improvement": 43.46848791031507,
                    "length_improvement": 16.393430548549265,
                    "smoothness_improvement": 1168.2139281306681,
                    "objective_score": 22.160302123457715
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling, incremental tree connection, and rigorous rewiring for path cost improvement. It grows trees alternately from start and goal positions with efficient collision checks, early termination on time limits (30 seconds), and applies randomized path smoothing once a valid path is found for improved path quality and smoothness.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal, sampling points either uniformly or within an ellipsoidal informed region biased by the best path cost. It extends the active tree towards samples, rewires neighbors for cost reduction, then incrementally connects to the opposite tree with iterative rewiring. Once connected, the combined path is extracted and smoothed. The search terminates early on time limit or at first improved path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children: List[Node] = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Remove from old parent's children list\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Assign new parent and cost\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs\n        for child in self.children:\n            child.update_parent(self, new_cost + child._distance(self))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 max_planning_time: float = 30.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> bool:\n            resolution = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = (2.0 * (1.5 * (math.log(n_nodes) / n_nodes)) ** (1.0/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r2 = radius*radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= r2]\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1.0, 1.0) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_enabled = False\n\n        # Rotation matrix for ellipsoidal sampling\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n                # Create arbitrary vector not colinear to (vx,vy,vz)\n                if abs(vx) < 0.9:\n                    arbitrary = (1.0,0.0,0.0)\n                else:\n                    arbitrary = (0.0,1.0,0.0)\n                # Cross product w = v x arbitrary\n                wx = vy*arbitrary[2] - vz*arbitrary[1]\n                wy = vz*arbitrary[0] - vx*arbitrary[2]\n                wz = vx*arbitrary[1] - vy*arbitrary[0]\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w; wy /= norm_w; wz /= norm_w\n                # u = v\n                ux, uy, uz = vx, vy, vz\n                # v_ = w\n                vx_, vy_, vz_ = wx, wy, wz\n                # w_ = u cross v_\n                wx_, wy_, wz_ = uy*wz - uz*vy_, uz*vx_ - ux*wz, ux*vy_ - uy*vx_\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                r = random.random() ** (1.0 / n)\n                sample_unit = tuple(r * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free() -> Tuple[float, ...]:\n            attempts = 30\n            for _ in range(attempts):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # Fallback if sampling fails repeatedly\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            n_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node: Node, other_tree: List[Node]) -> Node:\n            if not other_tree:\n                return None\n            current_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n                min_cost = current_node.cost + math.dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, step_pos)\n                    if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n                if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n                current_node = connect_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path_nodes: List[Tuple[float, ...]] = []\n        best_path_cost = math.inf\n        informed_sampling_enabled = False\n        grow_start = True\n\n        start_time = time.perf_counter()\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                # Time exceeded, return best path found if any\n                if best_path_nodes:\n                    smoothed = path_smoothing(best_path_nodes, self.smoothing_trials)\n                    # Gather all nodes and edges\n                    all_nodes = tree_start + tree_goal\n                    edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n                else:\n                    all_nodes = tree_start + tree_goal\n                    edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                # Remove overlap in connection point\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Compute total cost\n                total_cost = 0.0\n                for i in range(len(combined_path)-1):\n                    total_cost += math.dist(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-9 < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = combined_path\n                    informed_sampling_enabled = True\n\n                smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n\n                all_nodes = tree_start + tree_goal\n                edges = []\n                for node in all_nodes:\n                    for c in node.children:\n                        edges.append((node, c))\n\n                return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached\n        if best_path_nodes:\n            smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n            all_nodes = tree_start + tree_goal\n            edges = []\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.24574,
          "time_improvement": 51.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1529.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015781450271606445,
                    "num_nodes_avg": 62.5,
                    "path_length_avg": 160.12592662173205,
                    "smoothness_avg": 0.0414925668946553,
                    "success_improvement": 0.0,
                    "time_improvement": 36.428106313951545,
                    "length_improvement": 12.23244226094837,
                    "smoothness_improvement": 549.4487744525086,
                    "objective_score": 16.122164218637682
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035854554176330565,
                    "num_nodes_avg": 236.9,
                    "path_length_avg": 237.2838880288203,
                    "smoothness_avg": 0.09845816398917688,
                    "success_improvement": 0.0,
                    "time_improvement": 77.54025574121387,
                    "length_improvement": 20.78780833795353,
                    "smoothness_improvement": 2433.399475990574,
                    "objective_score": 39.58663576990774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029289388656616212,
                    "num_nodes_avg": 200.4,
                    "path_length_avg": 128.10000819020397,
                    "smoothness_avg": 0.1339278140664068,
                    "success_improvement": 0.0,
                    "time_improvement": 40.08750201783301,
                    "length_improvement": 14.92207402695679,
                    "smoothness_improvement": 1603.5519094017636,
                    "objective_score": 23.02842495775008
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT* variant enhanced with adaptive neighbor radius, ellipsoidal informed sampling after the first solution, robust incremental extend-and-rewire steps, consistent parent-child cost propagation, randomized path smoothing, and thorough collision checking to ensure feasibility and efficiency within a strict 30-second time limit.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling with goal bias and switching to focused ellipsoidal sampling after finding an initial path. Each iteration extends one tree toward a sample with steering and adaptive neighbor rewiring, then incrementally connects the other tree. Upon successful connection, it shortcuts and smooths the combined path. Iterations stop either on timeout or max iterations, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                # Tuple[float, ...]\n        self.parent = None                      # Node or None\n        self.cost = 0.0\n        self.children = []                     # List[Node]\n        self.valid = True                      # Validity flag for collision checks\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + math.dist(self.position, c.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K,sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes+1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.18055,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1637.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015459370613098145,
                    "num_nodes_avg": 69.1,
                    "path_length_avg": 164.94822463487387,
                    "smoothness_avg": 0.04062795546838197,
                    "success_improvement": 0.0,
                    "time_improvement": 37.72552913991114,
                    "length_improvement": 9.589264305743352,
                    "smoothness_improvement": 535.9157280975678,
                    "objective_score": 15.91509024360985
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040113639831542966,
                    "num_nodes_avg": 255.8,
                    "path_length_avg": 235.80564763820144,
                    "smoothness_avg": 0.11296878333955736,
                    "success_improvement": 0.0,
                    "time_improvement": 74.87231085137101,
                    "length_improvement": 21.281287529132562,
                    "smoothness_improvement": 2806.7681634525256,
                    "objective_score": 40.751791578500445
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032284116744995116,
                    "num_nodes_avg": 237.7,
                    "path_length_avg": 121.59499216372414,
                    "smoothness_avg": 0.13109787658732472,
                    "success_improvement": 0.0,
                    "time_improvement": 33.96167799823163,
                    "length_improvement": 19.242395936168286,
                    "smoothness_improvement": 1567.5553135520959,
                    "objective_score": 21.874759154463625
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements an efficient bidirectional informed RRT* with adaptive neighbor radius, dynamic rewiring, and ellipsoidal informed sampling. It uses rigorous 2D/3D collision checks and incremental tree connection attempts, coupled with randomized path smoothing to produce high-quality, smooth paths. The planner enforces a strict 30-second time limit, alternates growth between start and goal trees, and biases sampling towards promising regions as solutions improve to optimize planning speed and path quality.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Each iteration performs goal-biased or ellipsoidal informed sampling, extends and rewires one tree towards the sample with an adaptive neighborhood, then incrementally attempts to connect the opposing tree to the new node. Upon successful connection, it merges and smooths the path, updates the best solution, and switches growth direction. The process terminates if the time limit or iteration limits are reached, returning the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position           # Tuple[float, ...]\n        self.parent = None                 # Parent Node\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # List of child Nodes\n        self.valid = True                 # Validity flag for collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = self._distance\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1, p2):\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 8000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int, iter_num: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 35.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            factor = min(1.0, iter_num / self.max_iter)\n            scaled_radius = base_radius * (1.0 - 0.5 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, scaled_radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample(max_attempts=100):\n            for _ in range(max_attempts):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0, 1 - cos_t * cos_t))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1 - cos_t))\n\n        c_min = dist_func(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            for _ in range(200):\n                dir_sample = unit_ball_sample(dim)\n                r_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(r_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n\n                if collision_free_node(clamped):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return clamped\n\n            return uniform_sample()\n\n        def extend_and_rewire(tree: list, sample: tuple, iter_num: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cand_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple, iter_num: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cand_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if (time.perf_counter() - start_time) > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = self.smoothing_trials) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_rate and grow_start else (\n                    start_pos if random.random() < self.goal_sample_rate and not grow_start else uniform_sample()\n                )\n            )\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smooth_path = path_smoothing(best_path, self.smoothing_trials)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smooth_path = path_smoothing(best_path, self.smoothing_trials)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        final_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.16872,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1504.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019357013702392577,
                    "num_nodes_avg": 68.7,
                    "path_length_avg": 160.58083031371604,
                    "smoothness_avg": 0.04250598761094988,
                    "success_improvement": 0.0,
                    "time_improvement": 22.024782514324574,
                    "length_improvement": 11.98310233896166,
                    "smoothness_improvement": 565.3110093408272,
                    "objective_score": 11.83061026879384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.038924455642700195,
                    "num_nodes_avg": 249.0,
                    "path_length_avg": 233.03937596771743,
                    "smoothness_avg": 0.10340687428565883,
                    "success_improvement": 0.0,
                    "time_improvement": 75.61723080286863,
                    "length_improvement": 22.204748635455356,
                    "smoothness_improvement": 2560.7333563310062,
                    "objective_score": 39.929785749606694
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022962260246276855,
                    "num_nodes_avg": 184.5,
                    "path_length_avg": 121.15167670507103,
                    "smoothness_avg": 0.11681578261725933,
                    "success_improvement": 0.0,
                    "time_improvement": 53.02987075627163,
                    "length_improvement": 19.53682495539203,
                    "smoothness_improvement": 1385.8881324473823,
                    "objective_score": 26.745766880196804
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive neighbor radius, goal-biased and ellipsoidal informed sampling after finding an initial path, incremental extend-and-rewire steps for optimized tree growth, robust collision checking, and post-hoc path smoothing. It enforces a 30-second planning time limit to ensure timely results and maintains consistent parent-child links with cost propagation to optimize path length and smoothness while improving planning efficiency and success rate.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points with goal bias and switching to informed ellipsoidal sampling upon discovering a path. Each extension chooses the best parent within an adaptive radius and rewires neighbors to minimize path costs. Incremental connections attempt to link the two trees progressively while ensuring collision-free paths. Path smoothing refines the final trajectory before returning. Timing is strictly monitored to enforce the maximum planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                  # Tuple[float, ...]\n        self.parent = None                        # Node or None\n        self.cost = cost                          # Cost from root\n        self.children = []                        # List[Node]\n        self.valid = True                         # For collision/validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # Clamp to bounds\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                # Time check to limit execution during incremental connect\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # On time limit or iteration end, return best found path or failure\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.11398,
          "time_improvement": 52.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1378.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015044641494750977,
                    "num_nodes_avg": 67.2,
                    "path_length_avg": 160.32343966413097,
                    "smoothness_avg": 0.04740254039094182,
                    "success_improvement": 0.0,
                    "time_improvement": 39.396168717790125,
                    "length_improvement": 12.124182232615077,
                    "smoothness_improvement": 641.9526933822505,
                    "objective_score": 17.453450528771306
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03404114246368408,
                    "num_nodes_avg": 233.7,
                    "path_length_avg": 232.14836316368215,
                    "smoothness_avg": 0.08683891562649824,
                    "success_improvement": 0.0,
                    "time_improvement": 78.67619967462957,
                    "length_improvement": 22.5021943558239,
                    "smoothness_improvement": 2134.4278466125347,
                    "objective_score": 38.77543800661633
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029708361625671385,
                    "num_nodes_avg": 211.5,
                    "path_length_avg": 123.78476098665263,
                    "smoothness_avg": 0.11456508567798769,
                    "success_improvement": 0.0,
                    "time_improvement": 39.230477739949,
                    "length_improvement": 17.78805574956528,
                    "smoothness_improvement": 1357.2594335090141,
                    "objective_score": 22.113051639442826
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive neighbor radius, informed ellipsoidal sampling after the first solution, incremental extend-and-rewire tree expansions, and path smoothing. It enforces a 30-second planning time limit, employs efficient collision checking, and maintains robust parent-child tree structure for consistent cost updates. Sampling alternates growth between start and goal trees, aiming to progressively improve the solution both in path quality and planning efficiency.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternatingly extending towards sampled points. Sampling is goal-biased initially and switches to informed ellipsoidal sampling after finding an initial feasible path to focus search and speed convergence. Each extension rewires neighbors within an adaptive radius, improving path optimality. Incremental connection attempts bridge the two trees smoothly. Upon connecting, the combined path is smoothed and returned. If the 30-second time limit hits before completion, the best available path is returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.children = []\n        self.cost = cost\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Detach from old parent if exists\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update recursively\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(a, b):\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            # Smaller resolution for finer accuracy, but capped to step_size / 5 minimum\n            resolution = max(self.step_size / 5, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_neighbor_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        # Find nodes nearby position within radius\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos)**2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        # Rotation matrix for 2D and 3D informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                \n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                \n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def informed_sample(c_best):\n            # If no best yet or invalid, sample uniformly\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if collision_free_node(sample_clamped):\n                    return sample_clamped\n\n        def extend_and_rewire(tree, sample):\n            # Find nearest \n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            # Choose best parent with lowest cost to new_pos and collision free edge\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors if new_node provides lower cost path and edges collision-free\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials=self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iter_count = 0\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            # Sampling\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    # Build combined path\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    candidate_path = path_s + path_g[::-1]\n\n                    candidate_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling = True\n\n                    # Update edges and nodes\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    # Smooth path before returning\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    candidate_path = path_s + path_g[::-1]\n\n                    candidate_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # If time limit or iteration limit reached return best found path if any\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed_path = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.02559,
          "time_improvement": 49.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1574.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017846441268920897,
                    "num_nodes_avg": 74.4,
                    "path_length_avg": 158.70535739924725,
                    "smoothness_avg": 0.03581784225382538,
                    "success_improvement": 0.0,
                    "time_improvement": 28.109771440754972,
                    "length_improvement": 13.011078762152122,
                    "smoothness_improvement": 460.62701096172844,
                    "objective_score": 13.338282239465558
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047143745422363284,
                    "num_nodes_avg": 262.2,
                    "path_length_avg": 239.6206933391445,
                    "smoothness_avg": 0.11160578593964379,
                    "success_improvement": 0.0,
                    "time_improvement": 70.46856417791994,
                    "length_improvement": 20.007715464155844,
                    "smoothness_improvement": 2771.6972586254046,
                    "objective_score": 39.00059863933418
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025639796257019044,
                    "num_nodes_avg": 168.2,
                    "path_length_avg": 120.29237919369317,
                    "smoothness_avg": 0.12500902174593667,
                    "success_improvement": 0.0,
                    "time_improvement": 47.552874540287654,
                    "length_improvement": 20.10752944709882,
                    "smoothness_improvement": 1490.1055294021537,
                    "objective_score": 25.73789589851683
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after initial solution discovery, incremental extend-and-rewire steps, and randomized path smoothing. It maintains and grows two trees from start and goal positions alternately, aggressively attempts to connect the trees, and performs recursive cost updates to optimize paths under strict collision and boundary constraints, all within a 30-second time limit.",
          "planning_mechanism": "The planner iteratively samples points using a combination of goal bias and ellipsoidal informed sampling, extends one tree toward the sample with rewiring to optimize costs, then incrementally attempts to connect the opposite tree to the newly added node. Upon connecting, it combines and smooths the path and returns early. The adaptive neighbor radius balances exploration and exploitation, and tight collision checks ensure feasibility and safety. If the time limit is reached before a solution is found, the best path so far is returned.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position                # Node coordinates (2D or 3D)\n        self.parent = None                      # Parent node reference\n        self.cost = 0.0                        # Cost from root to this node\n        self.children: List['Node'] = []       # List of child nodes\n        self.valid = True                      # Validity flag (collision)\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 6.0, goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 7.0, neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(min(max(0.0, pos[d]), bounds[d]) for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = dist_func(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            scale = self.step_size / dist\n            return tuple(from_p[d] + scale * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 6.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes: List[Node], pos: Tuple[float, ...], radius: float):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n: int):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction: Tuple[float, ...]):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0,-kz,ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.00389,
          "time_improvement": 52.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1497.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01748628616333008,
                    "num_nodes_avg": 63.1,
                    "path_length_avg": 164.93099564244054,
                    "smoothness_avg": 0.03491419773603069,
                    "success_improvement": 0.0,
                    "time_improvement": 29.560572329713853,
                    "length_improvement": 9.598707789506916,
                    "smoothness_improvement": 446.4830119627635,
                    "objective_score": 13.020328316629357
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029943013191223146,
                    "num_nodes_avg": 198.4,
                    "path_length_avg": 243.0350083420968,
                    "smoothness_avg": 0.10383662253682273,
                    "success_improvement": 0.0,
                    "time_improvement": 81.24331945936477,
                    "length_improvement": 18.867918840562048,
                    "smoothness_improvement": 2571.7910883686072,
                    "objective_score": 41.00553504776488
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026508474349975587,
                    "num_nodes_avg": 198.1,
                    "path_length_avg": 128.76541994851763,
                    "smoothness_avg": 0.12353825436023147,
                    "success_improvement": 0.0,
                    "time_improvement": 45.775962256403055,
                    "length_improvement": 14.480139220587812,
                    "smoothness_improvement": 1471.3974768167395,
                    "objective_score": 23.98580390512218
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation provides an enhanced bidirectional RRT* planner for 2D/3D environments, incorporating adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, incremental extend-and-rewire expansions, and rigorous collision and boundary checks. It maintains parent-child relationships with recursive cost updates for efficient rewiring and optimal path cost improvements. The planner benefits from early stopping upon finding better paths, path smoothing via random shortcutting, and enforces a 30-second time limit for timely response, returning the best available solution if interrupted.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with goal bias initially and focused ellipsoidal informed sampling once a solution is found. New nodes are added by steering towards samples with incremental connection attempts to the opposite tree and rewiring neighbors adaptively based on node density, which improves path cost quality. Paths from both trees are merged, smoothed, and returned early upon improvement. Planning halts if the runtime exceeds the 30-second limit, outputting the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 27.0  # Slightly tuned value for tighter neighbor radius\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos) ** 2 <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2])\n                    y_rot = (R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2])\n                    z_rot = (R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_tree_start = True\n        iter_cnt = 0\n        success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_cnt += 1\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_rate else sample_free())\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n                        # Prepare edges and nodes for return\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # On timeout or max iterations reached\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed_path = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.89994,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1323.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01829349994659424,
                    "num_nodes_avg": 78.4,
                    "path_length_avg": 158.6148076988789,
                    "smoothness_avg": 0.040650676543581246,
                    "success_improvement": 0.0,
                    "time_improvement": 26.308899769308642,
                    "length_improvement": 13.060710487775834,
                    "smoothness_improvement": 536.2713622640409,
                    "objective_score": 13.186168839667964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047746133804321286,
                    "num_nodes_avg": 281.4,
                    "path_length_avg": 236.4099202531062,
                    "smoothness_avg": 0.08959639868918132,
                    "success_improvement": 0.0,
                    "time_improvement": 70.09122050947818,
                    "length_improvement": 21.079563937254512,
                    "smoothness_improvement": 2205.37987195014,
                    "objective_score": 36.27017830004506
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01942884922027588,
                    "num_nodes_avg": 153.0,
                    "path_length_avg": 120.27417918571132,
                    "smoothness_avg": 0.10443872413434199,
                    "success_improvement": 0.0,
                    "time_improvement": 60.25759010020645,
                    "length_improvement": 20.119617025809113,
                    "smoothness_improvement": 1228.4528621240995,
                    "objective_score": 28.243464745844257
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines adaptive bidirectional RRT* with informed ellipsoidal sampling after finding a feasible path, dynamic rewiring with recursive cost propagation, robust and efficient collision checking for both nodes and edges, and aggressive path smoothing via randomized shortcutting. It enforces a strict 30-second planning limit, balances exploration and exploitation via alternating tree growth, and maintains consistent parent-child trees to ensure global cost improvements. A dynamic neighborhood radius accelerates rewiring while preventing excessive computational overhead. The planner aggressively connects and rewires the opposing tree incrementally to minimize overall path cost and search time, returning an optimized and smoothed path upon success or timeout.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. It samples points with goal bias before a solution and switches to ellipsoidal informed sampling after a first feasible path is found, focusing search in promising regions. Each iteration extends one tree towards the sample, rewires nearby nodes for path cost reduction using adaptive radius, and attempts incremental connection to the other tree with rewiring. Upon successfully connecting trees, it extracts, aggressively smooths, and updates the best path. The process terminates when the max iterations or 30 seconds are reached, yielding the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # List[Node]\n        self.valid = True                 # Validity flag for collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        # Prevent redundant updates\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        # Recursive update for children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 8000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = None) -> list:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time-out: return best solution so far\n                success_state = (len(best_path) > 0)\n                smoothed_path = path_smoothing(best_path) if success_state else []\n                all_nodes = tree_start + tree_goal\n                all_edges = []\n                for node in all_nodes:\n                    for c in node.children:\n                        all_edges.append((node, c))\n                return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n            # Sampling\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    # Combine paths from start and goal trees\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplicated connecting node in joint path\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Iterations exhausted: return best found solution\n        final_success = (len(best_path) > 0)\n        final_path = path_smoothing(best_path) if final_success else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(final_success, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.82377,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01797184944152832,
                    "num_nodes_avg": 68.3,
                    "path_length_avg": 158.34860786959325,
                    "smoothness_avg": 0.0396680227598747,
                    "success_improvement": 0.0,
                    "time_improvement": 27.604593850663367,
                    "length_improvement": 13.20661883241353,
                    "smoothness_improvement": 520.8906966821885,
                    "objective_score": 13.527155405092659
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0362393856048584,
                    "num_nodes_avg": 235.4,
                    "path_length_avg": 242.3844419263825,
                    "smoothness_avg": 0.09181065347175564,
                    "success_improvement": 0.0,
                    "time_improvement": 77.2991924881339,
                    "length_improvement": 19.0850966356435,
                    "smoothness_improvement": 2262.3542423690324,
                    "objective_score": 38.31854828541403
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02474074363708496,
                    "num_nodes_avg": 191.6,
                    "path_length_avg": 122.28679186258083,
                    "smoothness_avg": 0.11873426565839522,
                    "success_improvement": 0.0,
                    "time_improvement": 49.39191901162028,
                    "length_improvement": 18.782935516149333,
                    "smoothness_improvement": 1410.2910951229428,
                    "objective_score": 25.625618282330663
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner enhanced with adaptive neighbor radius and informed ellipsoidal sampling. It grows two trees from start and goal positions, alternately extending toward samples biased within the current best solution's informed subset once a feasible path is found. The planner dynamically rewires for path cost improvement, performs strict collision checks on nodes and edges, and applies shortcut smoothing post-processing. It respects workspace bounds and enforces a 30-second planning time limit to ensure timely termination while prioritizing path quality and success rate.",
          "planning_mechanism": "The planner initializes two trees at start and goal, then iteratively samples points\u2014initially uniformly, then inside an ellipsoidal informed region after the first solution. Each iteration extends one tree toward the sample using a step size limit, then incrementally attempts to connect to the opposite tree with rewiring of neighbors within an adaptive radius. Upon successful connection, the combined path undergoes shortcut smoothing. The planner alternates tree growth, maintains best path cost, performs continual collision validation, and stops upon timeout or satisfactory path discovery.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + self._distance(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter=15000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=5.0, neighbor_radius_max=30.0, smoothing_trials=150,\n                 max_planning_time=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        t_start = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iter_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1 - 0.6 * iter_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(nodes_list, pos, radius):\n            r_sq = radius * radius\n            return [node for node in nodes_list if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def unit_ball_sample(n):\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in sample)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in sample)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        rotation_mat = None\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n\n        grow_start = True\n        iteration = 0\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_uniform()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(rotation_mat[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(rotation_mat[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_node.position))\n            current_node = nearest\n\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, new_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist(new_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                current_node = new_node\n\n        def shortcut_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                r = random.random()\n                if r < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_uniform()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(other_tree, new_node, iteration)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n                    smoothed = shortcut_smoothing(best_path, self.smoothing_trials)\n                    final_nodes = tree_start + tree_goal\n                    final_edges = []\n                    for n in final_nodes:\n                        for c in n.children:\n                            final_edges.append((n, c))\n                    return PlannerResult(True, smoothed, final_nodes, final_edges)\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed = shortcut_smoothing(best_path, self.smoothing_trials) if success else []\n        final_nodes = tree_start + tree_goal\n        final_edges = []\n        for n in final_nodes:\n            for c in n.children:\n                final_edges.append((n, c))\n\n        return PlannerResult(success, smoothed, final_nodes, final_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.6651,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1512.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016969871520996094,
                    "num_nodes_avg": 65.3,
                    "path_length_avg": 161.41874983501975,
                    "smoothness_avg": 0.047429776767605916,
                    "success_improvement": 0.0,
                    "time_improvement": 31.64082833758156,
                    "length_improvement": 11.523825371650599,
                    "smoothness_improvement": 642.379001821782,
                    "objective_score": 15.008908584713499
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036951541900634766,
                    "num_nodes_avg": 235.8,
                    "path_length_avg": 234.985096812773,
                    "smoothness_avg": 0.09989346562056736,
                    "success_improvement": 0.0,
                    "time_improvement": 76.85308881614958,
                    "length_improvement": 21.555211012906533,
                    "smoothness_improvement": 2470.3308207722293,
                    "objective_score": 39.71862295128733
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029794740676879882,
                    "num_nodes_avg": 200.4,
                    "path_length_avg": 124.65872522004568,
                    "smoothness_avg": 0.11965647536923658,
                    "success_improvement": 0.0,
                    "time_improvement": 39.05378628380755,
                    "length_improvement": 17.207610319450254,
                    "smoothness_improvement": 1422.021534574405,
                    "objective_score": 22.26776562190434
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after the first feasible solution, incremental and rewiring tree expansions avoiding collisions, and progressive tree connection attempts. It enforces map bounds and applies multi-pass random shortcut path smoothing. A strict 30-second timeout guarantees prompt termination, returning the best path found.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points combining goal bias and informed ellipsoidal distribution after the first solution, and selects parents for new nodes based on minimal cumulative cost within an adaptive radius. Neighboring nodes are rewired if a better cost path is found through new nodes. The two trees are incrementally connected attempting rewiring and cost improvement. Upon connection, combined paths are smoothed and returned early, or the best path is returned when time expires.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...], 2D or 3D coordinate\n        self.parent = None                # Parent Node or None\n        self.cost = 0.0                  # Cost from root to this node\n        self.children = []               # List of child Nodes\n        self.valid = True                # Validity for collision checking or pruning\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Remove from old parent child list\n        if self.parent:\n            self.parent.remove_child(self)\n        # Assign new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update recursively to children\n        dist_fn = self._distance\n        for ch in self.children:\n            ch.update_parent(self, self.cost + dist_fn(self.position, ch.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n        dist_fn = math.dist\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_fn(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist_fn(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def sample_unit_ball(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = sample_unit_ball\n\n        c_min = dist_fn(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                direction_sample = self._unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * ds for ds in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            # Find nearest node in tree\n            nearest_node = min(tree, key=lambda n: dist_fn(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Choose best parent among neighbors\n            min_cost = nearest_node.cost + dist_fn(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist_fn(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            # Create new node with best parent\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors to new node if better cost found\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_fn(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_fn(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_fn(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist_fn(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr == new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_fn(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                # Check if close enough to target\n                if dist_fn(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees from start and goal\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start_tree = True\n        iter_count = 0\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        while iter_count < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Timeout: return best found path so far\n                break\n            iter_count += 1\n\n            if informed_sampling:\n                sample_point = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_point = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_point = sample_uniform_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_point)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect_and_rewire(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_fn(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges list\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_point)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect_and_rewire(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_fn(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # If here, no early solution found; return best found or failure\n        success = (len(best_path) > 0)\n        if success:\n            best_path = path_smoothing(best_path)\n        else:\n            best_path = []\n\n        # Update edges\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, best_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.59545,
          "time_improvement": 49.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1457.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01672821044921875,
                    "num_nodes_avg": 68.2,
                    "path_length_avg": 155.13783779684508,
                    "smoothness_avg": 0.037026322629656404,
                    "success_improvement": 0.0,
                    "time_improvement": 32.614303632860754,
                    "length_improvement": 14.966492787194435,
                    "smoothness_improvement": 479.5423531006228,
                    "objective_score": 15.175301412800227
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043354034423828125,
                    "num_nodes_avg": 260.3,
                    "path_length_avg": 238.7286924134167,
                    "smoothness_avg": 0.10415372065139916,
                    "success_improvement": 0.0,
                    "time_improvement": 72.84248687190224,
                    "length_improvement": 20.305491047986855,
                    "smoothness_improvement": 2579.950251253199,
                    "objective_score": 38.81359552743404
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028838229179382325,
                    "num_nodes_avg": 192.2,
                    "path_length_avg": 120.901021123547,
                    "smoothness_avg": 0.11090775284393976,
                    "success_improvement": 0.0,
                    "time_improvement": 41.010364955885656,
                    "length_improvement": 19.70329845770413,
                    "smoothness_improvement": 1310.738429816153,
                    "objective_score": 22.79746132738729
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, goal biasing, ellipsoidal informed sampling after first solution, incremental connect and rewiring for efficient tree merging, rigorous collision checks on nodes and edges, and randomized shortcut path smoothing. It enforces a 30-second time limit and returns the best feasible path with improved path quality, smoothness, and planning speed.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately. Sampling switches from uniform with goal bias to informed ellipsoidal sampling after the first solution to focus exploration. Each node extension rewires neighbors adaptively, maintaining parent-child cost consistency. Incremental connections attempt to join both trees efficiently. Once connected, the combined path is smoothed and the planner terminates early if time or iterations exceed limits, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Path cost from root\n        self.children = []\n        self.valid = True                   # For collision checking etc.\n\n        if parent:\n            parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 9000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float =30.0, smoothing_trials: int = 150,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 35.0\n            base = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            factor = min(1.0, iteration / self.max_iter)\n            radius = base * (1 - 0.5 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius*radius\n            return [n for n in tree_nodes if (dist(n.position, pos)**2) <= r_sq]\n\n        def uniform_sample():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return uniform_sample()\n\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cand_cost = nbr.cost + dist(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            curr = nearest\n            while True:\n                new_pos = steer(curr.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cand_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def random_path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iter_num in range(1, self.max_iter+1):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling_active:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iter_num)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined, self.smoothing_trials)\n                        informed_sampling_active = True\n                        # immediately return best found path\n                        all_nodes = tree_start + tree_goal\n                        edges = [(n, c) for n in all_nodes for c in n.children]\n                        return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iter_num)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined, self.smoothing_trials)\n                        informed_sampling_active = True\n                        all_nodes = tree_start + tree_goal\n                        edges = [(n, c) for n in all_nodes for c in n.children]\n                        return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        success = len(best_path) > 0\n        smoothed = random_path_smoothing(best_path, self.smoothing_trials) if success else []\n        all_nodes = tree_start + tree_goal\n        edges = [(n, c) for n in all_nodes for c in n.children]\n        return PlannerResult(success, smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist_len = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_len / resolution))\n        for i in range(steps+1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.49648,
          "time_improvement": 47.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1583.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02085111141204834,
                    "num_nodes_avg": 69.5,
                    "path_length_avg": 158.6530547710763,
                    "smoothness_avg": 0.04261658457714363,
                    "success_improvement": 0.0,
                    "time_improvement": 16.006158172448046,
                    "length_improvement": 13.039746661440793,
                    "smoothness_improvement": 567.0420920269154,
                    "objective_score": 10.24500724415715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.037842631340026855,
                    "num_nodes_avg": 242.2,
                    "path_length_avg": 239.04107805103726,
                    "smoothness_avg": 0.11767119468290191,
                    "success_improvement": 0.0,
                    "time_improvement": 76.2948991696677,
                    "length_improvement": 20.201207730627083,
                    "smoothness_improvement": 2927.764594326768,
                    "objective_score": 41.56753426865957
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024922800064086915,
                    "num_nodes_avg": 189.6,
                    "path_length_avg": 122.72603953129553,
                    "smoothness_avg": 0.10649129557501387,
                    "success_improvement": 0.0,
                    "time_improvement": 49.01951604195533,
                    "length_improvement": 18.491208129315343,
                    "smoothness_improvement": 1254.5614193443816,
                    "objective_score": 24.676903535171576
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional Anytime Informed RRT* planner with an adaptive neighbor radius, ellipsoidal informed sampling to focus search space, incremental and robust rewiring for improved path cost, and aggressive path smoothing. It rigorously checks collisions on nodes and edges, maintains consistent parent-child relationships, prunes unnecessary nodes outside the best path, and enforces a strict 30-second timeout to deliver efficient, high-quality, and smooth paths.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling either uniformly or from an informed ellipsoid if a better path is found. Nodes are added via steering and rewired incrementally within an adaptive neighbor radius. Upon connecting trees, paths are combined, smoothed, and nodes outside the best path are marked invalid. The process continues until time or iteration limits are reached, returning the best optimized path found.",
          "code": "class Node:\n    def __init__(self, position: tuple, parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                  # List of child nodes\n        self.valid = True                   # Validity flag for pruning\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, self.position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = 30.0\n        self.goal_sample_rate = 0.2\n        self.neighbor_radius_min = 10.0\n        self.neighbor_radius_max = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: tuple) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos: tuple, to_pos: tuple) -> tuple:\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def coll_free_node(pos: tuple) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def coll_free_edge(p1: tuple, p2: tuple) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes: list, pos: tuple, radius: float) -> list:\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq and node.valid]\n\n        def sample_uniform() -> tuple:\n            for _ in range(1000):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if coll_free_node(pt):\n                    return pt\n            # fallback rare\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def unit_ball_sample(n: int) -> tuple:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction: tuple) -> list:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-14:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0, 1 - cos_t * cos_t))\n                K = [\n                    [0, -kz, ky],\n                    [kz, 0, -kx],\n                    [-ky, kx, 0]\n                ]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1 - cos_t))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best: float) -> tuple:\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            for _ in range(1000):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if coll_free_node(sample_pt):\n                    return sample_pt\n            return sample_uniform()\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda node: dist_func(node.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if not coll_free_node(new_pos) or not coll_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_via_nbr < min_cost and coll_free_edge(nbr.position, new_pos):\n                    min_cost = cost_via_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and coll_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda node: dist_func(node.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n\n                if not coll_free_node(new_pos) or not coll_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_via_nbr < min_cost and coll_free_edge(nbr.position, new_pos):\n                        min_cost = cost_via_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and coll_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if coll_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, max_trials: int = 200) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if coll_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nodes(tree: list, best_path: list) -> None:\n            best_positions = set(best_path)\n            for node in tree:\n                node.valid = (node.position in best_positions)\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        prune_nodes(tree_start, best_path)\n                        prune_nodes(tree_goal, best_path)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            if not node.valid:\n                                continue\n                            for c in node.children:\n                                if c.valid:\n                                    all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        prune_nodes(tree_start, best_path)\n                        prune_nodes(tree_goal, best_path)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            if not node.valid:\n                                continue\n                            for c in node.children:\n                                if c.valid:\n                                    all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            if not node.valid:\n                continue\n            for c in node.children:\n                if c.valid:\n                    all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.44546,
          "time_improvement": 47.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1569.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02320263385772705,
                    "num_nodes_avg": 66.1,
                    "path_length_avg": 158.51807827383044,
                    "smoothness_avg": 0.04307525181168788,
                    "success_improvement": 0.0,
                    "time_improvement": 6.533598151395778,
                    "length_improvement": 13.113729418420725,
                    "smoothness_improvement": 574.2212302593745,
                    "objective_score": 7.453931480399751
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035085511207580564,
                    "num_nodes_avg": 202.2,
                    "path_length_avg": 235.14183422007372,
                    "smoothness_avg": 0.10774207842727786,
                    "success_improvement": 0.0,
                    "time_improvement": 78.0219939415328,
                    "length_improvement": 21.50288755491343,
                    "smoothness_improvement": 2672.281281416194,
                    "objective_score": 41.06858210052349
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021143531799316405,
                    "num_nodes_avg": 157.3,
                    "path_length_avg": 124.36748005888012,
                    "smoothness_avg": 0.12277772128724951,
                    "success_improvement": 0.0,
                    "time_improvement": 56.75014521082271,
                    "length_improvement": 17.401041487892176,
                    "smoothness_improvement": 1461.7235522651208,
                    "objective_score": 27.81386962215085
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner with dynamic informed sampling, adaptive neighbor radius, robust collision checking, incremental rewiring with recursive cost propagation, and sophisticated randomized shortcut smoothing with early stopping upon better solution or timeout. The planner maintains consistent parent-child relations, enforces strict boundary and obstacle checks, and dynamically alternates tree growth between start and goal to expedite path discovery and optimization within a 30-second time limit.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points with goal bias and informed ellipsoidal distribution once a solution is found. It extends and rewires using an adaptive radius based on node density, dynamically rewires nearby nodes reducing cost recursively, and incrementally connects opposite trees. Upon connection, the best path is smoothed by multiple randomized shortcuts. The search halts early on timeout or upon discovering a better path, returning the highest-quality path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                 # List of child nodes\n        self.valid = True                  # For obstacle validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Avoid excessive updates if cost does not change meaningfully\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 smoothing_trials: int = 150,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 35.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors via new_node if cost improves\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_node: Node):\n            if not tree or not target_node:\n                return None\n            curr = min(tree, key=lambda n: dist_func(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr.cost + dist_func(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                curr = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sample with goal bias and informed sampling after first solution\n            sample = informed_sample(best_cost) if informed_sampling_active else (\n                goal_pos if random.random() < self.goal_sample_rate else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # Early stopping: return immediately with smoothed path\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n        else:\n            smoothed_path = []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = [(node, child) for node in nodes_all for child in node.children]\n\n        return PlannerResult(success_state, smoothed_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.37437,
          "time_improvement": 46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1587.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020984077453613283,
                    "num_nodes_avg": 87.4,
                    "path_length_avg": 157.60116024034528,
                    "smoothness_avg": 0.039957844445175764,
                    "success_improvement": 0.0,
                    "time_improvement": 15.47053546903722,
                    "length_improvement": 13.616306722069968,
                    "smoothness_improvement": 525.4270354150128,
                    "objective_score": 9.991557162200225
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04594333171844482,
                    "num_nodes_avg": 300.2,
                    "path_length_avg": 238.18816860531638,
                    "smoothness_avg": 0.10115500590198441,
                    "success_improvement": 0.0,
                    "time_improvement": 71.22051843907624,
                    "length_improvement": 20.485933453245917,
                    "smoothness_improvement": 2502.791160863827,
                    "objective_score": 37.97729802669119
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023635125160217284,
                    "num_nodes_avg": 200.3,
                    "path_length_avg": 120.52708828079858,
                    "smoothness_avg": 0.14414964895847884,
                    "success_improvement": 0.0,
                    "time_improvement": 51.65350137310184,
                    "length_improvement": 19.951646847089105,
                    "smoothness_improvement": 1733.572894731552,
                    "objective_score": 28.154244255006134
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius and informed sampling to efficiently find and optimize a collision-free path. It grows two trees from start and goal, alternating expansion with goal and sample biasing, rewiring nodes for cost improvement, and incrementally connecting the trees. It enforces collision checks on nodes and edges, maintains parent-child consistency with recursive cost updates, applies path smoothing for final refinement, and obeys a strict 30-second time limit to ensure timely termination with the best feasible solution.",
          "planning_mechanism": "The planner alternately samples points (using uniform, goal bias, and informed ellipsoidal sampling after the initial path), extends the nearest tree towards these samples with collision verification, rewires for cost reduction by examining neighbors within an adaptive radius, and attempts incremental connections between trees. Once connected, it extracts and smooths the path, returning early if time expires or a high-quality solution is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D point\n        self.parent = None              # Parent Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist = math.dist\n        for c in self.children:\n            c.update_parent(self, self.cost + dist(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.2,\n                 neighbor_rad_min=10.0, neighbor_rad_max=30.0, max_time_sec=30.0,\n                 smoothing_trials=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_rad_min = neighbor_rad_min\n        self.neighbor_rad_max = neighbor_rad_max\n        self.max_time_sec = max_time_sec\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def steer(from_p, to_p):\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_rad_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_rad_min, min(self.neighbor_rad_max, r))\n\n        def near(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist_func(node.position, pos) ** 2 <= r_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            # For 3D: simple identity fallback to keep code concise\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        R = None  # rotation matrix for ellipsoidal sampling\n\n        def informed_sample(c_best):\n            nonlocal R\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d]+goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n            if R is None:\n                R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best/2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = [a1,a2]\n                n = 2\n                while True:\n                    dir_sample = unit_ball_sample(n)\n                    radius_s = random.random() ** (1.0 / n)\n                    sample_unit = tuple(radius_s * d for d in dir_sample)\n                    sample_scaled = (sample_unit[0]*radii[0], sample_unit[1]*radii[1])\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    sample_pt = (center[0]+x_rot, center[1]+y_rot)\n                    sample_pt = tuple(max(0.0,min(bounds[d],sample_pt[d])) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n            else:\n                # Simple uniform sample fallback for 3D to keep concise\n                return sample_free()\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def add_node(tree, pos, parent_node, cost):\n            new_node = Node(pos)\n            new_node.update_parent(parent_node, cost)\n            tree.append(new_node)\n            return new_node\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n            radius = adaptive_radius(len(tree)+1)\n            neighbors = near(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n                radius = adaptive_radius(len(tree)+1)\n                neighbors = near(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_time_sec:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            if time.perf_counter() - start_time > self.max_time_sec:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected = incremental_connect(tree_goal, new_node.position)\n                if connected:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected.cost + dist_func(new_node.position, connected.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = path_smoothing(combined)\n                        informed_sampling = True\n                    break\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected = incremental_connect(tree_start, new_node.position)\n                if connected:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected.cost + dist_func(new_node.position, connected.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = path_smoothing(combined)\n                        informed_sampling = True\n                    break\n\n            grow_start = not grow_start\n\n        if not best_path and best_path != []:\n            # No final path but partial found\n            best_path = []\n\n        success_state = len(best_path) > 0\n\n        # Collect nodes and edges for output\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=all_nodes,\n            edges=all_edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.2871,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1321.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01558375358581543,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 159.8811283068053,
                    "smoothness_avg": 0.03978602392578066,
                    "success_improvement": 0.0,
                    "time_improvement": 37.22448132859786,
                    "length_improvement": 12.366620096437257,
                    "smoothness_improvement": 522.7376711722497,
                    "objective_score": 16.25435677372806
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029855632781982423,
                    "num_nodes_avg": 210.0,
                    "path_length_avg": 233.8268162674097,
                    "smoothness_avg": 0.08462511464727338,
                    "success_improvement": 0.0,
                    "time_improvement": 81.29805564811008,
                    "length_improvement": 21.94187839820576,
                    "smoothness_improvement": 2077.4651528806853,
                    "objective_score": 39.1651181384776
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03215770721435547,
                    "num_nodes_avg": 245.6,
                    "path_length_avg": 125.2405713470688,
                    "smoothness_avg": 0.11496163403815989,
                    "success_improvement": 0.0,
                    "time_improvement": 34.220253239871695,
                    "length_improvement": 16.82117582641671,
                    "smoothness_improvement": 1362.3034993802491,
                    "objective_score": 20.441828634146095
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an advanced bidirectional RRT* planner with adaptive informed sampling and dynamic neighbor radius scaling tuned by node density and iteration progress. It grows two trees alternately from start and goal, performs incremental extend-and-rewire with recursive cost updates, enforces strict collision and boundary checks, and aggressively smooths paths by randomized shortcutting. The planner prioritizes early feasible path discovery and quality improvement under a strict 30-second time limit, ensuring efficient and robust path planning in 2D/3D environments.",
          "planning_mechanism": "Planning mechanism: The planner initializes two trees at the start and goal positions and iteratively samples points using a goal-biased uniform or ellipsoidal informed distribution after an initial solution. Each iteration attempts to extend and rewire one tree toward the sampled point, followed by incremental connection and rewiring of the opposite tree toward the new node. Adaptive neighbor radius dynamically scales with tree size and iteration count to optimize rewiring locality. Recursively propagated parent-child cost updates maintain global path cost consistency. Upon connecting the two trees, the combined path is shortcut-smoothed to improve smoothness and reduce length. The process enforces tight collision and boundary checks and halts within 30 seconds, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] e.g. (x,y) or (x,y,z)\n        self.parent = None                  # type: Node or None\n        self.cost = cost                    # Path cost from root to this node\n        self.children: List['Node'] = []   # Child nodes list\n        self.valid = True                   # Validity flag for collision\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update cost of all descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    rows = len(A)\n                    cols = len(B[0])\n                    return [[sum(A[i][k]*B[k][j] for k in range(len(B))) for j in range(cols)] for i in range(rows)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success else []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for node in nodes_all:\n            for c in node.children:\n                edges_all.append((node, c))\n\n        return PlannerResult(success, smoothed, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.28016,
          "time_improvement": 48.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1525.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020598411560058594,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 163.47506959241795,
                    "smoothness_avg": 0.04367856895104431,
                    "success_improvement": 0.0,
                    "time_improvement": 17.024100620619315,
                    "length_improvement": 10.396723928148914,
                    "smoothness_improvement": 583.6644536144399,
                    "objective_score": 10.104897239887777
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03490955829620361,
                    "num_nodes_avg": 221.9,
                    "path_length_avg": 232.77738879457712,
                    "smoothness_avg": 0.09426688841092093,
                    "success_improvement": 0.0,
                    "time_improvement": 78.1322130610254,
                    "length_improvement": 22.292207494732256,
                    "smoothness_improvement": 2325.5549365082725,
                    "objective_score": 39.52588009979544
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02548041343688965,
                    "num_nodes_avg": 193.8,
                    "path_length_avg": 124.14239219545193,
                    "smoothness_avg": 0.13893055146464137,
                    "success_improvement": 0.0,
                    "time_improvement": 47.87889783156715,
                    "length_improvement": 17.550534129248916,
                    "smoothness_improvement": 1667.186359843644,
                    "objective_score": 26.209707974538148
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines adaptive bidirectional RRT* with goal-biased and ellipsoidal informed sampling, adaptive neighbor radius rewiring, and incremental connect-and-rewire for efficient tree merging. It features robust collision checking on nodes and edges, recursive parent-child cost updates, and aggressive randomized shortcut path smoothing to achieve improved planning efficiency, path quality, robustness, and smoothness within a 30-second time limit.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, initially sampling uniformly with goal bias and switches to ellipsoidal informed sampling after the first solution to focus search. Nodes are incrementally extended and rewired within an adaptive radius, ensuring collision-free placement and connections. Incremental connection attempts bridge the trees, extracting and smoothing the combined path upon success. Execution halts early on improved solutions or after 30 seconds, returning the best feasible smooth path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                  # Node or None\n        self.cost = cost                      # Path cost from root\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=5.0, neighbor_radius_max: float=30.0,\n                 smoothing_trials: int=150, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes: int, iteration=1) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 35.0\n            base = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            factor = min(1.0, iteration / self.max_iter)\n            radius = base * (1 - 0.5 * factor)  # shrink radius slowly\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree_nodes if (dist(n.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            # Try uniform random sampling in free space\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # Fall back on start or goal\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:  # 3D rotation matrix to align x-axis with direction vec\n                vx, vy, vz = direction\n                # Normalize direction vector\n                norm_dir = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_dir < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx, vy, vz = vx/norm_dir, vy/norm_dir, vz/norm_dir\n                # Axis for rotation (cross product with x-axis (1,0,0))\n                kx, ky, kz = 0.0, -vz, vy\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx, ky, kz = kx/norm_k, ky/norm_k, kz/norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(1 - cos_theta*cos_theta)\n\n                # Rodrigues rotation formula components\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return uniform_sample()\n\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    # occasionally direct goal bias\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cand_cost = nbr.cost + dist(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors if progress possible\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, target_pos))\n            curr = nearest_node\n            while True:\n                new_pos = steer(curr.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cand_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def random_path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iter_num in range(1, self.max_iter+1):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Time limit reached: return best found path\n                success_state = len(best_path) > 0\n                smoothed_path = random_path_smoothing(best_path, self.smoothing_trials) if success_state else []\n                all_nodes = tree_start + tree_goal\n                edges = [(n, c) for n in all_nodes for c in n.children]\n                return PlannerResult(success_state, smoothed_path, all_nodes, edges)\n\n            if informed_sampling_active:\n                sample_pt = informed_sample(best_cost)\n            else:\n                # Goal bias sampling with uniform fallback\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iter_num)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined, self.smoothing_trials)\n                        informed_sampling_active = True\n                    # Early return on improvement\n                    if informed_sampling_active:\n                        all_nodes = tree_start + tree_goal\n                        edges = [(n, c) for n in all_nodes for c in n.children]\n                        return PlannerResult(True, best_path, all_nodes, edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iter_num)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined, self.smoothing_trials)\n                        informed_sampling_active = True\n                    # Early return on improvement\n                    if informed_sampling_active:\n                        all_nodes = tree_start + tree_goal\n                        edges = [(n, c) for n in all_nodes for c in n.children]\n                        return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Time or iteration limit reached without early return\n        success_state = len(best_path) > 0\n        smoothed_path = random_path_smoothing(best_path, self.smoothing_trials) if success_state else []\n        all_nodes = tree_start + tree_goal\n        edges = [(n, c) for n in all_nodes for c in n.children]\n        return PlannerResult(success_state, smoothed_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.2539,
          "time_improvement": 47.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1481.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0222212553024292,
                    "num_nodes_avg": 60.8,
                    "path_length_avg": 151.16462602587836,
                    "smoothness_avg": 0.04126985500039761,
                    "success_improvement": 0.0,
                    "time_improvement": 10.486852897279922,
                    "length_improvement": 17.14427311843077,
                    "smoothness_improvement": 545.9628496807564,
                    "objective_score": 9.304724741273914
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0379150390625,
                    "num_nodes_avg": 234.1,
                    "path_length_avg": 237.10199888264555,
                    "smoothness_avg": 0.10509317256180639,
                    "success_improvement": 0.0,
                    "time_improvement": 76.24954206046728,
                    "length_improvement": 20.848528170335445,
                    "smoothness_improvement": 2604.1230255678374,
                    "objective_score": 40.065183380046456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022464561462402343,
                    "num_nodes_avg": 168.2,
                    "path_length_avg": 122.62888027097725,
                    "smoothness_avg": 0.10953328002052878,
                    "success_improvement": 0.0,
                    "time_improvement": 54.047931519990335,
                    "length_improvement": 18.555736683791938,
                    "smoothness_improvement": 1293.2552369553962,
                    "objective_score": 26.391802977532468
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional Anytime Informed RRT* planner with adaptive neighbor radius, recursive cost propagation on parent updates, incremental rewiring, and ellipsoidal informed sampling to efficiently discover high-quality, smooth, and short paths within a strict 30-second planning time limit. It dynamically alternates tree growth from start and goal, rigorously checks collisions, and employs randomized shortcut smoothing to optimize the final path.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling uniformly or informed by ellipsoidal regions after a first solution. Nodes extend towards samples with adaptive neighborhood radius for pruning and rewiring to minimize costs. Incremental connection attempts bidirectionally link the trees with rewiring for path improvement. The best path found triggers informed sampling and multiple path smoothings. The process halts immediately upon time expiration or early improved solutions, returning the best valid path with updated edges and nodes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                 # List[Node]\n        self.valid = True                  # Valid for collision checks\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            # No change needed\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n\n        dist_func = math.dist\n        # Recursively propagate cost updates to children\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 15000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=25.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 33.0\n            radius = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            tries = 0\n            while tries < 50:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                tries += 1\n            # Fallback to goal if failed\n            return goal_pos\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        use_informed_sampling = False\n        rotation_mat = None\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(rotation_mat[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(rotation_mat[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample_pt: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            # Rewire neighbors to possibly improve path cost\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_node.position))\n            current_node = nearest\n\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                new_pos = clamp_to_bounds(new_pos)\n\n                if not collision_free_node(new_pos) or not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + dist_func(current_node.position, new_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    candidate_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if candidate_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = candidate_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                current_node = new_node\n\n        def shortcut_smoothing(path: list, trials: int) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path_nodes = []\n        best_path_cost = math.inf\n        use_informed_sampling = False\n        grow_start_tree = True\n        all_nodes = tree_start + tree_goal\n\n        edges = []\n\n        for iter_idx in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time limit reached, return best so far\n                success = len(best_path_nodes) > 0\n                final_path = shortcut_smoothing(best_path_nodes, self.smoothing_trials) if success else []\n                # update edges from current nodes\n                all_nodes = tree_start + tree_goal\n                edges.clear()\n                for node in all_nodes:\n                    for c in node.children:\n                        edges.append((node, c))\n                return PlannerResult(success, final_path, all_nodes, edges)\n\n            # Sample point\n            if use_informed_sampling:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            active_tree = tree_start if grow_start_tree else tree_goal\n            other_tree = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n            all_nodes.append(new_node)\n\n            connect_node = incremental_connect(other_tree, new_node)\n            if connect_node is not None:\n                # Extract path from roots to connection\n                if grow_start_tree:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n\n                combined_path = path_start + path_goal[::-1]\n\n                # Calculate total cost accurately via node costs and edge\n                total_cost = 0.0\n                for i in range(len(combined_path)-1):\n                    total_cost += dist_func(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-12 < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = combined_path\n                    use_informed_sampling = True\n                    rotation_mat = None  # reset rotation matrix for sampling\n\n                    # Recompute edges for current trees\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            edges.append((n, c))\n\n                    smoothed_path = shortcut_smoothing(best_path_nodes, self.smoothing_trials)\n                    return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # max_iter reached without timeout or early success\n        success = len(best_path_nodes) > 0\n        final_path = shortcut_smoothing(best_path_nodes, self.smoothing_trials) if success else []\n        all_nodes = tree_start + tree_goal\n        edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(success, final_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.21609,
          "time_improvement": 48.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1476.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022158360481262206,
                    "num_nodes_avg": 76.2,
                    "path_length_avg": 165.58659468621906,
                    "smoothness_avg": 0.0437746409571087,
                    "success_improvement": 0.0,
                    "time_improvement": 10.740210023261227,
                    "length_improvement": 9.23936356498026,
                    "smoothness_improvement": 585.168189133048,
                    "objective_score": 7.995776665639661
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03384168148040771,
                    "num_nodes_avg": 219.8,
                    "path_length_avg": 234.66524790011667,
                    "smoothness_avg": 0.09834783746328077,
                    "success_improvement": 0.0,
                    "time_improvement": 78.80114454640128,
                    "length_improvement": 21.661985786291712,
                    "smoothness_improvement": 2430.5606950142824,
                    "objective_score": 40.12554399625014
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021700334548950196,
                    "num_nodes_avg": 177.3,
                    "path_length_avg": 122.0790548509322,
                    "smoothness_avg": 0.11885933294110655,
                    "success_improvement": 0.0,
                    "time_improvement": 55.611185159283224,
                    "length_improvement": 18.92090454791287,
                    "smoothness_improvement": 1411.8819417275245,
                    "objective_score": 27.526946166005164
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional Anytime Informed RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after the first feasible path, incremental extend-and-rewire expansions with robust cost propagation, aggressive randomized path smoothing, and efficient pruning. It enforces strict collision checks for nodes and edges, maintains consistent parent-child relationships, and uses a 30-second timeout to deliver efficient, smooth, and near-optimal paths.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling with goal bias and ellipsoidal informed domain refinement once a path is found. It extends and rewires the trees incrementally using an adaptive neighbor radius, connects the trees via incremental connection, and updates paths if improvements occur. Completed paths are aggressively smoothed via randomized shortcuts. The search terminates upon timeout or iteration limits, returning the best found path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...] (2D or 3D)\n        self.parent = None                    # Node or None\n        self.cost = 0.0                      # Cumulative cost from root\n        self.children = []                   # List of child Node objects\n        self.valid = True                    # Validity flag for pruning and collision\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = self._distance\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = 30.0\n        self.goal_sample_rate = 0.2\n        self.neighbor_radius_min = 10.0\n        self.neighbor_radius_max = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def coll_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def coll_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes:int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if node.valid and (dist_func(node.position, pos)**2) <= r_sq]\n\n        def sample_uniform():\n            for _ in range(1000):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if coll_free_node(pt):\n                    return pt\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0, 1 - cos_t*cos_t))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1-cos_t))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d]+goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            for _ in range(1000):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2])\n                    y_rot = (R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2])\n                    z_rot = (R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if coll_free_node(sample_pt):\n                    return sample_pt\n            return sample_uniform()\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if not coll_free_node(new_pos) or not coll_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                new_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if new_cost < min_cost and coll_free_edge(nbr.position, new_pos):\n                    min_cost = new_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and coll_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n\n                if not coll_free_node(new_pos) or not coll_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes+1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    new_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if new_cost < min_cost and coll_free_edge(nbr.position, new_pos):\n                        min_cost = new_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and coll_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if coll_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, max_trials=200):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if coll_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_nodes(tree, best_path):\n            best_set = set(best_path)\n            for node in tree:\n                node.valid = (node.position in best_set)\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        prune_nodes(tree_start, best_path)\n                        prune_nodes(tree_goal, best_path)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            if not node.valid:\n                                continue\n                            for c in node.children:\n                                if c.valid:\n                                    all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        prune_nodes(tree_start, best_path)\n                        prune_nodes(tree_goal, best_path)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            if not node.valid:\n                                continue\n                            for c in node.children:\n                                if c.valid:\n                                    all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        smoothed = path_smoothing(best_path) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            if not node.valid:\n                continue\n            for c in node.children:\n                if c.valid:\n                    all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.18962,
          "time_improvement": 45.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1683.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020487189292907715,
                    "num_nodes_avg": 58.1,
                    "path_length_avg": 155.4156890402465,
                    "smoothness_avg": 0.04918111552668565,
                    "success_improvement": 0.0,
                    "time_improvement": 17.472133597383067,
                    "length_improvement": 14.814198117851419,
                    "smoothness_improvement": 669.7912564943658,
                    "objective_score": 11.553435985257032
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03939576148986816,
                    "num_nodes_avg": 224.7,
                    "path_length_avg": 234.22706689083765,
                    "smoothness_avg": 0.11087979621343518,
                    "success_improvement": 0.0,
                    "time_improvement": 75.32199888496484,
                    "length_improvement": 21.80826321953009,
                    "smoothness_improvement": 2753.017020060793,
                    "objective_score": 40.72333740969944
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02888202667236328,
                    "num_nodes_avg": 200.7,
                    "path_length_avg": 128.8378537844316,
                    "smoothness_avg": 0.13568413148072095,
                    "success_improvement": 0.0,
                    "time_improvement": 40.92077560867842,
                    "length_improvement": 14.432032115702379,
                    "smoothness_improvement": 1625.892137273973,
                    "objective_score": 23.292099792113866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a time-limited bidirectional Anytime RRT* planner with adaptive neighbor radius, incremental extend-and-rewire, and iterative path refinement. It features goal biasing, informed ellipsoidal sampling after initial solution discovery, rigorous collision and boundary checking, and an efficient path smoothing postprocess. The planner balances exploration and exploitation by toggling tree expansion from start and goal and dynamically adapts neighborhood connectivity based on tree size to optimize path cost and smoothness while halting immediately upon timeout or improved solutions.",
          "planning_mechanism": "The planner builds two search trees from start and goal nodes, alternately extending them toward sampled points generated uniformly, with goal bias, or informed ellipsoidal distribution after a first feasible path. Each extension steers a fixed step size while collision testing both nodes and connecting edges. Newly added nodes undergo local rewiring within an adaptive radius to minimize costs, with updates cascading recursively to descendants. Incremental connect attempts bridge the trees. Improved solutions trigger informed sampling and intermediate path smoothing. The process repeats until the 30-second limit or max iterations are reached, then returns the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                 # List of children nodes\n        self.valid = True                  # Validity flag for collision checking\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=15000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=25.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 33.0\n            radius = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos)**2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d])*0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d])/c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                success = (len(best_path) > 0)\n                final_path = path_smoothing(best_path, self.smoothing_trials) if success else []\n                all_nodes = tree_start + tree_goal\n                all_edges = [(node, c) for node in all_nodes for c in node.children]\n                return PlannerResult(success, final_path, all_nodes, all_edges)\n\n            if informed_sampling:\n                sample_point = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_point = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_point = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = incremental_connect(tree_goal, new_node.position)\n                if connect_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = [(node, c) for node in all_nodes for c in node.children]\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = incremental_connect(tree_start, new_node.position)\n                if connect_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = [(node, c) for node in all_nodes for c in node.children]\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # End after max_iter without timeout or success\n        final_success = (len(best_path) > 0)\n        final_path = path_smoothing(best_path, self.smoothing_trials) if final_success else []\n        all_nodes = tree_start + tree_goal\n        all_edges = [(node, c) for node in all_nodes for c in node.children]\n\n        return PlannerResult(final_success, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.78979,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1356.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021341538429260253,
                    "num_nodes_avg": 66.6,
                    "path_length_avg": 160.8233943341031,
                    "smoothness_avg": 0.04505872621114924,
                    "success_improvement": 0.0,
                    "time_improvement": 14.030587254542285,
                    "length_improvement": 11.850149155714632,
                    "smoothness_improvement": 605.2669117945419,
                    "objective_score": 9.605540566478322
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0335770845413208,
                    "num_nodes_avg": 217.1,
                    "path_length_avg": 231.87927121065135,
                    "smoothness_avg": 0.08442764875099279,
                    "success_improvement": 0.0,
                    "time_improvement": 78.9668914011613,
                    "length_improvement": 22.59202499512799,
                    "smoothness_improvement": 2072.3842131404494,
                    "objective_score": 38.57039348507624
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023044514656066894,
                    "num_nodes_avg": 194.1,
                    "path_length_avg": 125.06959806376703,
                    "smoothness_avg": 0.11710773417070539,
                    "success_improvement": 0.0,
                    "time_improvement": 52.86161640250734,
                    "length_improvement": 16.934728140312874,
                    "smoothness_improvement": 1389.601734657594,
                    "objective_score": 26.193439222102747
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner with adaptive neighbor radius, efficient incremental tree connection and rewiring, robust collision and boundary checks, goal biasing, and an anytime time budget cutoff of 30 seconds. It grows two trees from the start and goal simultaneously, samples with goal biasing, and dynamically rewires neighbors using cost-based parent reassignment. A final path smoothing step removes unnecessary waypoints for improved path smoothness and quality. Early termination occurs upon time limit or first improved solution for planning efficiency.",
          "planning_mechanism": "The planner alternates tree growth from start and goal by sampling points (biased towards the goal), extending and rewiring the trees locally with an adaptive neighbor radius, incrementally connecting the opposing trees, and maintaining consistent parent-child and cost information. Collision checks prevent invalid expansions. If time limit exceeds, it returns the best path found so far. Path smoothing is applied to produce a smoother final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] 2D or 3D coordinate\n        self.parent = None              # Parent node\n        self.cost = 0.0                # Cost-to-come from root\n        self.children = []             # Children nodes list\n        self.valid = True              # Validity flag\n        \n        if parent is not None:\n            self.set_parent(parent)\n            self.update_cost(cost)\n\n    def set_parent(self, new_parent):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n\n    def update_cost(self, new_cost):\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost(child.cost + cost_diff)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 10.0, max_neighbor_radius: float = 30.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        import time\n        import random\n        import math\n\n        start_time = time.perf_counter()\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not is_in_obstacle(p):\n                    return p\n            # Fallback\n            return goal_position\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def adaptive_neighbor_radius(node_count):\n            # Adaptive radius according to RRT* literature: \u03b3*(log(n)/n)^(1/d)\n            # \u03b3 chosen as max_neighbor_radius for simplicity, bounded by min/max radius\n            if node_count < 2:\n                return self.max_neighbor_radius\n            import math\n            gamma = self.max_neighbor_radius\n            n = node_count\n            r = gamma * (math.log(n) / n) ** (1 / dimension)\n            return min(max(r, self.min_neighbor_radius), self.max_neighbor_radius)\n\n        def nearest(tree, pt):\n            # Return closest node in tree to pt\n            return min(tree, key=lambda n: distance(n.position, pt))\n\n        def near_nodes(tree, pos, radius):\n            # Return nodes within radius of pos\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, None, 0.0)]\n        tree_goal = [Node(goal_position, None, 0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)\n        success_state = False\n        extracted_path = []\n\n        # ------ Core functions for extending and rewiring ------\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                tentative_cost = neighbor.cost + distance(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.set_parent(best_parent)\n            new_node.update_cost(min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    neighbor.set_parent(new_node)\n                    neighbor.update_cost(cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        # Remove outdated edge\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            # Incrementally extend tree toward target_node.position with rewiring\n            current_node = nearest(tree, target_node.position)\n\n            while True:\n                dist_to_target = distance(current_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    new_pos = target_node.position\n                else:\n                    new_pos = steer(current_node.position, target_node.position)\n\n                if (not within_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + distance(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + distance(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                new_node.set_parent(best_parent)\n                new_node.update_cost(min_cost)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_through_new < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                        neighbor.set_parent(new_node)\n                        neighbor.update_cost(cost_through_new)\n                        edges.append((new_node, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n\n                if new_node.position == target_node.position:\n                    return new_node\n\n                current_node = new_node\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def path_smoothing(path, iterations=50):\n            # Remove unnecessary waypoints by shortcutting path segments\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            import random\n            for _ in range(iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # Shortcut possible: remove intermediate points between i and j\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        # ----- Main planning loop -----\n\n        for iteration in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                if success_state:\n                    extracted_path = path_smoothing(extracted_path)\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                # Swap trees for balanced growth\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                # Swap trees for next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early stop if found path\n                if success_state:\n                    extracted_path = path_smoothing(extracted_path)\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.76518,
          "time_improvement": 54.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1030.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012971878051757812,
                    "num_nodes_avg": 76.9,
                    "path_length_avg": 167.24655728520398,
                    "smoothness_avg": 0.031034823234490035,
                    "success_improvement": 0.0,
                    "time_improvement": 47.74581307660836,
                    "length_improvement": 8.329511760685989,
                    "smoothness_improvement": 385.7623768170883,
                    "objective_score": 17.918458159205148
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.054288935661315915,
                    "num_nodes_avg": 319.8,
                    "path_length_avg": 236.81632083633494,
                    "smoothness_avg": 0.07381201027472953,
                    "success_improvement": 0.0,
                    "time_improvement": 65.9927270315975,
                    "length_improvement": 20.943895724980564,
                    "smoothness_improvement": 1799.2361890108605,
                    "objective_score": 32.98277819952966
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02476174831390381,
                    "num_nodes_avg": 190.0,
                    "path_length_avg": 119.98394953299164,
                    "smoothness_avg": 0.07904361337896625,
                    "success_improvement": 0.0,
                    "time_improvement": 49.34895318968801,
                    "length_improvement": 20.312373741894593,
                    "smoothness_improvement": 905.4289277878111,
                    "objective_score": 23.394305344224378
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius and informed sampling. It grows two trees from start and goal points, alternately extending towards sampled points biased inside an ellipsoidal informed region once a solution is found. The planner rewires connections dynamically for path cost improvement, performs precise collision checks for nodes and edges, and applies path shortcut smoothing. It enforces a strict 30-second time limit while attempting to find a smooth, low-cost path with high success and robustness.",
          "planning_mechanism": "The planner continuously samples points\u2014initially uniform then informed by the current best path cost\u2014and extends one of the two trees towards these points using steering constrained by step size. It dynamically adjusts the neighbor radius based on tree size to perform rewiring that reduces path cost. When the two trees connect incrementally via collision-free edges, their paths are combined and smoothed. The process alternates growth between trees and terminates on timeout or upon finding a satisfactory path, returning the best result found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position               # Tuple[float, ...]\n        self.parent = parent                   # Node or None\n        self.cost = cost                       # Cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Propagate cost updates to children recursively\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter=15000, step_size=5.0,\n                 goal_sample_rate=0.15,\n                 neighbor_radius_min=5.0,\n                 neighbor_radius_max=30.0,\n                 smoothing_trials=150,\n                 max_planning_time=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n        t_start = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            # Optionally reduce radius with iterations\n            iter_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1 - 0.6 * iter_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(nodes_list, pos, radius):\n            rad_sq = radius * radius\n            return [node for node in nodes_list if (dist(node.position, pos) ** 2) <= rad_sq]\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def unit_ball_sample(n):\n            while True:\n                point = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in point)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in point)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        rotation_mat = None\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n\n        grow_start = True\n        iteration = 0\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_uniform()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim -1)\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(rotation_mat[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(rotation_mat[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree)+1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_node.position))\n            current_node = nearest\n\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, new_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist(new_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                current_node = new_node\n\n        def shortcut_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) -1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            sample = informed_sample(best_cost) if informed_sampling else (goal_pos if (random.random() < self.goal_sample_rate and grow_start) else (\n                     start_pos if (random.random() < self.goal_sample_rate and not grow_start) else sample_uniform()))\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(other_tree, new_node, iteration)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n                    smoothed = shortcut_smoothing(best_path, self.smoothing_trials)\n                    return_nodes = tree_start + tree_goal\n                    return_edges = []\n                    for n in return_nodes:\n                        for c in n.children:\n                            return_edges.append((n, c))\n                    return PlannerResult(True, smoothed, return_nodes, return_edges)\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed = shortcut_smoothing(best_path, self.smoothing_trials) if success else []\n        final_nodes = tree_start + tree_goal\n        final_edges = []\n        for n in final_nodes:\n            for c in n.children:\n                final_edges.append((n, c))\n\n        return PlannerResult(success, smoothed, final_nodes, final_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.55576,
          "time_improvement": 46.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1588.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02259540557861328,
                    "num_nodes_avg": 92.7,
                    "path_length_avg": 174.95105069539687,
                    "smoothness_avg": 0.04827393937945801,
                    "success_improvement": 0.0,
                    "time_improvement": 8.979675725928676,
                    "length_improvement": 4.106556837048567,
                    "smoothness_improvement": 655.5919798257192,
                    "objective_score": 6.793173984316913
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03587996959686279,
                    "num_nodes_avg": 225.0,
                    "path_length_avg": 236.7421650603272,
                    "smoothness_avg": 0.10732911859775163,
                    "success_improvement": 0.0,
                    "time_improvement": 77.5243352017316,
                    "length_improvement": 20.96865105746761,
                    "smoothness_improvement": 2661.6555275595415,
                    "objective_score": 40.759308409810714
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023754572868347167,
                    "num_nodes_avg": 174.6,
                    "path_length_avg": 124.57763414619444,
                    "smoothness_avg": 0.12169495729333346,
                    "success_improvement": 0.0,
                    "time_improvement": 51.40916678980935,
                    "length_improvement": 17.26146714956026,
                    "smoothness_improvement": 1447.9508741838333,
                    "objective_score": 26.11479783777402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This planner implements a bidirectional Informed RRT* with adaptive neighbor radius, incremental extend-and-rewire, and combined advanced path smoothing. It uses ellipsoidal informed sampling after first solution, continuous rewiring with recursive cost updates, and strict collision checks on nodes and edges to ensure feasibility. The algorithm balances exploration and exploitation with alternating tree growth, aggressively attempts incremental connection, optimizes path quality through smoothing, and enforces a hard 30-second time limit for planning efficiency, robustness, and high success rate.",
          "planning_mechanism": "The planner maintains two trees grown alternately from start and goal; samples points with goal bias and informed ellipsoidal focusing post-initial path; extends and rewires tree nodes within adaptive radii; incrementally connects opposing trees with rewiring for minimal cost; applies randomized shortcut smoothing on paths; and terminates early upon timeout or best path found, returning an optimized feasible trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0\n        self.children = []                  # List[Node]\n        self.valid = True                   # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 6.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 7.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 6.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if (not collision_free_node(new_pos)) or (not collision_free_edge(nearest.position, new_pos)):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if (not collision_free_node(new_pos)) or (not collision_free_edge(current.position, new_pos)):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes+1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.50062,
          "time_improvement": 44.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1661.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020828557014465333,
                    "num_nodes_avg": 79.5,
                    "path_length_avg": 164.04702238677336,
                    "smoothness_avg": 0.03813925269215495,
                    "success_improvement": 0.0,
                    "time_improvement": 16.097013305570975,
                    "length_improvement": 10.083227538390707,
                    "smoothness_improvement": 496.96212534503735,
                    "objective_score": 9.330560126074621
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028560113906860352,
                    "num_nodes_avg": 192.5,
                    "path_length_avg": 242.67989487125402,
                    "smoothness_avg": 0.11926114323163488,
                    "success_improvement": 0.0,
                    "time_improvement": 82.10958498618453,
                    "length_improvement": 18.986465938503887,
                    "smoothness_improvement": 2968.675115679318,
                    "objective_score": 43.27354426195272
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032259035110473636,
                    "num_nodes_avg": 190.2,
                    "path_length_avg": 127.14661914343546,
                    "smoothness_avg": 0.1270887170262303,
                    "success_improvement": 0.0,
                    "time_improvement": 34.01298338378525,
                    "length_improvement": 15.555269636312607,
                    "smoothness_improvement": 1516.5590998603514,
                    "objective_score": 20.897744441699853
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive neighbor radius, goal-biased and informed ellipsoidal sampling after an initial path is found, incremental connection attempts between two trees, dynamic rewiring for path cost optimization, and randomized path smoothing before returning the final path. It strictly enforces a 30-second planning time limit to balance search efficiency, path quality, and robustness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling points with a goal bias, switching to informed ellipsoidal sampling after the first feasible path is found. It extends and rewires trees incrementally using adaptive neighbor radius, tries bridging the trees progressively via incremental connection, and upon success or timeout, performs path smoothing and returns the optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                    # Cost from root\n        self.children = []                  # List[Node]\n        self.valid = True                   # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        self._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        for child in self.children:\n            child.cost = self.cost + self._dist(self.position, child.position)\n            child._update_cost_recursive()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_pos(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_radius(n_nodes, iter_num=0):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            base = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            fraction = min(1.0, iter_num / self.max_iter)\n            radius = base * (1.0 - 0.6 * fraction)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree_nodes if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        rot_mat = None\n\n        def informed_sample(c_best):\n            nonlocal rot_mat\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rot_mat is None:\n                rot_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                dir_sample = unit_ball_sample(dim)\n                r = random.random() ** (1.0 / dim)\n                sample_unit = tuple(r * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = rot_mat[0][0] * sample_scaled[0] + rot_mat[0][1] * sample_scaled[1]\n                    y_rot = rot_mat[1][0] * sample_scaled[0] + rot_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rot_mat[0][0] * sample_scaled[0] + rot_mat[0][1] * sample_scaled[1] + rot_mat[0][2] * sample_scaled[2])\n                    y_rot = (rot_mat[1][0] * sample_scaled[0] + rot_mat[1][1] * sample_scaled[1] + rot_mat[1][2] * sample_scaled[2])\n                    z_rot = (rot_mat[2][0] * sample_scaled[0] + rot_mat[2][1] * sample_scaled[1] + rot_mat[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp_pos(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_pos(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            current = nearest\n            while True:\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_pos(new_pos)\n\n                if (not collision_free_node(new_pos)) or (not collision_free_edge(current.position, new_pos)):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialization\n        start_time = time.perf_counter()\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        rot_mat = None\n        grow_start = True\n\n        for iter_num in range(1, self.max_iter + 1):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position, iter_num)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined = path_s + path_g[::-1]\n                    total_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    edges = []\n                    for node in all_nodes:\n                        for child in node.children:\n                            edges.append((node, child))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position, iter_num)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined = path_s + path_g[::-1]\n                    total_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    edges = []\n                    for node in all_nodes:\n                        for child in node.children:\n                            edges.append((node, child))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n        for node in all_nodes:\n            for child in node.children:\n                edges.append((node, child))\n\n        return PlannerResult(success_state, smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.33168,
          "time_improvement": 44.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1570.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022186803817749023,
                    "num_nodes_avg": 84.9,
                    "path_length_avg": 157.96992634658915,
                    "smoothness_avg": 0.04282885963448825,
                    "success_improvement": 0.0,
                    "time_improvement": 10.625632672504706,
                    "length_improvement": 13.414180175764809,
                    "smoothness_improvement": 570.3646576370237,
                    "objective_score": 8.722349125089492
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03294479846954346,
                    "num_nodes_avg": 218.3,
                    "path_length_avg": 233.35065616647222,
                    "smoothness_avg": 0.10810948720843579,
                    "success_improvement": 0.0,
                    "time_improvement": 79.3629633590128,
                    "length_improvement": 22.10083434540727,
                    "smoothness_improvement": 2681.734973989236,
                    "objective_score": 41.63773074673147
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029035115242004396,
                    "num_nodes_avg": 212.8,
                    "path_length_avg": 126.72888077782031,
                    "smoothness_avg": 0.12242423522382884,
                    "success_improvement": 0.0,
                    "time_improvement": 40.60762743316523,
                    "length_improvement": 15.832711568190827,
                    "smoothness_improvement": 1457.227235630037,
                    "objective_score": 22.634966721737918
               }
          ],
          "success_rate": 1.0
     }
]