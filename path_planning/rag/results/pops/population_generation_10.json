[
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a time-limited bidirectional informed RRT* planner with adaptive neighbor radius, goal bias and ellipsoidal informed sampling, recursive cost propagation to children on rewiring, robust collision checking, incremental extend-and-rewire operations, and randomized path smoothing for high-quality, smooth, and efficient paths within 30 seconds max planning time.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling with goal bias switching to ellipsoidal informed sampling post-solution. It connects new nodes optimally within an adaptive neighborhood and rewires neighbors recursively to minimize costs. Incremental connection attempts link the trees progressively. Early termination occurs upon timeout or improved solution. Final paths are smoothed by shortcutting and returned with full exploration graph.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root\n        self.children = []                 # List[Node]\n        self.valid = True                  # Collision validity flag\n        \n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-14:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 5.0, neighbor_radius_max: float = 30.0, max_planning_time: float = 30.0,\n                 smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 2.5 * (1 + 1 / dim) ** (1 / dim)\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n\n                # Arbitrary orthogonal vector\n                if abs(vx) < 0.9:\n                    arb = (1.0, 0.0, 0.0)\n                else:\n                    arb = (0.0, 1.0, 0.0)\n\n                wx = vy*arb[2] - vz*arb[1]\n                wy = vz*arb[0] - vx*arb[2]\n                wz = vx*arb[1] - vy*arb[0]\n\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-14:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w; wy /= norm_w; wz /= norm_w\n\n                vx2 = wy * vz - wz * vy\n                vy2 = wz * vx - wx * vz\n                vz2 = wx * vy - wy * vx\n\n                return [[vx, vx2, wx], [vy, vy2, wy], [vz, vz2, wz]]\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new + 1e-14 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative_cost + 1e-14 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if tentative_cost + 1e-14 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                rewire(tree, new_node, neighbors)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            for _ in range(trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path) - 3)\n                j = random.randint(i + 2, len(smoothed_path) - 1)\n                if collision_free_edge(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n            return smoothed_path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        grow_start = True\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            opposite_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connected_node = incremental_connect(opposite_tree, new_node.position)\n            if connected_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = 0.0\n                for i in range(len(combined_path) - 1):\n                    total_cost += dist_func(combined_path[i], combined_path[i + 1])\n\n                if total_cost + 1e-14 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for child in node.children:\n                            all_edges.append((node, child))\n\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for child in node.children:\n                all_edges.append((node, child))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.92986,
          "time_improvement": 61.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1686.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014389538764953613,
                    "num_nodes_avg": 58.2,
                    "path_length_avg": 157.0171224248782,
                    "smoothness_avg": 0.04419145545565596,
                    "success_improvement": 0.0,
                    "time_improvement": 42.035097357133665,
                    "length_improvement": 13.936427103398888,
                    "smoothness_improvement": 591.6922411624832,
                    "objective_score": 18.356275833632292
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04134116172790527,
                    "num_nodes_avg": 275.2,
                    "path_length_avg": 245.41334599869697,
                    "smoothness_avg": 0.11746050253256786,
                    "success_improvement": 0.0,
                    "time_improvement": 74.10337567708964,
                    "length_improvement": 18.07396127413515,
                    "smoothness_improvement": 2922.343333543251,
                    "objective_score": 40.45752162567018
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01631455421447754,
                    "num_nodes_avg": 144.5,
                    "path_length_avg": 125.96283056634547,
                    "smoothness_avg": 0.12923183147868317,
                    "success_improvement": 0.0,
                    "time_improvement": 66.62799254998983,
                    "length_improvement": 16.34148564326129,
                    "smoothness_improvement": 1543.8193575072976,
                    "objective_score": 30.97579168118569
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner enhanced with adaptive neighbor radius, ellipsoidal informed sampling after first solution, incremental extend-and-rewire steps, and progressive bidirectional tree connection attempts. It maintains consistent and dynamic parent-child cost propagation, rigorous collision checking for nodes and edges, and applies randomized shortcut path smoothing. The planner runs under a strict 30-second time limit and returns the best path found if time expires.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions. It samples points with goal bias and informed ellipsoidal sampling once a feasible path is found. Each extension rewires neighbors adaptively to optimize path costs. Incremental connection tries to link the two trees. On a successful connection, the combined path is smoothed and returned early. If no exact solution is found in time, the best available path is returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...] e.g. 2D or 3D\n        self.parent = None                    # Node or None\n        self.cost = 0.0                      # Cost from root to this node\n        self.children = []\n        self.valid = True                    # Validity flag (collision, pruning)\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs to maintain consistency\n        for ch in self.children:\n            ch.update_parent(self, self.cost + self._distance(self.position, ch.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1, p2):\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 35.0\n            base_radius = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            factor = min(1.0, iteration / self.max_iter)\n            radius = base_radius * (1.0 - 0.5 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree_nodes if (math.dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_uniform():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            for _ in range(100):\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if collision_free_node(clamped):\n                    # Introduce small goal bias on informed sampling\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return clamped\n\n            return sample_uniform()\n\n        def extend_and_rewire(tree: list, sample: tuple, iteration: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iteration)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors through new_node if cheaper\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple, iteration: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iteration)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = math.dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = [(node, c) for node in nodes_all for c in node.children]\n                    return PlannerResult(True, smoothed, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = [(node, c) for node in nodes_all for c in node.children]\n                    return PlannerResult(True, smoothed, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = len(best_path) > 0\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success else []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = [(node, c) for node in nodes_all for c in node.children]\n\n        return PlannerResult(success, smoothed_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.65268,
          "time_improvement": 63.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1481.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01572568416595459,
                    "num_nodes_avg": 57.8,
                    "path_length_avg": 159.79226543957935,
                    "smoothness_avg": 0.03845847248883305,
                    "success_improvement": 0.0,
                    "time_improvement": 36.65274707121851,
                    "length_improvement": 12.415327242086036,
                    "smoothness_improvement": 501.9586083599331,
                    "objective_score": 15.988682611582426
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033181285858154295,
                    "num_nodes_avg": 209.3,
                    "path_length_avg": 235.77412678789224,
                    "smoothness_avg": 0.0992244015920287,
                    "success_improvement": 0.0,
                    "time_improvement": 79.21482468065952,
                    "length_improvement": 21.291810096243143,
                    "smoothness_improvement": 2453.1153214105884,
                    "objective_score": 40.288386030499424
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013629579544067382,
                    "num_nodes_avg": 118.9,
                    "path_length_avg": 123.46492916467116,
                    "smoothness_avg": 0.12491934125030824,
                    "success_improvement": 0.0,
                    "time_improvement": 72.12020481187945,
                    "length_improvement": 18.00047281697062,
                    "smoothness_improvement": 1488.9648001172857,
                    "objective_score": 32.680980007544385
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* planner with adaptive neighbor radius, dynamic rewiring through recursive cost propagation, ellipsoidal informed sampling, and iterative randomized shortcut path smoothing. It enforces robust collision checks for nodes and edges, clamps samples within map bounds, alternates growth between start and goal trees, and terminates upon the first improved solution or after a 30-second timeout, returning the best path found.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Sampling mixes uniform, goal-biased, and ellipsoidal informed strategies to focus search after an initial solution. New nodes are connected to the minimum-cost parent within an adaptive radius, triggering rewiring of neighbors via recursive cost updates. Incremental connection attempts join trees by repeatedly extending toward the other tree. Once a connection is found, the combined path is smoothed by randomly shortcutting segments. The process respects map bounds and collision constraints, and enforces a hard 30-second max planning time, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent = None                    # Node or None\n        self.cost = 0.0                      # Cost from root to this node\n        self.children: List[Node] = []       # Children nodes\n        self.valid = True                    # Validity flag for collision etc.\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Prevent redundant updates\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        # Remove self from current parent's children\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Set new parent and cost\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update children costs\n        d = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + d(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 10000,\n        step_size: float = 5.0,\n        goal_sample_rate: float = 0.2,\n        neighbor_radius_min: float = 5.0,\n        neighbor_radius_max: float = 25.0,\n        max_time_sec: float = 30.0,\n        smoothing_trials: int = 150\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                 # Tuple[int, ...]\n        start_pos = map.start             # Tuple[float, ...]\n        goal_pos = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles         # List of rectangular obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            for _ in range(1000):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n            # Fallback to start or goal if fail\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def rotation_matrix(direction: Tuple[float, ...]):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx ** 2 + ky ** 2 + kz ** 2)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta ** 2))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            for _ in range(100):\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(d * radius_sample for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_clamped):\n                    return sample_clamped\n            return uniform_sample()\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                if (time.perf_counter() - start_time) > self.max_time_sec:\n                    return None\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = None) -> List[Tuple[float, ...]]:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            if (time.perf_counter() - start_time) > self.max_time_sec:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if len(path_goal) > 0 and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                    smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = [(node, c) for node in all_nodes for c in node.children]\n\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if len(path_start) > 0 and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                    smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = [(node, c) for node in all_nodes for c in node.children]\n\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = len(best_path) > 0\n        smoothed_final = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = [(node, c) for node in all_nodes for c in node.children]\n\n        return PlannerResult(success_state, smoothed_final, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.04769,
          "time_improvement": 58.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1619.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017989444732666015,
                    "num_nodes_avg": 62.3,
                    "path_length_avg": 156.57926404739584,
                    "smoothness_avg": 0.04727377798695305,
                    "success_improvement": 0.0,
                    "time_improvement": 27.53371532186344,
                    "length_improvement": 14.176424218406968,
                    "smoothness_improvement": 639.9372821477905,
                    "objective_score": 14.295085850979376
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036628198623657224,
                    "num_nodes_avg": 227.0,
                    "path_length_avg": 239.00927108974284,
                    "smoothness_avg": 0.1110884267051454,
                    "success_improvement": 0.0,
                    "time_improvement": 77.0556351167673,
                    "length_improvement": 20.21182580981978,
                    "smoothness_improvement": 2758.385232882966,
                    "objective_score": 40.95098186140898
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014308667182922364,
                    "num_nodes_avg": 119.4,
                    "path_length_avg": 125.0827371032619,
                    "smoothness_avg": 0.12252368003495909,
                    "success_improvement": 0.0,
                    "time_improvement": 70.73110662107706,
                    "length_improvement": 16.926001815894207,
                    "smoothness_improvement": 1458.4921662873614,
                    "objective_score": 31.896993180938765
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive informed sampling after finding an initial path solution. It incrementally grows two trees from the start and goal positions, rewiring locally to optimize path costs, dynamically adjusting neighborhood radii. The planner incorporates robust collision checking for nodes and edges, enforces a strict 30-second runtime limit, and smooths the final path to improve quality and feasibility.",
          "planning_mechanism": "The planner alternates growth between the start and goal trees, sampling configurations biased towards the goal or within an informed ellipsoidal subset after the first solution. Each extension involves steering towards samples, rewiring neighbors to minimize costs, and incrementally attempting to connect the two trees. Upon successful connection, the combined path is smoothed and returned. The process terminates upon time expiration or max iterations, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            new_pt = tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(min(max(new_pt[d], 0.0), bounds[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        success_state = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        success_state = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.50914,
          "time_improvement": 56.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1622.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016451644897460937,
                    "num_nodes_avg": 69.2,
                    "path_length_avg": 150.5392184768476,
                    "smoothness_avg": 0.04309586299929125,
                    "success_improvement": 0.0,
                    "time_improvement": 33.72838348933654,
                    "length_improvement": 17.487068906271332,
                    "smoothness_improvement": 574.5438401032775,
                    "objective_score": 16.488648028571614
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029997587203979492,
                    "num_nodes_avg": 204.9,
                    "path_length_avg": 237.67032959361413,
                    "smoothness_avg": 0.11983256957008481,
                    "success_improvement": 0.0,
                    "time_improvement": 81.209133610514,
                    "length_improvement": 20.658803020521642,
                    "smoothness_improvement": 2983.37832694939,
                    "objective_score": 43.41139232200548
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02251169681549072,
                    "num_nodes_avg": 181.7,
                    "path_length_avg": 128.67739794773527,
                    "smoothness_avg": 0.11060146419662706,
                    "success_improvement": 0.0,
                    "time_improvement": 53.951514459876705,
                    "length_improvement": 14.538599242350195,
                    "smoothness_improvement": 1306.842460830212,
                    "objective_score": 25.627386490584115
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of bidirectional RRT* variants with adaptive neighbor radius, ellipsoidal informed sampling, incremental extend-and-rewire, rigorous collision checking, and dynamic path smoothing. It grows two trees alternately from start and goal, applying adaptive rewiring and incremental connections to continuously improve the path cost and smoothness, while enforcing a strict 30-second timeout to ensure efficient and robust planning.",
          "planning_mechanism": "The planner alternately samples points using goal biasing or ellipsoidal informed sampling (once a path is found) within map bounds, extends the active tree towards the sample with steering and collision checks, rewires neighbors to optimize local costs, then incrementally connects to the opposite tree using iterative extend-and-rewire steps. Upon connection, it extracts and smooths the combined path. The process stops early upon timeout or when a better path is identified, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True                   # For collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = (2.0 * (1.5 * (math.log(n_nodes) / n_nodes)) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            attempts = 30\n            for _ in range(attempts):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback if sampling repeatedly fails\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                # Arbitrary vector not colinear with v\n                if abs(vx) < 0.9:\n                    arbitrary = (1.0, 0.0, 0.0)\n                else:\n                    arbitrary = (0.0, 1.0, 0.0)\n                # w = v cross arbitrary\n                wx = vy * arbitrary[2] - vz * arbitrary[1]\n                wy = vz * arbitrary[0] - vx * arbitrary[2]\n                wz = vx * arbitrary[1] - vy * arbitrary[0]\n                norm_w = math.sqrt(wx * wx + wy * wy + wz * wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n                # u = v\n                ux, uy, uz = vx, vy, vz\n                # v_ = w\n                vx_, vy_, vz_ = wx, wy, wz\n                # w_ = u cross v_\n                wx_, wy_, wz_ = (uy * wz - uz * vy_), (uz * vx_ - ux * wz), (ux * vy_ - uy * vx_)\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            current = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n                rewire(tree, new_node, neighbors)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                # Check time constraint early\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else \\\n                        (goal_pos if (random.random() < self.goal_sample_rate and grow_start) else\n                         start_pos if (random.random() < self.goal_sample_rate and not grow_start) else uniform_sample())\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    total_cost = 0.0\n                    for i in range(len(combined_path) - 1):\n                        total_cost += dist_func(combined_path[i], combined_path[i + 1])\n\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    total_cost = 0.0\n                    for i in range(len(combined_path) - 1):\n                        total_cost += dist_func(combined_path[i], combined_path[i + 1])\n\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.01366,
          "time_improvement": 56.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1696.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017095541954040526,
                    "num_nodes_avg": 76.4,
                    "path_length_avg": 162.9755091837044,
                    "smoothness_avg": 0.04408547935958829,
                    "success_improvement": 0.0,
                    "time_improvement": 31.134594292453656,
                    "length_improvement": 10.670540904206065,
                    "smoothness_improvement": 590.0334851282482,
                    "objective_score": 14.424653894218551
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028893470764160156,
                    "num_nodes_avg": 205.0,
                    "path_length_avg": 236.34419864473517,
                    "smoothness_avg": 0.1019632230802231,
                    "success_improvement": 0.0,
                    "time_improvement": 81.90076605275016,
                    "length_improvement": 21.101503701820373,
                    "smoothness_improvement": 2523.5871709952116,
                    "objective_score": 41.40846641116518
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022553205490112305,
                    "num_nodes_avg": 194.1,
                    "path_length_avg": 134.15414536765348,
                    "smoothness_avg": 0.16301389685813333,
                    "success_improvement": 0.0,
                    "time_improvement": 53.86660697294812,
                    "length_improvement": 10.901204380727625,
                    "smoothness_improvement": 1973.5247356012178,
                    "objective_score": 28.207846646036046
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner leveraging adaptive neighbor radius, ellipsoidal informed sampling after the first feasible path, incremental connection attempts with rewiring, and randomized path smoothing for high-quality path extraction within a strict 30-second planning time limit. It ensures collision-free node and edge checks, maintains consistent node parent-child relationships with dynamic cost updating, and alternates growth between start and goal trees to efficiently explore and connect the search space.",
          "planning_mechanism": "The planner grows two trees from the start and goal positions alternately, sampling uniformly with goal bias initially, then switches to informed ellipsoidal sampling centered on the best solution. Each iteration extends one tree toward a sample, rewires neighbors adaptively to optimize path cost, and incrementally attempts to connect to the opposite tree. Upon successful connection, the path is combined, smoothed by randomized shortcutting, and returned. The process terminates early if the time limit is reached or an improved path is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                 # List[Node]\n        self.valid = True                  # For collision and tree integrity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0,\n                 goal_sample_rate=0.2,\n                 neighbor_radius_min=5.0,\n                 neighbor_radius_max=30.0,\n                 max_planning_time=30.0,\n                 smoothing_trials=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        # Helpers\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 2.5 * ((1 + 1/dim) ** (1/dim))\n            r = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= radius_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm_val = math.sqrt(norm_sq)\n                    return tuple(x / norm_val for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n                # Arbitrary vector for Gram-Schmidt\n                if abs(vx) < 0.9:\n                    arb = (1.0,0.0,0.0)\n                else:\n                    arb = (0.0,1.0,0.0)\n\n                wx = vy*arb[2] - vz*arb[1]\n                wy = vz*arb[0] - vx*arb[2]\n                wz = vx*arb[1] - vy*arb[0]\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-14:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w; wy /= norm_w; wz /= norm_w\n                # v = w x u\n                vx2 = wy * vz - wz * vy\n                vy2 = wz * vx - wx * vz\n                vz2 = wx * vy - wy * vx\n                return [[vx, vx2, wx],\n                        [vy, vy2, wy],\n                        [vz, vz2, wz]]\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                unit_dir = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * u for u in unit_dir)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest_node.cost + dist_func(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n                rewire(tree, new_node, neighbors)\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i+2, len(smoothed) - 1)\n                if collision_free_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        # Initialization of trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        grow_start = True\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_rate and grow_start else\n                start_pos if random.random() < self.goal_sample_rate and not grow_start else\n                sample_free())\n\n            active_tree = tree_start if grow_start else tree_goal\n            opposite_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connected_node = incremental_connect(opposite_tree, new_node.position)\n            if connected_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = 0.0\n                for i in range(len(combined_path) - 1):\n                    total_cost += dist_func(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-14 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.98369,
          "time_improvement": 59.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1393.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014384126663208008,
                    "num_nodes_avg": 65.7,
                    "path_length_avg": 159.1191696865942,
                    "smoothness_avg": 0.04023458560646773,
                    "success_improvement": 0.0,
                    "time_improvement": 42.0568987474285,
                    "length_improvement": 12.784261690181944,
                    "smoothness_improvement": 529.7586355422825,
                    "objective_score": 17.82271513997635
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03439531326293945,
                    "num_nodes_avg": 233.5,
                    "path_length_avg": 235.0120110285971,
                    "smoothness_avg": 0.09848677511869139,
                    "success_improvement": 0.0,
                    "time_improvement": 78.4543426258406,
                    "length_improvement": 21.546226272981702,
                    "smoothness_improvement": 2434.135660960746,
                    "objective_score": 40.01622634715225
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020659852027893066,
                    "num_nodes_avg": 162.1,
                    "path_length_avg": 130.08391730011857,
                    "smoothness_avg": 0.10329262606713288,
                    "success_improvement": 0.0,
                    "time_improvement": 57.739529580334626,
                    "length_improvement": 13.604456059751477,
                    "smoothness_improvement": 1213.874579305359,
                    "objective_score": 26.112122982577475
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* planner enhanced with adaptive neighbor radius, dynamic rewiring with recursive cost propagation, and ellipsoidal informed sampling to accelerate convergence. It employs robust collision checking for node positions and edges, enforces strict map bounds, and integrates iterative path shortcut smoothing for improved path quality. Time management halts planning after 30 seconds, returning the best feasible path found to ensure planning efficiency and robustness.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, alternating expansion steps. Sampling mixes uniform, goal-biased, and ellipsoidal informed strategies (after an initial path is found) to bias growth toward promising regions. New nodes are connected to minimum-cost parents within an adaptive radius, triggering rewiring of neighbors to maintain optimal subtrees. Incremental connection attempts join the trees for path completion. Upon a successful connection, the path is smoothed via randomized shortcuts. The process respects a strict 30-second timeout, returning the best solution discovered by then.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = 0.0                # Cost from root to this node\n        self.children = []             # List[Node]\n        self.valid = True              # For collision checking etc.\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5.0)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                trials += 1\n                if trials > 1000:\n                    return start_pos if random.random() < 0.5 else goal_pos\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            for _ in range(100):\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(d * radius_sample for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_clamped):\n                    return sample_clamped\n            return uniform_sample()\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = None) -> list:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sample\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            # Extend tree\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if len(path_goal) > 0 and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if len(path_start) > 0 and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Return best found path on timeout or iteration exhaustion\n        success_state = (len(best_path) > 0)\n        final_path = path_smoothing(best_path) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.74864,
          "time_improvement": 54.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1665.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020201230049133302,
                    "num_nodes_avg": 72.2,
                    "path_length_avg": 163.9503975902586,
                    "smoothness_avg": 0.04282688162226332,
                    "success_improvement": 0.0,
                    "time_improvement": 18.624053752432243,
                    "length_improvement": 10.136189120478328,
                    "smoothness_improvement": 570.3336974503814,
                    "objective_score": 10.466122437077244
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03457667827606201,
                    "num_nodes_avg": 231.5,
                    "path_length_avg": 239.2705510587059,
                    "smoothness_avg": 0.10687321445237918,
                    "success_improvement": 0.0,
                    "time_improvement": 78.34073329765899,
                    "length_improvement": 20.12460303565299,
                    "smoothness_improvement": 2649.924785524626,
                    "objective_score": 40.77676452405143
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01682701110839844,
                    "num_nodes_avg": 136.4,
                    "path_length_avg": 124.58414871428647,
                    "smoothness_avg": 0.147448505181393,
                    "success_improvement": 0.0,
                    "time_improvement": 65.57974354134936,
                    "length_improvement": 17.25714048362393,
                    "smoothness_improvement": 1775.5341023907822,
                    "objective_score": 32.0030216710835
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after the initial solution, and recursive cost propagation in node rewiring. It maintains robust collision and boundary checks, carefully updates parent-child relationships with consistent cost updates, and employs randomized shortcut path smoothing. Time-limited execution ensures timely termination with the best path found, optimizing planning efficiency, path quality, and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal alternatingly, initially sampling uniformly with goal bias and switching to ellipsoidal informed sampling once a solution is discovered. Each iteration extends one tree toward a sample by a limited step size, rewires neighbors based on adaptive radius for cost improvement, and incrementally attempts to connect the opposite tree. Parent-child links and costs are consistently updated through recursive rewiring. Upon successful tree connection, paths are merged and shortcut smoothing is applied. The process halts immediately when time expires or a better path is found, returning the best available result.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children: List[Node] = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n        # Recursive update of costs of descendants for consistency\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        t_start = time.perf_counter()\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = max(self.step_size / 5.0, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iter_factor = min(1.0, iteration / self.max_iter)\n            radius = base_radius * (1 - 0.6 * iter_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(nodes_list: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in nodes_list if (math.dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform() -> Tuple[float, ...]:\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in sample)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in sample)\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n        rotation_mat = None\n\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        all_nodes: List[Node] = tree_start + tree_goal\n        grow_start = True\n        iteration = 0\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_uniform()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(rotation_mat[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(rotation_mat[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_node: Node, iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            current_node = nearest\n\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = math.dist(new_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                current_node = new_node\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]], trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            sample: Tuple[float, ...]\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_uniform()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(other_tree, new_node, iteration)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n                    smoothed = shortcut_smoothing(best_path, self.smoothing_trials)\n\n                    all_edges = []\n                    for n in tree_start + tree_goal:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    # Early stopping on improvement to reduce planning time\n                    return PlannerResult(True, smoothed, tree_start + tree_goal, all_edges)\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed = shortcut_smoothing(best_path, self.smoothing_trials) if success else []\n\n        final_nodes = tree_start + tree_goal\n        final_edges = []\n        for n in final_nodes:\n            for c in n.children:\n                final_edges.append((n, c))\n\n        return PlannerResult(success, smoothed, final_nodes, final_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.58705,
          "time_improvement": 57.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1385.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016678977012634277,
                    "num_nodes_avg": 61.3,
                    "path_length_avg": 158.0357458570025,
                    "smoothness_avg": 0.04103473817605373,
                    "success_improvement": 0.0,
                    "time_improvement": 32.812629055586825,
                    "length_improvement": 13.378103459130367,
                    "smoothness_improvement": 542.2827608154188,
                    "objective_score": 15.230823212579214
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034638190269470216,
                    "num_nodes_avg": 217.1,
                    "path_length_avg": 236.3280016042307,
                    "smoothness_avg": 0.0932382777690487,
                    "success_improvement": 0.0,
                    "time_improvement": 78.30220141035669,
                    "length_improvement": 21.106910740146727,
                    "smoothness_improvement": 2299.088043814601,
                    "objective_score": 39.207482790209355
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019632363319396974,
                    "num_nodes_avg": 147.0,
                    "path_length_avg": 121.89014458679245,
                    "smoothness_avg": 0.11102541369262653,
                    "success_improvement": 0.0,
                    "time_improvement": 59.84129469042906,
                    "length_improvement": 19.04636975041438,
                    "smoothness_improvement": 1312.2350671266286,
                    "objective_score": 28.322837692844736
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional, adaptive informed RRT* path planner for 2D/3D environments, utilizing ellipsoidal informed sampling after an initial solution is found, adaptive neighbor radius with min/max limits, rigorous collision checking, parent-child node management with efficient rewiring, and randomized shortcutting for path smoothing. It enforces a strict 30-second planning time limit and returns the best feasible path found with improved path quality, efficiency, and robustness.",
          "planning_mechanism": "The planner grows two trees alternately from the start and goal locations. Uniform and goal-biased sampling is used initially, switching to ellipsoidal informed sampling once a solution is found, focusing exploration within a prolate hyperspheroid defined by the current best path cost. Nodes are extended toward sampled points with adaptive neighbor radius rewiring, and incremental connection attempts join the two trees. Parent-child relationships are managed recursively to maintain cost consistency. After a connection, the path is extracted and smoothed by random shortcutting, and the planner halts immediately if a better path is found or after 30 seconds, returning the best result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float, ...] (2D or 3D)\n        self.parent = None                    # Parent node or None\n        self.cost = cost                      # Cost from root to this node\n        self.children = []                    # List[Node]\n        self.valid = True                     # For collision validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Avoid redundant updates\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = self._dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 9000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 34.0\n            base_radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.5 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos)**2) <= r_sq]\n\n        def uniform_sample():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B): \n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree: list, sample: tuple, iter_num: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cand_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple, iter_num:int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cand_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def random_path_smoothing(path: list, trials: int) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i+2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iter_num in range(1, self.max_iter+1):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling_active:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iter_num)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined_path, self.smoothing_trials)\n                        informed_sampling_active = True\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(n, c) for n in nodes_all for c in n.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iter_num)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined_path, self.smoothing_trials)\n                        informed_sampling_active = True\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(n, c) for n in nodes_all for c in n.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        success = len(best_path) > 0\n        smoothed_path = random_path_smoothing(best_path, self.smoothing_trials) if success else []\n        nodes_all = tree_start + tree_goal\n        edges_all = [(n, c) for n in nodes_all for c in n.children]\n\n        return PlannerResult(success, smoothed_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.43898,
          "time_improvement": 53.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1669.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017316627502441406,
                    "num_nodes_avg": 61.9,
                    "path_length_avg": 159.36579723017758,
                    "smoothness_avg": 0.03979549899375149,
                    "success_improvement": 0.0,
                    "time_improvement": 30.244002696841587,
                    "length_improvement": 12.64908122548038,
                    "smoothness_improvement": 522.8859765614327,
                    "objective_score": 14.217446936955715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03868398666381836,
                    "num_nodes_avg": 243.6,
                    "path_length_avg": 240.35139522012236,
                    "smoothness_avg": 0.11700321368875002,
                    "success_improvement": 0.0,
                    "time_improvement": 75.76786359950852,
                    "length_improvement": 19.76378614419795,
                    "smoothness_improvement": 2910.576962219977,
                    "objective_score": 41.23600111979203
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023127269744873048,
                    "num_nodes_avg": 183.1,
                    "path_length_avg": 126.52572184885214,
                    "smoothness_avg": 0.13148302590676803,
                    "success_improvement": 0.0,
                    "time_improvement": 52.692337891807085,
                    "length_improvement": 15.96764005542287,
                    "smoothness_improvement": 1572.4543844666491,
                    "objective_score": 26.863501300959943
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, informed ellipsoidal sampling after the first solution, incremental connection between trees, and randomized path smoothing. It enforces strict collision checking on nodes and edges while respecting boundary limits and ensures robust parent-child management in the search trees. The planner runs until a path is found or a 30-second time limit is reached, always returning the best feasible and smooth path found.",
          "planning_mechanism": "The planner alternately grows two trees from the start and goal positions, sampling points using a combination of goal bias, uniform, and ellipsoidal informed distributions to focus search in promising regions. Nodes are connected via steering with a fixed step size and rewired adaptively using a radius dependent on node density for path cost minimization. Trees attempt incremental connections each iteration to bridge the paths. Upon connection, the combined path is smoothed through randomized shortcutting to improve quality before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=8.0, neighbor_radius_max=25.0, smoothing_trials=120,\n                 max_planning_time=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 35.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                trials += 1\n                if trials > 1000:\n                    return start_pos if random.random() < 0.5 else goal_pos\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample = informed_sample(best_cost) if informed_sampling_active else (\n                goal_pos if (random.random() < self.goal_sample_rate) else uniform_sample()\n            )\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connecting_node = incremental_connect(tree_goal, new_node.position)\n                if connecting_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connecting_node.cost + dist_func(new_node.position, connecting_node.position)\n\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling_active = True\n                        best_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connecting_node = incremental_connect(tree_start, new_node.position)\n                if connecting_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connecting_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connecting_node.cost + dist_func(new_node.position, connecting_node.position)\n\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling_active = True\n                        best_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = len(best_path) > 0\n        if success:\n            best_path = path_smoothing(best_path, self.smoothing_trials)\n        nodes_all = tree_start + tree_goal\n        edges_all = [(node, child) for node in nodes_all for child in node.children]\n        return PlannerResult(success, best_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.40365,
          "time_improvement": 56.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016196298599243163,
                    "num_nodes_avg": 69.2,
                    "path_length_avg": 157.37355636007882,
                    "smoothness_avg": 0.04151361559978314,
                    "success_improvement": 0.0,
                    "time_improvement": 34.75698652923788,
                    "length_improvement": 13.741060015458292,
                    "smoothness_improvement": 549.7782323957539,
                    "objective_score": 15.924199123841792
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03973178863525391,
                    "num_nodes_avg": 278.6,
                    "path_length_avg": 235.6629231311264,
                    "smoothness_avg": 0.09197871984809777,
                    "success_improvement": 0.0,
                    "time_improvement": 75.11150724944603,
                    "length_improvement": 21.328933077691367,
                    "smoothness_improvement": 2266.678711285633,
                    "objective_score": 38.13263234680025
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01999962329864502,
                    "num_nodes_avg": 172.9,
                    "path_length_avg": 123.94980026152447,
                    "smoothness_avg": 0.11621774730538599,
                    "success_improvement": 0.0,
                    "time_improvement": 59.090051193215984,
                    "length_improvement": 17.67844452152115,
                    "smoothness_improvement": 1378.2811674227285,
                    "objective_score": 28.154110099382667
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT* variant with adaptive neighbor radius bounded between minimum and maximum values, ellipsoidal informed sampling after discovering an initial path, recursive parent-child cost propagation, robust incremental extend-and-rewire steps with collision and boundary checking, randomized path smoothing, and early stopping upon improvement or timeout within a strict 30-second limit.",
          "planning_mechanism": "The algorithm grows two trees simultaneously from start and goal positions, alternating expansions with a goal bias initially and switching to informed ellipsoidal sampling after a solution is found. Each iteration extends one tree toward a sampled point with adaptive neighbor rewiring, then tries to incrementally connect the opposite tree. Successful connections trigger early termination with path extraction and smoothing. The planner enforces collision-free sampling, edge checking, and clamps points to map bounds, ensuring robustness, efficiency, and high path quality.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position                  # Tuple[float, ...]\n        self.parent = None                        # Parent Node\n        self.cost = 0.0                          # Cost from root\n        self.children: List['Node'] = []          # Children nodes\n        self.valid = True                         # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # propagate cost update recursively to children\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_active = False\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_node: Node) -> Node:\n            if not tree or target_node is None:\n                return None\n            current = min(tree, key=lambda n: dist_func(n.position, target_node.position))\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist_func(new_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            sample_pt = (informed_sample(best_cost) if informed_sampling_active else\n                         (goal_pos if random.random() < self.goal_sample_rate else uniform_sample()))\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node)\n                if connected_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node)\n                if connected_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = len(best_path) > 0\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        if distance < 1e-12:\n            return self._is_in_obstacle(from_pos, obstacles, is_3d)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.39818,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1448.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017297840118408202,
                    "num_nodes_avg": 83.3,
                    "path_length_avg": 164.67627631792016,
                    "smoothness_avg": 0.038341806161273535,
                    "success_improvement": 0.0,
                    "time_improvement": 30.31968329398839,
                    "length_improvement": 9.738323487562527,
                    "smoothness_improvement": 500.13252698864153,
                    "objective_score": 13.544232320652231
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04122128486633301,
                    "num_nodes_avg": 268.5,
                    "path_length_avg": 233.7294523968397,
                    "smoothness_avg": 0.09533108063843972,
                    "success_improvement": 0.0,
                    "time_improvement": 74.178468052809,
                    "length_improvement": 21.974381260665655,
                    "smoothness_improvement": 2352.9373690290095,
                    "objective_score": 38.41310351312087
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017633056640625,
                    "num_nodes_avg": 167.1,
                    "path_length_avg": 123.43583671527881,
                    "smoothness_avg": 0.12506303671525865,
                    "success_improvement": 0.0,
                    "time_improvement": 63.93094841321514,
                    "length_improvement": 18.019794636623445,
                    "smoothness_improvement": 1490.792595824959,
                    "objective_score": 30.237206430414027
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This is a bidirectional informed RRT* planner with adaptive neighbor radius, goal bias and ellipsoidal informed sampling, incremental connections between two trees grown from start and goal, dynamic rewiring for cost improvement, strict collision checks for nodes and edges, and randomized path smoothing. The planner runs up to 30 seconds, returning the best feasible and smoothed path found.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points using a mix of uniform, goal-biased, and informed ellipsoidal sampling once a solution is found. New nodes connect with steering and are rewired within an adaptive radius to improve path cost. Incremental connection attempts bridge the two trees gradually. Upon a successful connection, the combined path is extracted, smoothed by random shortcutting, and returned immediately or after the time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # 2D or 3D coordinate\n        self.parent = None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 6.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 120,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(min(max(0.0, pos[d]), bounds[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(src: Tuple[float, ...], tgt: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 32.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            tries = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                tries += 1\n                if tries > 1000:\n                    # fallback to start or goal if stuck\n                    return start_pos if random.random() < 0.5 else goal_pos\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B): \n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s): \n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B): \n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            sample = informed_sample(best_cost) if informed_sampling_active else (\n                goal_pos if random.random() < self.goal_sample_rate else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_smoothing(candidate_path, self.smoothing_trials)\n                        informed_sampling_active = True\n                        # Early return upon better solution\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(n, c) for n in nodes_all for c in n.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_smoothing(candidate_path, self.smoothing_trials)\n                        informed_sampling_active = True\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(n, c) for n in nodes_all for c in n.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = len(best_path) > 0\n        final_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = [(n, c) for n in all_nodes for c in n.children]\n\n        return PlannerResult(success_state, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.1945,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1587.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013717579841613769,
                    "num_nodes_avg": 64.5,
                    "path_length_avg": 154.46364109614237,
                    "smoothness_avg": 0.04322348079327672,
                    "success_improvement": 0.0,
                    "time_improvement": 44.741927242902065,
                    "length_improvement": 15.336030682179972,
                    "smoothness_improvement": 576.5413357056252,
                    "objective_score": 19.37249098783474
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03647317886352539,
                    "num_nodes_avg": 279.5,
                    "path_length_avg": 233.78375974357678,
                    "smoothness_avg": 0.10222989704142948,
                    "success_improvement": 0.0,
                    "time_improvement": 77.1527414467051,
                    "length_improvement": 21.95625190517451,
                    "smoothness_improvement": 2530.4488840945423,
                    "objective_score": 40.18931723551914
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031883621215820314,
                    "num_nodes_avg": 267.8,
                    "path_length_avg": 125.55698348849032,
                    "smoothness_avg": 0.13781858267575234,
                    "success_improvement": 0.0,
                    "time_improvement": 34.780906008241054,
                    "length_improvement": 16.611029948011595,
                    "smoothness_improvement": 1653.0421989259735,
                    "objective_score": 22.0216887867045
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner is an improved bidirectional RRT* variant with adaptive neighbor radius, informed ellipsoidal sampling after the first solution, incremental extend-and-rewire steps with recursive parent-child cost propagation, randomized path smoothing for reducing path length and sharp turns, and strict 30-second runtime limit enforcement. It balances exploration-exploitation efficiently to optimize planning speed, success rate, and path quality.",
          "planning_mechanism": "The planner alternately grows two trees rooted at start and goal, using goal bias initially, then switching to ellipsoidal informed sampling. Each iteration extends one tree towards a sample, rewires within an adaptive radius while maintaining cost consistency, and incrementally tries to connect the other tree to the newly added node. Upon a successful connection, the combined path is smoothed and returned early. The search stops if the maximum time or iteration limit is reached, returning the best available solution.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # float: cost from root\n        self.children: List[Node] = []\n        self.valid = True                   # For collision checking etc.\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        # Recursively update children cost and parents\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                   # Tuple[int,...]\n        start_pos = map.start               # Tuple[float, ...]\n        goal_pos = map.goal                 # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction: Tuple[float, ...]):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K,sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random()**(1.0/n)\n                sample_unit = tuple(radius_sample*d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.08501,
          "time_improvement": 54.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1513.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0180403470993042,
                    "num_nodes_avg": 62.8,
                    "path_length_avg": 162.34888059945655,
                    "smoothness_avg": 0.03969256812454978,
                    "success_improvement": 0.0,
                    "time_improvement": 27.328667003451734,
                    "length_improvement": 11.014005960797645,
                    "smoothness_improvement": 521.2748849404659,
                    "objective_score": 13.00777571789738
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03461320400238037,
                    "num_nodes_avg": 216.0,
                    "path_length_avg": 235.71539227290282,
                    "smoothness_avg": 0.09811209324860407,
                    "success_improvement": 0.0,
                    "time_improvement": 78.31785312271823,
                    "length_improvement": 21.31141736792589,
                    "smoothness_improvement": 2424.4948265709563,
                    "objective_score": 39.880113543255426
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020733904838562012,
                    "num_nodes_avg": 161.0,
                    "path_length_avg": 127.0043495525471,
                    "smoothness_avg": 0.13303190646649876,
                    "success_improvement": 0.0,
                    "time_improvement": 57.58805189256887,
                    "length_improvement": 15.649758324430746,
                    "smoothness_improvement": 1592.1560308599535,
                    "objective_score": 28.367147386956574
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after initial path discovery, incremental extend-and-rewire steps, robust collision checking, and path smoothing under a strict 30-second time limit.",
          "planning_mechanism": "A pair of trees grow alternately from start and goal positions. Sampling switches from goal bias to focused ellipsoidal informed distribution once a solution is found. Each extension rewires neighbors adaptively to improve path cost. Incremental connections attempt gradual linkage of trees. Collision checks ensure only feasible nodes and edges are added. Found paths are smoothed. Planning halts if 30 seconds elapse, returning the best path so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = 0.0                  # Cost from root\n        self.children = []                # List[Node]\n        self.valid = True                 # Collision flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_node: Node) -> Node:\n            if not tree or target_node is None:\n                return None\n            current = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for i in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            sample_pt = informed_sample(best_cost) if informed_sampling_active else \\\n                        (goal_pos if (grow_start_tree and random.random() < self.goal_sample_rate) else uniform_sample())\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node)\n                if connected_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node)\n                if connected_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = len(best_path) > 0\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.78836,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1459.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020650291442871095,
                    "num_nodes_avg": 79.6,
                    "path_length_avg": 159.56940011713894,
                    "smoothness_avg": 0.042331427203243906,
                    "success_improvement": 0.0,
                    "time_improvement": 16.815114606163164,
                    "length_improvement": 12.537483256842656,
                    "smoothness_improvement": 562.5787598962362,
                    "objective_score": 10.36492483269866
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03029487133026123,
                    "num_nodes_avg": 214.2,
                    "path_length_avg": 235.82413011919007,
                    "smoothness_avg": 0.09518961557141546,
                    "success_improvement": 0.0,
                    "time_improvement": 81.02291109005962,
                    "length_improvement": 21.27511754498984,
                    "smoothness_improvement": 2349.2973709613066,
                    "objective_score": 40.30838369082239
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01837334632873535,
                    "num_nodes_avg": 166.3,
                    "path_length_avg": 123.13115592138578,
                    "smoothness_avg": 0.1229937512796258,
                    "success_improvement": 0.0,
                    "time_improvement": 62.416659229336545,
                    "length_improvement": 18.222149112586873,
                    "smoothness_improvement": 1464.4714378224717,
                    "objective_score": 29.691784780430698
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a time-limited bidirectional RRT* planner with adaptive neighbor radius, goal-biased plus ellipsoidal informed sampling after an initial path is found, incremental extend-and-rewire steps with robust collision checking, and path smoothing. It maintains consistent parent-child relationships with recursive cost propagation for efficient rewiring and uses early termination upon timeout or improved solution to ensure fast convergence, improved path quality, and high success rates.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately. Sampling is biased towards the goal and switches to ellipsoidal informed sampling after a feasible path is found. Each new node is connected to the best parent within an adaptive neighborhood radius, neighbors are rewired to minimize costs, and incremental connections attempt to link the two trees progressively. Robust collision checks prevent invalid expansions. The process is time-limited to 30 seconds, and the best solution found is smoothed before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.2, \n                 neighbor_radius_min: float = 8.0, neighbor_radius_max: float = 30.0, max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best):\n            c_min = dist_func(start_pos, goal_pos)\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for child in node.children:\n                                all_edges.append((node, child))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for child in node.children:\n                                all_edges.append((node, child))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for child in node.children:\n                all_edges.append((node, child))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.68729,
          "time_improvement": 52.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1549.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02027289867401123,
                    "num_nodes_avg": 86.6,
                    "path_length_avg": 158.36715628450975,
                    "smoothness_avg": 0.041536845017126366,
                    "success_improvement": 0.0,
                    "time_improvement": 18.335353403417926,
                    "length_improvement": 13.19645215227936,
                    "smoothness_improvement": 550.1418232206626,
                    "objective_score": 10.890605567584561
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03168988227844238,
                    "num_nodes_avg": 230.2,
                    "path_length_avg": 243.08345474180896,
                    "smoothness_avg": 0.10659969060215416,
                    "success_improvement": 0.0,
                    "time_improvement": 80.14905866449972,
                    "length_improvement": 18.85174603788583,
                    "smoothness_improvement": 2642.88681984707,
                    "objective_score": 41.02950090616243
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02078251838684082,
                    "num_nodes_avg": 182.7,
                    "path_length_avg": 123.25061227958604,
                    "smoothness_avg": 0.12211748536728033,
                    "success_improvement": 0.0,
                    "time_improvement": 57.48861113102528,
                    "length_improvement": 18.142811887370772,
                    "smoothness_improvement": 1453.325400096659,
                    "objective_score": 28.141772717265034
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner enhanced with adaptive informed sampling within an ellipsoidal subset, adaptive neighbor radius for efficient rewiring, incremental tree connection, and dedicated path smoothing. It maintains robust collision checking and enforces a strict 30-second planning timeout to ensure timely and high-quality solutions.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending them towards samples drawn from a uniform distribution initially and later from an informed ellipsoidal region around the best solution. Each extension attempts incremental rewiring of nearby nodes to minimize path costs. Upon successful connection of trees, the combined path is extracted and smoothed. The process concludes either when a time or iteration limit is reached, delivering the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...], 2D or 3D\n        self.parent = None                  # Parent Node or None\n        self.cost = cost                    # Cost from root to this node\n        self.children = []                  # List of child nodes\n        self.valid = True                   # For obstacle validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0, max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    normed = tuple(x / math.sqrt(norm_sq) for x in pt)\n                    return normed\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.68288,
          "time_improvement": 54.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1405.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01598813533782959,
                    "num_nodes_avg": 70.3,
                    "path_length_avg": 160.07310344541804,
                    "smoothness_avg": 0.04324016794566805,
                    "success_improvement": 0.0,
                    "time_improvement": 35.595523703969775,
                    "length_improvement": 12.26139548092287,
                    "smoothness_improvement": 576.8025258772809,
                    "objective_score": 16.01494883676191
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040297436714172366,
                    "num_nodes_avg": 257.0,
                    "path_length_avg": 231.7466873890371,
                    "smoothness_avg": 0.08312651221825451,
                    "success_improvement": 0.0,
                    "time_improvement": 74.75717816950535,
                    "length_improvement": 22.636285290996536,
                    "smoothness_improvement": 2038.9050329823299,
                    "objective_score": 37.14893567396256
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022991228103637695,
                    "num_nodes_avg": 180.8,
                    "path_length_avg": 127.98573904981842,
                    "smoothness_avg": 0.13355395998673397,
                    "success_improvement": 0.0,
                    "time_improvement": 52.97061596211985,
                    "length_improvement": 14.997966149089132,
                    "smoothness_improvement": 1598.796513103363,
                    "objective_score": 26.884760583970596
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive informed sampling, dynamic neighbor radius scaling, incremental extend-and-rewire, and rigorous collision checks. It alternates growth between two trees seeded at start and goal, focusing sampling within an ellipsoidal region once a feasible path is found. The planner maintains consistent parent-child relationships with recursive cost updates and applies randomized path smoothing to improve solution quality, all within a strict 30-second planning time limit.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points using goal bias, uniform, or informed ellipsoidal distributions based on the current best cost. It extends and rewires nodes using an adaptive radius based on node density and iteration progress. Incremental connect attempts bridge the two trees iteratively, and upon finding a path, the planner applies randomized shortcut smoothing. The process halts early if time runs out or a satisfactory path is found, returning the best solution discovered.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Node coordinate tuple, 2D or 3D\n        self.parent = None                    # Parent Node or None\n        self.cost = cost                      # Cost from root\n        self.children: List[Node] = []       # Children nodes list\n        self.valid = True                     # Collision validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from current parent if any\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update descendants' costs and parents\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, \n                 max_iter: int = 15000, \n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)  # Reduce radius over time\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            rad_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= rad_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                point = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in point)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in point)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0],\n                            [0, 1, 0],\n                            [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = clamp(sample_pt)\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors toward new_node if cheaper\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_shortcut(path: List[Tuple[float, ...]], trials: int = self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n        c_min = dist(start_pos, goal_pos)\n\n        grow_start = True\n        iteration = 0\n        t_start = time.perf_counter()\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_uniform()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(other_tree, new_node.position, iteration)\n            if connected_node is not None:\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n\n                # Avoid duplicated middle node\n                if path_from_goal and path_from_goal[0] == new_node.position:\n                    path_from_goal = path_from_goal[1:]\n                combined_path = path_from_start + path_from_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    smoothed = path_shortcut(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, [(n, c) for n in all_nodes for c in n.children])\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed = path_shortcut(best_path) if success else []\n\n        edges = [(n, c) for n in all_nodes for c in n.children]\n\n        return PlannerResult(success, smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.66086,
          "time_improvement": 56.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1382.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019427227973937988,
                    "num_nodes_avg": 53.3,
                    "path_length_avg": 167.32838520346422,
                    "smoothness_avg": 0.036634018904249666,
                    "success_improvement": 0.0,
                    "time_improvement": 21.74194068869344,
                    "length_improvement": 8.284660582041207,
                    "smoothness_improvement": 473.40194789683244,
                    "objective_score": 10.546524062500437
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03835971355438232,
                    "num_nodes_avg": 218.6,
                    "path_length_avg": 244.07150961036504,
                    "smoothness_avg": 0.10085907257140406,
                    "success_improvement": 0.0,
                    "time_improvement": 75.97099235888778,
                    "length_improvement": 18.521904883179296,
                    "smoothness_improvement": 2495.176583115832,
                    "objective_score": 38.971561599881355
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01450345516204834,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 124.36167150818252,
                    "smoothness_avg": 0.10037330833942,
                    "success_improvement": 0.0,
                    "time_improvement": 70.33266080361206,
                    "length_improvement": 17.404899250692054,
                    "smoothness_improvement": 1176.7410732904711,
                    "objective_score": 30.464483457674383
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an advanced bidirectional informed RRT* planner that adaptively samples within an ellipsoidal region after an initial solution is found, uses adaptive neighbor radius for efficient rewiring with recursive cost propagation, performs incremental connection attempts between trees with rewiring, applies rigorous collision and boundary checks, and performs randomized path smoothing to produce high-quality, smooth, and efficient paths. It enforces a strict 30-second planning time limit, terminating early if time is exceeded or an improved solution is found, returning the best available path.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, initially sampling uniformly with goal bias, switching to informed ellipsoidal sampling post-solution. Each extension rewires neighbor nodes adaptively to minimize path cost. Incremental connections attempt to join the two trees efficiently, triggering rewiring. Upon connection, the path is extracted, smoothed by shortcutting, and returned. Planning halts when time limit is reached or upon finding a better path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = None             # Node or None\n        self.cost = 0.0                # Cost from root node\n        self.children = []             # List[Node]\n        self.valid = True              # Collision validity flag\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for c in self.children:\n            c.update_parent(self, self.cost + dist_func(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=5.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            res = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, res)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 2.5 * (1 + 1/dim) ** (1 / dim)\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n\n                # Construct orthonormal basis u=direction, v,w arbitrary orthogonal vectors\n                if abs(vx) < 0.9:\n                    arb = (1.0,0.0,0.0)\n                else:\n                    arb = (0.0,1.0,0.0)\n\n                wx = vy*arb[2] - vz*arb[1]\n                wy = vz*arb[0] - vx*arb[2]\n                wz = vx*arb[1] - vy*arb[0]\n\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-14:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w; wy /= norm_w; wz /= norm_w\n\n                # v = w x u\n                vx2 = wy * vz - wz * vy\n                vy2 = wz * vx - wx * vz\n                vz2 = wx * vy - wy * vx\n\n                return [[vx, vx2, wx], [vy, vy2, wy], [vz, vz2, wz]]\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                rewire(tree, new_node, neighbors)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            for _ in range(trials):\n                if len(smoothed_path) < 3:\n                    break\n                i = random.randint(0, len(smoothed_path)-3)\n                j = random.randint(i+2, len(smoothed_path)-1)\n                if collision_free_edge(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n            return smoothed_path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        grow_start = True\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            opposite_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connected_node = incremental_connect(opposite_tree, new_node.position)\n            if connected_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n\n                # Remove overlap on connection point\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = 0.0\n                for i in range(len(combined_path)-1):\n                    total_cost += dist_func(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-14 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n\n                    # Gather edges\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.5813,
          "time_improvement": 51.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1654.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01635730266571045,
                    "num_nodes_avg": 76.7,
                    "path_length_avg": 161.15983880979687,
                    "smoothness_avg": 0.03717784391649352,
                    "success_improvement": 0.0,
                    "time_improvement": 34.10841917830849,
                    "length_improvement": 11.665738607283002,
                    "smoothness_improvement": 481.9139902733644,
                    "objective_score": 14.97524342631597
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03572168350219727,
                    "num_nodes_avg": 254.6,
                    "path_length_avg": 244.2543114898976,
                    "smoothness_avg": 0.12461836399454304,
                    "success_improvement": 0.0,
                    "time_improvement": 77.62348760475484,
                    "length_improvement": 18.46088035413097,
                    "smoothness_improvement": 3106.5202645590925,
                    "objective_score": 42.51182367504811
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028421854972839354,
                    "num_nodes_avg": 210.1,
                    "path_length_avg": 129.2611748795124,
                    "smoothness_avg": 0.11585048940853751,
                    "success_improvement": 0.0,
                    "time_improvement": 41.86207337157828,
                    "length_improvement": 14.15088240073408,
                    "smoothness_improvement": 1373.6096740829742,
                    "objective_score": 22.25684686203517
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after the first solution, dynamic rewiring with recursive cost propagation, and multi-trial randomized shortcut path smoothing. It enforces strict collision checks for both nodes and edges, ensures samples remain within map bounds, alternates growth between start and goal trees, and terminates upon timeout or path convergence. The planner balances exploration and exploitation to efficiently find a smooth, low-cost path with high success and robustness within a 30-second planning window.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Initial sampling is uniform random; once a path is found, sampling is biased inside an ellipsoidal informed set to focus search on promising regions. New nodes are added via constrained steering, with parent selection from neighbors within an adaptively computed radius to minimize cost. Rewiring neighbors dynamically updates parents and propagates cost changes to descendants, optimizing path costs. Incremental connection attempts between trees trigger potential path updates. Shortcut smoothing prunes redundant waypoints. The process stops early on timeout or successful path discovery, returning the best available solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] (x,y) or (x,y,z)\n        self.parent = None                  # Node or None\n        self.cost = cost                    # Cost from root\n        self.children = []\n        self.valid = True                   # For collision or pruning flags\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + self._distance(self.position, c.position))\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float =5.0,\n                 goal_sample_rate: float=0.1,\n                 neighbor_radius_min: float=5.0,\n                 neighbor_radius_max: float=30.0,\n                 smoothing_trials: int=150,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        t_start = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist_val = math.dist(from_pos, to_pos)\n            if dist_val <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_val\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 35.0\n            base = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim))\n            shrink = min(1.0, iter_num/self.max_iter)\n            r = base * (1 - 0.5 * shrink)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree_nodes if (math.dist(n.position, pos)**2) <= r_sq]\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return random.choice([start_pos, goal_pos])\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0.0, 1 - cos_t*cos_t))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B): return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s): return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1-cos_t))\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        rotation_mat = None\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                r_sample = random.random() ** (1.0/dim)\n                unit_pt = tuple(r_sample * d for d in dir_sample)\n                scaled = tuple(unit_pt[d]*radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = rotation_mat[0][0]*scaled[0] + rotation_mat[0][1]*scaled[1]\n                    y_rot = rotation_mat[1][0]*scaled[0] + rotation_mat[1][1]*scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i]*scaled[i] for i in range(dim))\n                    y_rot = sum(rotation_mat[1][i]*scaled[i] for i in range(dim))\n                    z_rot = sum(rotation_mat[2][i]*scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pts = tuple(center[d] + rotated[d] for d in range(dim))\n                pts_clamped = clamp(pts)\n                if collision_free_node(pts_clamped):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return pts_clamped\n            return sample_uniform()\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes+1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            # Rewire neighbors for improvement\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target.position))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes+1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = math.dist(new_node.position, target.position)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target.position):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def shortcut_path(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) -1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connected_node = incremental_connect(other_tree, new_node, iteration)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                candidate_path = path_start + path_goal[::-1]\n                candidate_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                if candidate_cost + 1e-12 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    informed_sampling = True\n                    best_path = shortcut_path(best_path, self.smoothing_trials)\n\n                    # Prepare nodes and edges for return\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for n in nodes_all:\n                        for c in n.children:\n                            edges_all.append((n, c))\n\n                    return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = len(best_path) > 0\n        smoothed = shortcut_path(best_path, self.smoothing_trials) if success else []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for n in nodes_all:\n            for c in n.children:\n                edges_all.append((n, c))\n\n        return PlannerResult(success, smoothed, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.4688,
          "time_improvement": 51.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1528.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020235300064086914,
                    "num_nodes_avg": 70.8,
                    "path_length_avg": 154.5624175507092,
                    "smoothness_avg": 0.03977280929930181,
                    "success_improvement": 0.0,
                    "time_improvement": 18.486810639078467,
                    "length_improvement": 15.281889742218805,
                    "smoothness_improvement": 522.530833571835,
                    "objective_score": 11.215075308026478
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03416416645050049,
                    "num_nodes_avg": 217.8,
                    "path_length_avg": 236.9615138983604,
                    "smoothness_avg": 0.10177976720857998,
                    "success_improvement": 0.0,
                    "time_improvement": 78.59913590002499,
                    "length_improvement": 20.895426101725892,
                    "smoothness_improvement": 2518.8667192799107,
                    "objective_score": 40.35315958675223
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021622991561889647,
                    "num_nodes_avg": 155.0,
                    "path_length_avg": 125.06894790820198,
                    "smoothness_avg": 0.12925113333672425,
                    "success_improvement": 0.0,
                    "time_improvement": 55.76939302119956,
                    "length_improvement": 16.935159942682105,
                    "smoothness_improvement": 1544.0648757168653,
                    "objective_score": 27.838174273480615
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This simplified bidirectional RRT* planner grows two trees from start and goal, employing goal-biased and adaptive informed sampling once a path is found. It uses adaptive neighbor radius for rewiring to optimize paths, performing robust collision checks for nodes and edges to guarantee validity. Incremental extensions and rewiring improve tree quality while enforcing a 30-second planning time limit. Path smoothing is applied before returning the best found path, ensuring efficiency, solution quality, and robustness.",
          "planning_mechanism": "The planner alternately grows trees from start and goal. Sampling switches from uniform goal-biased to ellipsoidal informed after an initial solution. Extensions find optimal parents in an adaptive neighborhood and rewire neighbors to minimize cost. Incremental connection attempts bridge trees progressively. Timing enforces early termination with the best available path returned, applying path smoothing on completion.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = None             # Node or None\n        self.cost = cost               # Path cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0,1-cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best/2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best/2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = [a1, a_minor, a_minor]\n            n_ = dim\n            while True:\n                dir_sample = self._unit_ball_sample(n_)\n                r_sample = random.random() ** (1/n_)\n                sample_unit = tuple(r_sample * ds for ds in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n_))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n_))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n_))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, tries=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(tries):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path = []\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n\n            if informed:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed = True\n                    grow_start = not grow_start\n                    break\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed = True\n                    grow_start = not grow_start\n                    break\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        extracted_path = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = [(node, child) for node in all_nodes for child in node.children]\n\n        return PlannerResult(success_state, extracted_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.44803,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1542.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01830923557281494,
                    "num_nodes_avg": 80.1,
                    "path_length_avg": 159.66330926763604,
                    "smoothness_avg": 0.04347436047652111,
                    "success_improvement": 0.0,
                    "time_improvement": 26.245512467129846,
                    "length_improvement": 12.486010163369478,
                    "smoothness_improvement": 580.4681475423519,
                    "objective_score": 13.273196510524608
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0373302698135376,
                    "num_nodes_avg": 241.1,
                    "path_length_avg": 233.81434209429435,
                    "smoothness_avg": 0.09833497031214453,
                    "success_improvement": 0.0,
                    "time_improvement": 76.61584888211975,
                    "length_improvement": 21.94604263624083,
                    "smoothness_improvement": 2430.2296139477126,
                    "objective_score": 39.525111261622655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024415230751037596,
                    "num_nodes_avg": 176.2,
                    "path_length_avg": 124.58525164500907,
                    "smoothness_avg": 0.13486176545922535,
                    "success_improvement": 0.0,
                    "time_improvement": 50.05776732812575,
                    "length_improvement": 17.256407969553898,
                    "smoothness_improvement": 1615.4317021812947,
                    "objective_score": 26.545770303254976
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive informed sampling and dynamic neighborhood radius scaling. It grows two trees from start and goal, alternately extending and rewiring them with efficient collision checking and cost updates. The planner focuses sampling within informed ellipsoidal regions after initial feasible path discovery, aggressively smooths paths through randomized shortcutting, and halts within a 30-second time limit, returning the best path found.",
          "planning_mechanism": "The planner iteratively samples points biased by goal and informed ellipsoidal regions to extend one tree towards the sample, rewiring nearby nodes to optimize costs. It then incrementally connects the opposite tree to the new node with rewiring. Adaptive neighbor radius scales with tree size and iteration progress to optimize rewiring locality. Upon tree connection, the combined path is shortcut-smoothed. The process alternates tree growth, enforcing strict collision checks and bounds, and exits early if time limit or max iteration reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] e.g. (x,y) or (x,y,z)\n        self.parent = None                  # type: Node or None\n        self.cost = cost                    # cost from root to this node\n        self.children = []\n        self.valid = True                   # valid node flag\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 7000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pt = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            return tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_via_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_via_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, trials=self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sampling strategy\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        smoothed = path_smoothing(best_path) if success_state else []\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for node in nodes_all:\n            for c in node.children:\n                edges_all.append((node, c))\n\n        return PlannerResult(success_state, smoothed, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.35583,
          "time_improvement": 52.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1481.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019919705390930176,
                    "num_nodes_avg": 80.1,
                    "path_length_avg": 166.04426582975003,
                    "smoothness_avg": 0.04062840638195663,
                    "success_improvement": 0.0,
                    "time_improvement": 19.758110213231042,
                    "length_improvement": 8.98850675894757,
                    "smoothness_improvement": 535.9227858741857,
                    "objective_score": 10.404748345129754
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03934195041656494,
                    "num_nodes_avg": 242.6,
                    "path_length_avg": 235.24097549030694,
                    "smoothness_avg": 0.09376449938916415,
                    "success_improvement": 0.0,
                    "time_improvement": 75.35570681893434,
                    "length_improvement": 21.469791345286342,
                    "smoothness_improvement": 2312.6281051222845,
                    "objective_score": 38.46381084034899
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01874575614929199,
                    "num_nodes_avg": 155.1,
                    "path_length_avg": 122.42925069245436,
                    "smoothness_avg": 0.1330951623004038,
                    "success_improvement": 0.0,
                    "time_improvement": 61.65488154649649,
                    "length_improvement": 18.688321144507835,
                    "smoothness_improvement": 1592.9606403981657,
                    "objective_score": 30.198931894841344
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planner integrates bidirectional RRT* with adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, recursive parent-child cost updates, incremental extend-and-rewire connection attempts, and randomized path smoothing. It enforces collision and edge-validity checks, clamps samples within workspace bounds, alternates tree growth between start and goal, and terminates early on success or exceeding a strict 30-second limit, returning the best found path.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, initially sampling uniformly with goal bias, then switches to ellipsoidal informed sampling after the first solution. Each iteration extends one tree using adaptive radius rewiring and attempts incremental connection to the opposite tree. Upon connection, the path is extracted and smoothed by shortcutting random segments respecting collision constraints. The algorithm tracks the best solution and respects the maximum planning time, terminating early if the time limit is reached or an improved solution is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []              # List[Node]\n        self.valid = True               # Collision validity flag\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for c in self.children:\n            c.update_parent(self, self.cost + dist_func(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                new_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if new_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = new_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    new_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if new_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = new_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                # Check time limit mid-connect\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        # Prepare nodes and edges for return\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.34917,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1411.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015734434127807617,
                    "num_nodes_avg": 63.5,
                    "path_length_avg": 158.05171398045536,
                    "smoothness_avg": 0.0379325535853074,
                    "success_improvement": 0.0,
                    "time_improvement": 36.61749988955243,
                    "length_improvement": 13.369351077634741,
                    "smoothness_improvement": 493.7268354685786,
                    "objective_score": 16.12775435973557
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03369519710540771,
                    "num_nodes_avg": 218.6,
                    "path_length_avg": 236.11343562232028,
                    "smoothness_avg": 0.10381260037547893,
                    "success_improvement": 0.0,
                    "time_improvement": 78.89290420360489,
                    "length_improvement": 21.17853904084778,
                    "smoothness_improvement": 2571.172980854768,
                    "objective_score": 40.75944397352487
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02763652801513672,
                    "num_nodes_avg": 165.5,
                    "path_length_avg": 125.8846182366874,
                    "smoothness_avg": 0.09970293140216517,
                    "success_improvement": 0.0,
                    "time_improvement": 43.46848791031507,
                    "length_improvement": 16.393430548549265,
                    "smoothness_improvement": 1168.2139281306681,
                    "objective_score": 22.160302123457715
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a time-aware, bidirectional informed RRT* planner with dynamic adaptive neighbor radius and integrated path smoothing. It grows two trees alternately from start and goal positions, uses goal bias and ellipsoidal informed sampling after the initial path is found, and performs careful rewiring with recursive cost updates to maintain a consistent tree structure. Collision checks are integrated at node and edge addition to ensure obstacle avoidance. The planning halts immediately if the maximum allowed time of 30 seconds is reached, returning the best feasible path found. The algorithm balances exploration and exploitation efficiently to improve planning speed, path quality, smoothness, and success rate.",
          "planning_mechanism": "The planner samples points in the configuration space, initially using uniform and goal-biased sampling, then switching to ellipsoidal informed sampling after a solution is found. It alternately grows two RRT* trees from start and goal, extending towards sampled points with step size limits and rewiring neighbors within an adaptive radius to minimize cost. Incremental connection attempts are made between trees after every extension. Node parent-child relationships and costs are recursively updated to ensure accurate path cost propagation. The best path is smoothed by shortcutting. Execution is strictly limited to 30 seconds to ensure responsive results.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                # Tuple[float, ...]\n        self.parent = None                      # Node or None\n        self.cost = 0.0                        # Cost from root to this node\n        self.children = []                      # List[Node]\n        self.valid = True                       # Validity flag for collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        # Avoid unnecessary updates\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        # Remove from old parent's children list\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Set new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        # Add self as child of new parent\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update children cost based on new parent's cost\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                       # Tuple[int, ...]\n        start_pos = map.start                   # Tuple[float, ...]\n        goal_pos = map.goal                     # Tuple[float, ...]\n        obstacles = map.obstacles               # List of rectangular blocks\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            r = max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n            return r\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            # Uniform random sampling in free space\n            attempts = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                attempts += 1\n                if attempts > 1000:\n                    # Give up and return start pos as fallback (rare condition)\n                    return start_pos\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            # Ellipsoidal informed sampling within hyper-ellipsoid defined by current best cost c_best\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            attempts = 0\n            while True:\n                dir_sample = unit_ball_sample(dim)\n                r_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(r_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n                attempts += 1\n                if attempts > 2000:\n                    return uniform_sample()\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sample point\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            # Extend and rewire alternating trees\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_goal, new_node.position)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    # Avoid duplicate node\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        edges = []\n                        for node in all_nodes:\n                            for child in node.children:\n                                edges.append((node, child))\n                        return PlannerResult(True, smoothed_path, all_nodes, edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_start, new_node.position)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        edges = []\n                        for node in all_nodes:\n                            for child in node.children:\n                                edges.append((node, child))\n                        return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        success = len(best_path) > 0\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success else []\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n        for node in all_nodes:\n            for child in node.children:\n                edges.append((node, child))\n\n        return PlannerResult(success, smoothed_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.30924,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1525.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016617584228515624,
                    "num_nodes_avg": 66.2,
                    "path_length_avg": 160.26636191158988,
                    "smoothness_avg": 0.03821788551791616,
                    "success_improvement": 0.0,
                    "time_improvement": 33.059935575451064,
                    "length_improvement": 12.155467453237717,
                    "smoothness_improvement": 498.1928998221145,
                    "objective_score": 14.840038662393432
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03389260768890381,
                    "num_nodes_avg": 216.9,
                    "path_length_avg": 236.2643632846552,
                    "smoothness_avg": 0.10565811900316666,
                    "success_improvement": 0.0,
                    "time_improvement": 78.76924372807659,
                    "length_improvement": 21.1281550429485,
                    "smoothness_improvement": 2618.659504418511,
                    "objective_score": 40.949701649105236
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02919151782989502,
                    "num_nodes_avg": 201.2,
                    "path_length_avg": 122.26140875529356,
                    "smoothness_avg": 0.12251175403774757,
                    "success_improvement": 0.0,
                    "time_improvement": 40.28770031412356,
                    "length_improvement": 18.799793767395855,
                    "smoothness_improvement": 1458.3404684831164,
                    "objective_score": 23.13797119013182
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling, incremental tree connection, and rigorous rewiring for path cost improvement. It grows trees alternately from start and goal positions with efficient collision checks, early termination on time limits (30 seconds), and applies randomized path smoothing once a valid path is found for improved path quality and smoothness.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal, sampling points either uniformly or within an ellipsoidal informed region biased by the best path cost. It extends the active tree towards samples, rewires neighbors for cost reduction, then incrementally connects to the opposite tree with iterative rewiring. Once connected, the combined path is extracted and smoothed. The search terminates early on time limit or at first improved path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children: List[Node] = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Remove from old parent's children list\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Assign new parent and cost\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs\n        for child in self.children:\n            child.update_parent(self, new_cost + child._distance(self))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 max_planning_time: float = 30.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> bool:\n            resolution = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = (2.0 * (1.5 * (math.log(n_nodes) / n_nodes)) ** (1.0/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r2 = radius*radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= r2]\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1.0, 1.0) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_enabled = False\n\n        # Rotation matrix for ellipsoidal sampling\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n                # Create arbitrary vector not colinear to (vx,vy,vz)\n                if abs(vx) < 0.9:\n                    arbitrary = (1.0,0.0,0.0)\n                else:\n                    arbitrary = (0.0,1.0,0.0)\n                # Cross product w = v x arbitrary\n                wx = vy*arbitrary[2] - vz*arbitrary[1]\n                wy = vz*arbitrary[0] - vx*arbitrary[2]\n                wz = vx*arbitrary[1] - vy*arbitrary[0]\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w; wy /= norm_w; wz /= norm_w\n                # u = v\n                ux, uy, uz = vx, vy, vz\n                # v_ = w\n                vx_, vy_, vz_ = wx, wy, wz\n                # w_ = u cross v_\n                wx_, wy_, wz_ = uy*wz - uz*vy_, uz*vx_ - ux*wz, ux*vy_ - uy*vx_\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                r = random.random() ** (1.0 / n)\n                sample_unit = tuple(r * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free() -> Tuple[float, ...]:\n            attempts = 30\n            for _ in range(attempts):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # Fallback if sampling fails repeatedly\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            n_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node: Node, other_tree: List[Node]) -> Node:\n            if not other_tree:\n                return None\n            current_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n                min_cost = current_node.cost + math.dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, step_pos)\n                    if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n                if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n                current_node = connect_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path_nodes: List[Tuple[float, ...]] = []\n        best_path_cost = math.inf\n        informed_sampling_enabled = False\n        grow_start = True\n\n        start_time = time.perf_counter()\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                # Time exceeded, return best path found if any\n                if best_path_nodes:\n                    smoothed = path_smoothing(best_path_nodes, self.smoothing_trials)\n                    # Gather all nodes and edges\n                    all_nodes = tree_start + tree_goal\n                    edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n                else:\n                    all_nodes = tree_start + tree_goal\n                    edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                # Remove overlap in connection point\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Compute total cost\n                total_cost = 0.0\n                for i in range(len(combined_path)-1):\n                    total_cost += math.dist(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-9 < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = combined_path\n                    informed_sampling_enabled = True\n\n                smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n\n                all_nodes = tree_start + tree_goal\n                edges = []\n                for node in all_nodes:\n                    for c in node.children:\n                        edges.append((node, c))\n\n                return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached\n        if best_path_nodes:\n            smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n            all_nodes = tree_start + tree_goal\n            edges = []\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n        all_nodes = tree_start + tree_goal\n        edges = []\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.24574,
          "time_improvement": 51.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1529.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015781450271606445,
                    "num_nodes_avg": 62.5,
                    "path_length_avg": 160.12592662173205,
                    "smoothness_avg": 0.0414925668946553,
                    "success_improvement": 0.0,
                    "time_improvement": 36.428106313951545,
                    "length_improvement": 12.23244226094837,
                    "smoothness_improvement": 549.4487744525086,
                    "objective_score": 16.122164218637682
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035854554176330565,
                    "num_nodes_avg": 236.9,
                    "path_length_avg": 237.2838880288203,
                    "smoothness_avg": 0.09845816398917688,
                    "success_improvement": 0.0,
                    "time_improvement": 77.54025574121387,
                    "length_improvement": 20.78780833795353,
                    "smoothness_improvement": 2433.399475990574,
                    "objective_score": 39.58663576990774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029289388656616212,
                    "num_nodes_avg": 200.4,
                    "path_length_avg": 128.10000819020397,
                    "smoothness_avg": 0.1339278140664068,
                    "success_improvement": 0.0,
                    "time_improvement": 40.08750201783301,
                    "length_improvement": 14.92207402695679,
                    "smoothness_improvement": 1603.5519094017636,
                    "objective_score": 23.02842495775008
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT* variant enhanced with adaptive neighbor radius, ellipsoidal informed sampling after the first solution, robust incremental extend-and-rewire steps, consistent parent-child cost propagation, randomized path smoothing, and thorough collision checking to ensure feasibility and efficiency within a strict 30-second time limit.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling with goal bias and switching to focused ellipsoidal sampling after finding an initial path. Each iteration extends one tree toward a sample with steering and adaptive neighbor rewiring, then incrementally connects the other tree. Upon successful connection, it shortcuts and smooths the combined path. Iterations stop either on timeout or max iterations, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                # Tuple[float, ...]\n        self.parent = None                      # Node or None\n        self.cost = 0.0\n        self.children = []                     # List[Node]\n        self.valid = True                      # Validity flag for collision checks\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + math.dist(self.position, c.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K,sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes+1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.18055,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1637.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015459370613098145,
                    "num_nodes_avg": 69.1,
                    "path_length_avg": 164.94822463487387,
                    "smoothness_avg": 0.04062795546838197,
                    "success_improvement": 0.0,
                    "time_improvement": 37.72552913991114,
                    "length_improvement": 9.589264305743352,
                    "smoothness_improvement": 535.9157280975678,
                    "objective_score": 15.91509024360985
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040113639831542966,
                    "num_nodes_avg": 255.8,
                    "path_length_avg": 235.80564763820144,
                    "smoothness_avg": 0.11296878333955736,
                    "success_improvement": 0.0,
                    "time_improvement": 74.87231085137101,
                    "length_improvement": 21.281287529132562,
                    "smoothness_improvement": 2806.7681634525256,
                    "objective_score": 40.751791578500445
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032284116744995116,
                    "num_nodes_avg": 237.7,
                    "path_length_avg": 121.59499216372414,
                    "smoothness_avg": 0.13109787658732472,
                    "success_improvement": 0.0,
                    "time_improvement": 33.96167799823163,
                    "length_improvement": 19.242395936168286,
                    "smoothness_improvement": 1567.5553135520959,
                    "objective_score": 21.874759154463625
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements an efficient bidirectional informed RRT* with adaptive neighbor radius, dynamic rewiring, and ellipsoidal informed sampling. It uses rigorous 2D/3D collision checks and incremental tree connection attempts, coupled with randomized path smoothing to produce high-quality, smooth paths. The planner enforces a strict 30-second time limit, alternates growth between start and goal trees, and biases sampling towards promising regions as solutions improve to optimize planning speed and path quality.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Each iteration performs goal-biased or ellipsoidal informed sampling, extends and rewires one tree towards the sample with an adaptive neighborhood, then incrementally attempts to connect the opposing tree to the new node. Upon successful connection, it merges and smooths the path, updates the best solution, and switches growth direction. The process terminates if the time limit or iteration limits are reached, returning the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position           # Tuple[float, ...]\n        self.parent = None                 # Parent Node\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # List of child Nodes\n        self.valid = True                 # Validity flag for collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = self._distance\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1, p2):\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 8000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int, iter_num: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 35.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            factor = min(1.0, iter_num / self.max_iter)\n            scaled_radius = base_radius * (1.0 - 0.5 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, scaled_radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample(max_attempts=100):\n            for _ in range(max_attempts):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0, 1 - cos_t * cos_t))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1 - cos_t))\n\n        c_min = dist_func(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            for _ in range(200):\n                dir_sample = unit_ball_sample(dim)\n                r_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(r_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n\n                if collision_free_node(clamped):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return clamped\n\n            return uniform_sample()\n\n        def extend_and_rewire(tree: list, sample: tuple, iter_num: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cand_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple, iter_num: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cand_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if (time.perf_counter() - start_time) > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = self.smoothing_trials) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_rate and grow_start else (\n                    start_pos if random.random() < self.goal_sample_rate and not grow_start else uniform_sample()\n                )\n            )\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smooth_path = path_smoothing(best_path, self.smoothing_trials)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smooth_path = path_smoothing(best_path, self.smoothing_trials)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        final_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.16872,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1504.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019357013702392577,
                    "num_nodes_avg": 68.7,
                    "path_length_avg": 160.58083031371604,
                    "smoothness_avg": 0.04250598761094988,
                    "success_improvement": 0.0,
                    "time_improvement": 22.024782514324574,
                    "length_improvement": 11.98310233896166,
                    "smoothness_improvement": 565.3110093408272,
                    "objective_score": 11.83061026879384
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.038924455642700195,
                    "num_nodes_avg": 249.0,
                    "path_length_avg": 233.03937596771743,
                    "smoothness_avg": 0.10340687428565883,
                    "success_improvement": 0.0,
                    "time_improvement": 75.61723080286863,
                    "length_improvement": 22.204748635455356,
                    "smoothness_improvement": 2560.7333563310062,
                    "objective_score": 39.929785749606694
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022962260246276855,
                    "num_nodes_avg": 184.5,
                    "path_length_avg": 121.15167670507103,
                    "smoothness_avg": 0.11681578261725933,
                    "success_improvement": 0.0,
                    "time_improvement": 53.02987075627163,
                    "length_improvement": 19.53682495539203,
                    "smoothness_improvement": 1385.8881324473823,
                    "objective_score": 26.745766880196804
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional informed RRT* planner with adaptive neighbor radius rewiring, incremental connection attempts, and ellipsoidal informed sampling after initial solution. It maintains consistent parent-child cost propagation, robust collision and boundary checking, and applies randomized shortcut smoothing. Planning halts upon timeout or first improved solution, returning a high-quality, smoothed, and efficient path within a strict 30-second time limit.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling uniformly with goal bias initially, then switches to ellipsoidal informed sampling after the first feasible path is found. Each iteration extends one tree toward a sampled point with a capped step size, rewires neighbors to minimize path cost using an adaptive radius, and attempts incremental connections to the opposite tree with rewiring. Path smoothing is applied on new solutions to improve path quality. The process stops early on timeout or path improvement, ensuring efficient, high-quality planning outcomes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                    # Tuple[float, ...] (2D or 3D)\n        self.parent = None                          # Node or None\n        self.cost = 0.0                            # Cost from root node\n        self.children = []\n        self.valid = True                           # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent == new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        # Propagate cost update recursively to children\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0, neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_pos(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 2.5 * (1 + 1 / dim) ** (1 / dim)\n            base = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            decay = max(0.4, 1.0 - iteration / self.max_iter)\n            radius = base * decay\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree_nodes if (dist_func(n.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # Guaranteed fallback to start or goal to avoid deadlock\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                # Arbitrary vector not parallel to direction\n                if abs(vx) < 0.9:\n                    arbitrary = (1.0, 0.0, 0.0)\n                else:\n                    arbitrary = (0.0, 1.0, 0.0)\n                wx = vy * arbitrary[2] - vz * arbitrary[1]\n                wy = vz * arbitrary[0] - vx * arbitrary[2]\n                wz = vx * arbitrary[1] - vy * arbitrary[0]\n                norm_w = math.sqrt(wx * wx + wy * wy + wz * wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n                ux, uy, uz = vx, vy, vz\n                vx_, vy_, vz_ = wx, wy, wz\n                wx_, wy_, wz_ = (uy * vz_ - uz * vy_, uz * vx_ - ux * wz_, ux * vy_ - uy * vx_)\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp_pos(sample_pt)\n                if collision_free_node(sample_pt):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return sample_pt\n            return uniform_sample()\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend_and_rewire(tree, sample, iteration):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_pos(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1, iteration)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            current = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_pos(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree) + 1, 0)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n                rewire(tree, new_node, neighbors)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_time_sec:\n                    return None\n\n                current = new_node\n\n        def shortcut_smooth(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iteration in range(1, self.max_iter + 1):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                break\n\n            if informed_sampling_active:\n                sample = informed_sample(best_cost)\n            else:\n                r = random.random()\n                if grow_start_tree:\n                    sample = goal_pos if r < self.goal_sample_rate else uniform_sample()\n                else:\n                    sample = start_pos if r < self.goal_sample_rate else uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample, iteration)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = incremental_connect(tree_goal, new_node.position)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    total_cost = 0.0\n                    for i in range(len(combined_path) - 1):\n                        total_cost += dist_func(combined_path[i], combined_path[i + 1])\n\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        best_path = shortcut_smooth(combined_path, self.smoothing_trials)\n                        informed_sampling_active = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = [(n, c) for n in all_nodes for c in n.children]\n                        return PlannerResult(True, best_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample, iteration)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = incremental_connect(tree_start, new_node.position)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    total_cost = 0.0\n                    for i in range(len(combined_path) - 1):\n                        total_cost += dist_func(combined_path[i], combined_path[i + 1])\n\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        best_path = shortcut_smooth(combined_path, self.smoothing_trials)\n                        informed_sampling_active = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = [(n, c) for n in all_nodes for c in n.children]\n                        return PlannerResult(True, best_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = len(best_path) > 0\n        if success_state:\n            best_path = shortcut_smooth(best_path, self.smoothing_trials)\n        all_nodes = tree_start + tree_goal\n        all_edges = [(n, c) for n in all_nodes for c in n.children]\n\n        return PlannerResult(success_state, best_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.16582,
          "time_improvement": 48.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1725.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017322301864624023,
                    "num_nodes_avg": 72.5,
                    "path_length_avg": 162.13748660537777,
                    "smoothness_avg": 0.03953728187054335,
                    "success_improvement": 0.0,
                    "time_improvement": 30.221144851510445,
                    "length_improvement": 11.129874358704418,
                    "smoothness_improvement": 518.8443178557676,
                    "objective_score": 13.886539916472856
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.037307906150817874,
                    "num_nodes_avg": 244.4,
                    "path_length_avg": 240.016200437514,
                    "smoothness_avg": 0.11977027517922309,
                    "success_improvement": 0.0,
                    "time_improvement": 76.62985776207695,
                    "length_improvement": 19.875683810679494,
                    "smoothness_improvement": 2981.775447403682,
                    "objective_score": 41.87297132777739
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030731844902038574,
                    "num_nodes_avg": 233.5,
                    "path_length_avg": 126.3234512649241,
                    "smoothness_avg": 0.1395683069987424,
                    "success_improvement": 0.0,
                    "time_improvement": 37.136905885342216,
                    "length_improvement": 16.101978546177705,
                    "smoothness_improvement": 1675.2985631631918,
                    "objective_score": 22.737960290654165
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive neighbor radius, goal-biased and ellipsoidal informed sampling after finding an initial path, incremental extend-and-rewire steps for optimized tree growth, robust collision checking, and post-hoc path smoothing. It enforces a 30-second planning time limit to ensure timely results and maintains consistent parent-child links with cost propagation to optimize path length and smoothness while improving planning efficiency and success rate.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points with goal bias and switching to informed ellipsoidal sampling upon discovering a path. Each extension chooses the best parent within an adaptive radius and rewires neighbors to minimize path costs. Incremental connections attempt to link the two trees progressively while ensuring collision-free paths. Path smoothing refines the final trajectory before returning. Timing is strictly monitored to enforce the maximum planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                  # Tuple[float, ...]\n        self.parent = None                        # Node or None\n        self.cost = cost                          # Cost from root\n        self.children = []                        # List[Node]\n        self.valid = True                         # For collision/validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # Clamp to bounds\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                # Time check to limit execution during incremental connect\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # On time limit or iteration end, return best found path or failure\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.11398,
          "time_improvement": 52.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1378.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015044641494750977,
                    "num_nodes_avg": 67.2,
                    "path_length_avg": 160.32343966413097,
                    "smoothness_avg": 0.04740254039094182,
                    "success_improvement": 0.0,
                    "time_improvement": 39.396168717790125,
                    "length_improvement": 12.124182232615077,
                    "smoothness_improvement": 641.9526933822505,
                    "objective_score": 17.453450528771306
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03404114246368408,
                    "num_nodes_avg": 233.7,
                    "path_length_avg": 232.14836316368215,
                    "smoothness_avg": 0.08683891562649824,
                    "success_improvement": 0.0,
                    "time_improvement": 78.67619967462957,
                    "length_improvement": 22.5021943558239,
                    "smoothness_improvement": 2134.4278466125347,
                    "objective_score": 38.77543800661633
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029708361625671385,
                    "num_nodes_avg": 211.5,
                    "path_length_avg": 123.78476098665263,
                    "smoothness_avg": 0.11456508567798769,
                    "success_improvement": 0.0,
                    "time_improvement": 39.230477739949,
                    "length_improvement": 17.78805574956528,
                    "smoothness_improvement": 1357.2594335090141,
                    "objective_score": 22.113051639442826
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive neighbor radius, informed ellipsoidal sampling after the first solution, incremental extend-and-rewire tree expansions, and path smoothing. It enforces a 30-second planning time limit, employs efficient collision checking, and maintains robust parent-child tree structure for consistent cost updates. Sampling alternates growth between start and goal trees, aiming to progressively improve the solution both in path quality and planning efficiency.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternatingly extending towards sampled points. Sampling is goal-biased initially and switches to informed ellipsoidal sampling after finding an initial feasible path to focus search and speed convergence. Each extension rewires neighbors within an adaptive radius, improving path optimality. Incremental connection attempts bridge the two trees smoothly. Upon connecting, the combined path is smoothed and returned. If the 30-second time limit hits before completion, the best available path is returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.children = []\n        self.cost = cost\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Detach from old parent if exists\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update recursively\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(a, b):\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            # Smaller resolution for finer accuracy, but capped to step_size / 5 minimum\n            resolution = max(self.step_size / 5, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_neighbor_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        # Find nodes nearby position within radius\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos)**2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        # Rotation matrix for 2D and 3D informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                \n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                \n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def informed_sample(c_best):\n            # If no best yet or invalid, sample uniformly\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if collision_free_node(sample_clamped):\n                    return sample_clamped\n\n        def extend_and_rewire(tree, sample):\n            # Find nearest \n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            # Choose best parent with lowest cost to new_pos and collision free edge\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors if new_node provides lower cost path and edges collision-free\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials=self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iter_count = 0\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            # Sampling\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    # Build combined path\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    candidate_path = path_s + path_g[::-1]\n\n                    candidate_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling = True\n\n                    # Update edges and nodes\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    # Smooth path before returning\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    candidate_path = path_s + path_g[::-1]\n\n                    candidate_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # If time limit or iteration limit reached return best found path if any\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed_path = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.02559,
          "time_improvement": 49.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1574.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017846441268920897,
                    "num_nodes_avg": 74.4,
                    "path_length_avg": 158.70535739924725,
                    "smoothness_avg": 0.03581784225382538,
                    "success_improvement": 0.0,
                    "time_improvement": 28.109771440754972,
                    "length_improvement": 13.011078762152122,
                    "smoothness_improvement": 460.62701096172844,
                    "objective_score": 13.338282239465558
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047143745422363284,
                    "num_nodes_avg": 262.2,
                    "path_length_avg": 239.6206933391445,
                    "smoothness_avg": 0.11160578593964379,
                    "success_improvement": 0.0,
                    "time_improvement": 70.46856417791994,
                    "length_improvement": 20.007715464155844,
                    "smoothness_improvement": 2771.6972586254046,
                    "objective_score": 39.00059863933418
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025639796257019044,
                    "num_nodes_avg": 168.2,
                    "path_length_avg": 120.29237919369317,
                    "smoothness_avg": 0.12500902174593667,
                    "success_improvement": 0.0,
                    "time_improvement": 47.552874540287654,
                    "length_improvement": 20.10752944709882,
                    "smoothness_improvement": 1490.1055294021537,
                    "objective_score": 25.73789589851683
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after initial solution discovery, incremental extend-and-rewire steps, and randomized path smoothing. It maintains and grows two trees from start and goal positions alternately, aggressively attempts to connect the trees, and performs recursive cost updates to optimize paths under strict collision and boundary constraints, all within a 30-second time limit.",
          "planning_mechanism": "The planner iteratively samples points using a combination of goal bias and ellipsoidal informed sampling, extends one tree toward the sample with rewiring to optimize costs, then incrementally attempts to connect the opposite tree to the newly added node. Upon connecting, it combines and smooths the path and returns early. The adaptive neighbor radius balances exploration and exploitation, and tight collision checks ensure feasibility and safety. If the time limit is reached before a solution is found, the best path so far is returned.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position                # Node coordinates (2D or 3D)\n        self.parent = None                      # Parent node reference\n        self.cost = 0.0                        # Cost from root to this node\n        self.children: List['Node'] = []       # List of child nodes\n        self.valid = True                      # Validity flag (collision)\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 6.0, goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 7.0, neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(min(max(0.0, pos[d]), bounds[d]) for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = dist_func(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            scale = self.step_size / dist\n            return tuple(from_p[d] + scale * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 6.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes: List[Node], pos: Tuple[float, ...], radius: float):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n: int):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction: Tuple[float, ...]):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0,-kz,ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.00389,
          "time_improvement": 52.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1497.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01748628616333008,
                    "num_nodes_avg": 63.1,
                    "path_length_avg": 164.93099564244054,
                    "smoothness_avg": 0.03491419773603069,
                    "success_improvement": 0.0,
                    "time_improvement": 29.560572329713853,
                    "length_improvement": 9.598707789506916,
                    "smoothness_improvement": 446.4830119627635,
                    "objective_score": 13.020328316629357
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029943013191223146,
                    "num_nodes_avg": 198.4,
                    "path_length_avg": 243.0350083420968,
                    "smoothness_avg": 0.10383662253682273,
                    "success_improvement": 0.0,
                    "time_improvement": 81.24331945936477,
                    "length_improvement": 18.867918840562048,
                    "smoothness_improvement": 2571.7910883686072,
                    "objective_score": 41.00553504776488
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026508474349975587,
                    "num_nodes_avg": 198.1,
                    "path_length_avg": 128.76541994851763,
                    "smoothness_avg": 0.12353825436023147,
                    "success_improvement": 0.0,
                    "time_improvement": 45.775962256403055,
                    "length_improvement": 14.480139220587812,
                    "smoothness_improvement": 1471.3974768167395,
                    "objective_score": 23.98580390512218
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation provides an enhanced bidirectional RRT* planner for 2D/3D environments, incorporating adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, incremental extend-and-rewire expansions, and rigorous collision and boundary checks. It maintains parent-child relationships with recursive cost updates for efficient rewiring and optimal path cost improvements. The planner benefits from early stopping upon finding better paths, path smoothing via random shortcutting, and enforces a 30-second time limit for timely response, returning the best available solution if interrupted.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with goal bias initially and focused ellipsoidal informed sampling once a solution is found. New nodes are added by steering towards samples with incremental connection attempts to the opposite tree and rewiring neighbors adaptively based on node density, which improves path cost quality. Paths from both trees are merged, smoothed, and returned early upon improvement. Planning halts if the runtime exceeds the 30-second limit, outputting the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 27.0  # Slightly tuned value for tighter neighbor radius\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos) ** 2 <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2])\n                    y_rot = (R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2])\n                    z_rot = (R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_tree_start = True\n        iter_cnt = 0\n        success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_cnt += 1\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_rate else sample_free())\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n                        # Prepare edges and nodes for return\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # On timeout or max iterations reached\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed_path = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.89994,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1323.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01829349994659424,
                    "num_nodes_avg": 78.4,
                    "path_length_avg": 158.6148076988789,
                    "smoothness_avg": 0.040650676543581246,
                    "success_improvement": 0.0,
                    "time_improvement": 26.308899769308642,
                    "length_improvement": 13.060710487775834,
                    "smoothness_improvement": 536.2713622640409,
                    "objective_score": 13.186168839667964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047746133804321286,
                    "num_nodes_avg": 281.4,
                    "path_length_avg": 236.4099202531062,
                    "smoothness_avg": 0.08959639868918132,
                    "success_improvement": 0.0,
                    "time_improvement": 70.09122050947818,
                    "length_improvement": 21.079563937254512,
                    "smoothness_improvement": 2205.37987195014,
                    "objective_score": 36.27017830004506
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01942884922027588,
                    "num_nodes_avg": 153.0,
                    "path_length_avg": 120.27417918571132,
                    "smoothness_avg": 0.10443872413434199,
                    "success_improvement": 0.0,
                    "time_improvement": 60.25759010020645,
                    "length_improvement": 20.119617025809113,
                    "smoothness_improvement": 1228.4528621240995,
                    "objective_score": 28.243464745844257
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines adaptive bidirectional RRT* with informed ellipsoidal sampling after finding a feasible path, dynamic rewiring with recursive cost propagation, robust and efficient collision checking for both nodes and edges, and aggressive path smoothing via randomized shortcutting. It enforces a strict 30-second planning limit, balances exploration and exploitation via alternating tree growth, and maintains consistent parent-child trees to ensure global cost improvements. A dynamic neighborhood radius accelerates rewiring while preventing excessive computational overhead. The planner aggressively connects and rewires the opposing tree incrementally to minimize overall path cost and search time, returning an optimized and smoothed path upon success or timeout.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. It samples points with goal bias before a solution and switches to ellipsoidal informed sampling after a first feasible path is found, focusing search in promising regions. Each iteration extends one tree towards the sample, rewires nearby nodes for path cost reduction using adaptive radius, and attempts incremental connection to the other tree with rewiring. Upon successfully connecting trees, it extracts, aggressively smooths, and updates the best path. The process terminates when the max iterations or 30 seconds are reached, yielding the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # List[Node]\n        self.valid = True                 # Validity flag for collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        # Prevent redundant updates\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        # Recursive update for children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 8000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = None) -> list:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time-out: return best solution so far\n                success_state = (len(best_path) > 0)\n                smoothed_path = path_smoothing(best_path) if success_state else []\n                all_nodes = tree_start + tree_goal\n                all_edges = []\n                for node in all_nodes:\n                    for c in node.children:\n                        all_edges.append((node, c))\n                return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n            # Sampling\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    # Combine paths from start and goal trees\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplicated connecting node in joint path\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Iterations exhausted: return best found solution\n        final_success = (len(best_path) > 0)\n        final_path = path_smoothing(best_path) if final_success else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(final_success, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.82377,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01797184944152832,
                    "num_nodes_avg": 68.3,
                    "path_length_avg": 158.34860786959325,
                    "smoothness_avg": 0.0396680227598747,
                    "success_improvement": 0.0,
                    "time_improvement": 27.604593850663367,
                    "length_improvement": 13.20661883241353,
                    "smoothness_improvement": 520.8906966821885,
                    "objective_score": 13.527155405092659
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0362393856048584,
                    "num_nodes_avg": 235.4,
                    "path_length_avg": 242.3844419263825,
                    "smoothness_avg": 0.09181065347175564,
                    "success_improvement": 0.0,
                    "time_improvement": 77.2991924881339,
                    "length_improvement": 19.0850966356435,
                    "smoothness_improvement": 2262.3542423690324,
                    "objective_score": 38.31854828541403
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02474074363708496,
                    "num_nodes_avg": 191.6,
                    "path_length_avg": 122.28679186258083,
                    "smoothness_avg": 0.11873426565839522,
                    "success_improvement": 0.0,
                    "time_improvement": 49.39191901162028,
                    "length_improvement": 18.782935516149333,
                    "smoothness_improvement": 1410.2910951229428,
                    "objective_score": 25.625618282330663
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner enhanced with adaptive neighbor radius and informed ellipsoidal sampling. It grows two trees from start and goal positions, alternately extending toward samples biased within the current best solution's informed subset once a feasible path is found. The planner dynamically rewires for path cost improvement, performs strict collision checks on nodes and edges, and applies shortcut smoothing post-processing. It respects workspace bounds and enforces a 30-second planning time limit to ensure timely termination while prioritizing path quality and success rate.",
          "planning_mechanism": "The planner initializes two trees at start and goal, then iteratively samples points\u2014initially uniformly, then inside an ellipsoidal informed region after the first solution. Each iteration extends one tree toward the sample using a step size limit, then incrementally attempts to connect to the opposite tree with rewiring of neighbors within an adaptive radius. Upon successful connection, the combined path undergoes shortcut smoothing. The planner alternates tree growth, maintains best path cost, performs continual collision validation, and stops upon timeout or satisfactory path discovery.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + self._distance(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter=15000, step_size=5.0, goal_sample_rate=0.15,\n                 neighbor_radius_min=5.0, neighbor_radius_max=30.0, smoothing_trials=150,\n                 max_planning_time=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        t_start = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iter_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1 - 0.6 * iter_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(nodes_list, pos, radius):\n            r_sq = radius * radius\n            return [node for node in nodes_list if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def unit_ball_sample(n):\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in sample)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in sample)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        rotation_mat = None\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n\n        grow_start = True\n        iteration = 0\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_uniform()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(rotation_mat[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(rotation_mat[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_node.position))\n            current_node = nearest\n\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, new_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist(new_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                current_node = new_node\n\n        def shortcut_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                r = random.random()\n                if r < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_uniform()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(other_tree, new_node, iteration)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n                    smoothed = shortcut_smoothing(best_path, self.smoothing_trials)\n                    final_nodes = tree_start + tree_goal\n                    final_edges = []\n                    for n in final_nodes:\n                        for c in n.children:\n                            final_edges.append((n, c))\n                    return PlannerResult(True, smoothed, final_nodes, final_edges)\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed = shortcut_smoothing(best_path, self.smoothing_trials) if success else []\n        final_nodes = tree_start + tree_goal\n        final_edges = []\n        for n in final_nodes:\n            for c in n.children:\n                final_edges.append((n, c))\n\n        return PlannerResult(success, smoothed, final_nodes, final_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.6651,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1512.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016969871520996094,
                    "num_nodes_avg": 65.3,
                    "path_length_avg": 161.41874983501975,
                    "smoothness_avg": 0.047429776767605916,
                    "success_improvement": 0.0,
                    "time_improvement": 31.64082833758156,
                    "length_improvement": 11.523825371650599,
                    "smoothness_improvement": 642.379001821782,
                    "objective_score": 15.008908584713499
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036951541900634766,
                    "num_nodes_avg": 235.8,
                    "path_length_avg": 234.985096812773,
                    "smoothness_avg": 0.09989346562056736,
                    "success_improvement": 0.0,
                    "time_improvement": 76.85308881614958,
                    "length_improvement": 21.555211012906533,
                    "smoothness_improvement": 2470.3308207722293,
                    "objective_score": 39.71862295128733
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029794740676879882,
                    "num_nodes_avg": 200.4,
                    "path_length_avg": 124.65872522004568,
                    "smoothness_avg": 0.11965647536923658,
                    "success_improvement": 0.0,
                    "time_improvement": 39.05378628380755,
                    "length_improvement": 17.207610319450254,
                    "smoothness_improvement": 1422.021534574405,
                    "objective_score": 22.26776562190434
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius and dynamic informed sampling. It grows two trees from start and goal, alternately extending and rewiring nodes with rigorous collision and boundary checks. Upon connection, the best path is shortcut-smoothed. The planner enforces a maximum 30-second runtime, aiming to optimize path length, smoothness, success rate, and planning efficiency.",
          "planning_mechanism": "The planner samples points biased toward the goal and the informed ellipsoidal subset after the first solution. It extends each tree toward samples within step-size constraints, rewires nearby nodes to reduce cost, and incrementally connects the two trees. On successful connection, it shortcut-smooths the combined path and returns the best found path or terminates on timeout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                 # Child nodes for rewiring consistency\n        self.valid = True                  # For collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 15000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        t_start = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iter_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1 - 0.6 * iter_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(nodes_list, pos, radius):\n            r_sq = radius * radius\n            return [node for node in nodes_list if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # fallback to goal if no free sample found\n            return goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in sample)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in sample)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        rotation_mat = None\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n\n        grow_start = True\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            while True:\n                direction_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(rotation_mat[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(rotation_mat[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_node, iter_num):\n            if not tree or target_node is None:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_node.position))\n            current_node = nearest\n\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, new_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist(new_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                current_node = new_node\n\n        def shortcut_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = uniform_sample()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(other_tree, new_node, iteration)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n                    smoothed = shortcut_smoothing(best_path, self.smoothing_trials)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for n in nodes_all:\n                        for c in n.children:\n                            edges_all.append((n, c))\n                    return PlannerResult(True, smoothed, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed_path = shortcut_smoothing(best_path, self.smoothing_trials) if success else []\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for n in nodes_all:\n            for c in n.children:\n                edges_all.append((n, c))\n\n        return PlannerResult(success, smoothed_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.59898,
          "time_improvement": 48.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1541.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01954798698425293,
                    "num_nodes_avg": 69.2,
                    "path_length_avg": 159.75865481547206,
                    "smoothness_avg": 0.04195271787629153,
                    "success_improvement": 0.0,
                    "time_improvement": 21.25549116515466,
                    "length_improvement": 12.433749757753668,
                    "smoothness_improvement": 556.6511365489654,
                    "objective_score": 11.646652983841957
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03495471477508545,
                    "num_nodes_avg": 231.2,
                    "path_length_avg": 234.83028129200972,
                    "smoothness_avg": 0.1047085988111904,
                    "success_improvement": 0.0,
                    "time_improvement": 78.1039264739903,
                    "length_improvement": 21.606892889855008,
                    "smoothness_improvement": 2594.2276659672116,
                    "objective_score": 40.72369485000415
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026873135566711427,
                    "num_nodes_avg": 190.1,
                    "path_length_avg": 123.8342539451642,
                    "smoothness_avg": 0.12368869603234804,
                    "success_improvement": 0.0,
                    "time_improvement": 45.03003462138137,
                    "length_improvement": 17.755184883123317,
                    "smoothness_improvement": 1473.311083781613,
                    "objective_score": 24.42660278194714
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive informed sampling within ellipsoidal subsets, dynamic neighbor radius scaling based on node count and iteration progress, recursive parent-child cost updates, and incremental extend-and-rewire connections between start and goal trees. It enforces strict collision checks for nodes and edges, clamps samples within workspace bounds, and applies randomized shortcut smoothing to improve path smoothness and length. The planner stops either upon reaching a time limit of 30 seconds or a maximum number of iterations, returning the best feasible path found.",
          "planning_mechanism": "The planner alternately grows two trees starting from the start and goal positions, sampling points uniformly at first with goal bias, then focusing sampling within an informed ellipsoid after a solution is found. Each iteration attempts to extend one tree toward a sampled point with rewiring in a dynamically scaled neighborhood radius to optimize costs. It then incrementally connects to the opposite tree via extend-and-rewire operations. Upon successful tree connection, the combined path is extracted and smoothed. The process repeats until time or iteration limits are met, ensuring efficient exploration and convergent refinement of the solution path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child Nodes\n        self.valid = True               # For collision validity\n        \n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        # Recursively update costs for children\n        for c in self.children:\n            c.update_parent(self, self.cost + dist_func(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 7000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            new_pt = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            return clamp_to_bounds(new_pt)\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos)**2) <= r2]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0,-kz,ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_via_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_via_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, trials=self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    # Early return on improved solution\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = []\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    # Early return on improved solution\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success_state else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.59807,
          "time_improvement": 51.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1441.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020059823989868164,
                    "num_nodes_avg": 73.1,
                    "path_length_avg": 164.65006469457555,
                    "smoothness_avg": 0.0449811002038792,
                    "success_improvement": 0.0,
                    "time_improvement": 19.19367509973896,
                    "length_improvement": 9.752690493667458,
                    "smoothness_improvement": 604.0518962131931,
                    "objective_score": 10.728900109721145
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04088568687438965,
                    "num_nodes_avg": 252.4,
                    "path_length_avg": 233.0956407068858,
                    "smoothness_avg": 0.08779193472253664,
                    "success_improvement": 0.0,
                    "time_improvement": 74.3886908612071,
                    "length_improvement": 22.185965846030236,
                    "smoothness_improvement": 2158.949714385512,
                    "objective_score": 37.548548999495736
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019113612174987794,
                    "num_nodes_avg": 151.5,
                    "path_length_avg": 132.1141082802596,
                    "smoothness_avg": 0.13042252829181314,
                    "success_improvement": 0.0,
                    "time_improvement": 60.90241881483585,
                    "length_improvement": 12.25609987804761,
                    "smoothness_improvement": 1558.9649330822144,
                    "objective_score": 28.516770285471345
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after the first feasible solution, incremental and rewiring tree expansions avoiding collisions, and progressive tree connection attempts. It enforces map bounds and applies multi-pass random shortcut path smoothing. A strict 30-second timeout guarantees prompt termination, returning the best path found.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points combining goal bias and informed ellipsoidal distribution after the first solution, and selects parents for new nodes based on minimal cumulative cost within an adaptive radius. Neighboring nodes are rewired if a better cost path is found through new nodes. The two trees are incrementally connected attempting rewiring and cost improvement. Upon connection, combined paths are smoothed and returned early, or the best path is returned when time expires.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...], 2D or 3D coordinate\n        self.parent = None                # Parent Node or None\n        self.cost = 0.0                  # Cost from root to this node\n        self.children = []               # List of child Nodes\n        self.valid = True                # Validity for collision checking or pruning\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Remove from old parent child list\n        if self.parent:\n            self.parent.remove_child(self)\n        # Assign new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update recursively to children\n        dist_fn = self._distance\n        for ch in self.children:\n            ch.update_parent(self, self.cost + dist_fn(self.position, ch.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n        dist_fn = math.dist\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_fn(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist_fn(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def sample_unit_ball(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = sample_unit_ball\n\n        c_min = dist_fn(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                direction_sample = self._unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * ds for ds in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            # Find nearest node in tree\n            nearest_node = min(tree, key=lambda n: dist_fn(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Choose best parent among neighbors\n            min_cost = nearest_node.cost + dist_fn(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist_fn(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            # Create new node with best parent\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors to new node if better cost found\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_fn(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_fn(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_fn(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist_fn(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr == new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_fn(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                # Check if close enough to target\n                if dist_fn(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees from start and goal\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start_tree = True\n        iter_count = 0\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        while iter_count < self.max_iter:\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Timeout: return best found path so far\n                break\n            iter_count += 1\n\n            if informed_sampling:\n                sample_point = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_point = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_point = sample_uniform_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_point)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect_and_rewire(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_fn(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges list\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_point)\n                if not new_node:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect_and_rewire(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_fn(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # If here, no early solution found; return best found or failure\n        success = (len(best_path) > 0)\n        if success:\n            best_path = path_smoothing(best_path)\n        else:\n            best_path = []\n\n        # Update edges\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, best_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.59545,
          "time_improvement": 49.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1457.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01672821044921875,
                    "num_nodes_avg": 68.2,
                    "path_length_avg": 155.13783779684508,
                    "smoothness_avg": 0.037026322629656404,
                    "success_improvement": 0.0,
                    "time_improvement": 32.614303632860754,
                    "length_improvement": 14.966492787194435,
                    "smoothness_improvement": 479.5423531006228,
                    "objective_score": 15.175301412800227
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043354034423828125,
                    "num_nodes_avg": 260.3,
                    "path_length_avg": 238.7286924134167,
                    "smoothness_avg": 0.10415372065139916,
                    "success_improvement": 0.0,
                    "time_improvement": 72.84248687190224,
                    "length_improvement": 20.305491047986855,
                    "smoothness_improvement": 2579.950251253199,
                    "objective_score": 38.81359552743404
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028838229179382325,
                    "num_nodes_avg": 192.2,
                    "path_length_avg": 120.901021123547,
                    "smoothness_avg": 0.11090775284393976,
                    "success_improvement": 0.0,
                    "time_improvement": 41.010364955885656,
                    "length_improvement": 19.70329845770413,
                    "smoothness_improvement": 1310.738429816153,
                    "objective_score": 22.79746132738729
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* with adaptive neighbor radius bounded between minimum and maximum limits, probabilistic goal biasing, rigorous collision checking, and incremental connection attempts between start and goal trees. It incorporates ellipsoidal informed sampling once an initial solution is found to focus exploration, and performs randomized shortcut-based path smoothing to improve path quality. The planner enforces strict boundary clamping and runs with a 30-second time limit, always returning the best feasible and smoothed path discovered.",
          "planning_mechanism": "The planning mechanism alternates expanding two trees rooted at start and goal positions. Samples are drawn from uniform or ellipsoidal informed distributions depending on solution status, with a configurable goal sample rate. New nodes are added via steering with a fixed step size within bounds, and rewiring is performed adaptively within a calculated neighbor radius to minimize path cost. Incremental connection attempts link the trees, and once connected, the combined path undergoes shortcut smoothing. The algorithm halts on timeout or max iterations, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = 0.0                 # cost from root to this node\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 12000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 smoothing_trials: int = 120,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 35.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                trials += 1\n                if trials > 1000:\n                    # fallback to start or goal to avoid infinite loop\n                    return start_pos if random.random() < 0.5 else goal_pos\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start = True\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample = informed_sample(best_cost) if informed_sampling_active else (\n                goal_pos if (random.random() < self.goal_sample_rate) else uniform_sample()\n            )\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connecting_node = incremental_connect(tree_goal, new_node.position)\n                if connecting_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connecting_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connecting_node.cost + dist_func(new_node.position, connecting_node.position)\n\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling_active = True\n                        best_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connecting_node = incremental_connect(tree_start, new_node.position)\n                if connecting_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connecting_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    candidate_path = path_start + path_goal[::-1]\n                    candidate_cost = new_node.cost + connecting_node.cost + dist_func(new_node.position, connecting_node.position)\n\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        informed_sampling_active = True\n                        best_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = len(best_path) > 0\n        if success:\n            best_path = path_smoothing(best_path, self.smoothing_trials)\n        nodes_all = tree_start + tree_goal\n        edges_all = [(node, child) for node in nodes_all for child in node.children]\n        return PlannerResult(success, best_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.50779,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1380.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022328805923461915,
                    "num_nodes_avg": 100.5,
                    "path_length_avg": 159.9156314731188,
                    "smoothness_avg": 0.0429129489007324,
                    "success_improvement": 0.0,
                    "time_improvement": 10.05361029102455,
                    "length_improvement": 12.347708364243172,
                    "smoothness_improvement": 571.6808372565089,
                    "objective_score": 8.344028946438543
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04329237937927246,
                    "num_nodes_avg": 296.1,
                    "path_length_avg": 235.01168538812522,
                    "smoothness_avg": 0.09220471454819526,
                    "success_improvement": 0.0,
                    "time_improvement": 72.88110836824477,
                    "length_improvement": 21.54633498114426,
                    "smoothness_improvement": 2272.4937176965445,
                    "objective_score": 37.536068095185
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01577012538909912,
                    "num_nodes_avg": 144.0,
                    "path_length_avg": 121.683358428689,
                    "smoothness_avg": 0.10981260942596396,
                    "success_improvement": 0.0,
                    "time_improvement": 67.74164129439781,
                    "length_improvement": 19.183707270527982,
                    "smoothness_improvement": 1296.8082863745797,
                    "objective_score": 30.64327527429784
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* path planner with adaptive neighbor radius and ellipsoidal informed sampling after an initial solution. It maintains parent-child node relationships with cost propagation and performs incremental tree connections with rewiring for path cost optimization. Randomized shortcut path smoothing refines the solution. Planning is limited to 30 seconds for timely termination, returning the best feasible and smoothed path discovered.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, performing extensions toward sampled points generated uniformly or informed within an ellipsoid after the first solution. Rewiring optimizes node connections within adaptive radius neighborhoods. Trees are incrementally connected with collision-checked extensions. Upon successful connection, the path is extracted and smoothed via randomized shortcuts. Early termination occurs if time limit is exceeded or improved path is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Parent Node or None\n        self.cost = 0.0                    # Cost from root\n        self.children = []                 # List of children Nodes\n        self.valid = True                  # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.neighbor_radius_min = 5.0\n        self.neighbor_radius_max = 30.0\n        self.max_planning_time = 30.0\n        self.smoothing_trials = 100\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            scale = self.step_size / dist\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.2)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 2.5 * (1 + 1/dim) ** (1/dim)\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-14:\n                    return [[1,0,0], [0,1,0], [0,0,1]]\n                vx /= norm_v; vy /= norm_v; vz /= norm_v\n\n                if abs(vx) < 0.9:\n                    arb = (1.0, 0.0, 0.0)\n                else:\n                    arb = (0.0, 1.0, 0.0)\n\n                wx = vy*arb[2] - vz*arb[1]\n                wy = vz*arb[0] - vx*arb[2]\n                wz = vx*arb[1] - vy*arb[0]\n\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-14:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w; wy /= norm_w; wz /= norm_w\n\n                vx2 = wy*vz - wz*vy\n                vy2 = wz*vx - wx*vz\n                vz2 = wx*vy - wy*vx\n\n                return [[vx, vx2, wx], [vy, vy2, wy], [vz, vz2, wz]]\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best/2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best/2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n            return uniform_sample()\n\n        def rewire(tree: list, new_node: Node, neighbors: list):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative = nbr.cost + dist_func(nbr.position, new_pos)\n                    if tentative + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                rewire(tree, new_node, neighbors)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size and collision_free_edge(new_node.position, target_pos):\n                    return new_node\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(trials):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if collision_free_edge(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if (random.random() < self.goal_sample_rate and grow_start) else \n                start_pos if (random.random() < self.goal_sample_rate and not grow_start) else \n                uniform_sample())\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connected_node = incremental_connect(other_tree, new_node.position)\n            if connected_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = 0.0\n                for k in range(len(combined_path)-1):\n                    total_cost += dist_func(combined_path[k], combined_path[k+1])\n\n                if total_cost + 1e-14 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges = [(n, c) for n in all_nodes for c in n.children]\n\n                    return PlannerResult(\n                        success=True,\n                        path=smoothed,\n                        nodes=all_nodes,\n                        edges=all_edges\n                    )\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        smoothed_path = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = [(n, c) for n in all_nodes for c in n.children]\n\n        return PlannerResult(\n            success=success_state,\n            path=smoothed_path,\n            nodes=all_nodes,\n            edges=all_edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.50001,
          "time_improvement": 53.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1349.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016199231147766113,
                    "num_nodes_avg": 84.9,
                    "path_length_avg": 168.8155595327148,
                    "smoothness_avg": 0.04077363283822421,
                    "success_improvement": 0.0,
                    "time_improvement": 34.745173441104555,
                    "length_improvement": 7.4695167663936815,
                    "smoothness_improvement": 538.1958952790707,
                    "objective_score": 14.608434862005458
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035755705833435056,
                    "num_nodes_avg": 241.4,
                    "path_length_avg": 238.5976686367094,
                    "smoothness_avg": 0.08795258644442612,
                    "success_improvement": 0.0,
                    "time_improvement": 77.60217558801827,
                    "length_improvement": 20.349230555962063,
                    "smoothness_improvement": 2163.0833989024864,
                    "objective_score": 38.165915782110325
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026459407806396485,
                    "num_nodes_avg": 207.1,
                    "path_length_avg": 126.23246849337495,
                    "smoothness_avg": 0.11368445917151085,
                    "success_improvement": 0.0,
                    "time_improvement": 45.8763296361268,
                    "length_improvement": 16.162404970906636,
                    "smoothness_improvement": 1346.0579293477163,
                    "objective_score": 23.72566953175795
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, goal biasing, ellipsoidal informed sampling after first solution, incremental connect and rewiring for efficient tree merging, rigorous collision checks on nodes and edges, and randomized shortcut path smoothing. It enforces a 30-second time limit and returns the best feasible path with improved path quality, smoothness, and planning speed.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately. Sampling switches from uniform with goal bias to informed ellipsoidal sampling after the first solution to focus exploration. Each node extension rewires neighbors adaptively, maintaining parent-child cost consistency. Incremental connections attempt to join both trees efficiently. Once connected, the combined path is smoothed and the planner terminates early if time or iterations exceed limits, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Path cost from root\n        self.children = []\n        self.valid = True                   # For collision checking etc.\n\n        if parent:\n            parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 9000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float =30.0, smoothing_trials: int = 150,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 35.0\n            base = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            factor = min(1.0, iteration / self.max_iter)\n            radius = base * (1 - 0.5 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius*radius\n            return [n for n in tree_nodes if (dist(n.position, pos)**2) <= r_sq]\n\n        def uniform_sample():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return uniform_sample()\n\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0/dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(dim))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(dim))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(dim))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return sample_pt\n            return uniform_sample()\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cand_cost = nbr.cost + dist(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            curr = nearest\n            while True:\n                new_pos = steer(curr.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cand_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                dist_to_target = dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def random_path_smoothing(path, trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iter_num in range(1, self.max_iter+1):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling_active:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iter_num)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined, self.smoothing_trials)\n                        informed_sampling_active = True\n                        # immediately return best found path\n                        all_nodes = tree_start + tree_goal\n                        edges = [(n, c) for n in all_nodes for c in n.children]\n                        return PlannerResult(True, best_path, all_nodes, edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iter_num)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = random_path_smoothing(combined, self.smoothing_trials)\n                        informed_sampling_active = True\n                        all_nodes = tree_start + tree_goal\n                        edges = [(n, c) for n in all_nodes for c in n.children]\n                        return PlannerResult(True, best_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        success = len(best_path) > 0\n        smoothed = random_path_smoothing(best_path, self.smoothing_trials) if success else []\n        all_nodes = tree_start + tree_goal\n        edges = [(n, c) for n in all_nodes for c in n.children]\n        return PlannerResult(success, smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist_len = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_len / resolution))\n        for i in range(steps+1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.49648,
          "time_improvement": 47.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1583.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02085111141204834,
                    "num_nodes_avg": 69.5,
                    "path_length_avg": 158.6530547710763,
                    "smoothness_avg": 0.04261658457714363,
                    "success_improvement": 0.0,
                    "time_improvement": 16.006158172448046,
                    "length_improvement": 13.039746661440793,
                    "smoothness_improvement": 567.0420920269154,
                    "objective_score": 10.24500724415715
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.037842631340026855,
                    "num_nodes_avg": 242.2,
                    "path_length_avg": 239.04107805103726,
                    "smoothness_avg": 0.11767119468290191,
                    "success_improvement": 0.0,
                    "time_improvement": 76.2948991696677,
                    "length_improvement": 20.201207730627083,
                    "smoothness_improvement": 2927.764594326768,
                    "objective_score": 41.56753426865957
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024922800064086915,
                    "num_nodes_avg": 189.6,
                    "path_length_avg": 122.72603953129553,
                    "smoothness_avg": 0.10649129557501387,
                    "success_improvement": 0.0,
                    "time_improvement": 49.01951604195533,
                    "length_improvement": 18.491208129315343,
                    "smoothness_improvement": 1254.5614193443816,
                    "objective_score": 24.676903535171576
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional Anytime Informed RRT* planner with an adaptive neighbor radius, ellipsoidal informed sampling to focus search space, incremental and robust rewiring for improved path cost, and aggressive path smoothing. It rigorously checks collisions on nodes and edges, maintains consistent parent-child relationships, prunes unnecessary nodes outside the best path, and enforces a strict 30-second timeout to deliver efficient, high-quality, and smooth paths.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling either uniformly or from an informed ellipsoid if a better path is found. Nodes are added via steering and rewired incrementally within an adaptive neighbor radius. Upon connecting trees, paths are combined, smoothed, and nodes outside the best path are marked invalid. The process continues until time or iteration limits are reached, returning the best optimized path found.",
          "code": "class Node:\n    def __init__(self, position: tuple, parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                  # List of child nodes\n        self.valid = True                   # Validity flag for pruning\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, self.position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = 30.0\n        self.goal_sample_rate = 0.2\n        self.neighbor_radius_min = 10.0\n        self.neighbor_radius_max = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos: tuple) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos: tuple, to_pos: tuple) -> tuple:\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def coll_free_node(pos: tuple) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def coll_free_edge(p1: tuple, p2: tuple) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes: list, pos: tuple, radius: float) -> list:\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq and node.valid]\n\n        def sample_uniform() -> tuple:\n            for _ in range(1000):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if coll_free_node(pt):\n                    return pt\n            # fallback rare\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def unit_ball_sample(n: int) -> tuple:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction: tuple) -> list:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-14:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_t = vx\n                sin_t = math.sqrt(max(0, 1 - cos_t * cos_t))\n                K = [\n                    [0, -kz, ky],\n                    [kz, 0, -kx],\n                    [-ky, kx, 0]\n                ]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_t)), mat_scale(K2, 1 - cos_t))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best: float) -> tuple:\n            if c_best == math.inf or c_best < c_min - 1e-14:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            for _ in range(1000):\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if coll_free_node(sample_pt):\n                    return sample_pt\n            return sample_uniform()\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda node: dist_func(node.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if not coll_free_node(new_pos) or not coll_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_via_nbr < min_cost and coll_free_edge(nbr.position, new_pos):\n                    min_cost = cost_via_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and coll_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda node: dist_func(node.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n\n                if not coll_free_node(new_pos) or not coll_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_via_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_via_nbr < min_cost and coll_free_edge(nbr.position, new_pos):\n                        min_cost = cost_via_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and coll_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if coll_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, max_trials: int = 200) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if coll_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nodes(tree: list, best_path: list) -> None:\n            best_positions = set(best_path)\n            for node in tree:\n                node.valid = (node.position in best_positions)\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        prune_nodes(tree_start, best_path)\n                        prune_nodes(tree_goal, best_path)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            if not node.valid:\n                                continue\n                            for c in node.children:\n                                if c.valid:\n                                    all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        prune_nodes(tree_start, best_path)\n                        prune_nodes(tree_goal, best_path)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            if not node.valid:\n                                continue\n                            for c in node.children:\n                                if c.valid:\n                                    all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            if not node.valid:\n                continue\n            for c in node.children:\n                if c.valid:\n                    all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.44546,
          "time_improvement": 47.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1569.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02320263385772705,
                    "num_nodes_avg": 66.1,
                    "path_length_avg": 158.51807827383044,
                    "smoothness_avg": 0.04307525181168788,
                    "success_improvement": 0.0,
                    "time_improvement": 6.533598151395778,
                    "length_improvement": 13.113729418420725,
                    "smoothness_improvement": 574.2212302593745,
                    "objective_score": 7.453931480399751
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035085511207580564,
                    "num_nodes_avg": 202.2,
                    "path_length_avg": 235.14183422007372,
                    "smoothness_avg": 0.10774207842727786,
                    "success_improvement": 0.0,
                    "time_improvement": 78.0219939415328,
                    "length_improvement": 21.50288755491343,
                    "smoothness_improvement": 2672.281281416194,
                    "objective_score": 41.06858210052349
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021143531799316405,
                    "num_nodes_avg": 157.3,
                    "path_length_avg": 124.36748005888012,
                    "smoothness_avg": 0.12277772128724951,
                    "success_improvement": 0.0,
                    "time_improvement": 56.75014521082271,
                    "length_improvement": 17.401041487892176,
                    "smoothness_improvement": 1461.7235522651208,
                    "objective_score": 27.81386962215085
               }
          ],
          "success_rate": 1.0
     }
]