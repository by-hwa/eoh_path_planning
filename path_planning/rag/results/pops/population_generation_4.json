[
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive informed sampling after finding an initial path solution. It incrementally grows two trees from the start and goal positions, rewiring locally to optimize path costs, dynamically adjusting neighborhood radii. The planner incorporates robust collision checking for nodes and edges, enforces a strict 30-second runtime limit, and smooths the final path to improve quality and feasibility.",
          "planning_mechanism": "The planner alternates growth between the start and goal trees, sampling configurations biased towards the goal or within an informed ellipsoidal subset after the first solution. Each extension involves steering towards samples, rewiring neighbors to minimize costs, and incrementally attempting to connect the two trees. Upon successful connection, the combined path is smoothed and returned. The process terminates upon time expiration or max iterations, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            new_pt = tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(min(max(new_pt[d], 0.0), bounds[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        success_state = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        success_state = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = len(best_path) > 0\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.50914,
          "time_improvement": 56.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1622.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016451644897460937,
                    "num_nodes_avg": 69.2,
                    "path_length_avg": 150.5392184768476,
                    "smoothness_avg": 0.04309586299929125,
                    "success_improvement": 0.0,
                    "time_improvement": 33.72838348933654,
                    "length_improvement": 17.487068906271332,
                    "smoothness_improvement": 574.5438401032775,
                    "objective_score": 16.488648028571614
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029997587203979492,
                    "num_nodes_avg": 204.9,
                    "path_length_avg": 237.67032959361413,
                    "smoothness_avg": 0.11983256957008481,
                    "success_improvement": 0.0,
                    "time_improvement": 81.209133610514,
                    "length_improvement": 20.658803020521642,
                    "smoothness_improvement": 2983.37832694939,
                    "objective_score": 43.41139232200548
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02251169681549072,
                    "num_nodes_avg": 181.7,
                    "path_length_avg": 128.67739794773527,
                    "smoothness_avg": 0.11060146419662706,
                    "success_improvement": 0.0,
                    "time_improvement": 53.951514459876705,
                    "length_improvement": 14.538599242350195,
                    "smoothness_improvement": 1306.842460830212,
                    "objective_score": 25.627386490584115
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a time-limited bidirectional RRT* planner with adaptive neighbor radius, goal-biased plus ellipsoidal informed sampling after an initial path is found, incremental extend-and-rewire steps with robust collision checking, and path smoothing. It maintains consistent parent-child relationships with recursive cost propagation for efficient rewiring and uses early termination upon timeout or improved solution to ensure fast convergence, improved path quality, and high success rates.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately. Sampling is biased towards the goal and switches to ellipsoidal informed sampling after a feasible path is found. Each new node is connected to the best parent within an adaptive neighborhood radius, neighbors are rewired to minimize costs, and incremental connections attempt to link the two trees progressively. Robust collision checks prevent invalid expansions. The process is time-limited to 30 seconds, and the best solution found is smoothed before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.2, \n                 neighbor_radius_min: float = 8.0, neighbor_radius_max: float = 30.0, max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best):\n            c_min = dist_func(start_pos, goal_pos)\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for child in node.children:\n                                all_edges.append((node, child))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for child in node.children:\n                                all_edges.append((node, child))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for child in node.children:\n                all_edges.append((node, child))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.68729,
          "time_improvement": 52.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1549.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02027289867401123,
                    "num_nodes_avg": 86.6,
                    "path_length_avg": 158.36715628450975,
                    "smoothness_avg": 0.041536845017126366,
                    "success_improvement": 0.0,
                    "time_improvement": 18.335353403417926,
                    "length_improvement": 13.19645215227936,
                    "smoothness_improvement": 550.1418232206626,
                    "objective_score": 10.890605567584561
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03168988227844238,
                    "num_nodes_avg": 230.2,
                    "path_length_avg": 243.08345474180896,
                    "smoothness_avg": 0.10659969060215416,
                    "success_improvement": 0.0,
                    "time_improvement": 80.14905866449972,
                    "length_improvement": 18.85174603788583,
                    "smoothness_improvement": 2642.88681984707,
                    "objective_score": 41.02950090616243
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02078251838684082,
                    "num_nodes_avg": 182.7,
                    "path_length_avg": 123.25061227958604,
                    "smoothness_avg": 0.12211748536728033,
                    "success_improvement": 0.0,
                    "time_improvement": 57.48861113102528,
                    "length_improvement": 18.142811887370772,
                    "smoothness_improvement": 1453.325400096659,
                    "objective_score": 28.141772717265034
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner enhanced with adaptive informed sampling within an ellipsoidal subset, adaptive neighbor radius for efficient rewiring, incremental tree connection, and dedicated path smoothing. It maintains robust collision checking and enforces a strict 30-second planning timeout to ensure timely and high-quality solutions.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending them towards samples drawn from a uniform distribution initially and later from an informed ellipsoidal region around the best solution. Each extension attempts incremental rewiring of nearby nodes to minimize path costs. Upon successful connection of trees, the combined path is extracted and smoothed. The process concludes either when a time or iteration limit is reached, delivering the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...], 2D or 3D\n        self.parent = None                  # Parent Node or None\n        self.cost = cost                    # Cost from root to this node\n        self.children = []                  # List of child nodes\n        self.valid = True                   # For obstacle validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0, max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    normed = tuple(x / math.sqrt(norm_sq) for x in pt)\n                    return normed\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.68288,
          "time_improvement": 54.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1405.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01598813533782959,
                    "num_nodes_avg": 70.3,
                    "path_length_avg": 160.07310344541804,
                    "smoothness_avg": 0.04324016794566805,
                    "success_improvement": 0.0,
                    "time_improvement": 35.595523703969775,
                    "length_improvement": 12.26139548092287,
                    "smoothness_improvement": 576.8025258772809,
                    "objective_score": 16.01494883676191
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040297436714172366,
                    "num_nodes_avg": 257.0,
                    "path_length_avg": 231.7466873890371,
                    "smoothness_avg": 0.08312651221825451,
                    "success_improvement": 0.0,
                    "time_improvement": 74.75717816950535,
                    "length_improvement": 22.636285290996536,
                    "smoothness_improvement": 2038.9050329823299,
                    "objective_score": 37.14893567396256
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022991228103637695,
                    "num_nodes_avg": 180.8,
                    "path_length_avg": 127.98573904981842,
                    "smoothness_avg": 0.13355395998673397,
                    "success_improvement": 0.0,
                    "time_improvement": 52.97061596211985,
                    "length_improvement": 14.997966149089132,
                    "smoothness_improvement": 1598.796513103363,
                    "objective_score": 26.884760583970596
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive informed sampling, dynamic neighbor radius scaling, incremental extend-and-rewire, and rigorous collision checks. It alternates growth between two trees seeded at start and goal, focusing sampling within an ellipsoidal region once a feasible path is found. The planner maintains consistent parent-child relationships with recursive cost updates and applies randomized path smoothing to improve solution quality, all within a strict 30-second planning time limit.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points using goal bias, uniform, or informed ellipsoidal distributions based on the current best cost. It extends and rewires nodes using an adaptive radius based on node density and iteration progress. Incremental connect attempts bridge the two trees iteratively, and upon finding a path, the planner applies randomized shortcut smoothing. The process halts early if time runs out or a satisfactory path is found, returning the best solution discovered.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Node coordinate tuple, 2D or 3D\n        self.parent = None                    # Parent Node or None\n        self.cost = cost                      # Cost from root\n        self.children: List[Node] = []       # Children nodes list\n        self.valid = True                     # Collision validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from current parent if any\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update descendants' costs and parents\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, \n                 max_iter: int = 15000, \n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)  # Reduce radius over time\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            rad_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= rad_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                point = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in point)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in point)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0],\n                            [0, 1, 0],\n                            [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = clamp(sample_pt)\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors toward new_node if cheaper\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_shortcut(path: List[Tuple[float, ...]], trials: int = self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n        c_min = dist(start_pos, goal_pos)\n\n        grow_start = True\n        iteration = 0\n        t_start = time.perf_counter()\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_uniform()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample, iteration)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(other_tree, new_node.position, iteration)\n            if connected_node is not None:\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n\n                # Avoid duplicated middle node\n                if path_from_goal and path_from_goal[0] == new_node.position:\n                    path_from_goal = path_from_goal[1:]\n                combined_path = path_from_start + path_from_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    smoothed = path_shortcut(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, [(n, c) for n in all_nodes for c in n.children])\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed = path_shortcut(best_path) if success else []\n\n        edges = [(n, c) for n in all_nodes for c in n.children]\n\n        return PlannerResult(success, smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.66086,
          "time_improvement": 56.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1382.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019427227973937988,
                    "num_nodes_avg": 53.3,
                    "path_length_avg": 167.32838520346422,
                    "smoothness_avg": 0.036634018904249666,
                    "success_improvement": 0.0,
                    "time_improvement": 21.74194068869344,
                    "length_improvement": 8.284660582041207,
                    "smoothness_improvement": 473.40194789683244,
                    "objective_score": 10.546524062500437
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03835971355438232,
                    "num_nodes_avg": 218.6,
                    "path_length_avg": 244.07150961036504,
                    "smoothness_avg": 0.10085907257140406,
                    "success_improvement": 0.0,
                    "time_improvement": 75.97099235888778,
                    "length_improvement": 18.521904883179296,
                    "smoothness_improvement": 2495.176583115832,
                    "objective_score": 38.971561599881355
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01450345516204834,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 124.36167150818252,
                    "smoothness_avg": 0.10037330833942,
                    "success_improvement": 0.0,
                    "time_improvement": 70.33266080361206,
                    "length_improvement": 17.404899250692054,
                    "smoothness_improvement": 1176.7410732904711,
                    "objective_score": 30.464483457674383
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid path planner integrates bidirectional RRT* with adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, recursive parent-child cost updates, incremental extend-and-rewire connection attempts, and randomized path smoothing. It enforces collision and edge-validity checks, clamps samples within workspace bounds, alternates tree growth between start and goal, and terminates early on success or exceeding a strict 30-second limit, returning the best found path.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, initially sampling uniformly with goal bias, then switches to ellipsoidal informed sampling after the first solution. Each iteration extends one tree using adaptive radius rewiring and attempts incremental connection to the opposite tree. Upon connection, the path is extracted and smoothed by shortcutting random segments respecting collision constraints. The algorithm tracks the best solution and respects the maximum planning time, terminating early if the time limit is reached or an improved solution is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []              # List[Node]\n        self.valid = True               # Collision validity flag\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for c in self.children:\n            c.update_parent(self, self.cost + dist_func(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                new_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if new_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = new_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    new_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if new_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = new_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                # Check time limit mid-connect\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        # Prepare nodes and edges for return\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.34917,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1411.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015734434127807617,
                    "num_nodes_avg": 63.5,
                    "path_length_avg": 158.05171398045536,
                    "smoothness_avg": 0.0379325535853074,
                    "success_improvement": 0.0,
                    "time_improvement": 36.61749988955243,
                    "length_improvement": 13.369351077634741,
                    "smoothness_improvement": 493.7268354685786,
                    "objective_score": 16.12775435973557
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03369519710540771,
                    "num_nodes_avg": 218.6,
                    "path_length_avg": 236.11343562232028,
                    "smoothness_avg": 0.10381260037547893,
                    "success_improvement": 0.0,
                    "time_improvement": 78.89290420360489,
                    "length_improvement": 21.17853904084778,
                    "smoothness_improvement": 2571.172980854768,
                    "objective_score": 40.75944397352487
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02763652801513672,
                    "num_nodes_avg": 165.5,
                    "path_length_avg": 125.8846182366874,
                    "smoothness_avg": 0.09970293140216517,
                    "success_improvement": 0.0,
                    "time_improvement": 43.46848791031507,
                    "length_improvement": 16.393430548549265,
                    "smoothness_improvement": 1168.2139281306681,
                    "objective_score": 22.160302123457715
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT* variant enhanced with adaptive neighbor radius, ellipsoidal informed sampling after the first solution, robust incremental extend-and-rewire steps, consistent parent-child cost propagation, randomized path smoothing, and thorough collision checking to ensure feasibility and efficiency within a strict 30-second time limit.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling with goal bias and switching to focused ellipsoidal sampling after finding an initial path. Each iteration extends one tree toward a sample with steering and adaptive neighbor rewiring, then incrementally connects the other tree. Upon successful connection, it shortcuts and smooths the combined path. Iterations stop either on timeout or max iterations, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                # Tuple[float, ...]\n        self.parent = None                      # Node or None\n        self.cost = 0.0\n        self.children = []                     # List[Node]\n        self.valid = True                      # Validity flag for collision checks\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + math.dist(self.position, c.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K,sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes+1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.18055,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1637.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015459370613098145,
                    "num_nodes_avg": 69.1,
                    "path_length_avg": 164.94822463487387,
                    "smoothness_avg": 0.04062795546838197,
                    "success_improvement": 0.0,
                    "time_improvement": 37.72552913991114,
                    "length_improvement": 9.589264305743352,
                    "smoothness_improvement": 535.9157280975678,
                    "objective_score": 15.91509024360985
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040113639831542966,
                    "num_nodes_avg": 255.8,
                    "path_length_avg": 235.80564763820144,
                    "smoothness_avg": 0.11296878333955736,
                    "success_improvement": 0.0,
                    "time_improvement": 74.87231085137101,
                    "length_improvement": 21.281287529132562,
                    "smoothness_improvement": 2806.7681634525256,
                    "objective_score": 40.751791578500445
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032284116744995116,
                    "num_nodes_avg": 237.7,
                    "path_length_avg": 121.59499216372414,
                    "smoothness_avg": 0.13109787658732472,
                    "success_improvement": 0.0,
                    "time_improvement": 33.96167799823163,
                    "length_improvement": 19.242395936168286,
                    "smoothness_improvement": 1567.5553135520959,
                    "objective_score": 21.874759154463625
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive neighbor radius, goal-biased and ellipsoidal informed sampling after finding an initial path, incremental extend-and-rewire steps for optimized tree growth, robust collision checking, and post-hoc path smoothing. It enforces a 30-second planning time limit to ensure timely results and maintains consistent parent-child links with cost propagation to optimize path length and smoothness while improving planning efficiency and success rate.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points with goal bias and switching to informed ellipsoidal sampling upon discovering a path. Each extension chooses the best parent within an adaptive radius and rewires neighbors to minimize path costs. Incremental connections attempt to link the two trees progressively while ensuring collision-free paths. Path smoothing refines the final trajectory before returning. Timing is strictly monitored to enforce the maximum planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                  # Tuple[float, ...]\n        self.parent = None                        # Node or None\n        self.cost = cost                          # Cost from root\n        self.children = []                        # List[Node]\n        self.valid = True                         # For collision/validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # Clamp to bounds\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                # Time check to limit execution during incremental connect\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # On time limit or iteration end, return best found path or failure\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.11398,
          "time_improvement": 52.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1378.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015044641494750977,
                    "num_nodes_avg": 67.2,
                    "path_length_avg": 160.32343966413097,
                    "smoothness_avg": 0.04740254039094182,
                    "success_improvement": 0.0,
                    "time_improvement": 39.396168717790125,
                    "length_improvement": 12.124182232615077,
                    "smoothness_improvement": 641.9526933822505,
                    "objective_score": 17.453450528771306
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03404114246368408,
                    "num_nodes_avg": 233.7,
                    "path_length_avg": 232.14836316368215,
                    "smoothness_avg": 0.08683891562649824,
                    "success_improvement": 0.0,
                    "time_improvement": 78.67619967462957,
                    "length_improvement": 22.5021943558239,
                    "smoothness_improvement": 2134.4278466125347,
                    "objective_score": 38.77543800661633
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029708361625671385,
                    "num_nodes_avg": 211.5,
                    "path_length_avg": 123.78476098665263,
                    "smoothness_avg": 0.11456508567798769,
                    "success_improvement": 0.0,
                    "time_improvement": 39.230477739949,
                    "length_improvement": 17.78805574956528,
                    "smoothness_improvement": 1357.2594335090141,
                    "objective_score": 22.113051639442826
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation provides an enhanced bidirectional RRT* planner for 2D/3D environments, incorporating adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, incremental extend-and-rewire expansions, and rigorous collision and boundary checks. It maintains parent-child relationships with recursive cost updates for efficient rewiring and optimal path cost improvements. The planner benefits from early stopping upon finding better paths, path smoothing via random shortcutting, and enforces a 30-second time limit for timely response, returning the best available solution if interrupted.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with goal bias initially and focused ellipsoidal informed sampling once a solution is found. New nodes are added by steering towards samples with incremental connection attempts to the opposite tree and rewiring neighbors adaptively based on node density, which improves path cost quality. Paths from both trees are merged, smoothed, and returned early upon improvement. Planning halts if the runtime exceeds the 30-second limit, outputting the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 27.0  # Slightly tuned value for tighter neighbor radius\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos) ** 2 <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2])\n                    y_rot = (R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2])\n                    z_rot = (R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_tree_start = True\n        iter_cnt = 0\n        success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_cnt += 1\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_rate else sample_free())\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n                        # Prepare edges and nodes for return\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # On timeout or max iterations reached\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed_path = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.89994,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1323.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01829349994659424,
                    "num_nodes_avg": 78.4,
                    "path_length_avg": 158.6148076988789,
                    "smoothness_avg": 0.040650676543581246,
                    "success_improvement": 0.0,
                    "time_improvement": 26.308899769308642,
                    "length_improvement": 13.060710487775834,
                    "smoothness_improvement": 536.2713622640409,
                    "objective_score": 13.186168839667964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047746133804321286,
                    "num_nodes_avg": 281.4,
                    "path_length_avg": 236.4099202531062,
                    "smoothness_avg": 0.08959639868918132,
                    "success_improvement": 0.0,
                    "time_improvement": 70.09122050947818,
                    "length_improvement": 21.079563937254512,
                    "smoothness_improvement": 2205.37987195014,
                    "objective_score": 36.27017830004506
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01942884922027588,
                    "num_nodes_avg": 153.0,
                    "path_length_avg": 120.27417918571132,
                    "smoothness_avg": 0.10443872413434199,
                    "success_improvement": 0.0,
                    "time_improvement": 60.25759010020645,
                    "length_improvement": 20.119617025809113,
                    "smoothness_improvement": 1228.4528621240995,
                    "objective_score": 28.243464745844257
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines adaptive bidirectional RRT* with informed ellipsoidal sampling after finding a feasible path, dynamic rewiring with recursive cost propagation, robust and efficient collision checking for both nodes and edges, and aggressive path smoothing via randomized shortcutting. It enforces a strict 30-second planning limit, balances exploration and exploitation via alternating tree growth, and maintains consistent parent-child trees to ensure global cost improvements. A dynamic neighborhood radius accelerates rewiring while preventing excessive computational overhead. The planner aggressively connects and rewires the opposing tree incrementally to minimize overall path cost and search time, returning an optimized and smoothed path upon success or timeout.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. It samples points with goal bias before a solution and switches to ellipsoidal informed sampling after a first feasible path is found, focusing search in promising regions. Each iteration extends one tree towards the sample, rewires nearby nodes for path cost reduction using adaptive radius, and attempts incremental connection to the other tree with rewiring. Upon successfully connecting trees, it extracts, aggressively smooths, and updates the best path. The process terminates when the max iterations or 30 seconds are reached, yielding the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # List[Node]\n        self.valid = True                 # Validity flag for collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        # Prevent redundant updates\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        # Recursive update for children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 8000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = None) -> list:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time-out: return best solution so far\n                success_state = (len(best_path) > 0)\n                smoothed_path = path_smoothing(best_path) if success_state else []\n                all_nodes = tree_start + tree_goal\n                all_edges = []\n                for node in all_nodes:\n                    for c in node.children:\n                        all_edges.append((node, c))\n                return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n            # Sampling\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    # Combine paths from start and goal trees\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Avoid duplicated connecting node in joint path\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Iterations exhausted: return best found solution\n        final_success = (len(best_path) > 0)\n        final_path = path_smoothing(best_path) if final_success else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(final_success, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.82377,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01797184944152832,
                    "num_nodes_avg": 68.3,
                    "path_length_avg": 158.34860786959325,
                    "smoothness_avg": 0.0396680227598747,
                    "success_improvement": 0.0,
                    "time_improvement": 27.604593850663367,
                    "length_improvement": 13.20661883241353,
                    "smoothness_improvement": 520.8906966821885,
                    "objective_score": 13.527155405092659
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0362393856048584,
                    "num_nodes_avg": 235.4,
                    "path_length_avg": 242.3844419263825,
                    "smoothness_avg": 0.09181065347175564,
                    "success_improvement": 0.0,
                    "time_improvement": 77.2991924881339,
                    "length_improvement": 19.0850966356435,
                    "smoothness_improvement": 2262.3542423690324,
                    "objective_score": 38.31854828541403
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02474074363708496,
                    "num_nodes_avg": 191.6,
                    "path_length_avg": 122.28679186258083,
                    "smoothness_avg": 0.11873426565839522,
                    "success_improvement": 0.0,
                    "time_improvement": 49.39191901162028,
                    "length_improvement": 18.782935516149333,
                    "smoothness_improvement": 1410.2910951229428,
                    "objective_score": 25.625618282330663
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner with dynamic informed sampling, adaptive neighbor radius, robust collision checking, incremental rewiring with recursive cost propagation, and sophisticated randomized shortcut smoothing with early stopping upon better solution or timeout. The planner maintains consistent parent-child relations, enforces strict boundary and obstacle checks, and dynamically alternates tree growth between start and goal to expedite path discovery and optimization within a 30-second time limit.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points with goal bias and informed ellipsoidal distribution once a solution is found. It extends and rewires using an adaptive radius based on node density, dynamically rewires nearby nodes reducing cost recursively, and incrementally connects opposite trees. Upon connection, the best path is smoothed by multiple randomized shortcuts. The search halts early on timeout or upon discovering a better path, returning the highest-quality path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                 # List of child nodes\n        self.valid = True                  # For obstacle validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Avoid excessive updates if cost does not change meaningfully\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 smoothing_trials: int = 150,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 35.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_active = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors via new_node if cost improves\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_node: Node):\n            if not tree or not target_node:\n                return None\n            curr = min(tree, key=lambda n: dist_func(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr.cost + dist_func(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                curr = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sample with goal bias and informed sampling after first solution\n            sample = informed_sample(best_cost) if informed_sampling_active else (\n                goal_pos if random.random() < self.goal_sample_rate else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # Early stopping: return immediately with smoothed path\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n                        nodes_all = tree_start + tree_goal\n                        edges_all = [(node, child) for node in nodes_all for child in node.children]\n                        return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n        else:\n            smoothed_path = []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = [(node, child) for node in nodes_all for child in node.children]\n\n        return PlannerResult(success_state, smoothed_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.37437,
          "time_improvement": 46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1587.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020984077453613283,
                    "num_nodes_avg": 87.4,
                    "path_length_avg": 157.60116024034528,
                    "smoothness_avg": 0.039957844445175764,
                    "success_improvement": 0.0,
                    "time_improvement": 15.47053546903722,
                    "length_improvement": 13.616306722069968,
                    "smoothness_improvement": 525.4270354150128,
                    "objective_score": 9.991557162200225
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04594333171844482,
                    "num_nodes_avg": 300.2,
                    "path_length_avg": 238.18816860531638,
                    "smoothness_avg": 0.10115500590198441,
                    "success_improvement": 0.0,
                    "time_improvement": 71.22051843907624,
                    "length_improvement": 20.485933453245917,
                    "smoothness_improvement": 2502.791160863827,
                    "objective_score": 37.97729802669119
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023635125160217284,
                    "num_nodes_avg": 200.3,
                    "path_length_avg": 120.52708828079858,
                    "smoothness_avg": 0.14414964895847884,
                    "success_improvement": 0.0,
                    "time_improvement": 51.65350137310184,
                    "length_improvement": 19.951646847089105,
                    "smoothness_improvement": 1733.572894731552,
                    "objective_score": 28.154244255006134
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an advanced bidirectional RRT* planner with adaptive informed sampling and dynamic neighbor radius scaling tuned by node density and iteration progress. It grows two trees alternately from start and goal, performs incremental extend-and-rewire with recursive cost updates, enforces strict collision and boundary checks, and aggressively smooths paths by randomized shortcutting. The planner prioritizes early feasible path discovery and quality improvement under a strict 30-second time limit, ensuring efficient and robust path planning in 2D/3D environments.",
          "planning_mechanism": "Planning mechanism: The planner initializes two trees at the start and goal positions and iteratively samples points using a goal-biased uniform or ellipsoidal informed distribution after an initial solution. Each iteration attempts to extend and rewire one tree toward the sampled point, followed by incremental connection and rewiring of the opposite tree toward the new node. Adaptive neighbor radius dynamically scales with tree size and iteration count to optimize rewiring locality. Recursively propagated parent-child cost updates maintain global path cost consistency. Upon connecting the two trees, the combined path is shortcut-smoothed to improve smoothness and reduce length. The process enforces tight collision and boundary checks and halts within 30 seconds, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] e.g. (x,y) or (x,y,z)\n        self.parent = None                  # type: Node or None\n        self.cost = cost                    # Path cost from root to this node\n        self.children: List['Node'] = []   # Child nodes list\n        self.valid = True                   # Validity flag for collision\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update cost of all descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    rows = len(A)\n                    cols = len(B[0])\n                    return [[sum(A[i][k]*B[k][j] for k in range(len(B))) for j in range(cols)] for i in range(rows)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success else []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for node in nodes_all:\n            for c in node.children:\n                edges_all.append((node, c))\n\n        return PlannerResult(success, smoothed, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.28016,
          "time_improvement": 48.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1525.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020598411560058594,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 163.47506959241795,
                    "smoothness_avg": 0.04367856895104431,
                    "success_improvement": 0.0,
                    "time_improvement": 17.024100620619315,
                    "length_improvement": 10.396723928148914,
                    "smoothness_improvement": 583.6644536144399,
                    "objective_score": 10.104897239887777
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03490955829620361,
                    "num_nodes_avg": 221.9,
                    "path_length_avg": 232.77738879457712,
                    "smoothness_avg": 0.09426688841092093,
                    "success_improvement": 0.0,
                    "time_improvement": 78.1322130610254,
                    "length_improvement": 22.292207494732256,
                    "smoothness_improvement": 2325.5549365082725,
                    "objective_score": 39.52588009979544
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02548041343688965,
                    "num_nodes_avg": 193.8,
                    "path_length_avg": 124.14239219545193,
                    "smoothness_avg": 0.13893055146464137,
                    "success_improvement": 0.0,
                    "time_improvement": 47.87889783156715,
                    "length_improvement": 17.550534129248916,
                    "smoothness_improvement": 1667.186359843644,
                    "objective_score": 26.209707974538148
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional Anytime Informed RRT* planner with adaptive neighbor radius, recursive cost propagation on parent updates, incremental rewiring, and ellipsoidal informed sampling to efficiently discover high-quality, smooth, and short paths within a strict 30-second planning time limit. It dynamically alternates tree growth from start and goal, rigorously checks collisions, and employs randomized shortcut smoothing to optimize the final path.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling uniformly or informed by ellipsoidal regions after a first solution. Nodes extend towards samples with adaptive neighborhood radius for pruning and rewiring to minimize costs. Incremental connection attempts bidirectionally link the trees with rewiring for path improvement. The best path found triggers informed sampling and multiple path smoothings. The process halts immediately upon time expiration or early improved solutions, returning the best valid path with updated edges and nodes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                 # List[Node]\n        self.valid = True                  # Valid for collision checks\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            # No change needed\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n\n        dist_func = math.dist\n        # Recursively propagate cost updates to children\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 15000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=25.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 33.0\n            radius = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            tries = 0\n            while tries < 50:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                tries += 1\n            # Fallback to goal if failed\n            return goal_pos\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        use_informed_sampling = False\n        rotation_mat = None\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(rotation_mat[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(rotation_mat[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample_pt: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            # Rewire neighbors to possibly improve path cost\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_node.position))\n            current_node = nearest\n\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                new_pos = clamp_to_bounds(new_pos)\n\n                if not collision_free_node(new_pos) or not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + dist_func(current_node.position, new_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    candidate_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if candidate_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = candidate_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                current_node = new_node\n\n        def shortcut_smoothing(path: list, trials: int) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_path_nodes = []\n        best_path_cost = math.inf\n        use_informed_sampling = False\n        grow_start_tree = True\n        all_nodes = tree_start + tree_goal\n\n        edges = []\n\n        for iter_idx in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time limit reached, return best so far\n                success = len(best_path_nodes) > 0\n                final_path = shortcut_smoothing(best_path_nodes, self.smoothing_trials) if success else []\n                # update edges from current nodes\n                all_nodes = tree_start + tree_goal\n                edges.clear()\n                for node in all_nodes:\n                    for c in node.children:\n                        edges.append((node, c))\n                return PlannerResult(success, final_path, all_nodes, edges)\n\n            # Sample point\n            if use_informed_sampling:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            active_tree = tree_start if grow_start_tree else tree_goal\n            other_tree = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n            all_nodes.append(new_node)\n\n            connect_node = incremental_connect(other_tree, new_node)\n            if connect_node is not None:\n                # Extract path from roots to connection\n                if grow_start_tree:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n\n                combined_path = path_start + path_goal[::-1]\n\n                # Calculate total cost accurately via node costs and edge\n                total_cost = 0.0\n                for i in range(len(combined_path)-1):\n                    total_cost += dist_func(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-12 < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = combined_path\n                    use_informed_sampling = True\n                    rotation_mat = None  # reset rotation matrix for sampling\n\n                    # Recompute edges for current trees\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            edges.append((n, c))\n\n                    smoothed_path = shortcut_smoothing(best_path_nodes, self.smoothing_trials)\n                    return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # max_iter reached without timeout or early success\n        success = len(best_path_nodes) > 0\n        final_path = shortcut_smoothing(best_path_nodes, self.smoothing_trials) if success else []\n        all_nodes = tree_start + tree_goal\n        edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(success, final_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.21609,
          "time_improvement": 48.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1476.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022158360481262206,
                    "num_nodes_avg": 76.2,
                    "path_length_avg": 165.58659468621906,
                    "smoothness_avg": 0.0437746409571087,
                    "success_improvement": 0.0,
                    "time_improvement": 10.740210023261227,
                    "length_improvement": 9.23936356498026,
                    "smoothness_improvement": 585.168189133048,
                    "objective_score": 7.995776665639661
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03384168148040771,
                    "num_nodes_avg": 219.8,
                    "path_length_avg": 234.66524790011667,
                    "smoothness_avg": 0.09834783746328077,
                    "success_improvement": 0.0,
                    "time_improvement": 78.80114454640128,
                    "length_improvement": 21.661985786291712,
                    "smoothness_improvement": 2430.5606950142824,
                    "objective_score": 40.12554399625014
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021700334548950196,
                    "num_nodes_avg": 177.3,
                    "path_length_avg": 122.0790548509322,
                    "smoothness_avg": 0.11885933294110655,
                    "success_improvement": 0.0,
                    "time_improvement": 55.611185159283224,
                    "length_improvement": 18.92090454791287,
                    "smoothness_improvement": 1411.8819417275245,
                    "objective_score": 27.526946166005164
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a time-limited bidirectional Anytime RRT* planner with adaptive neighbor radius, incremental extend-and-rewire, and iterative path refinement. It features goal biasing, informed ellipsoidal sampling after initial solution discovery, rigorous collision and boundary checking, and an efficient path smoothing postprocess. The planner balances exploration and exploitation by toggling tree expansion from start and goal and dynamically adapts neighborhood connectivity based on tree size to optimize path cost and smoothness while halting immediately upon timeout or improved solutions.",
          "planning_mechanism": "The planner builds two search trees from start and goal nodes, alternately extending them toward sampled points generated uniformly, with goal bias, or informed ellipsoidal distribution after a first feasible path. Each extension steers a fixed step size while collision testing both nodes and connecting edges. Newly added nodes undergo local rewiring within an adaptive radius to minimize costs, with updates cascading recursively to descendants. Incremental connect attempts bridge the trees. Improved solutions trigger informed sampling and intermediate path smoothing. The process repeats until the 30-second limit or max iterations are reached, then returns the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                 # List of children nodes\n        self.valid = True                  # Validity flag for collision checking\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=15000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=25.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 33.0\n            radius = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos)**2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d])*0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d])/c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                success = (len(best_path) > 0)\n                final_path = path_smoothing(best_path, self.smoothing_trials) if success else []\n                all_nodes = tree_start + tree_goal\n                all_edges = [(node, c) for node in all_nodes for c in node.children]\n                return PlannerResult(success, final_path, all_nodes, all_edges)\n\n            if informed_sampling:\n                sample_point = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_point = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_point = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = incremental_connect(tree_goal, new_node.position)\n                if connect_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = [(node, c) for node in all_nodes for c in node.children]\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_point)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                connect_node = incremental_connect(tree_start, new_node.position)\n                if connect_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = [(node, c) for node in all_nodes for c in node.children]\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # End after max_iter without timeout or success\n        final_success = (len(best_path) > 0)\n        final_path = path_smoothing(best_path, self.smoothing_trials) if final_success else []\n        all_nodes = tree_start + tree_goal\n        all_edges = [(node, c) for node in all_nodes for c in node.children]\n\n        return PlannerResult(final_success, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.78979,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1356.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021341538429260253,
                    "num_nodes_avg": 66.6,
                    "path_length_avg": 160.8233943341031,
                    "smoothness_avg": 0.04505872621114924,
                    "success_improvement": 0.0,
                    "time_improvement": 14.030587254542285,
                    "length_improvement": 11.850149155714632,
                    "smoothness_improvement": 605.2669117945419,
                    "objective_score": 9.605540566478322
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0335770845413208,
                    "num_nodes_avg": 217.1,
                    "path_length_avg": 231.87927121065135,
                    "smoothness_avg": 0.08442764875099279,
                    "success_improvement": 0.0,
                    "time_improvement": 78.9668914011613,
                    "length_improvement": 22.59202499512799,
                    "smoothness_improvement": 2072.3842131404494,
                    "objective_score": 38.57039348507624
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023044514656066894,
                    "num_nodes_avg": 194.1,
                    "path_length_avg": 125.06959806376703,
                    "smoothness_avg": 0.11710773417070539,
                    "success_improvement": 0.0,
                    "time_improvement": 52.86161640250734,
                    "length_improvement": 16.934728140312874,
                    "smoothness_improvement": 1389.601734657594,
                    "objective_score": 26.193439222102747
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner with adaptive neighbor radius, efficient incremental tree connection and rewiring, robust collision and boundary checks, goal biasing, and an anytime time budget cutoff of 30 seconds. It grows two trees from the start and goal simultaneously, samples with goal biasing, and dynamically rewires neighbors using cost-based parent reassignment. A final path smoothing step removes unnecessary waypoints for improved path smoothness and quality. Early termination occurs upon time limit or first improved solution for planning efficiency.",
          "planning_mechanism": "The planner alternates tree growth from start and goal by sampling points (biased towards the goal), extending and rewiring the trees locally with an adaptive neighbor radius, incrementally connecting the opposing trees, and maintaining consistent parent-child and cost information. Collision checks prevent invalid expansions. If time limit exceeds, it returns the best path found so far. Path smoothing is applied to produce a smoother final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] 2D or 3D coordinate\n        self.parent = None              # Parent node\n        self.cost = 0.0                # Cost-to-come from root\n        self.children = []             # Children nodes list\n        self.valid = True              # Validity flag\n        \n        if parent is not None:\n            self.set_parent(parent)\n            self.update_cost(cost)\n\n    def set_parent(self, new_parent):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n\n    def update_cost(self, new_cost):\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost(child.cost + cost_diff)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 10.0, max_neighbor_radius: float = 30.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        import time\n        import random\n        import math\n\n        start_time = time.perf_counter()\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not is_in_obstacle(p):\n                    return p\n            # Fallback\n            return goal_position\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def adaptive_neighbor_radius(node_count):\n            # Adaptive radius according to RRT* literature: \u03b3*(log(n)/n)^(1/d)\n            # \u03b3 chosen as max_neighbor_radius for simplicity, bounded by min/max radius\n            if node_count < 2:\n                return self.max_neighbor_radius\n            import math\n            gamma = self.max_neighbor_radius\n            n = node_count\n            r = gamma * (math.log(n) / n) ** (1 / dimension)\n            return min(max(r, self.min_neighbor_radius), self.max_neighbor_radius)\n\n        def nearest(tree, pt):\n            # Return closest node in tree to pt\n            return min(tree, key=lambda n: distance(n.position, pt))\n\n        def near_nodes(tree, pos, radius):\n            # Return nodes within radius of pos\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, None, 0.0)]\n        tree_goal = [Node(goal_position, None, 0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)\n        success_state = False\n        extracted_path = []\n\n        # ------ Core functions for extending and rewiring ------\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                tentative_cost = neighbor.cost + distance(neighbor.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.set_parent(best_parent)\n            new_node.update_cost(min_cost)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    neighbor.set_parent(new_node)\n                    neighbor.update_cost(cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        # Remove outdated edge\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            # Incrementally extend tree toward target_node.position with rewiring\n            current_node = nearest(tree, target_node.position)\n\n            while True:\n                dist_to_target = distance(current_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    new_pos = target_node.position\n                else:\n                    new_pos = steer(current_node.position, target_node.position)\n\n                if (not within_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + distance(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    tentative_cost = neighbor.cost + distance(neighbor.position, new_pos)\n                    if tentative_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                new_node.set_parent(best_parent)\n                new_node.update_cost(min_cost)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_through_new < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                        neighbor.set_parent(new_node)\n                        neighbor.update_cost(cost_through_new)\n                        edges.append((new_node, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n\n                if new_node.position == target_node.position:\n                    return new_node\n\n                current_node = new_node\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def path_smoothing(path, iterations=50):\n            # Remove unnecessary waypoints by shortcutting path segments\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            import random\n            for _ in range(iterations):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # Shortcut possible: remove intermediate points between i and j\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n            return smoothed\n\n        # ----- Main planning loop -----\n\n        for iteration in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                if success_state:\n                    extracted_path = path_smoothing(extracted_path)\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                # Swap trees for balanced growth\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                # Swap trees for next iteration\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early stop if found path\n                if success_state:\n                    extracted_path = path_smoothing(extracted_path)\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.76518,
          "time_improvement": 54.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1030.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012971878051757812,
                    "num_nodes_avg": 76.9,
                    "path_length_avg": 167.24655728520398,
                    "smoothness_avg": 0.031034823234490035,
                    "success_improvement": 0.0,
                    "time_improvement": 47.74581307660836,
                    "length_improvement": 8.329511760685989,
                    "smoothness_improvement": 385.7623768170883,
                    "objective_score": 17.918458159205148
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.054288935661315915,
                    "num_nodes_avg": 319.8,
                    "path_length_avg": 236.81632083633494,
                    "smoothness_avg": 0.07381201027472953,
                    "success_improvement": 0.0,
                    "time_improvement": 65.9927270315975,
                    "length_improvement": 20.943895724980564,
                    "smoothness_improvement": 1799.2361890108605,
                    "objective_score": 32.98277819952966
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02476174831390381,
                    "num_nodes_avg": 190.0,
                    "path_length_avg": 119.98394953299164,
                    "smoothness_avg": 0.07904361337896625,
                    "success_improvement": 0.0,
                    "time_improvement": 49.34895318968801,
                    "length_improvement": 20.312373741894593,
                    "smoothness_improvement": 905.4289277878111,
                    "objective_score": 23.394305344224378
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, incremental connect and rewiring, ellipsoidal informed sampling after the first feasible solution, goal biasing, and rigorous collision checking. It maintains explicit parent-child relationships with dynamic cost updates and supports path smoothing and early termination within a 30-second planning time limit to improve planning efficiency, path quality, smoothness, and success rate.",
          "planning_mechanism": "The planner grows two RRT* trees from start and goal positions alternating expansions. Sampling is initially uniform with goal bias and switches to informed ellipsoidal sampling once a first valid path is found, focusing search on promising regions. Each new node rewires neighbors within an adaptive radius to optimize path cost. Incremental connection attempts between trees improve path quality. The algorithm continually checks for collisions on nodes and edges, and applies post-processing smoothing on final paths. Planning halts early if time exceeds 30 seconds or a high-quality path is found, returning the best obtained solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        if parent:\n            parent.add_child(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        self._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        for child in self.children:\n            child.cost = self.cost + math.dist(self.position, child.position)\n            child._update_cost_recursive()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0  # seconds\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(f_pos, t_pos, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(f_pos, t_pos, obstacles, is_3d, resolution=resolution)\n\n        # Uniform random sample within bounds avoiding obstacles\n        def sample_free():\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        # Unit n-ball sampling for informed sampling\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = ((cos_a, -sin_a), (sin_a, cos_a))\n            else:\n                # Householder approach to build orthonormal basis (direction aligned to x-axis)\n                ux, uy, uz = direction\n                if abs(ux) < 1e-10 and abs(uy) < 1e-10:\n                    vx_, vy_, vz_ = 1, 0, 0\n                else:\n                    vx_, vy_, vz_ = -uy, ux, 0\n                norm_v_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_v_\n                vy_ /= norm_v_\n                vz_ /= norm_v_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                R = [\n                    [ux, vx_, wx],\n                    [uy, vy_, wy],\n                    [uz, vz_, wz]\n                ]\n\n            a1 = c_best / 2.0\n            if dim == 2:\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        # Adaptive radius for neighbor search\n        def adaptive_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return 50.0\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(5.0, min(30.0, r))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target):\n            nearest = min(tree, key=lambda n: dist(n.position, target))\n            new_pos = steer(nearest.position, target)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr = min(tree, key=lambda n: dist(n.position, target_pos))\n\n            while True:\n                new_pos = steer(curr.position, target_pos)\n                new_pos = clamp(new_pos)\n\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                neighbors_radius = adaptive_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(new_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                tree.append(connect_node)\n\n                rewire(tree, connect_node, neighbors)\n\n                if dist(connect_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(connect_node.position, target_pos):\n                        return connect_node\n                    else:\n                        return None\n\n                curr = connect_node\n\n        def path_smooth(path: list, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success_state = False\n\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            current_time = time.perf_counter()\n            if current_time - start_time > self.max_planning_time:\n                if best_path:\n                    smooth_path = path_smooth(best_path)\n                    return PlannerResult(True, smooth_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < 0.15:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect_and_rewire(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect_and_rewire(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        if best_path:\n            smooth_path = path_smooth(best_path)\n            return PlannerResult(True, smooth_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.92383,
          "time_improvement": 44.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1496.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023353886604309083,
                    "num_nodes_avg": 88.2,
                    "path_length_avg": 162.5641920913915,
                    "smoothness_avg": 0.04718954807895943,
                    "success_improvement": 0.0,
                    "time_improvement": 5.924311719543842,
                    "length_improvement": 10.895990320239173,
                    "smoothness_improvement": 638.6189011795176,
                    "objective_score": 7.149586085808576
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03457486629486084,
                    "num_nodes_avg": 204.3,
                    "path_length_avg": 235.5540057270995,
                    "smoothness_avg": 0.09177974132940063,
                    "success_improvement": 0.0,
                    "time_improvement": 78.341868345502,
                    "length_improvement": 21.365292842169193,
                    "smoothness_improvement": 2261.5588506811223,
                    "objective_score": 39.08341332549005
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025414371490478517,
                    "num_nodes_avg": 167.7,
                    "path_length_avg": 126.52786287418228,
                    "smoothness_avg": 0.13272172256953335,
                    "success_improvement": 0.0,
                    "time_improvement": 48.01398900835761,
                    "length_improvement": 15.966218088343265,
                    "smoothness_improvement": 1588.210514585947,
                    "objective_score": 25.53849289310567
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* path planner with adaptive neighbor radius and informed ellipsoidal sampling to accelerate finding high-quality paths. It alternates growth between two trees from start and goal positions, incrementally extends with rewiring and collision checking, and incorporates path smoothing for smoother, shorter paths. A strict 30-second time limit enforces timely termination, returning the best path found so far.",
          "planning_mechanism": "The planner samples points biased by goal and informed ellipsoid after a solution is found, extends and rewires nodes adaptively within a dynamic radius, tries incremental connection between trees, and applies shortcut smoothing. It stops early upon timeout or upon improving solutions, balancing exploration and refinement to efficiently return smooth and low-cost paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] e.g. 2D or 3D\n        self.parent = None              # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # Child nodes list\n        self.valid = True               # Node validity (collision-free)\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_radius(n_nodes, iter_num=0):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            base = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            # Reduce radius as iterations progress to balance rewiring cost and connectivity\n            radius = base * (1.0 - 0.6 * iteration_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(nodes_list, pos, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        rotation_mat = None\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                dir_sample = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0]*sample_scaled[0] + rotation_mat[0][1]*sample_scaled[1]\n                    y_rot = rotation_mat[1][0]*sample_scaled[0] + rotation_mat[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = rotation_mat[0][0]*sample_scaled[0] + rotation_mat[0][1]*sample_scaled[1] + rotation_mat[0][2]*sample_scaled[2]\n                    y_rot = rotation_mat[1][0]*sample_scaled[0] + rotation_mat[1][1]*sample_scaled[1] + rotation_mat[1][2]*sample_scaled[2]\n                    z_rot = rotation_mat[2][0]*sample_scaled[0] + rotation_mat[2][1]*sample_scaled[1] + rotation_mat[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(dim))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(dim))\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes+1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes+1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample_pt = (informed_sample(best_cost) if informed_sampling\n                         else goal_pos if random.random() < self.goal_sample_rate and grow_start\n                         else start_pos if random.random() < self.goal_sample_rate and not grow_start\n                         else sample_uniform())\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path)\n                    return self._build_result(True, smoothed, tree_start + tree_goal)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path)\n                    return self._build_result(True, smoothed, tree_start + tree_goal)\n\n            grow_start = not grow_start\n\n        success = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success else []\n        return self._build_result(success, smoothed, tree_start + tree_goal)\n\n    def _build_result(self, success, path, nodes):\n        edges = []\n        for node in nodes:\n            for child in node.children:\n                edges.append((node, child))\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.74477,
          "time_improvement": 44.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1374.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019850778579711913,
                    "num_nodes_avg": 74.7,
                    "path_length_avg": 164.61872223265846,
                    "smoothness_avg": 0.042612267285597714,
                    "success_improvement": 0.0,
                    "time_improvement": 20.035765805047557,
                    "length_improvement": 9.769869793697307,
                    "smoothness_improvement": 566.9745170390731,
                    "objective_score": 10.799576285449096
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.045652008056640624,
                    "num_nodes_avg": 234.9,
                    "path_length_avg": 231.95373323993402,
                    "smoothness_avg": 0.09615846318542019,
                    "success_improvement": 0.0,
                    "time_improvement": 71.4030072495207,
                    "length_improvement": 22.567167426482758,
                    "smoothness_improvement": 2374.226517902378,
                    "objective_score": 37.80546824966465
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02833552360534668,
                    "num_nodes_avg": 185.3,
                    "path_length_avg": 119.62950344386209,
                    "smoothness_avg": 0.10075682849853813,
                    "success_improvement": 0.0,
                    "time_improvement": 42.038667288963936,
                    "length_improvement": 20.547779957385412,
                    "smoothness_improvement": 1181.6194214059403,
                    "objective_score": 22.629253285195965
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional, adaptive informed RRT* planner for 2D/3D environments with enhanced parent-child node management, recursive cost propagation, and adaptive neighbor radius scaling. It grows trees alternately from start and goal, employs ellipsoidal informed sampling after initial feasible path discovery, and performs incremental extend-and-rewire with thorough collision checking and dynamic rewiring that maintains global cost consistency. The planner aggressively smooths paths using randomized shortcutting, operates under a strict 30-second time limit, and returns the best found path, ensuring robust, efficient, and high-quality path planning.",
          "planning_mechanism": "The planner initializes two trees at start and goal locations. It iteratively samples points biased by an ellipsoidal informed distribution once a solution is found. Each iteration extends one tree toward the sampled point using adaptive neighbor radius for rewiring, with recursive parent-child cost updates. After tree growth, it incrementally attempts to connect the opposite tree to the new node. Upon connection, the combined path is extracted and smoothed. The process enforces strict collision and boundary constraints, and halts within 30 seconds, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] e.g. (x,y) or (x,y,z)\n        self.parent = None              # Node or None\n        self.cost = cost                # cost from root to this node\n        self.children = []              # List[Node]\n        self.valid = True               # Validity flag for collision\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from existing parent\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            # Clamp within bounds, strict without exceeding\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt_star = 35.0\n            base = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            factor = min(1.0, iter_num / self.max_iter)\n            radius = base * (1.0 - 0.5 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            rsq = radius * radius\n            return [node for node in tree_nodes if (math.dist(node.position, pos) ** 2) <= rsq]\n\n        def sample_uniform():\n            # Uniform random valid sample\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            # fallback to start or goal\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    rows = len(A)\n                    cols = len(B[0])\n                    return [[sum(A[i][k]*B[k][j] for k in range(len(B))) for j in range(cols)] for i in range(rows)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            for _ in range(100):\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clamped):\n                    if random.random() < self.goal_sample_rate:\n                        return goal_pos\n                    return clamped\n\n            return sample_uniform()  # fallback\n\n        def extend_and_rewire(tree: list, sample: tuple, iter_num: int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors if cheaper path found through new_node\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple, iter_num:int) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cand_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cand_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = math.dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def random_path_smoothing(path: list, trials: int = 150) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            # Extend current tree\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    # Build combined path\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = random_path_smoothing(best_path, self.smoothing_trials)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node,c))\n                    return PlannerResult(True, smoothed, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = random_path_smoothing(best_path, self.smoothing_trials)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node,c))\n                    return PlannerResult(True, smoothed, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        # Timeout or iteration limit reached\n        success = len(best_path) > 0\n        smoothed_path = random_path_smoothing(best_path, self.smoothing_trials) if success else []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for node in nodes_all:\n            for c in node.children:\n                edges_all.append((node, c))\n\n        return PlannerResult(success, smoothed_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.65137,
          "time_improvement": 41.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1537.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024845004081726074,
                    "num_nodes_avg": 97.5,
                    "path_length_avg": 157.57214250919532,
                    "smoothness_avg": 0.042876445692616484,
                    "success_improvement": 0.0,
                    "time_improvement": -0.08230745146549241,
                    "length_improvement": 13.632211800328637,
                    "smoothness_improvement": 571.1094827815098,
                    "objective_score": 5.5572975385336285
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04166045188903809,
                    "num_nodes_avg": 256.4,
                    "path_length_avg": 239.100289734546,
                    "smoothness_avg": 0.1069354824709998,
                    "success_improvement": 0.0,
                    "time_improvement": 73.90336829927867,
                    "length_improvement": 20.18144116635805,
                    "smoothness_improvement": 2651.526986493575,
                    "objective_score": 39.46493365552308
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02412431240081787,
                    "num_nodes_avg": 193.0,
                    "path_length_avg": 121.96683079392483,
                    "smoothness_avg": 0.11693370496546614,
                    "success_improvement": 0.0,
                    "time_improvement": 50.652851277294396,
                    "length_improvement": 18.995438423041826,
                    "smoothness_improvement": 1387.3880960124507,
                    "objective_score": 25.931883547858938
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner is a bidirectional RRT* variant with adaptive neighbor radius, ellipsoidal informed sampling post initial solution, robust parent-child cost propagation, incremental extend-and-rewire steps, randomized path smoothing, and strict 30-second time limit enforcement to optimize planning efficiency, path quality, smoothness, and success rate.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling with goal bias initially and switching to informed ellipsoidal sampling after the first solution. Each iteration extends one tree toward a sample, performs adaptive neighbor rewiring with recursive cost updates, then incrementally connects the other tree to the new node. Upon successful connection, it merges, smooths the path, and returns early. The process stops on timeout or max iterations, returning the best solution found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = 0.0                  # cost from root\n        self.children = []                # List[Node]\n        self.valid = True                 # For collision checking etc.\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0, goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=8.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0, smoothing_trials: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist_func(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K,sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0/n)\n                sample_unit = tuple(radius_sample*d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(n))\n                pt = clamp_to_bounds(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.64936,
          "time_improvement": 44.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1448.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018645620346069335,
                    "num_nodes_avg": 81.9,
                    "path_length_avg": 166.2148040675449,
                    "smoothness_avg": 0.03789713352303899,
                    "success_improvement": 0.0,
                    "time_improvement": 24.89046482100771,
                    "length_improvement": 8.8950320484609,
                    "smoothness_improvement": 493.17243457818154,
                    "objective_score": 11.712008028885402
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03554911613464355,
                    "num_nodes_avg": 224.3,
                    "path_length_avg": 235.02489784508094,
                    "smoothness_avg": 0.0995112048107993,
                    "success_improvement": 0.0,
                    "time_improvement": 77.73158597696181,
                    "length_improvement": 21.54192428271295,
                    "smoothness_improvement": 2460.494974805565,
                    "objective_score": 39.93033552365896
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.034885191917419435,
                    "num_nodes_avg": 228.4,
                    "path_length_avg": 122.2429157762381,
                    "smoothness_avg": 0.11715448748235939,
                    "success_improvement": 0.0,
                    "time_improvement": 28.64108517718159,
                    "length_improvement": 18.812075923543453,
                    "smoothness_improvement": 1390.1964333308624,
                    "objective_score": 19.30572290451748
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This implementation is a bidirectional RRT* planner optimized for both 2D and 3D path planning. It grows two trees simultaneously from start and goal positions using adaptive neighbor radius rewiring and goal-biased sampling, including informed ellipsoidal sampling after the first feasible path to focus search. The planner rigorously checks collisions for nodes and edges, enforces map boundary constraints, and applies path shortcut smoothing. It respects a strict 30-second planning time limit, returning the best smooth feasible path found.",
          "planning_mechanism": "The planner alternates growth between two trees from start and goal, sampling points uniformly, with goal bias, or with ellipsoidal informed sampling based on current best cost. New nodes are added via steer steps ensuring collision-free expansion and rewired within a dynamic radius to minimize path cost. Trees attempt incremental connection each iteration. When connected, the combined path is shortcut-smoothed and returned. The process halts when the best solution is found or the time limit is reached, ensuring efficient exploration, optimized paths, and timely response.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                 # List of children nodes\n        self.valid = True                  # Validity for collision checking\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5.0)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 33.0  # Tuned constant balancing connectivity & computation\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                trials += 1\n                if trials > 1000:  # fallback to start or goal if stuck\n                    return start_pos if random.random() < 0.5 else goal_pos\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            n = dim\n            for _ in range(100):\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_clamped):\n                    return sample_clamped\n            return uniform_sample()\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = None) -> list:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                success_state = (len(best_path) > 0)\n                smoothed_path = path_smoothing(best_path) if success_state else []\n                all_nodes = tree_start + tree_goal\n                all_edges = []\n                for node in all_nodes:\n                    for c in node.children:\n                        all_edges.append((node, c))\n                return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        final_success = (len(best_path) > 0)\n        final_path = path_smoothing(best_path) if final_success else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(final_success, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.58251,
          "time_improvement": 43.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1564.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020181727409362794,
                    "num_nodes_avg": 79.9,
                    "path_length_avg": 168.62243191829324,
                    "smoothness_avg": 0.0402307909049522,
                    "success_improvement": 0.0,
                    "time_improvement": 18.702615590587175,
                    "length_improvement": 7.575373072161017,
                    "smoothness_improvement": 529.6992402232382,
                    "objective_score": 9.774355492724547
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036414813995361325,
                    "num_nodes_avg": 237.0,
                    "path_length_avg": 238.7153929268505,
                    "smoothness_avg": 0.11023194757321124,
                    "success_improvement": 0.0,
                    "time_improvement": 77.18930193512217,
                    "length_improvement": 20.309930799407145,
                    "smoothness_improvement": 2736.347407921317,
                    "objective_score": 40.90051378002467
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.033235907554626465,
                    "num_nodes_avg": 234.9,
                    "path_length_avg": 125.43984683047938,
                    "smoothness_avg": 0.11997654232670885,
                    "success_improvement": 0.0,
                    "time_improvement": 32.014755662978246,
                    "length_improvement": 16.688826538814205,
                    "smoothness_improvement": 1426.092762648567,
                    "objective_score": 20.072655819899147
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This implementation is an optimized bidirectional RRT* planner for 2D and 3D spaces with adaptive neighbor radius, incremental tree extension and rewiring, goal biasing, and informed ellipsoidal sampling after the first feasible path. It performs rigorous collision checking for nodes and edges, enforces map boundary constraints, limits planning runtime to 30 seconds, and applies path shortcut smoothing to improve path quality and smoothness while minimizing path length and execution time. The planner dynamically balances exploration and exploitation to efficiently discover smooth, low-cost paths and halts early upon finding improved solutions or when the time budget is exhausted.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling points either uniformly, with goal bias, or informed ellipsoidal distribution after the first solution. Each extension steers towards sampled points by a fixed step size, ensuring collision-free nodes and edges are maintained. Newly added nodes are locally rewired within an adaptive radius for cost minimization. Once the trees connect incrementally with collision-checked edges, a combined path is extracted, shortcut-smoothed, and returned. The process respects a 30-second planning time limit and returns the best feasible solution found within this budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                  # Tuple[float, ...]\n        self.parent = None                        # Parent Node or None\n        self.cost = 0.0                          # Cost from root to this node\n        self.children = []                      # List of children nodes\n        self.valid = True                       # Validity flag for collision checking\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update children's costs\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 35.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = None) -> list:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time limit reached: return best found so far\n                success_state = (len(best_path) > 0)\n                smoothed_path = path_smoothing(best_path) if success_state else []\n                all_nodes = tree_start + tree_goal\n                all_edges = []\n                for node in all_nodes:\n                    for c in node.children:\n                        all_edges.append((node, c))\n                return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # End of iterations reached - return best found solution\n        final_success = (len(best_path) > 0)\n        final_path = path_smoothing(best_path) if final_success else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(final_success, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.41279,
          "time_improvement": 43.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1429.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02322845458984375,
                    "num_nodes_avg": 95.8,
                    "path_length_avg": 171.18271234637552,
                    "smoothness_avg": 0.04108737789847548,
                    "success_improvement": 0.0,
                    "time_improvement": 6.42958535100239,
                    "length_improvement": 6.172042799289528,
                    "smoothness_improvement": 543.1066867803061,
                    "objective_score": 5.878817599060153
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03691425323486328,
                    "num_nodes_avg": 258.3,
                    "path_length_avg": 233.89526148878673,
                    "smoothness_avg": 0.09309644198475484,
                    "success_improvement": 0.0,
                    "time_improvement": 76.87644690597159,
                    "length_improvement": 21.919029413223644,
                    "smoothness_improvement": 2295.4385069245336,
                    "objective_score": 38.92393248905888
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025823450088500975,
                    "num_nodes_avg": 198.4,
                    "path_length_avg": 120.18639554132542,
                    "smoothness_avg": 0.12180679988238355,
                    "success_improvement": 0.0,
                    "time_improvement": 47.177204022303215,
                    "length_improvement": 20.177918742602277,
                    "smoothness_improvement": 1449.3735036611893,
                    "objective_score": 25.435612473517367
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with adaptive informed sampling, dynamic rewiring, and incremental tree connections to enhance planning efficiency, path quality, robustness, and smoothness. It grows two trees simultaneously from start and goal, biases sampling toward the goal and informed ellipsoidal regions after initial solutions, performs rewiring to reduce path costs, and includes path smoothing. The planner enforces map bounds and thorough collision checks with early termination on success or timeout (30 seconds).",
          "planning_mechanism": "The planner alternates growing two trees from start and goal by sampling adaptively (goal biasing and informed ellipsoid), extending nodes while checking collisions, rewiring to optimize locally, and incrementally connecting the trees when feasible. On connection, it builds the solution path by merging both trees, performs shortcut smoothing for better smoothness and shorter path lengths, and returns the best path found within 30 seconds or max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Remove from old parent's children\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Propagate cost updates to descendants recursively\n        self._update_children_costs()\n\n    def _update_children_costs(self):\n        for child in self.children:\n            updated_cost = self.cost + math.dist(self.position, child.position)\n            if child.cost > updated_cost:\n                child.cost = updated_cost\n                child._update_children_costs()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        # Trees from start and goal\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        nodes = tree_start + tree_goal\n        edges = []\n\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)\n        success_state = False\n        extracted_path = []\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def sample_free():\n            # Goal biased sampling or informed sampling if solution exists\n            if success_state:\n                # Informed sampling inside ellipsoid\n                return informed_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def informed_sample():\n            c_best = best_path_cost\n            c_min = dist(start_position, goal_position)\n            if c_best == float('inf') or c_best < c_min:\n                # Fallback to uniform sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n            center = tuple((start_position[d] + goal_position[d]) * 0.5 for d in range(dimension))\n            direction = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dimension))\n\n            # Rotation matrix for 2D or 3D\n            def rotation_matrix(dir_vec):\n                if dimension == 2:\n                    dx, dy = dir_vec\n                    angle = math.atan2(dy, dx)\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    return [[cos_a, -sin_a],[sin_a, cos_a]]\n                else:\n                    vx, vy, vz = dir_vec\n                    k = (-0.0, -vy, -vz)\n                    k_norm = math.sqrt(k[0]*k[0] + k[1]*k[1] + k[2]*k[2])\n                    if k_norm < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    k = tuple(ki/k_norm for ki in k)\n                    cos_theta = vx\n                    sin_theta = k_norm\n                    Kx, Ky, Kz = k\n                    K = [[0, -Kz, Ky],[Kz, 0, -Kx],[-Ky, Kx, 0]]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n                    def mat_add(A,B):\n                        return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                    def mat_scale(A,s):\n                        return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                    def mat_mul(A,B):\n                        return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    K2 = mat_mul(K,K)\n                    R = mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n                    return R\n\n            R = rotation_matrix(direction)\n\n            a1 = c_best * 0.5\n            if dimension == 2:\n                a2 = math.sqrt(max(c_best**2 - c_min**2, 0.0)) * 0.5\n                radii = [a1,a2]\n            else:\n                a_minor = math.sqrt(max(c_best**2 - c_min**2, 0.0)) * 0.5\n                radii = [a1,a_minor,a_minor]\n\n            def unit_ball_sample(n):\n                while True:\n                    pt = [random.uniform(-1,1) for _ in range(n)]\n                    norm_sq = sum(x*x for x in pt)\n                    if norm_sq <=1.0:\n                        norm = math.sqrt(norm_sq)\n                        if norm > 1e-10:\n                            return tuple(x/norm for x in pt)\n                        else:\n                            return tuple(0.0 for _ in range(n))\n\n            while True:\n                n = dimension\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.uniform(0,1) ** (1.0/n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                # Scale by radii\n                sample_scaled = tuple(sample_unit[d]*radii[d] for d in range(n))\n\n                if dimension == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    sample_rot = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    sample_rot = (x_rot, y_rot, z_rot)\n\n                sample_point = tuple(center[d] + sample_rot[d] for d in range(n))\n\n                # Clamp sample inside bounds\n                sample_point = tuple(min(max(0.0, sample_point[d]), bounds[d]) for d in range(n))\n\n                if not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                    return sample_point\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbor_radius = max(self.step_size * 2, 20.0 * (math.log(len(tree)+1) / (len(tree)+1))**(1/dimension))\n            neighbors = near_nodes(tree, new_pos, neighbor_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                subt_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if subt_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = subt_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost found through new node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, neighbor))\n                    # Remove old edge if exists\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except Exception:\n                        pass\n\n            return new_node\n\n        def try_connect(tree, connecting_node):\n            # Attempt to connect connecting_node to tree incrementally with rewiring\n            current_node = nearest(tree, connecting_node.position)\n            target_pos = connecting_node.position\n\n            while True:\n                d = dist(current_node.position, target_pos)\n                if d <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if not within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = max(self.step_size*2, 20.0 * (math.log(len(tree)+1) / (len(tree)+1))**(1/dimension))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    if neighbor == current_node:\n                        continue\n                    candidate_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for improving cost\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node, cost_thru_new)\n                        edges.append((new_node, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n\n                if new_node.position == target_pos:\n                    return new_node\n                current_node = new_node\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_path(path):\n            # Smooth the path by shortcutting segments if collision-free\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                # Try to jump as far as possible\n                j = len(path) -1\n                while j > i +1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -=1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        iteration = 0\n        while iteration < self.max_iter:\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time exceeded, return best path found so far\n                if success_state:\n                    extracted_path = shortcut_path(merge_paths(best_path_nodes[0], best_path_nodes[1]))\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                # Swap trees\n                tree_start, tree_goal = tree_goal, tree_start\n                iteration += 1\n                continue\n\n            connect_node_goal = try_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = shortcut_path(merge_paths(new_node_start, connect_node_goal))\n                    success_state = True\n\n                # Swap trees after connection attempt\n                tree_start, tree_goal = tree_goal, tree_start\n\n                # Early stop when first path found for speed (optional)\n                if success_state:\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n            iteration += 1\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.30836,
          "time_improvement": 42.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1502.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01883273124694824,
                    "num_nodes_avg": 90.6,
                    "path_length_avg": 163.39622514563027,
                    "smoothness_avg": 0.04658638176178405,
                    "success_improvement": 0.0,
                    "time_improvement": 24.13673217328168,
                    "length_improvement": 10.439939818803454,
                    "smoothness_improvement": 629.1780385191012,
                    "objective_score": 12.4748978083407
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04234762191772461,
                    "num_nodes_avg": 282.8,
                    "path_length_avg": 235.26873206866327,
                    "smoothness_avg": 0.1003287435538787,
                    "success_improvement": 0.0,
                    "time_improvement": 73.4729163396559,
                    "length_improvement": 21.46052540050219,
                    "smoothness_improvement": 2481.5308355143534,
                    "objective_score": 38.741634159568974
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035346579551696775,
                    "num_nodes_avg": 251.5,
                    "path_length_avg": 124.83976469412278,
                    "smoothness_avg": 0.11764047661879902,
                    "success_improvement": 0.0,
                    "time_improvement": 27.697300176008692,
                    "length_improvement": 17.087372520941603,
                    "smoothness_improvement": 1396.378179274388,
                    "objective_score": 18.70855545336287
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements a bidirectional RRT* with dynamic adaptive neighbor radius, informed ellipsoidal sampling after the first solution, incremental extension and rewiring for continuous path cost improvement, and early termination with a 30-second time limit. It combines goal bias and informed sampling to accelerate convergence, maintains robust collision and boundary checks, and performs path smoothing to deliver shorter, smoother, and feasible paths efficiently.",
          "planning_mechanism": "The planner grows two RRT* trees from start and goal, alternately extending towards sampled points. Initially, uniform random sampling with goal bias is used; upon finding a first feasible path, ellipsoidal informed sampling focuses the search within regions likely to improve path cost. Each extension includes rewiring of neighbors based on adaptive radius to locally optimize costs. Trees attempt incremental connections with rewiring, and once connected, the combined path is smoothed. Planning halts early if time limit exceeds or a high-quality path is found, returning the best solution found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children costs\n        for c in self.children:\n            c._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        for c in self.children:\n            c.cost = self.cost + math.dist(self.position, c.position)\n            c._update_cost_recursive()\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(f_pos, t_pos, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(f_pos, t_pos, obstacles, is_3d, resolution=resolution)\n\n        # Uniform random sample within bounds avoiding obstacles\n        def sample_free():\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        # Unit n-ball sampling for informed sampling\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = ((cos_a, -sin_a), (sin_a, cos_a))\n            else:\n                # Householder approach to build orthonormal basis (direction aligned to x-axis)\n                ux, uy, uz = direction\n                # Create arbitrary orthonormal vectors perpendicular to ux, uy, uz\n                if abs(ux) < 1e-10 and abs(uy) < 1e-10:\n                    vx_, vy_, vz_ = 1,0,0\n                else:\n                    vx_, vy_, vz_ = -uy, ux, 0\n                norm_v_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                vx_ /= norm_v_\n                vy_ /= norm_v_\n                vz_ /= norm_v_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n\n                R = [\n                    [ux, vx_, wx],\n                    [uy, vy_, wy],\n                    [uz, vz_, wz]\n                ]\n\n            a1 = c_best / 2.0\n            if dim == 2:\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def adaptive_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return 50.0\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(5.0, min(30.0, r))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, target):\n            nearest = min(tree, key=lambda n: dist(n.position, target))\n            new_pos = steer(nearest.position, target)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            neighbors_radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr = min(tree, key=lambda n: dist(n.position, target_pos))\n\n            while True:\n                new_pos = steer(curr.position, target_pos)\n                new_pos = clamp(new_pos)\n\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                neighbors_radius = adaptive_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, neighbors_radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(new_pos)\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                tree.append(connect_node)\n\n                rewire(tree, connect_node, neighbors)\n\n                if dist(connect_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(connect_node.position, target_pos):\n                        return connect_node\n                    else:\n                        return None\n\n                curr = connect_node\n\n        def path_smooth(path: List[Tuple[float, ...]], max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_path = []\n        best_cost = math.inf\n        success_state = False\n\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                # Time limit exceeded: return best path if any\n                if best_path:\n                    smooth_path = path_smooth(best_path)\n                    return PlannerResult(True, smooth_path, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < 0.15:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect_and_rewire(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    # Refresh edges list\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            else:\n                new_node = extend(tree_goal, sample)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect_and_rewire(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smooth(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached - return best path if any\n        if best_path:\n            smooth_path = path_smooth(best_path)\n            return PlannerResult(True, smooth_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.29256,
          "time_improvement": 39.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1593.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020206856727600097,
                    "num_nodes_avg": 73.6,
                    "path_length_avg": 159.14026677692104,
                    "smoothness_avg": 0.04520935386914754,
                    "success_improvement": 0.0,
                    "time_improvement": 18.601387989834986,
                    "length_improvement": 12.772698040669017,
                    "smoothness_improvement": 607.62456173541,
                    "objective_score": 11.17307881376135
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04909365177154541,
                    "num_nodes_avg": 257.4,
                    "path_length_avg": 239.7096814808026,
                    "smoothness_avg": 0.10836196634723846,
                    "success_improvement": 0.0,
                    "time_improvement": 69.24711828527725,
                    "length_improvement": 19.978008661088737,
                    "smoothness_improvement": 2688.231444084002,
                    "objective_score": 38.21089443822093
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.034293103218078616,
                    "num_nodes_avg": 216.5,
                    "path_length_avg": 119.51124412566529,
                    "smoothness_avg": 0.12441519752305503,
                    "success_improvement": 0.0,
                    "time_improvement": 29.852223908017052,
                    "length_improvement": 20.626322165628142,
                    "smoothness_improvement": 1482.552129118644,
                    "objective_score": 20.493692251123964
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after the first solution, incremental extend-and-rewire expansions with robust parent-child cost propagation, and progressive tree connection attempts. It continuously rewires nodes for cost improvement while ensuring collision-free node and edge additions, enforcing map bounds, and applying multi-pass path smoothing. A strict 30-second timeout guarantees timely results by returning the best found path if time expires.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with goal bias and informed ellipsoidal sampling once a path is found. Each extension rewires nearby nodes adaptively for path cost optimization. Incremental connection attempts gradually bridge the two trees. On successful connection, the combined path is smoothed and returned early. If time limit is reached before a solution, the best available path is returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...], 2D or 3D\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # Cost from root to this node\n        self.children = []                  # List[Node]\n        self.valid = True                   # For collision checking or pruning\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for ch in self.children:\n            ch.update_parent(self, self.cost + self._distance(self.position, ch.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        # Rotation matrix for informed sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0,1-cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n_ = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n_)\n                radius_sample = random.random() ** (1.0 / n_)\n                sample_unit = tuple(radius_sample * ds for ds in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n_))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n_))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n_))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                # Rewire neighbors\n                for nbr in neighbors:\n                    if nbr == new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials: int=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_tree_start = True\n        iter_cnt = 0\n\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_cnt += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_tree_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if not new_node:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.2647,
          "time_improvement": 45.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1339.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016116404533386232,
                    "num_nodes_avg": 70.1,
                    "path_length_avg": 172.72743414295078,
                    "smoothness_avg": 0.04343183281564418,
                    "success_improvement": 0.0,
                    "time_improvement": 35.07882114984566,
                    "length_improvement": 5.325356304903362,
                    "smoothness_improvement": 579.8024972993342,
                    "objective_score": 14.487730092431041
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04493093490600586,
                    "num_nodes_avg": 247.1,
                    "path_length_avg": 233.30625111124087,
                    "smoothness_avg": 0.08935858084385873,
                    "success_improvement": 0.0,
                    "time_improvement": 71.85469655167985,
                    "length_improvement": 22.115658030972146,
                    "smoothness_improvement": 2199.2606474967197,
                    "objective_score": 36.97584380918198
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035297608375549315,
                    "num_nodes_avg": 207.0,
                    "path_length_avg": 121.8938115904648,
                    "smoothness_avg": 0.10507127322371398,
                    "success_improvement": 0.0,
                    "time_improvement": 27.79747247822082,
                    "length_improvement": 19.04393430117916,
                    "smoothness_improvement": 1236.4988398509943,
                    "objective_score": 18.33052280295705
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* path planner using adaptive informed sampling, dynamic neighborhood rewiring, incremental tree connection with recursive cost updates, and randomized shortcut smoothing. It maintains two trees from start and goal, alternately growing and attempting to connect while enforcing collision-free expansions and edges. Sampling switches from uniform to ellipsoidal informed sampling upon finding an initial solution to focus search and accelerate convergence. The planner stops when a valid path is found or a 30-second timeout occurs, returning the best feasible and smoothed path.",
          "planning_mechanism": "The planner grows two RRT* trees bidirectionally, sampling points with goal bias initially and switching to adaptive informed ellipsoidal sampling after a first solution. Each iteration extends and rewires one tree toward a sample, then incrementally attempts to connect and rewire the opposite tree to minimize overall cost. Costs and parent-child relations propagate recursively for consistency. After connecting, the path is smoothed by randomized shortcutting. The process continues within a 30-second limit, aiming for efficient, high-quality path discovery.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                # Tuple[float, ...]\n        self.parent = None                      # Node or None\n        self.cost = cost                        # Cost from root\n        self.children = []                      # List[Node]\n        self.valid = True                       # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        dist_func = self._dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path, node = [], self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=30.0, max_planning_time: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            res = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, res)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, (time.perf_counter() - start_time) / self.max_planning_time)\n            r = r * (1.0 - 0.6 * iteration_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s],[s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B): return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s): return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim -1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n                radius = adaptive_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials=None):\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start_tree = True\n        iter_num = 0\n\n        while iter_num < self.max_iter:\n            iter_num += 1\n            if (time.perf_counter() - start_time) > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_point = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_point = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_point = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_point, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iter_num)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed = path_smoothing(best_path)\n                        return self._build_result(True, smoothed, tree_start + tree_goal)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_point, iter_num)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iter_num)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        smoothed = path_smoothing(best_path)\n                        return self._build_result(True, smoothed, tree_start + tree_goal)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or no path found\n        success = len(best_path) > 0\n        final_path = path_smoothing(best_path) if success else []\n        return self._build_result(success, final_path, tree_start + tree_goal)\n\n    def _build_result(self, success, path, nodes):\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.08575,
          "time_improvement": 39.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1624.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017873263359069823,
                    "num_nodes_avg": 62.4,
                    "path_length_avg": 158.33186618364329,
                    "smoothness_avg": 0.04184557767687193,
                    "success_improvement": 0.0,
                    "time_improvement": 28.001724902950205,
                    "length_improvement": 13.215795215771697,
                    "smoothness_improvement": 554.9741597693817,
                    "objective_score": 13.81854731288631
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03201124668121338,
                    "num_nodes_avg": 211.8,
                    "path_length_avg": 238.7871492870861,
                    "smoothness_avg": 0.1184622162992659,
                    "success_improvement": 0.0,
                    "time_improvement": 79.9477519556053,
                    "length_improvement": 20.285976460968197,
                    "smoothness_improvement": 2948.118150265654,
                    "objective_score": 42.7821116302035
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044910764694213866,
                    "num_nodes_avg": 238.6,
                    "path_length_avg": 125.18961460868972,
                    "smoothness_avg": 0.11549678369761525,
                    "success_improvement": 0.0,
                    "time_improvement": 8.133415460965729,
                    "length_improvement": 16.855018865748956,
                    "smoothness_improvement": 1369.1105635478825,
                    "objective_score": 12.656581229178922
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling biased by the current best path, incremental tree extension and rewiring, and randomized path smoothing. It maintains two trees growing from start and goal, alternately sampling and extending them with careful collision checks and rewiring for cost optimization. The planner enforces a strict 30-second time limit, returning the best path found so far, and applies path smoothing with shortcut attempts to improve path quality and smoothness before returning.",
          "planning_mechanism": "The planner grows two trees bidirectionally, samples points with goal bias and later ellipsoidal informed sampling, extends the closer tree towards samples while adaptively rewiring neighbors to minimize cost, then incrementally connects to the opposite tree. Upon connection, it extracts the path, attempts randomized shortcut smoothing, and returns. Timing is strictly enforced to terminate early if necessary, ensuring efficient convergence to high-quality, collision-free paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other):\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            c.update_parent(self, new_cost + c._distance(self))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0\n        self.goal_sample_rate = 0.15\n        self.neighbor_radius_min = 5.0\n        self.neighbor_radius_max = 30.0\n        self.smoothing_trials = 100\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_p, to_p):\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = 30.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, val))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= r2]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                arbitrary = (1.0, 0.0, 0.0) if abs(vx) < 0.9 else (0.0, 1.0, 0.0)\n                wx = vy * arbitrary[2] - vz * arbitrary[1]\n                wy = vz * arbitrary[0] - vx * arbitrary[2]\n                wz = vx * arbitrary[1] - vy * arbitrary[0]\n                norm_w = math.sqrt(wx * wx + wy * wy + wz * wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n                ux, uy, uz = vx, vy, vz\n                vx_, vy_, vz_ = wx, wy, wz\n                wx_, wy_, wz_ = uy * wz - uz * vy_, uz * vx_ - ux * wz, ux * vy_ - uy * vx_\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                r = random.random() ** (1.0 / n)\n                sample_unit = tuple(r * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            n_radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            current_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n                min_cost = current_node.cost + math.dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, step_pos)\n                    if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n                if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n                current_node = connect_node\n\n        def path_smoothing(path, max_trials):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        # Initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        best_path_nodes = []\n        best_path_cost = math.inf\n        informed_sampling_enabled = False\n        grow_start = True\n\n        start_time = time.perf_counter()\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                if best_path_nodes:\n                    smoothed = path_smoothing(best_path_nodes, self.smoothing_trials)\n                    all_nodes = tree_start + tree_goal\n                    edges = [(n, c) for n in all_nodes for c in n.children]\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n                else:\n                    all_nodes = tree_start + tree_goal\n                    edges = [(n, c) for n in all_nodes for c in n.children]\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect(new_node, other_tree)\n            if connect_node is not None:\n                if grow_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = 0.0\n                for i in range(len(combined_path) - 1):\n                    total_cost += math.dist(combined_path[i], combined_path[i + 1])\n\n                if total_cost + 1e-9 < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = combined_path\n                    informed_sampling_enabled = True\n\n                smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n                all_nodes = tree_start + tree_goal\n                edges = [(n, c) for n in all_nodes for c in n.children]\n                return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached\n        if best_path_nodes:\n            smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n            all_nodes = tree_start + tree_goal\n            edges = [(n, c) for n in all_nodes for c in n.children]\n            return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n        all_nodes = tree_start + tree_goal\n        edges = [(n, c) for n in all_nodes for c in n.children]\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.88229,
          "time_improvement": 39.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1574.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020860981941223145,
                    "num_nodes_avg": 89.3,
                    "path_length_avg": 159.08698058819144,
                    "smoothness_avg": 0.03914849245077623,
                    "success_improvement": 0.0,
                    "time_improvement": 15.966397046535882,
                    "length_improvement": 12.801905045085405,
                    "smoothness_improvement": 512.758919166674,
                    "objective_score": 9.914094718811215
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036894488334655764,
                    "num_nodes_avg": 240.0,
                    "path_length_avg": 241.4222685105834,
                    "smoothness_avg": 0.10600823399426891,
                    "success_improvement": 0.0,
                    "time_improvement": 76.88882788836446,
                    "length_improvement": 19.406297816463443,
                    "smoothness_improvement": 2627.6682153172073,
                    "objective_score": 40.086249006388066
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.037193012237548825,
                    "num_nodes_avg": 226.9,
                    "path_length_avg": 123.7347017146401,
                    "smoothness_avg": 0.13217299626111334,
                    "success_improvement": 0.0,
                    "time_improvement": 23.920355704334682,
                    "length_improvement": 17.82130273446963,
                    "smoothness_improvement": 1581.2307564456075,
                    "objective_score": 18.646521040422368
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner is an adaptive bidirectional RRT* that combines informed ellipsoidal sampling, adaptive rewiring radius, recursive parent-child cost update, and aggressive path smoothing with early stopping on improved solution or timeout. It ensures robust collision checks for nodes and edges, clamps samples within bounds, and dynamically alternates tree growth to efficiently explore and optimize diverse environments in 2D and 3D.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling points biased by goal and informed ellipsoid regions once a solution is found. It extends and rewires trees adaptively using neighbors within a dynamically computed radius, incrementally connects opposite trees, and recursively updates node costs upon rewiring. The planning halts early if a better path is found or when a 30-second timeout occurs. Finally, randomized shortcut path smoothing improves solution quality before returning results.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position               # Tuple[float, ...]\n        self.parent = None                     # Node or None\n        self.cost = 0.0                       # Path cost from root\n        self.children = []                    # List[Node]\n        self.valid = True                     # For collision validity\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Update children costs recursively\n        for c in self.children:\n            c.update_parent(self, self.cost + self._distance(self.position, c.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, max_planning_time=30.0,\n                 goal_sample_rate=0.15, min_neighbor_radius=8.0, max_neighbor_radius=25.0,\n                 smoothing_trials=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma_rrt = 35.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling_active = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if (not collision_free_node(new_pos)) or (not collision_free_edge(nearest.position, new_pos)):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors with better cost via new node, recursively updating costs\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_node: Node) -> Node:\n            if not tree or not target_node:\n                return None\n            curr = min(tree, key=lambda n: dist_func(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                new_pos = clamp_to_bounds(new_pos)\n                if (not collision_free_node(new_pos)) or (not collision_free_edge(curr.position, new_pos)):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr.cost + dist_func(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                curr = new_node\n\n        def path_smoothing(path: list, trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample = informed_sample(best_cost) if informed_sampling_active else (\n                goal_pos if random.random() < self.goal_sample_rate else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node)\n                if connected_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        nodes = tree_start + tree_goal\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node)\n                if connected_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed = path_smoothing(best_path, self.smoothing_trials)\n                        nodes = tree_start + tree_goal\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        success_state = len(best_path) > 0\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        nodes = tree_start + tree_goal\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        if distance < 1e-10:\n            return self._is_in_obstacle(from_pos, obstacles, is_3d)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.73865,
          "time_improvement": 39.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1540.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01798059940338135,
                    "num_nodes_avg": 67.5,
                    "path_length_avg": 157.10433853063077,
                    "smoothness_avg": 0.0496016703497942,
                    "success_improvement": 0.0,
                    "time_improvement": 27.56934666899727,
                    "length_improvement": 13.888622573808274,
                    "smoothness_improvement": 676.3738527254302,
                    "objective_score": 14.430397779087986
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04592099189758301,
                    "num_nodes_avg": 299.0,
                    "path_length_avg": 236.6922891821887,
                    "smoothness_avg": 0.10498414874586684,
                    "success_improvement": 0.0,
                    "time_improvement": 71.2345123841934,
                    "length_improvement": 20.9853010611878,
                    "smoothness_improvement": 2601.317764257032,
                    "objective_score": 38.574002748780735
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04070703983306885,
                    "num_nodes_avg": 287.4,
                    "path_length_avg": 124.42178648690597,
                    "smoothness_avg": 0.1135046675895806,
                    "success_improvement": 0.0,
                    "time_improvement": 16.73228586463474,
                    "length_improvement": 17.364973744191616,
                    "smoothness_improvement": 1343.7709936963972,
                    "objective_score": 15.211535476710731
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation presents an enhanced bidirectional RRT* planner with adaptive neighbor radius, informed ellipsoidal sampling, incremental connect and rewire steps, and path shortcut smoothing. The planner dynamically balances exploration and exploitation, performing collision checks on nodes and edges, and halts after 30 seconds or upon finding an improved feasible path. Recursive cost updates and explicit parent-child relationships ensure tree consistency and quick convergence to smooth, low-cost solutions.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal by sampling informed points within an ellipsoidal region once an initial path is found. Nodes are added with careful collision validation, rewired using neighbors within a dynamically computed radius to optimize paths locally, and connected incrementally to the opposite tree. The algorithm performs early exits on improved solutions or timeout, followed by randomized path shortcut smoothing to enhance solution quality.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node'] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children: List['Node'] = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional['Node'], new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update cost for children\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n        self.min_neighbor_radius = 8.0\n        self.max_neighbor_radius = 20.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(src: Tuple[float, ...], tgt: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p: Tuple[float, ...]) -> bool:\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r = self.max_neighbor_radius * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos)**2 <= radius_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best: float, c_min: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            r = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_node: Node) -> Optional[Node]:\n            curr = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n                r = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_tree: List[Node] = [Node(start_pos, cost=0.0)]\n        goal_tree: List[Node] = [Node(goal_pos, cost=0.0)]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        c_min = dist(start_pos, goal_pos)\n        grow_start_tree = True\n\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            sample = informed_sample(best_cost, c_min) if informed_sampling_active else (\n                goal_pos if random.random() < 0.2 else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # Early termination on improved feasible path\n                        smoothed = path_smoothing(best_path)\n                        # Collect nodes and edges for return\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed = path_smoothing(best_path)\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            success_state = True\n            smoothed = path_smoothing(best_path)\n        else:\n            success_state = False\n            smoothed = []\n\n        nodes = start_tree + goal_tree\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.6335,
          "time_improvement": 42.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1362.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014331412315368653,
                    "num_nodes_avg": 73.8,
                    "path_length_avg": 157.60831825929054,
                    "smoothness_avg": 0.03375109906189614,
                    "success_improvement": 0.0,
                    "time_improvement": 42.26924620972745,
                    "length_improvement": 13.612383298460001,
                    "smoothness_improvement": 428.2779920033616,
                    "objective_score": 17.544640482627045
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06457438468933105,
                    "num_nodes_avg": 351.2,
                    "path_length_avg": 245.5500092889095,
                    "smoothness_avg": 0.08948971390908934,
                    "success_improvement": 0.0,
                    "time_improvement": 59.549792233972795,
                    "length_improvement": 18.028339134227505,
                    "smoothness_improvement": 2202.6347957164326,
                    "objective_score": 32.4837794756195
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03742551803588867,
                    "num_nodes_avg": 248.6,
                    "path_length_avg": 123.79261055925981,
                    "smoothness_avg": 0.12236051620731514,
                    "success_improvement": 0.0,
                    "time_improvement": 23.44475673102762,
                    "length_improvement": 17.78284243719607,
                    "smoothness_improvement": 1456.4167344432315,
                    "objective_score": 17.87207917896366
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an efficient bidirectional RRT* path planner with adaptive neighbor radius and informed ellipsoidal sampling to focus the search after an initial solution is found. It grows two trees alternately from start and goal positions, incrementally extends and rewires connections while ensuring collision-free expansion and edges. The planner enforces a strict 30-second max planning time and applies post-processing path smoothing for improved path quality and smoothness.",
          "planning_mechanism": "The planner samples points biased towards the goal or within an informed ellipsoid once a solution is found, extends one tree towards these samples with adaptive rewiring to optimize path costs, then tries to incrementally connect the other tree to the new node. This alternating bidirectional growth rapidly attempts to connect the trees with cost improvements. When a connection is found, the combined path is smoothed. The procedure repeats until time or iteration limits are reached, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n        rotation_mat = None\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            nonlocal rotation_mat\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0]*sample_scaled[0] + rotation_mat[0][1]*sample_scaled[1]\n                    y_rot = rotation_mat[1][0]*sample_scaled[0] + rotation_mat[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = rotation_mat[0][0]*sample_scaled[0] + rotation_mat[0][1]*sample_scaled[1] + rotation_mat[0][2]*sample_scaled[2]\n                    y_rot = rotation_mat[1][0]*sample_scaled[0] + rotation_mat[1][1]*sample_scaled[1] + rotation_mat[1][2]*sample_scaled[2]\n                    z_rot = rotation_mat[2][0]*sample_scaled[0] + rotation_mat[2][1]*sample_scaled[1] + rotation_mat[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected = incremental_connect(tree_goal, new_node.position)\n                if connected:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected.cost + dist_func(new_node.position, connected.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    return self._build_result(True, smoothed_path, tree_start, tree_goal)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected = incremental_connect(tree_start, new_node.position)\n                if connected:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected.cost + dist_func(new_node.position, connected.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    return self._build_result(True, smoothed_path, tree_start, tree_goal)\n\n            grow_start = not grow_start\n\n        success = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success else []\n        return self._build_result(success, smoothed, tree_start, tree_goal)\n\n    def _build_result(self, success: bool, path: list, tree_start: list, tree_goal: list):\n        nodes = tree_start + tree_goal\n        edges = []\n        for node in nodes:\n            for child in node.children:\n                edges.append((node, child))\n        return PlannerResult(success, path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.58295,
          "time_improvement": 41.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1357.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021058201789855957,
                    "num_nodes_avg": 89.0,
                    "path_length_avg": 163.17042507617967,
                    "smoothness_avg": 0.041117326893017725,
                    "success_improvement": 0.0,
                    "time_improvement": 15.171942859228329,
                    "length_improvement": 10.563704414900396,
                    "smoothness_improvement": 543.5754535801748,
                    "objective_score": 9.382201008649453
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03521578311920166,
                    "num_nodes_avg": 228.5,
                    "path_length_avg": 240.09732672203876,
                    "smoothness_avg": 0.09139994434168228,
                    "success_improvement": 0.0,
                    "time_improvement": 77.94038997555614,
                    "length_improvement": 19.848601521814498,
                    "smoothness_improvement": 2251.7864006304158,
                    "objective_score": 38.610769300181815
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03371152877807617,
                    "num_nodes_avg": 242.1,
                    "path_length_avg": 119.99668771457057,
                    "smoothness_avg": 0.10821661510678496,
                    "success_improvement": 0.0,
                    "time_improvement": 31.041855343197433,
                    "length_improvement": 20.303913648216895,
                    "smoothness_improvement": 1276.5073564386694,
                    "objective_score": 19.755876114795957
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements a bidirectional RRT* with adaptive neighbor radius and ellipsoidal informed sampling after obtaining an initial solution. It alternates tree growth from start and goal, performs incremental connection attempts, rewires neighbors to minimize path costs, maintains consistent parent-child cost propagation, and applies randomized path smoothing. The planner strictly enforces a 30-second planning time limit to ensure timely outputs while optimizing path quality, success rate, and efficiency.",
          "planning_mechanism": "The planner grows two trees from start and goal positions with goal bias sampling initially and switches to focused ellipsoidal informed sampling after a first path is found. Each extension utilizes adaptive neighbor radius for efficient rewiring and cost optimization. Incremental connects bridge the two trees progressively. Once connected, the combined path is smoothed and returned. The planning process terminates early if time expires or a high-quality path is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # Child nodes list\n        self.valid = True                 # Flag for collision/validity\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        for c in self.children:\n            c.cost = self.cost + math.dist(self.position, c.position)\n            c._update_cost_recursive()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(f_pos, t_pos, resolution=None):\n            if resolution is None:\n                resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(f_pos, t_pos, obstacles, is_3d, resolution=resolution)\n\n        def sample_free():\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(s):\n                    return s\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                R = ((cos_a, -sin_a), (sin_a, cos_a))\n            else:\n                ux, uy, uz = direction\n                if abs(ux) < 1e-10 and abs(uy) < 1e-10:\n                    vx_, vy_, vz_ = 1,0,0\n                else:\n                    vx_, vy_, vz_ = -uy, ux, 0\n                norm_v_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                vx_ /= norm_v_\n                vy_ /= norm_v_\n                vz_ /= norm_v_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                R = [\n                    [ux, vx_, wx],\n                    [uy, vy_, wy],\n                    [uz, vz_, wz]\n                ]\n\n            a1 = c_best / 2.0\n            if dim == 2:\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def adaptive_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return 50.0\n            gamma_rrt = 30.0\n            radius = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(5.0, min(30.0, radius))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos)**2 <= r_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend_and_rewire(tree, sample):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            current = min(tree, key=lambda n: dist(n.position, target_pos))\n\n            while True:\n                if time.perf_counter() - start_time > self.max_planning_time:\n                    return None\n\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp(new_pos)\n\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                rewire(tree, new_node, neighbors)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path, max_trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        grow_start_tree = True\n        iter_count = 0\n        success_state = False\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                if best_path:\n                    smooth = path_smoothing(best_path)\n                    return PlannerResult(True, smooth, all_nodes, edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            iter_count += 1\n\n            if informed_sampling_enabled:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < 0.15:\n                    sample = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect_and_rewire(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_s = new_node.path_from_root()\n                    path_g = connected_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect_and_rewire(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_g = new_node.path_from_root()\n                    path_s = connected_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined = path_s + path_g[::-1]\n\n                    total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined\n                        informed_sampling_enabled = True\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smooth_path = path_smoothing(best_path)\n                    success_state = True\n                    return PlannerResult(success_state, smooth_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # End of iterations: return best found\n        if best_path:\n            smooth = path_smoothing(best_path)\n            return PlannerResult(True, smooth, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.32201,
          "time_improvement": 38.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1529.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018084025382995604,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 163.42026939025394,
                    "smoothness_avg": 0.04123798637691558,
                    "success_improvement": 0.0,
                    "time_improvement": 27.15271921922211,
                    "length_improvement": 10.426760787319784,
                    "smoothness_improvement": 545.4640365194392,
                    "objective_score": 12.958488105827787
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.041797828674316403,
                    "num_nodes_avg": 231.6,
                    "path_length_avg": 237.12705999560572,
                    "smoothness_avg": 0.0989455505215591,
                    "success_improvement": 0.0,
                    "time_improvement": 73.8173137509702,
                    "length_improvement": 20.8401620494852,
                    "smoothness_improvement": 2445.940282519098,
                    "objective_score": 38.54292794778359
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041822290420532225,
                    "num_nodes_avg": 233.1,
                    "path_length_avg": 126.84215867670358,
                    "smoothness_avg": 0.13329969369493913,
                    "success_improvement": 0.0,
                    "time_improvement": 14.451000674480504,
                    "length_improvement": 15.757477781466452,
                    "smoothness_improvement": 1595.562264639718,
                    "objective_score": 15.464607081836032
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner implements a bidirectional RRT* with adaptive informed sampling after an initial solution, incremental extend-and-rewire steps for path optimization, and path smoothing. It grows two trees from start and goal, alternately extending them with goal bias and ellipsoidal informed sampling. The algorithm efficiently rewires local neighborhoods to minimize cost, performs robust collision checking, and enforces a strict 30-second planning time limit to guarantee timely output.",
          "planning_mechanism": "The planner samples configurations biased towards the goal or via informed ellipsoids after finding a solution, then extends one tree toward the sample, rewires the neighborhood to reduce path costs, and incrementally attempts to connect the two trees. Upon connection, it extracts and smooths the combined path. The planning loop respects the time limit, returning the best solution found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.71824,
          "time_improvement": 37.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1366.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02254364490509033,
                    "num_nodes_avg": 96.7,
                    "path_length_avg": 159.55648446985919,
                    "smoothness_avg": 0.04460211395919851,
                    "success_improvement": 0.0,
                    "time_improvement": 9.188181533550138,
                    "length_improvement": 12.544562527778217,
                    "smoothness_improvement": 598.1199385021376,
                    "objective_score": 8.255966658131374
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.038587307929992674,
                    "num_nodes_avg": 248.5,
                    "path_length_avg": 235.24109191110043,
                    "smoothness_avg": 0.09333894379068908,
                    "success_improvement": 0.0,
                    "time_improvement": 75.8284243758693,
                    "length_improvement": 21.46975248067449,
                    "smoothness_improvement": 2301.6782530582127,
                    "objective_score": 38.55086907418675
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035490679740905764,
                    "num_nodes_avg": 213.6,
                    "path_length_avg": 119.46007876775484,
                    "smoothness_avg": 0.10212397521226743,
                    "success_improvement": 0.0,
                    "time_improvement": 27.402538055964808,
                    "length_improvement": 20.660303760119735,
                    "smoothness_improvement": 1199.0094266923038,
                    "objective_score": 18.34786930227491
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias and informed sampling after an initial solution. It uses an adaptive neighbor radius and incremental extend-and-rewire expansions to optimize path cost dynamically. The planner alternates growth between start and goal trees, tries connecting them incrementally, and performs path smoothing to improve path quality. Strict 30-second time enforcement ensures timely returns.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, sampling points with a bias towards the goal and later with informed sampling inside an ellipsoidal region. Each extension attempts to connect incrementally to the opposite tree, rewiring neighbors for cost improvements. Upon connecting paths, it combines, smooths, and returns the best path found. The process halts on time or iteration limits, returning the best feasible solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = 0.0                # Cost-to-come\n        self.children = []\n        self.valid = True              # Collision validity\n        if parent:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update recursively to children\n        for c in self.children:\n            c.update_parent(self, self.cost + self._dist(self.position, c.position))\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size / 5, 0.5))\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def sample_free():\n            attempt = 0\n            while True:\n                attempt += 1\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                if attempt > 1000:  # fallback to goal or start\n                    return random.choice([start_pos, goal_pos])\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                aminor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, aminor, aminor]\n\n            n = dim\n            for _ in range(100):\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n            # fallback:\n            return sample_free()\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                new_cost = nbr.cost + dist(nbr.position, new_pos)\n                if new_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = new_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    new_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if new_cost < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = new_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials=150):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start_tree = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            curr_time = time.perf_counter()\n            if curr_time - start_time > self.max_time_sec:\n                break\n\n            iter_count += 1\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                # Goal bias toward opposite root in alternate tree\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    # Build edges from both trees\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    smoothed_path = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or max iterations reached\n        success_state = best_path != []\n        if success_state:\n            best_path = path_smoothing(best_path)\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(success_state, best_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.18014,
          "time_improvement": 36.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1383.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01807126998901367,
                    "num_nodes_avg": 70.5,
                    "path_length_avg": 158.04660799724533,
                    "smoothness_avg": 0.04278370756020367,
                    "success_improvement": 0.0,
                    "time_improvement": 27.204101350533712,
                    "length_improvement": 13.372149747941641,
                    "smoothness_improvement": 569.6579296251715,
                    "objective_score": 13.6839500028743
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04615936279296875,
                    "num_nodes_avg": 241.3,
                    "path_length_avg": 236.0424315626298,
                    "smoothness_avg": 0.09393733045872209,
                    "success_improvement": 0.0,
                    "time_improvement": 71.08519385347697,
                    "length_improvement": 21.20224223971101,
                    "smoothness_improvement": 2317.0751730271977,
                    "objective_score": 37.15138246912128
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04373712539672851,
                    "num_nodes_avg": 236.5,
                    "path_length_avg": 126.18497915625451,
                    "smoothness_avg": 0.10701401676986044,
                    "success_improvement": 0.0,
                    "time_improvement": 10.53413685760367,
                    "length_improvement": 16.193945127422804,
                    "smoothness_improvement": 1261.210394359565,
                    "objective_score": 12.705082054563487
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive informed sampling and dynamic neighborhood rewiring. It grows two trees from start and goal points, alternately extending them towards sampled points focused by ellipsoidal informed regions once a path is found. The planner enforces strict time limits and integrates efficient collision checking, adaptive neighbor radius, incremental connection attempts, and iterative path shortcut smoothing to quickly discover smooth, low-cost paths with high success rate and robustness.",
          "planning_mechanism": "The planner initializes separate start and goal trees. It samples points either uniformly or within an informed ellipsoidal region defined by the current best cost to bias samples closer to optimal paths. Trees are extended towards these samples stepwise, checking collisions for nodes and edges. Nearby nodes are dynamically rewired to reduce path costs. Periodic incremental connection attempts between the two trees check for possible path merges. When a connection is found, the combined path is extracted, smoothed via shortcutting, and updated as the current best. The process repeats until hitting the iteration or 30-seconds time limit, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = 0.0                    # cost from root to this node\n        self.children = []                 # List of child nodes\n        self.valid = True                  # for collision checking\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # propagate cost updates recursively\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float=5.0,\n                 goal_sample_rate: float=0.18,\n                 neighbor_radius_min: float=7.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = max(self.step_size / 5.0, 0.1)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 32.0\n            radius = gamma_rrt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos)**2) <= r_sq]\n\n        def uniform_sample():\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos\n\n        def rotation_matrix(direction):\n            # Returns rotation matrix to align x-axis with given direction vector (normalized)\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = max(0.0, math.sqrt(1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        use_informed_sampling = False\n        rotation_mat = None\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(rotation_mat[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(rotation_mat[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(rotation_mat[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample_pt: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp_bounds(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_node.position))\n            current_node = nearest\n\n            while True:\n                new_pos = steer(current_node.position, target_node.position)\n                new_pos = clamp_bounds(new_pos)\n\n                if not collision_free_node(new_pos) or not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current_node.cost + dist_func(current_node.position, new_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr is current_node:\n                        continue\n                    candidate_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if candidate_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = candidate_cost\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist_func(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n\n                current_node = new_node\n\n        def shortcut_smoothing(path: list, trials: int) -> list:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Timeout reached return best so far\n                success = len(best_path) > 0\n                final_path = shortcut_smoothing(best_path, self.smoothing_trials) if success else []\n                # update edges for all nodes\n                all_nodes = tree_start + tree_goal\n                edges.clear()\n                for node in all_nodes:\n                    for c in node.children:\n                        edges.append((node, c))\n                return PlannerResult(success, final_path, all_nodes, edges)\n\n            if use_informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            active_tree = tree_start if grow_start_tree else tree_goal\n            other_tree = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n            all_nodes.append(new_node)\n\n            connect_node = incremental_connect(other_tree, new_node)\n            if connect_node is not None:\n                if grow_start_tree:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                else:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n\n                combined_path = path_start + path_goal[::-1]\n                total_cost = 0.0\n                for i in range(len(combined_path) - 1):\n                    total_cost += dist_func(combined_path[i], combined_path[i+1])\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    use_informed_sampling = True\n                    rotation_mat = None\n\n                    edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n\n                    smoothed_path = shortcut_smoothing(best_path, self.smoothing_trials)\n                    return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # Max iteration reached: return best found\n        success = len(best_path) > 0\n        final_path = shortcut_smoothing(best_path, self.smoothing_trials) if success else []\n        all_nodes = tree_start + tree_goal\n        edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success, final_path, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.64603,
          "time_improvement": 34.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1496.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021890473365783692,
                    "num_nodes_avg": 91.1,
                    "path_length_avg": 170.52800321464045,
                    "smoothness_avg": 0.03776836492058003,
                    "success_improvement": 0.0,
                    "time_improvement": 11.819330822171725,
                    "length_improvement": 6.530899248923612,
                    "smoothness_improvement": 491.1569263242031,
                    "objective_score": 7.307763728057256
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039145469665527344,
                    "num_nodes_avg": 254.4,
                    "path_length_avg": 237.38622705969738,
                    "smoothness_avg": 0.10367946633425915,
                    "success_improvement": 0.0,
                    "time_improvement": 75.47878483570109,
                    "length_improvement": 20.75364462378108,
                    "smoothness_improvement": 2567.747346081609,
                    "objective_score": 39.63310110587459
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041261935234069826,
                    "num_nodes_avg": 232.2,
                    "path_length_avg": 126.68539239301076,
                    "smoothness_avg": 0.12021668632673113,
                    "success_improvement": 0.0,
                    "time_improvement": 15.597227363327478,
                    "length_improvement": 15.86159448268698,
                    "smoothness_improvement": 1429.147376603264,
                    "objective_score": 14.99722398855196
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner implements a bidirectional RRT* variant with adaptive neighbor radius scaling, goal-biased and ellipsoidal informed sampling after a first solution, incremental grow-and-rewire extensions on alternating trees, recursive cost updates across parent-child links, strict collision and boundary checks on nodes and edges, and aggressive randomized shortcut path smoothing. It balances rapid early feasible path discovery with continuous path cost improvement within a strict 30-second time limit to ensure efficient, robust, and high-quality planning in 2D and 3D environments.",
          "planning_mechanism": "The planner initializes start and goal trees, alternately samples points biased initially toward goals and later inside an ellipsoidal informed set defined by the best path cost, incrementally extends and rewires nodes with adaptive radius neighbors considering collision-free edges, connects trees via incremental greedy attempts, recursively updates subtree costs upon rewiring, and applies randomized shortcut smoothing on discovered paths. It monitors elapsed time to terminate at 30 seconds at latest, returning the best feasible solution found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...], e.g. (x, y) or (x, y, z)\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children = []                # List of child nodes\n        self.valid = True                 # Validity flag for collision checks\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Avoid unnecessary updates if cost and parent are the same\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update children costs\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.18,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_position(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0  # constant tuning parameter\n            base = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            progress = min(1.0, iter_num / self.max_iter)\n            radius = base * (1.0 - 0.6 * progress)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= radius_sq]\n\n        def uniform_sample():\n            attempts = 0\n            while attempts < 100:\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n                attempts += 1\n            return start_pos  # fallback if no valid found\n\n        def unit_ball_sample(n):\n            while True:\n                vec = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in vec)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in vec)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ux, uy, uz = vx/norm_v, vy/norm_v, vz/norm_v\n                kx, ky, kz = 0.0, -uz, uy\n                k_norm = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if k_norm < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= k_norm\n                ky /= k_norm\n                kz /= k_norm\n                cos_theta = ux\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    result = []\n                    for i in range(3):\n                        row = []\n                        for j in range(3):\n                            val = 0\n                            for k in range(3):\n                                val += A[i][k]*B[k][j]\n                            row.append(val)\n                        result.append(row)\n                    return result\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n\n            for _ in range(100):\n                dir_sample = unit_ball_sample(dim)\n                r = random.random() ** (1.0 / dim)\n                ellipsoid_pt = tuple(r * radii[i] * dir_sample[i] for i in range(dim))\n\n                if dim == 2:\n                    x_rot = R[0][0] * ellipsoid_pt[0] + R[0][1] * ellipsoid_pt[1]\n                    y_rot = R[1][0] * ellipsoid_pt[0] + R[1][1] * ellipsoid_pt[1]\n                    sample_pt = (center[0] + x_rot, center[1] + y_rot)\n                else:\n                    x_rot = sum(R[0][i] * ellipsoid_pt[i] for i in range(dim))\n                    y_rot = sum(R[1][i] * ellipsoid_pt[i] for i in range(dim))\n                    z_rot = sum(R[2][i] * ellipsoid_pt[i] for i in range(dim))\n                    sample_pt = (center[0] + x_rot, center[1] + y_rot, center[2] + z_rot)\n\n                clamped = clamp_position(sample_pt)\n                if collision_free_node(clamped):\n                    return clamped\n            return uniform_sample()\n\n        def extend_and_rewire(tree, sample, iter_num):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_position(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors if cost improvement possible\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, new_cost)\n\n            return new_node\n\n        def incremental_connect(tree, target_pos, iter_num):\n            if not tree:\n                return None\n            closest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = closest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_position(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(tree) + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_via_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_via_new)\n\n                dist_to_target = dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            path_copy = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(path_copy) < 3:\n                    break\n                i = random.randint(0, len(path_copy)-3)\n                j = random.randint(i+2, len(path_copy)-1)\n                if collision_free_edge(path_copy[i], path_copy[j]):\n                    path_copy = path_copy[:i+1] + path_copy[j:]\n            return path_copy\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_rate else uniform_sample()\n            )\n\n            active_tree = tree_start if grow_start_tree else tree_goal\n            other_tree = tree_goal if grow_start_tree else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt, iteration)\n            if new_node is None:\n                grow_start_tree = not grow_start_tree\n                continue\n\n            connect_node = incremental_connect(other_tree, new_node.position, iteration)\n            if connect_node is not None:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                candidate_path = path_a + path_b[::-1]\n\n                candidate_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                if candidate_cost + 1e-12 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    informed_sampling = True\n\n                    best_path = path_smoothing(best_path)\n\n                    # Early return on improvement with path smoothing\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n\n                    return PlannerResult(True, best_path, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        success = len(best_path) > 0\n        final_path = path_smoothing(best_path) if success else []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for node in nodes_all:\n            for c in node.children:\n                edges_all.append((node, c))\n\n        return PlannerResult(success, final_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.8234,
          "time_improvement": 31.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1433.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024420332908630372,
                    "num_nodes_avg": 87.4,
                    "path_length_avg": 159.10169486115404,
                    "smoothness_avg": 0.04317897029111069,
                    "success_improvement": 0.0,
                    "time_improvement": 1.6283813764264545,
                    "length_improvement": 12.793839918912026,
                    "smoothness_improvement": 575.8446496906244,
                    "objective_score": 5.926505645163463
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04494657516479492,
                    "num_nodes_avg": 289.5,
                    "path_length_avg": 238.00096486397288,
                    "smoothness_avg": 0.09725334613004774,
                    "success_improvement": 0.0,
                    "time_improvement": 71.84489929661385,
                    "length_improvement": 20.548427450467305,
                    "smoothness_improvement": 2402.398644679954,
                    "objective_score": 37.675148502477384
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03951718807220459,
                    "num_nodes_avg": 270.2,
                    "path_length_avg": 124.09589233476706,
                    "smoothness_avg": 0.11167362252198457,
                    "success_improvement": 0.0,
                    "time_improvement": 19.166170438246507,
                    "length_improvement": 17.581417122630384,
                    "smoothness_improvement": 1320.4802355902639,
                    "objective_score": 15.868535733951349
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner with goal-biased and adaptive informed sampling, efficient incremental extension and rewiring strategies, and recursive cost updates. It dynamically adjusts neighbor search radius based on node count and dimension, alternates growth of start and goal trees, and applies aggressive path smoothing. A strict 30-second time limit halts planning early, returning the best discovered path while maintaining collision safety checks.",
          "planning_mechanism": "The planner grows two trees from the start and goal positions, alternately extending toward samples that are initially uniform but become goal- and solution-cost informed after an initial solution is found. Extensions use adaptive neighbor radius to locally optimize paths via rewiring. Incremental connection attempts improve tree linkage efficiency. Upon discovering better paths, early exit and smoothing reduce overall path length and complexity. Timeouts ensure responsiveness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 min_neighbor_radius: float = 8.0,\n                 max_neighbor_radius: float = 25.0,\n                 max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            factor = self.step_size / dist_\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma_rrt = 25.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def near(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (math.dist(n.position, pos) ** 2) <= radius_sq]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1.0 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A,s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mul(K,K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(min(max(sample_pt[d], 0.0), bounds[d]) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1)\n            neighbors = near(tree, new_pos, radius)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_via_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_via_nbr\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_via_new)\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1)\n                neighbors = near(tree, new_pos, radius)\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_via_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_via_nbr\n                        best_parent = nbr\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_via_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_via_new)\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path, trials=120):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize start and goal trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        grow_start = True\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_time_sec:\n                break\n            iter_count += 1\n\n            if informed:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if not new_node:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + math.dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Timeout or max iterations exhausted\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.3732,
          "time_improvement": 28.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1514.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018894481658935546,
                    "num_nodes_avg": 80.9,
                    "path_length_avg": 160.15409781233242,
                    "smoothness_avg": 0.04496419323986507,
                    "success_improvement": 0.0,
                    "time_improvement": 23.88798503291338,
                    "length_improvement": 12.217001184979221,
                    "smoothness_improvement": 603.787265512312,
                    "objective_score": 12.628732074431419
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03914468288421631,
                    "num_nodes_avg": 237.4,
                    "path_length_avg": 235.33881654466882,
                    "smoothness_avg": 0.10408480817679344,
                    "success_improvement": 0.0,
                    "time_improvement": 75.47927768542239,
                    "length_improvement": 21.437129185141746,
                    "smoothness_improvement": 2578.1770836459445,
                    "objective_score": 39.822094560884786
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05694959163665771,
                    "num_nodes_avg": 296.5,
                    "path_length_avg": 121.78850258301281,
                    "smoothness_avg": 0.11468208198519161,
                    "success_improvement": 0.0,
                    "time_improvement": -16.492438064109287,
                    "length_improvement": 19.113875529652706,
                    "smoothness_improvement": 1358.747617900879,
                    "objective_score": 5.668781776202151
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -19.222664746243094,
          "time_improvement": 56.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01836371421813965,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 26.791944956378185,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 9.632888750165714
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034141016006469724,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 78.8061931267961,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 27.280148667759597
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017978572845458986,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 63.44687412595209,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 20.754956820803976
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a hybrid bidirectional RRT* planner with adaptive informed sampling, dynamic neighbor radius scaling based on node density and iteration progress, incremental extend-and-rewire with recursive cost propagation, and aggressive path smoothing via randomized shortcutting. It balances exploration and exploitation by switching between uniform and ellipsoidal informed sampling after finding an initial solution. It enforces strict collision checks on nodes and edges, bounds all expansions within the map limits, and dynamically manages parent-child relationships to optimize path cost and smoothness. The planner halts upon reaching a feasible path or upon hitting a 30-second runtime limit, returning the best solution found.",
          "planning_mechanism": "The planner grows two trees from start and goal positions in alternation, sampling points with goal bias and switching to informed ellipsoidal sampling when a valid path is found. Each iteration incrementally extends and rewires one tree toward the sample, then attempts incremental connection with the other tree. Adaptive neighbor radius depends on both tree size and progress to improve rewiring quality and convergence. Parent-child cost and topology updates are recursively propagated to maintain consistency. The algorithm performs randomized shortcut path smoothing after each new solution to enhance path quality while ensuring collision-free edges. It enforces a strict 30-second planning time cap and returns the best path found within this constraint.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []                # List[Node]\n        self.valid = True                 # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from current parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates to descendants recursively\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.perf_counter()\n\n        # Helper functions\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            # Use fine resolution for better collision detection\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            # Interpolate based on iteration progress (favor smaller radius at later stages)\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)  # reduce radius as iterations grow\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            rad_sq = radius * radius\n            return [node for node in tree_nodes if (math.dist(node.position, pos) ** 2) <= rad_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                point = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in point)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in point)\n\n        def rotation_matrix(direction):\n            # Returns rotation matrix aligning unit x-axis to direction vector in dim=2 or dim=3\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0],\n                            [0, 1, 0],\n                            [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        # Informed sampling returns a point inside an ellipsoid defined by start, goal, and current best cost\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree: list, sample: tuple, iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors toward new_node if cheaper\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple, iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = math.dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 150):\n            # Random shortcut smoothing with collision checks\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialization\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sample point: goal bias + informed sampling if solution found\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    # Construct combined path\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    # avoid duplicated connecting node position in concatenation\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path)\n                    return self._build_result(True, smoothed, tree_start + tree_goal)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path)\n                    return self._build_result(True, smoothed, tree_start + tree_goal)\n\n            grow_start = not grow_start\n\n        # Timeout or iteration completion with best path found\n        success = (len(best_path) > 0)\n        if success:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        return self._build_result(success, smoothed, tree_start + tree_goal)\n\n    def _build_result(self, success, path, nodes):\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.16508,
          "time_improvement": 25.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1593.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019535040855407713,
                    "num_nodes_avg": 68.4,
                    "path_length_avg": 154.075377060829,
                    "smoothness_avg": 0.04778847884688942,
                    "success_improvement": 0.0,
                    "time_improvement": 21.307641627401765,
                    "length_improvement": 15.548844352372582,
                    "smoothness_improvement": 647.9934682966013,
                    "objective_score": 12.742028700178052
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0390239953994751,
                    "num_nodes_avg": 231.3,
                    "path_length_avg": 235.9932067793355,
                    "smoothness_avg": 0.10498215270113234,
                    "success_improvement": 0.0,
                    "time_improvement": 75.55487784570309,
                    "length_improvement": 21.218674889231465,
                    "smoothness_improvement": 2601.2664045883207,
                    "objective_score": 39.916530354498825
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059827661514282225,
                    "num_nodes_avg": 303.0,
                    "path_length_avg": 121.14628597802967,
                    "smoothness_avg": 0.12802729706394325,
                    "success_improvement": 0.0,
                    "time_improvement": -22.3796335176328,
                    "length_improvement": 19.540405219614065,
                    "smoothness_improvement": 1528.497768661288,
                    "objective_score": 4.8366798319394135
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, incremental extend-and-rewire steps for efficient tree growth and connection, robust collision checking with fine discretization, and post-hoc path smoothing. It enforces a strict maximum planning time of 30 seconds to ensure timely results. The planner maintains consistent parent-child links with cost propagation and dynamically rewires nodes to improve path cost and smoothness while respecting map bounds and obstacles.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. It samples points with goal bias and switches to informed ellipsoidal sampling after finding a solution to focus search around the best cost. Each iteration extends one tree toward the sampled point, rewires neighboring nodes within an adaptive radius, then attempts to incrementally connect the other tree to the new node. Upon successful connection, combined paths are smoothed and updated as the best solution. The process terminates either when the time limit is reached or the maximum iterations are done, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = None            # type: Node or None\n        self.cost = cost              # Cost from root node\n        self.children = []            # List of child nodes\n        self.valid = True             # For collision and validity checks\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to descendants\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # Clamp to bounds\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            # Remove unnecessary intermediate points using collision checks\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sample point with goal bias or informed sampling if solution found\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Return best found path on timeout or iteration end\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    # Collision helpers same as provided\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.9314,
          "time_improvement": 31.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1274.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02140035629272461,
                    "num_nodes_avg": 96.7,
                    "path_length_avg": 165.6679199431512,
                    "smoothness_avg": 0.039374954031528714,
                    "success_improvement": 0.0,
                    "time_improvement": 13.793653202307294,
                    "length_improvement": 9.194787902974594,
                    "smoothness_improvement": 516.303534674644,
                    "objective_score": 8.558571214660327
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033504605293273926,
                    "num_nodes_avg": 226.3,
                    "path_length_avg": 242.86341383565892,
                    "smoothness_avg": 0.07872449738910461,
                    "success_improvement": 0.0,
                    "time_improvement": 79.01229331488184,
                    "length_improvement": 18.925202025885028,
                    "smoothness_improvement": 1925.63802078518,
                    "objective_score": 37.11691850356746
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04808731079101562,
                    "num_nodes_avg": 271.8,
                    "path_length_avg": 122.48458875157633,
                    "smoothness_avg": 0.11631665025974325,
                    "success_improvement": 0.0,
                    "time_improvement": 1.635676165478412,
                    "length_improvement": 18.65156824055423,
                    "smoothness_improvement": 1379.5392057018962,
                    "objective_score": 11.11871252626385
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with adaptive informed sampling, dynamic neighbor radius, incremental connection, and recursive rewiring for efficient, timely path planning within 30 seconds. It robustly checks for collisions on nodes and edges, alternates tree growth from start and goal, adapts its sampling strategy once a solution is found, and smooths the resulting path for improved quality.",
          "planning_mechanism": "The planner grows two trees from start and goal positions by sampling free configurations, using goal biasing initially and switching to adaptive informed ellipsoid sampling upon obtaining a feasible path. It extends trees incrementally with rewiring to optimize local costs, attempts connection between the trees through incremental steps, and applies randomized shortcut smoothing on the final path. Planning terminates early upon finding a suitable path or after 30 seconds, ensuring timely responses.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Propagate cost update to descendants recursively\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n        self.min_neighbor_radius = 8.0\n        self.max_neighbor_radius = 20.0\n        self.goal_sample_prob = 0.2\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(p: Tuple[float, ...]) -> bool:\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r = self.max_neighbor_radius * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos)**2 <= r_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            while True:\n                sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                vec = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in vec)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in vec)\n\n        def rotation_matrix(direction: Tuple[float, ...]):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = 0.0, -vz, vy\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0], [0,1,0], [0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_th = vx\n                sin_th = math.sqrt(max(0.0, 1 - cos_th*cos_th))\n\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_th)), mat_scale(K2, 1 - cos_th))\n\n        def informed_sample(c_best: float, c_min: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            dx = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(dx)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_samp = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_samp * d for d in dir_sample)\n                sample_ellipsoid = tuple(sample_unit[i] * radii[i] for i in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_ellipsoid[0] + R[0][1]*sample_ellipsoid[1]\n                    y_rot = R[1][0]*sample_ellipsoid[0] + R[1][1]*sample_ellipsoid[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_ellipsoid[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_ellipsoid[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_ellipsoid[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clipped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clipped):\n                    return clipped\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_via_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_via_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, new_cost)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_node: Node) -> Node:\n            curr_node = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                radius = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr is curr_node:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_via_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    return None\n\n                curr_node = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations: int=100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n        informed_sampling = False\n        c_min = dist(start_pos, goal_pos)\n        grow_start_tree = True\n\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            sample = informed_sample(best_cost, c_min) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_prob else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n                        smoothed = path_smoothing(best_path, iterations=200)\n                        nodes_all = start_tree + goal_tree\n                        edges_all = []\n                        for node in nodes_all:\n                            for child in node.children:\n                                edges_all.append((node, child))\n                        return PlannerResult(True, smoothed, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n                        smoothed = path_smoothing(best_path, iterations=200)\n                        nodes_all = start_tree + goal_tree\n                        edges_all = []\n                        for node in nodes_all:\n                            for child in node.children:\n                                edges_all.append((node, child))\n                        return PlannerResult(True, smoothed, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        success = bool(best_path)\n        final_path = path_smoothing(best_path, iterations=200) if success else []\n\n        nodes_all = start_tree + goal_tree\n        edges_all = []\n        for node in nodes_all:\n            for child in node.children:\n                edges_all.append((node, child))\n\n        return PlannerResult(success, final_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.92609,
          "time_improvement": 26.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1543.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023072171211242675,
                    "num_nodes_avg": 90.9,
                    "path_length_avg": 159.4709102413174,
                    "smoothness_avg": 0.04985970135980969,
                    "success_improvement": 0.0,
                    "time_improvement": 7.059136511278143,
                    "length_improvement": 12.591467118452396,
                    "smoothness_improvement": 680.4125983554791,
                    "objective_score": 8.038097368851318
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05931763648986817,
                    "num_nodes_avg": 312.4,
                    "path_length_avg": 237.46392627764376,
                    "smoothness_avg": 0.10719535375417381,
                    "success_improvement": 0.0,
                    "time_improvement": 62.842685505274765,
                    "length_improvement": 20.72770638838259,
                    "smoothness_improvement": 2658.213661787362,
                    "objective_score": 36.28941523819576
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04489891529083252,
                    "num_nodes_avg": 251.4,
                    "path_length_avg": 123.79819080831537,
                    "smoothness_avg": 0.10924025846401686,
                    "success_improvement": 0.0,
                    "time_improvement": 8.15765384178336,
                    "length_improvement": 17.779136301476274,
                    "smoothness_improvement": 1289.528024385166,
                    "objective_score": 12.450763534756092
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation enhances bidirectional RRT* with adaptive rewiring, goal biasing, and incremental connections under a strict 30-second time limit. It grows two trees simultaneously from start and goal, samples points biased toward the goal, and extends trees incrementally within a step size constraint. Rewiring optimizes path costs locally and collision checks ensure validity of nodes and edges. Early termination occurs upon finding a valid connection or time expiry, returning the best path found so far, thus balancing efficiency, path quality, and robustness.",
          "planning_mechanism": "The planner alternates extending two trees toward random samples with goal biasing, rewires neighbors to minimize cost, and attempts incremental connection between trees. It employs collision checking for nodes and edges, maintains a graph of nodes and edges, and cuts off computation once a connection is found or 30 seconds elapse, ensuring rapid and high-quality planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 neighbor_radius: float=15.0, max_time_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        import time, random, math\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        extracted_path = []\n        best_path_cost = float('inf')\n        best_path_nodes = (None, None)  # Tuple[Node,Node]\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position):\n            r = self.neighbor_radius\n            return [node for node in tree if math.dist(node.position, position) <= r]\n\n        def try_extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not self._within_bounds(new_pos, bounds) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via the new node if beneficial\n            for neighbor in neighbors:\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if (\n                    cost_through_new < neighbor.cost and\n                    not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                ):\n                    old_parent = neighbor.parent\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((old_parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        def try_incremental_connect(tree, target_node):\n            target_pos = target_node.position\n            current_node = nearest(tree, target_pos)\n\n            while True:\n                dist = math.dist(current_node.position, target_pos)\n                if dist <= self.step_size:\n                    new_pos = target_pos\n                else:\n                    new_pos = steer(current_node.position, target_pos)\n\n                if (\n                    not self._within_bounds(new_pos, bounds) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors for potential cost improvement\n                for neighbor in neighbors:\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if (\n                        cost_through_new < neighbor.cost and\n                        not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d)\n                    ):\n                        old_parent = neighbor.parent\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n                        try:\n                            edges.remove((old_parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node.position == target_pos:\n                    return new_node\n\n                current_node = new_node\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        for i in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                # Return best path found so far if any\n                if success_state:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            connect_node_goal = try_incremental_connect(tree_goal, new_node_start)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    success_state = True\n                tree_start, tree_goal = tree_goal, tree_start\n                # Early break as success found\n                if success_state:\n                    break\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))",
          "objective": -18.80425,
          "time_improvement": 47.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 292.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01118032932281494,
                    "num_nodes_avg": 79.5,
                    "path_length_avg": 156.85279842257313,
                    "smoothness_avg": 0.023211586971181856,
                    "success_improvement": 0.0,
                    "time_improvement": 54.96264951239799,
                    "length_improvement": 14.026495692942747,
                    "smoothness_improvement": 263.31174086686025,
                    "objective_score": 20.610652696642244
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027942562103271486,
                    "num_nodes_avg": 238.5,
                    "path_length_avg": 242.66568094102286,
                    "smoothness_avg": 0.015811457306217663,
                    "success_improvement": 0.0,
                    "time_improvement": 82.49642721289152,
                    "length_improvement": 18.991210957540346,
                    "smoothness_improvement": 306.84018502135024,
                    "objective_score": 30.081371280482276
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04769892692565918,
                    "num_nodes_avg": 287.5,
                    "path_length_avg": 124.45988546494837,
                    "smoothness_avg": 0.03182042236163751,
                    "success_improvement": 0.0,
                    "time_improvement": 2.4301293315132715,
                    "length_improvement": 17.33967021705423,
                    "smoothness_improvement": 304.75342370076896,
                    "objective_score": 5.720739961368672
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, goal-biased and informed ellipsoidal sampling after initial path discovery, incremental extend-and-rewire with robust collision checking, and path smoothing. It enforces a 30-second maximum planning duration to ensure timely results while striving for efficient, high-quality, and smooth paths in 2D or 3D spaces.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions toward sampled points, initially using uniform and goal-biased sampling and switching to informed ellipsoidal sampling after the first solution. It dynamically rewires the tree locally based on an adaptive radius to optimize path costs. When a connection between trees is established, the combined path is smoothed. The process respects collisions and map bounds and terminates early if the time limit expires, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root node\n        self.children = []\n        self.valid = True               # Validity flag\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            # Use finer resolution for edge collision checking\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def _rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = _rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # Clamp to bounds\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.61176,
          "time_improvement": 29.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1294.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021314287185668947,
                    "num_nodes_avg": 89.9,
                    "path_length_avg": 162.7853948427183,
                    "smoothness_avg": 0.038472706977865714,
                    "success_improvement": 0.0,
                    "time_improvement": 14.140362536951912,
                    "length_improvement": 10.774745587055062,
                    "smoothness_improvement": 502.181409023982,
                    "objective_score": 8.907964923616497
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04317150115966797,
                    "num_nodes_avg": 265.6,
                    "path_length_avg": 232.41800591335777,
                    "smoothness_avg": 0.08860547872068211,
                    "success_improvement": 0.0,
                    "time_improvement": 72.95682800724579,
                    "length_improvement": 22.412179844745957,
                    "smoothness_improvement": 2179.8827874298518,
                    "objective_score": 37.268898308272185
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04911673069000244,
                    "num_nodes_avg": 269.1,
                    "path_length_avg": 121.91131392590538,
                    "smoothness_avg": 0.1020913409478107,
                    "success_improvement": 0.0,
                    "time_improvement": -0.4700392642261438,
                    "length_improvement": 19.032310083351177,
                    "smoothness_improvement": 1198.594321257225,
                    "objective_score": 9.658421843688519
               }
          ],
          "success_rate": 1.0
     }
]