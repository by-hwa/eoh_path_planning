[
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner enhanced with adaptive informed sampling within an ellipsoidal subset, adaptive neighbor radius for efficient rewiring, incremental tree connection, and dedicated path smoothing. It maintains robust collision checking and enforces a strict 30-second planning timeout to ensure timely and high-quality solutions.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending them towards samples drawn from a uniform distribution initially and later from an informed ellipsoidal region around the best solution. Each extension attempts incremental rewiring of nearby nodes to minimize path costs. Upon successful connection of trees, the combined path is extracted and smoothed. The process concludes either when a time or iteration limit is reached, delivering the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...], 2D or 3D\n        self.parent = None                  # Parent Node or None\n        self.cost = cost                    # Cost from root to this node\n        self.children = []                  # List of child nodes\n        self.valid = True                   # For obstacle validity\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0, max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    normed = tuple(x / math.sqrt(norm_sq) for x in pt)\n                    return normed\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.68288,
          "time_improvement": 54.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1405.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01598813533782959,
                    "num_nodes_avg": 70.3,
                    "path_length_avg": 160.07310344541804,
                    "smoothness_avg": 0.04324016794566805,
                    "success_improvement": 0.0,
                    "time_improvement": 35.595523703969775,
                    "length_improvement": 12.26139548092287,
                    "smoothness_improvement": 576.8025258772809,
                    "objective_score": 16.01494883676191
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040297436714172366,
                    "num_nodes_avg": 257.0,
                    "path_length_avg": 231.7466873890371,
                    "smoothness_avg": 0.08312651221825451,
                    "success_improvement": 0.0,
                    "time_improvement": 74.75717816950535,
                    "length_improvement": 22.636285290996536,
                    "smoothness_improvement": 2038.9050329823299,
                    "objective_score": 37.14893567396256
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022991228103637695,
                    "num_nodes_avg": 180.8,
                    "path_length_avg": 127.98573904981842,
                    "smoothness_avg": 0.13355395998673397,
                    "success_improvement": 0.0,
                    "time_improvement": 52.97061596211985,
                    "length_improvement": 14.997966149089132,
                    "smoothness_improvement": 1598.796513103363,
                    "objective_score": 26.884760583970596
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation provides an enhanced bidirectional RRT* planner for 2D/3D environments, incorporating adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, incremental extend-and-rewire expansions, and rigorous collision and boundary checks. It maintains parent-child relationships with recursive cost updates for efficient rewiring and optimal path cost improvements. The planner benefits from early stopping upon finding better paths, path smoothing via random shortcutting, and enforces a 30-second time limit for timely response, returning the best available solution if interrupted.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with goal bias initially and focused ellipsoidal informed sampling once a solution is found. New nodes are added by steering towards samples with incremental connection attempts to the opposite tree and rewiring neighbors adaptively based on node density, which improves path cost quality. Paths from both trees are merged, smoothed, and returned early upon improvement. Planning halts if the runtime exceeds the 30-second limit, outputting the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 27.0  # Slightly tuned value for tighter neighbor radius\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos) ** 2 <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2])\n                    y_rot = (R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2])\n                    z_rot = (R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node':\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node':\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr == current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_tree_start = True\n        iter_cnt = 0\n        success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        while iter_cnt < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_cnt += 1\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_rate else sample_free())\n\n            if grow_tree_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n                        # Prepare edges and nodes for return\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_tree_start = not grow_tree_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed_path = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_tree_start = not grow_tree_start\n\n        # On timeout or max iterations reached\n        if best_path:\n            smoothed_path = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed_path = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.89994,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1323.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01829349994659424,
                    "num_nodes_avg": 78.4,
                    "path_length_avg": 158.6148076988789,
                    "smoothness_avg": 0.040650676543581246,
                    "success_improvement": 0.0,
                    "time_improvement": 26.308899769308642,
                    "length_improvement": 13.060710487775834,
                    "smoothness_improvement": 536.2713622640409,
                    "objective_score": 13.186168839667964
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047746133804321286,
                    "num_nodes_avg": 281.4,
                    "path_length_avg": 236.4099202531062,
                    "smoothness_avg": 0.08959639868918132,
                    "success_improvement": 0.0,
                    "time_improvement": 70.09122050947818,
                    "length_improvement": 21.079563937254512,
                    "smoothness_improvement": 2205.37987195014,
                    "objective_score": 36.27017830004506
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01942884922027588,
                    "num_nodes_avg": 153.0,
                    "path_length_avg": 120.27417918571132,
                    "smoothness_avg": 0.10443872413434199,
                    "success_improvement": 0.0,
                    "time_improvement": 60.25759010020645,
                    "length_improvement": 20.119617025809113,
                    "smoothness_improvement": 1228.4528621240995,
                    "objective_score": 28.243464745844257
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an advanced bidirectional RRT* planner with adaptive informed sampling and dynamic neighbor radius scaling tuned by node density and iteration progress. It grows two trees alternately from start and goal, performs incremental extend-and-rewire with recursive cost updates, enforces strict collision and boundary checks, and aggressively smooths paths by randomized shortcutting. The planner prioritizes early feasible path discovery and quality improvement under a strict 30-second time limit, ensuring efficient and robust path planning in 2D/3D environments.",
          "planning_mechanism": "Planning mechanism: The planner initializes two trees at the start and goal positions and iteratively samples points using a goal-biased uniform or ellipsoidal informed distribution after an initial solution. Each iteration attempts to extend and rewire one tree toward the sampled point, followed by incremental connection and rewiring of the opposite tree toward the new node. Adaptive neighbor radius dynamically scales with tree size and iteration count to optimize rewiring locality. Recursively propagated parent-child cost updates maintain global path cost consistency. Upon connecting the two trees, the combined path is shortcut-smoothed to improve smoothness and reduce length. The process enforces tight collision and boundary checks and halts within 30 seconds, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] e.g. (x,y) or (x,y,z)\n        self.parent = None                  # type: Node or None\n        self.cost = cost                    # Path cost from root to this node\n        self.children: List['Node'] = []   # Child nodes list\n        self.valid = True                   # Validity flag for collision\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update cost of all descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = dist_func(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    rows = len(A)\n                    cols = len(B[0])\n                    return [[sum(A[i][k]*B[k][j] for k in range(len(B))) for j in range(cols)] for i in range(rows)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = dist_func(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start = True\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + dist_func(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    nodes_all = tree_start + tree_goal\n                    edges_all = []\n                    for node in nodes_all:\n                        for c in node.children:\n                            edges_all.append((node, c))\n                    return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            grow_start = not grow_start\n\n        success = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success else []\n\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n        for node in nodes_all:\n            for c in node.children:\n                edges_all.append((node, c))\n\n        return PlannerResult(success, smoothed, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -25.28016,
          "time_improvement": 48.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1525.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020598411560058594,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 163.47506959241795,
                    "smoothness_avg": 0.04367856895104431,
                    "success_improvement": 0.0,
                    "time_improvement": 17.024100620619315,
                    "length_improvement": 10.396723928148914,
                    "smoothness_improvement": 583.6644536144399,
                    "objective_score": 10.104897239887777
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03490955829620361,
                    "num_nodes_avg": 221.9,
                    "path_length_avg": 232.77738879457712,
                    "smoothness_avg": 0.09426688841092093,
                    "success_improvement": 0.0,
                    "time_improvement": 78.1322130610254,
                    "length_improvement": 22.292207494732256,
                    "smoothness_improvement": 2325.5549365082725,
                    "objective_score": 39.52588009979544
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02548041343688965,
                    "num_nodes_avg": 193.8,
                    "path_length_avg": 124.14239219545193,
                    "smoothness_avg": 0.13893055146464137,
                    "success_improvement": 0.0,
                    "time_improvement": 47.87889783156715,
                    "length_improvement": 17.550534129248916,
                    "smoothness_improvement": 1667.186359843644,
                    "objective_score": 26.209707974538148
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This implementation is an optimized bidirectional RRT* planner for 2D and 3D spaces with adaptive neighbor radius, incremental tree extension and rewiring, goal biasing, and informed ellipsoidal sampling after the first feasible path. It performs rigorous collision checking for nodes and edges, enforces map boundary constraints, limits planning runtime to 30 seconds, and applies path shortcut smoothing to improve path quality and smoothness while minimizing path length and execution time. The planner dynamically balances exploration and exploitation to efficiently discover smooth, low-cost paths and halts early upon finding improved solutions or when the time budget is exhausted.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling points either uniformly, with goal bias, or informed ellipsoidal distribution after the first solution. Each extension steers towards sampled points by a fixed step size, ensuring collision-free nodes and edges are maintained. Newly added nodes are locally rewired within an adaptive radius for cost minimization. Once the trees connect incrementally with collision-checked edges, a combined path is extracted, shortcut-smoothed, and returned. The process respects a 30-second planning time limit and returns the best feasible solution found within this budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                  # Tuple[float, ...]\n        self.parent = None                        # Parent Node or None\n        self.cost = 0.0                          # Cost from root to this node\n        self.children = []                      # List of children nodes\n        self.valid = True                       # Validity flag for collision checking\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node' or None, new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update children's costs\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 8.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(src, tgt):\n            d = dist_func(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 35.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz, 0, -kx],[-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1] + [a_minor]*(dim - 1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> 'Node' or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = None) -> list:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                # Time limit reached: return best found so far\n                success_state = (len(best_path) > 0)\n                smoothed_path = path_smoothing(best_path) if success_state else []\n                all_nodes = tree_start + tree_goal\n                all_edges = []\n                for node in all_nodes:\n                    for c in node.children:\n                        all_edges.append((node, c))\n                return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        smoothed_path = path_smoothing(best_path)\n                        all_nodes = tree_start + tree_goal\n                        all_edges = []\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start_tree = not grow_start_tree\n\n        # End of iterations reached - return best found solution\n        final_success = (len(best_path) > 0)\n        final_path = path_smoothing(best_path) if final_success else []\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(final_success, final_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.41279,
          "time_improvement": 43.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1429.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02322845458984375,
                    "num_nodes_avg": 95.8,
                    "path_length_avg": 171.18271234637552,
                    "smoothness_avg": 0.04108737789847548,
                    "success_improvement": 0.0,
                    "time_improvement": 6.42958535100239,
                    "length_improvement": 6.172042799289528,
                    "smoothness_improvement": 543.1066867803061,
                    "objective_score": 5.878817599060153
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03691425323486328,
                    "num_nodes_avg": 258.3,
                    "path_length_avg": 233.89526148878673,
                    "smoothness_avg": 0.09309644198475484,
                    "success_improvement": 0.0,
                    "time_improvement": 76.87644690597159,
                    "length_improvement": 21.919029413223644,
                    "smoothness_improvement": 2295.4385069245336,
                    "objective_score": 38.92393248905888
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025823450088500975,
                    "num_nodes_avg": 198.4,
                    "path_length_avg": 120.18639554132542,
                    "smoothness_avg": 0.12180679988238355,
                    "success_improvement": 0.0,
                    "time_improvement": 47.177204022303215,
                    "length_improvement": 20.177918742602277,
                    "smoothness_improvement": 1449.3735036611893,
                    "objective_score": 25.435612473517367
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This implementation presents an enhanced bidirectional RRT* planner with adaptive neighbor radius, informed ellipsoidal sampling, incremental connect and rewire steps, and path shortcut smoothing. The planner dynamically balances exploration and exploitation, performing collision checks on nodes and edges, and halts after 30 seconds or upon finding an improved feasible path. Recursive cost updates and explicit parent-child relationships ensure tree consistency and quick convergence to smooth, low-cost solutions.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal by sampling informed points within an ellipsoidal region once an initial path is found. Nodes are added with careful collision validation, rewired using neighbors within a dynamically computed radius to optimize paths locally, and connected incrementally to the opposite tree. The algorithm performs early exits on improved solutions or timeout, followed by randomized path shortcut smoothing to enhance solution quality.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node'] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children: List['Node'] = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional['Node'], new_cost: float) -> None:\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-10:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update cost for children\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n        self.min_neighbor_radius = 8.0\n        self.max_neighbor_radius = 20.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(src: Tuple[float, ...], tgt: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(src, tgt)\n            if d <= self.step_size:\n                return tgt\n            factor = self.step_size / d\n            return tuple(src[d] + factor * (tgt[d] - src[d]) for d in range(dim))\n\n        def collision_free_node(p: Tuple[float, ...]) -> bool:\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r = self.max_neighbor_radius * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos)**2 <= radius_sq]\n\n        def uniform_sample() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx**2 + ky**2 + kz**2)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0.0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky], [kz, 0, -kx], [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best: float, c_min: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1] + [a_minor] * (dim - 1)\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n            r = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr is nearest_node:\n                    continue\n                cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_node: Node) -> Optional[Node]:\n            curr = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n                r = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    else:\n                        return None\n                curr = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], iterations: int = 100) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_tree: List[Node] = [Node(start_pos, cost=0.0)]\n        goal_tree: List[Node] = [Node(goal_pos, cost=0.0)]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n        informed_sampling_active = False\n        c_min = dist(start_pos, goal_pos)\n        grow_start_tree = True\n\n        start_time = time.perf_counter()\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            sample = informed_sample(best_cost, c_min) if informed_sampling_active else (\n                goal_pos if random.random() < 0.2 else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node)\n                if connect_node:\n                    path_s = new_node.path_from_root()\n                    path_g = connect_node.path_from_root()\n                    if path_g and path_g[0] == new_node.position:\n                        path_g = path_g[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        # Early termination on improved feasible path\n                        smoothed = path_smoothing(best_path)\n                        # Collect nodes and edges for return\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node)\n                if connect_node:\n                    path_g = new_node.path_from_root()\n                    path_s = connect_node.path_from_root()\n                    if path_s and path_s[0] == new_node.position:\n                        path_s = path_s[1:]\n                    combined_path = path_s + path_g[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling_active = True\n                        smoothed = path_smoothing(best_path)\n                        nodes = start_tree + goal_tree\n                        edges = []\n                        for node in nodes:\n                            for c in node.children:\n                                edges.append((node, c))\n                        return PlannerResult(True, smoothed, nodes, edges)\n\n            grow_start_tree = not grow_start_tree\n\n        if best_path:\n            success_state = True\n            smoothed = path_smoothing(best_path)\n        else:\n            success_state = False\n            smoothed = []\n\n        nodes = start_tree + goal_tree\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.6335,
          "time_improvement": 42.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1362.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014331412315368653,
                    "num_nodes_avg": 73.8,
                    "path_length_avg": 157.60831825929054,
                    "smoothness_avg": 0.03375109906189614,
                    "success_improvement": 0.0,
                    "time_improvement": 42.26924620972745,
                    "length_improvement": 13.612383298460001,
                    "smoothness_improvement": 428.2779920033616,
                    "objective_score": 17.544640482627045
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06457438468933105,
                    "num_nodes_avg": 351.2,
                    "path_length_avg": 245.5500092889095,
                    "smoothness_avg": 0.08948971390908934,
                    "success_improvement": 0.0,
                    "time_improvement": 59.549792233972795,
                    "length_improvement": 18.028339134227505,
                    "smoothness_improvement": 2202.6347957164326,
                    "objective_score": 32.4837794756195
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03742551803588867,
                    "num_nodes_avg": 248.6,
                    "path_length_avg": 123.79261055925981,
                    "smoothness_avg": 0.12236051620731514,
                    "success_improvement": 0.0,
                    "time_improvement": 23.44475673102762,
                    "length_improvement": 17.78284243719607,
                    "smoothness_improvement": 1456.4167344432315,
                    "objective_score": 17.87207917896366
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an efficient bidirectional RRT* path planner with adaptive neighbor radius and informed ellipsoidal sampling to focus the search after an initial solution is found. It grows two trees alternately from start and goal positions, incrementally extends and rewires connections while ensuring collision-free expansion and edges. The planner enforces a strict 30-second max planning time and applies post-processing path smoothing for improved path quality and smoothness.",
          "planning_mechanism": "The planner samples points biased towards the goal or within an informed ellipsoid once a solution is found, extends one tree towards these samples with adaptive rewiring to optimize path costs, then tries to incrementally connect the other tree to the new node. This alternating bidirectional growth rapidly attempts to connect the trees with cost improvements. When a connection is found, the combined path is smoothed. The procedure repeats until time or iteration limits are reached, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: list = []\n        informed_sampling = False\n        rotation_mat = None\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            nonlocal rotation_mat\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0]*sample_scaled[0] + rotation_mat[0][1]*sample_scaled[1]\n                    y_rot = rotation_mat[1][0]*sample_scaled[0] + rotation_mat[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = rotation_mat[0][0]*sample_scaled[0] + rotation_mat[0][1]*sample_scaled[1] + rotation_mat[0][2]*sample_scaled[2]\n                    y_rot = rotation_mat[1][0]*sample_scaled[0] + rotation_mat[1][1]*sample_scaled[1] + rotation_mat[1][2]*sample_scaled[2]\n                    z_rot = rotation_mat[2][0]*sample_scaled[0] + rotation_mat[2][1]*sample_scaled[1] + rotation_mat[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize bidirectional trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected = incremental_connect(tree_goal, new_node.position)\n                if connected:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected.cost + dist_func(new_node.position, connected.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    return self._build_result(True, smoothed_path, tree_start, tree_goal)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected = incremental_connect(tree_start, new_node.position)\n                if connected:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected.cost + dist_func(new_node.position, connected.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n\n                    smoothed_path = path_smoothing(best_path)\n                    return self._build_result(True, smoothed_path, tree_start, tree_goal)\n\n            grow_start = not grow_start\n\n        success = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success else []\n        return self._build_result(success, smoothed, tree_start, tree_goal)\n\n    def _build_result(self, success: bool, path: list, tree_start: list, tree_goal: list):\n        nodes = tree_start + tree_goal\n        edges = []\n        for node in nodes:\n            for child in node.children:\n                edges.append((node, child))\n        return PlannerResult(success, path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.58295,
          "time_improvement": 41.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1357.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021058201789855957,
                    "num_nodes_avg": 89.0,
                    "path_length_avg": 163.17042507617967,
                    "smoothness_avg": 0.041117326893017725,
                    "success_improvement": 0.0,
                    "time_improvement": 15.171942859228329,
                    "length_improvement": 10.563704414900396,
                    "smoothness_improvement": 543.5754535801748,
                    "objective_score": 9.382201008649453
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03521578311920166,
                    "num_nodes_avg": 228.5,
                    "path_length_avg": 240.09732672203876,
                    "smoothness_avg": 0.09139994434168228,
                    "success_improvement": 0.0,
                    "time_improvement": 77.94038997555614,
                    "length_improvement": 19.848601521814498,
                    "smoothness_improvement": 2251.7864006304158,
                    "objective_score": 38.610769300181815
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03371152877807617,
                    "num_nodes_avg": 242.1,
                    "path_length_avg": 119.99668771457057,
                    "smoothness_avg": 0.10821661510678496,
                    "success_improvement": 0.0,
                    "time_improvement": 31.041855343197433,
                    "length_improvement": 20.303913648216895,
                    "smoothness_improvement": 1276.5073564386694,
                    "objective_score": 19.755876114795957
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner implements a bidirectional RRT* with adaptive informed sampling after an initial solution, incremental extend-and-rewire steps for path optimization, and path smoothing. It grows two trees from start and goal, alternately extending them with goal bias and ellipsoidal informed sampling. The algorithm efficiently rewires local neighborhoods to minimize cost, performs robust collision checking, and enforces a strict 30-second planning time limit to guarantee timely output.",
          "planning_mechanism": "The planner samples configurations biased towards the goal or via informed ellipsoids after finding a solution, then extends one tree toward the sample, rewires the neighborhood to reduce path costs, and incrementally attempts to connect the two trees. Upon connection, it extracts and smooths the combined path. The planning loop respects the time limit, returning the best solution found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=10.0, neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node is not None:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n\n                        smoothed = path_smoothing(best_path)\n                        return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.71824,
          "time_improvement": 37.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1366.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02254364490509033,
                    "num_nodes_avg": 96.7,
                    "path_length_avg": 159.55648446985919,
                    "smoothness_avg": 0.04460211395919851,
                    "success_improvement": 0.0,
                    "time_improvement": 9.188181533550138,
                    "length_improvement": 12.544562527778217,
                    "smoothness_improvement": 598.1199385021376,
                    "objective_score": 8.255966658131374
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.038587307929992674,
                    "num_nodes_avg": 248.5,
                    "path_length_avg": 235.24109191110043,
                    "smoothness_avg": 0.09333894379068908,
                    "success_improvement": 0.0,
                    "time_improvement": 75.8284243758693,
                    "length_improvement": 21.46975248067449,
                    "smoothness_improvement": 2301.6782530582127,
                    "objective_score": 38.55086907418675
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035490679740905764,
                    "num_nodes_avg": 213.6,
                    "path_length_avg": 119.46007876775484,
                    "smoothness_avg": 0.10212397521226743,
                    "success_improvement": 0.0,
                    "time_improvement": 27.402538055964808,
                    "length_improvement": 20.660303760119735,
                    "smoothness_improvement": 1199.0094266923038,
                    "objective_score": 18.34786930227491
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -19.222664746243094,
          "time_improvement": 56.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01836371421813965,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 26.791944956378185,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 9.632888750165714
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034141016006469724,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 78.8061931267961,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 27.280148667759597
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017978572845458986,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 63.44687412595209,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 20.754956820803976
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a hybrid bidirectional RRT* planner with adaptive informed sampling, dynamic neighbor radius scaling based on node density and iteration progress, incremental extend-and-rewire with recursive cost propagation, and aggressive path smoothing via randomized shortcutting. It balances exploration and exploitation by switching between uniform and ellipsoidal informed sampling after finding an initial solution. It enforces strict collision checks on nodes and edges, bounds all expansions within the map limits, and dynamically manages parent-child relationships to optimize path cost and smoothness. The planner halts upon reaching a feasible path or upon hitting a 30-second runtime limit, returning the best solution found.",
          "planning_mechanism": "The planner grows two trees from start and goal positions in alternation, sampling points with goal bias and switching to informed ellipsoidal sampling when a valid path is found. Each iteration incrementally extends and rewires one tree toward the sample, then attempts incremental connection with the other tree. Adaptive neighbor radius depends on both tree size and progress to improve rewiring quality and convergence. Parent-child cost and topology updates are recursively propagated to maintain consistency. The algorithm performs randomized shortcut path smoothing after each new solution to enhance path quality while ensuring collision-free edges. It enforces a strict 30-second planning time cap and returns the best path found within this constraint.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []                # List[Node]\n        self.valid = True                 # Validity flag\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        # Detach from current parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates to descendants recursively\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.perf_counter()\n\n        # Helper functions\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            # Use fine resolution for better collision detection\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            base_radius = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            # Interpolate based on iteration progress (favor smaller radius at later stages)\n            iteration_factor = min(1.0, iter_num / self.max_iter)\n            radius = base_radius * (1.0 - 0.6 * iteration_factor)  # reduce radius as iterations grow\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree_nodes, pos, radius):\n            rad_sq = radius * radius\n            return [node for node in tree_nodes if (math.dist(node.position, pos) ** 2) <= rad_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def unit_ball_sample(n):\n            while True:\n                point = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in point)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in point)\n\n        def rotation_matrix(direction):\n            # Returns rotation matrix aligning unit x-axis to direction vector in dim=2 or dim=3\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a = math.cos(angle)\n                sin_a = math.sin(angle)\n                return [[cos_a, -sin_a],\n                        [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0],\n                            [0, 1, 0],\n                            [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0, 1 - cos_theta * cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0],\n                     [0, 1, 0],\n                     [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1 - cos_theta))\n\n        # Informed sampling returns a point inside an ellipsoid defined by start, goal, and current best cost\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_uniform()\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0] * sample_scaled[0] + R[0][1] * sample_scaled[1] + R[0][2] * sample_scaled[2]\n                    y_rot = R[1][0] * sample_scaled[0] + R[1][1] * sample_scaled[1] + R[1][2] * sample_scaled[2]\n                    z_rot = R[2][0] * sample_scaled[0] + R[2][1] * sample_scaled[1] + R[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clamped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clamped):\n                    return clamped\n\n        def extend_and_rewire(tree: list, sample: tuple, iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors toward new_node if cheaper\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple, iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = math.dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 150):\n            # Random shortcut smoothing with collision checks\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialization\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sample point: goal bias + informed sampling if solution found\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iteration)\n                if connect_node:\n                    # Construct combined path\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    # avoid duplicated connecting node position in concatenation\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path)\n                    return self._build_result(True, smoothed, tree_start + tree_goal)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iteration)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iteration)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    smoothed = path_smoothing(best_path)\n                    return self._build_result(True, smoothed, tree_start + tree_goal)\n\n            grow_start = not grow_start\n\n        # Timeout or iteration completion with best path found\n        success = (len(best_path) > 0)\n        if success:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        return self._build_result(success, smoothed, tree_start + tree_goal)\n\n    def _build_result(self, success, path, nodes):\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.16508,
          "time_improvement": 25.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1593.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019535040855407713,
                    "num_nodes_avg": 68.4,
                    "path_length_avg": 154.075377060829,
                    "smoothness_avg": 0.04778847884688942,
                    "success_improvement": 0.0,
                    "time_improvement": 21.307641627401765,
                    "length_improvement": 15.548844352372582,
                    "smoothness_improvement": 647.9934682966013,
                    "objective_score": 12.742028700178052
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0390239953994751,
                    "num_nodes_avg": 231.3,
                    "path_length_avg": 235.9932067793355,
                    "smoothness_avg": 0.10498215270113234,
                    "success_improvement": 0.0,
                    "time_improvement": 75.55487784570309,
                    "length_improvement": 21.218674889231465,
                    "smoothness_improvement": 2601.2664045883207,
                    "objective_score": 39.916530354498825
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059827661514282225,
                    "num_nodes_avg": 303.0,
                    "path_length_avg": 121.14628597802967,
                    "smoothness_avg": 0.12802729706394325,
                    "success_improvement": 0.0,
                    "time_improvement": -22.3796335176328,
                    "length_improvement": 19.540405219614065,
                    "smoothness_improvement": 1528.497768661288,
                    "objective_score": 4.8366798319394135
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after an initial solution, incremental extend-and-rewire steps for efficient tree growth and connection, robust collision checking with fine discretization, and post-hoc path smoothing. It enforces a strict maximum planning time of 30 seconds to ensure timely results. The planner maintains consistent parent-child links with cost propagation and dynamically rewires nodes to improve path cost and smoothness while respecting map bounds and obstacles.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. It samples points with goal bias and switches to informed ellipsoidal sampling after finding a solution to focus search around the best cost. Each iteration extends one tree toward the sampled point, rewires neighboring nodes within an adaptive radius, then attempts to incrementally connect the other tree to the new node. Upon successful connection, combined paths are smoothed and updated as the best solution. The process terminates either when the time limit is reached or the maximum iterations are done, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = None            # type: Node or None\n        self.cost = cost              # Cost from root node\n        self.children = []            # List of child nodes\n        self.valid = True             # For collision and validity checks\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to descendants\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # Clamp to bounds\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100):\n            # Remove unnecessary intermediate points using collision checks\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Sample point with goal bias or informed sampling if solution found\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Return best found path on timeout or iteration end\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    # Collision helpers same as provided\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.9314,
          "time_improvement": 31.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1274.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02140035629272461,
                    "num_nodes_avg": 96.7,
                    "path_length_avg": 165.6679199431512,
                    "smoothness_avg": 0.039374954031528714,
                    "success_improvement": 0.0,
                    "time_improvement": 13.793653202307294,
                    "length_improvement": 9.194787902974594,
                    "smoothness_improvement": 516.303534674644,
                    "objective_score": 8.558571214660327
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033504605293273926,
                    "num_nodes_avg": 226.3,
                    "path_length_avg": 242.86341383565892,
                    "smoothness_avg": 0.07872449738910461,
                    "success_improvement": 0.0,
                    "time_improvement": 79.01229331488184,
                    "length_improvement": 18.925202025885028,
                    "smoothness_improvement": 1925.63802078518,
                    "objective_score": 37.11691850356746
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04808731079101562,
                    "num_nodes_avg": 271.8,
                    "path_length_avg": 122.48458875157633,
                    "smoothness_avg": 0.11631665025974325,
                    "success_improvement": 0.0,
                    "time_improvement": 1.635676165478412,
                    "length_improvement": 18.65156824055423,
                    "smoothness_improvement": 1379.5392057018962,
                    "objective_score": 11.11871252626385
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, goal-biased and informed ellipsoidal sampling after initial path discovery, incremental extend-and-rewire with robust collision checking, and path smoothing. It enforces a 30-second maximum planning duration to ensure timely results while striving for efficient, high-quality, and smooth paths in 2D or 3D spaces.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions toward sampled points, initially using uniform and goal-biased sampling and switching to informed ellipsoidal sampling after the first solution. It dynamically rewires the tree locally based on an adaptive radius to optimize path costs. When a connection between trees is established, the combined path is smoothed. The process respects collisions and map bounds and terminates early if the time limit expires, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root node\n        self.children = []\n        self.valid = True               # Validity flag\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            # Use finer resolution for edge collision checking\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def _rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = _rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                # Clamp to bounds\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple) -> Node or None:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        if success_state:\n            smoothed = path_smoothing(best_path)\n        else:\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.61176,
          "time_improvement": 29.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1294.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021314287185668947,
                    "num_nodes_avg": 89.9,
                    "path_length_avg": 162.7853948427183,
                    "smoothness_avg": 0.038472706977865714,
                    "success_improvement": 0.0,
                    "time_improvement": 14.140362536951912,
                    "length_improvement": 10.774745587055062,
                    "smoothness_improvement": 502.181409023982,
                    "objective_score": 8.907964923616497
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04317150115966797,
                    "num_nodes_avg": 265.6,
                    "path_length_avg": 232.41800591335777,
                    "smoothness_avg": 0.08860547872068211,
                    "success_improvement": 0.0,
                    "time_improvement": 72.95682800724579,
                    "length_improvement": 22.412179844745957,
                    "smoothness_improvement": 2179.8827874298518,
                    "objective_score": 37.268898308272185
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04911673069000244,
                    "num_nodes_avg": 269.1,
                    "path_length_avg": 121.91131392590538,
                    "smoothness_avg": 0.1020913409478107,
                    "success_improvement": 0.0,
                    "time_improvement": -0.4700392642261438,
                    "length_improvement": 19.032310083351177,
                    "smoothness_improvement": 1198.594321257225,
                    "objective_score": 9.658421843688519
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm implements a bidirectional RRT* with adaptive informed sampling based on the current best path cost, dynamically adjusting neighbor radius and incremental rewiring to optimize path length and smoothness. It enforces strict collision checks and boundary constraints, incorporates randomized path shortcut smoothing after solution discovery, and applies a hard 30-second planning time limit to ensure timely termination while returning the best solution found so far.",
          "planning_mechanism": "The planner grows two trees from start and goal positions in turns, initially using goal-biased and uniform sampling, switching to ellipsoidal informed sampling once a feasible path is found. Each extension step incorporates adaptive neighbor radius for rewiring to minimize cost. Incremental connection attempts bridge the two trees gradually, improving the chance of successful linkage. After connecting, path smoothing shortens the path. The process halts either upon timeout or max iteration count, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position                  # Tuple[float, ...]\n        self.parent = None                        # type: Node or None\n        self.cost = cost                          # cumulative cost from root\n        self.children = []                        # List[Node]\n        self.valid = True                         # validity (collision free)\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds: Tuple[float, ...] = map.size\n        start_pos: Tuple[float, ...] = map.start\n        goal_pos: Tuple[float, ...] = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        t_start = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [n for n in tree if (dist_func(n.position, pos) ** 2) <= r_sq]\n\n        def unit_ball_sample(n: int):\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in sample)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in sample)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ux, uy, uz = vx/norm_v, vy/norm_v, vz/norm_v\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0.0; vy_ = 1.0; vz_ = 0.0\n                else:\n                    vx_ = -uy; vy_ = ux; vz_ = 0.0\n                norm_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                vx_ /= norm_; vy_ /= norm_; vz_ /= norm_\n                wx = uy*vz_ - uz*vy_\n                wy = uz*vx_ - ux*vz_\n                wz = ux*vy_ - uy*vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        rotation_mat_cache = None\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat_cache\n\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat_cache is None:\n                rotation_mat_cache = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat_cache[0][0] * sample_scaled[0] + rotation_mat_cache[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat_cache[1][0] * sample_scaled[0] + rotation_mat_cache[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat_cache[0][0] * sample_scaled[0] +\n                             rotation_mat_cache[0][1] * sample_scaled[1] +\n                             rotation_mat_cache[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat_cache[1][0] * sample_scaled[0] +\n                             rotation_mat_cache[1][1] * sample_scaled[1] +\n                             rotation_mat_cache[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat_cache[2][0] * sample_scaled[0] +\n                             rotation_mat_cache[2][1] * sample_scaled[1] +\n                             rotation_mat_cache[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node:\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node: Node, other_tree: List[Node]) -> Node:\n            if not other_tree:\n                return None\n            current = min(other_tree, key=lambda n: dist_func(n.position, new_node.position))\n            while True:\n                new_pos = steer(current.position, new_node.position)\n                new_pos = clamp(new_pos)\n\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist_func(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    return None\n\n                current = conn_node\n\n        def path_shortcut(path: List[Tuple[float, ...]], trials: int = None) -> List[Tuple[float, ...]]:\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start: List[Node] = [Node(start_pos, None, 0.0)]\n        tree_goal: List[Node] = [Node(goal_pos, None, 0.0)]\n\n        all_nodes: List[Node] = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_start = True\n        iteration = 0\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                if best_path:\n                    smoothed = path_shortcut(best_path)\n                    success_state = True\n                else:\n                    smoothed = []\n                    success_state = False\n\n                all_edges.clear()\n                all_nodes = tree_start + tree_goal\n                for n in all_nodes:\n                    for c in n.children:\n                        all_edges.append((n, c))\n\n                return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            # Sample point with goal bias or informed sampling after first solution\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    while True:\n                        candidate = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample = candidate\n                            break\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    smoothed_path = path_shortcut(best_path)\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    # Return immediately on finding better path\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Time or iteration limit reached without timeout\n        if best_path:\n            smoothed = path_shortcut(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.04096,
          "time_improvement": 26.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1292.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02946593761444092,
                    "num_nodes_avg": 72.1,
                    "path_length_avg": 157.62980716723177,
                    "smoothness_avg": 0.04622541405565252,
                    "success_improvement": 0.0,
                    "time_improvement": -18.69666102583705,
                    "length_improvement": 13.600604887503872,
                    "smoothness_improvement": 623.5281100642228,
                    "objective_score": 0.22876322007077476
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.059715986251831055,
                    "num_nodes_avg": 232.8,
                    "path_length_avg": 227.72048991710184,
                    "smoothness_avg": 0.08342479037617742,
                    "success_improvement": 0.0,
                    "time_improvement": 62.59315419789231,
                    "length_improvement": 23.98034589479719,
                    "smoothness_improvement": 2046.5799448267596,
                    "objective_score": 33.806915162460925
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032363390922546385,
                    "num_nodes_avg": 166.8,
                    "path_length_avg": 121.04361101057233,
                    "smoothness_avg": 0.10260455437214089,
                    "success_improvement": 0.0,
                    "time_improvement": 33.79951981670518,
                    "length_improvement": 19.608597044142673,
                    "smoothness_improvement": 1205.1223581332306,
                    "objective_score": 20.08718714450624
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with adaptive informed sampling, dynamic neighbor radius, incremental tree connection, and recursive rewiring to efficiently find smooth, low-cost paths within a strict 30-second time limit. It employs robust collision checks for nodes and edges, alternates growth between two trees rooted at start and goal, and applies path shortcut smoothing upon path discovery or timeout. Early termination ensures time-bounded planning with prioritized solution quality and performance.",
          "planning_mechanism": "The planner grows two trees from the start and goal positions by sampling points biased towards the goal initially and within an informed ellipsoid after a feasible path is found. Nodes are connected and rewired using an adaptive neighbor radius based on dimensionality and tree size to optimize local path costs. Incremental connection attempts between the two trees improve chances for early linkage. The planner performs continuous validity checks for node positioning and edge collision, maintains recursive parent-child relations with cost updates, and applies path smoothing to the final solution before return, all under a maximum 30-second planning horizon.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Cumulative cost from root\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def _distance(self, a, b):\n        from math import dist\n        return dist(a, b)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and abs(self.cost - new_cost) < 1e-12:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent and self not in new_parent.children:\n            new_parent.children.append(self)\n        # Recursively update descendants' costs\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time_sec = max_time_sec\n        self.min_neighbor_radius = 8.0\n        self.max_neighbor_radius = 20.0\n        self.goal_sample_prob = 0.2\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r = self.max_neighbor_radius * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos) ** 2 <= radius_sq]\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n\n        def rotation_matrix(direction):\n            # Generates rotation matrix aligning unit vector along x-axis to 'direction'\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                # Cross product unit x-axis (1,0,0) and direction\n                kx, ky, kz = 0.0, -vz, vy\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_th = vx\n                sin_th = math.sqrt(max(0.0, 1 - cos_th * cos_th))\n\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n\n                def mat_scale(A, s):\n                    return [[A[i][j] * s for j in range(3)] for i in range(3)]\n\n                def mat_mul(A, B):\n                    return [[sum(A[i][k] * B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_th)), mat_scale(K2, 1 - cos_th))\n\n        def unit_ball_sample(n):\n            while True:\n                vec = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in vec)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in vec)\n\n        def informed_sample(c_best, c_min):\n            # If no best cost or smaller than theoretic min, revert to uniform sample\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return uniform_sample()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            dx = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(dx)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(0.0, c_best*c_best - c_min*c_min)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_samp = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_samp * d for d in dir_sample)\n                sample_ellipsoid = tuple(sample_unit[i] * radii[i] for i in range(n))\n                if dim == 2:\n                    x_rot = R[0][0] * sample_ellipsoid[0] + R[0][1] * sample_ellipsoid[1]\n                    y_rot = R[1][0] * sample_ellipsoid[0] + R[1][1] * sample_ellipsoid[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i] * sample_ellipsoid[i] for i in range(n))\n                    y_rot = sum(R[1][i] * sample_ellipsoid[i] for i in range(n))\n                    z_rot = sum(R[2][i] * sample_ellipsoid[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                clipped = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(clipped):\n                    return clipped\n\n        def extend_and_rewire(tree, sample):\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            # Better parent search\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_via_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_via_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_via_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewiring neighbors if beneficial\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, new_cost)\n\n            return new_node\n\n        def incremental_connect(tree, target_node):\n            curr_node = min(tree, key=lambda n: dist(n.position, target_node.position))\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr_node.position, new_pos):\n                    return None\n\n                radius = neighbor_radius(len(tree) + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for nbr in neighbors:\n                    if nbr is curr_node:\n                        continue\n                    cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_via_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_via_new)\n\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_node.position):\n                        return new_node\n                    return None\n                curr_node = new_node\n\n        def path_smoothing(path, iterations=100):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n\n        best_path = []\n        best_cost = math.inf\n        informed_sampling = False\n        c_min = dist(start_pos, goal_pos)\n        grow_start_tree = True\n\n        start_time = time.perf_counter()\n\n        for iter_count in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            sample = informed_sample(best_cost, c_min) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_prob else uniform_sample()\n            )\n\n            if grow_start_tree:\n                new_node = extend_and_rewire(start_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(goal_tree, new_node)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n                        smoothed_path = path_smoothing(best_path, iterations=200)\n                        # Early return with best solution\n                        nodes_all = start_tree + goal_tree\n                        edges_all = []\n                        for node in nodes_all:\n                            for child in node.children:\n                                edges_all.append((node, child))\n                        return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n            else:\n                new_node = extend_and_rewire(goal_tree, sample)\n                if new_node is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                connect_node = incremental_connect(start_tree, new_node)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined\n                        informed_sampling = True\n                        smoothed_path = path_smoothing(best_path, iterations=200)\n                        # Early return with best solution\n                        nodes_all = start_tree + goal_tree\n                        edges_all = []\n                        for node in nodes_all:\n                            for child in node.children:\n                                edges_all.append((node, child))\n                        return PlannerResult(True, smoothed_path, nodes_all, edges_all)\n\n            grow_start_tree = not grow_start_tree\n\n        # Timeout or max iterations reached: return best path found\n        if best_path:\n            success_state = True\n            extracted_path = path_smoothing(best_path, iterations=200)\n        else:\n            success_state = False\n            extracted_path = []\n\n        nodes_all = start_tree + goal_tree\n        edges_all = []\n        for node in nodes_all:\n            for child in node.children:\n                edges_all.append((node, child))\n\n        return PlannerResult(success_state, extracted_path, nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -17.39775,
          "time_improvement": 23.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1463.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017689776420593262,
                    "num_nodes_avg": 67.5,
                    "path_length_avg": 163.08557279261203,
                    "smoothness_avg": 0.03949170455350223,
                    "success_improvement": 0.0,
                    "time_improvement": 28.74085926290172,
                    "length_improvement": 10.610213296094297,
                    "smoothness_improvement": 518.130933871346,
                    "objective_score": 13.334955107446106
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06299633979797363,
                    "num_nodes_avg": 328.1,
                    "path_length_avg": 236.86381557187912,
                    "smoothness_avg": 0.1007456668487231,
                    "success_improvement": 0.0,
                    "time_improvement": 60.538299426517085,
                    "length_improvement": 20.928040615195755,
                    "smoothness_improvement": 2492.2585721884107,
                    "objective_score": 34.808390811936334
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05817921161651611,
                    "num_nodes_avg": 303.6,
                    "path_length_avg": 129.04207973931193,
                    "smoothness_avg": 0.11624161963690585,
                    "success_improvement": 0.0,
                    "time_improvement": -19.007669960062746,
                    "length_improvement": 14.296394960665781,
                    "smoothness_improvement": 1378.584821717589,
                    "objective_score": 4.049902112702277
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an advanced bidirectional informed RRT* planner with adaptive neighbor radius and ellipsoidal informed sampling focused after an initial solution is found. It utilizes alternating tree growth between start and goal with incremental extend-and-rewire steps to efficiently expand and optimize the search trees. Robust collision checking prevents invalid node and edge expansions, and the planner maintains strict boundary conditions. The planner applies recursive parent-child cost updates to ensure consistent path cost propagation and employs randomized shortcut path smoothing upon solution discovery. It enforces a hard time limit of 30 seconds and returns the best path found so far if the limit is exceeded.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternating expansions with goal bias sampling initially and switching to ellipsoidal informed sampling after finding a solution. Each extension involves adaptive neighbor radius searches for near nodes, rewiring connections to minimize cost, and incremental connections to the opposite tree. Upon successful connection, the combined path is smoothed via random shortcutting. The process ends early if the time limit is reached or the maximum number of iterations is met, returning the best feasible path discovered.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] (2D or 3D)\n        self.parent = None                  # type: Node or None\n        self.cost = cost                    # Cost from root node\n        self.children = []                  # Children nodes\n        self.valid = True                   # Validity flag for collision\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist_func = math.dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist_func(self.position, child.position))\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 5.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        t_start = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (dist_func(n.position, pos) ** 2) <= r_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in sample)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in sample)\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ux, uy, uz = vx/norm_v, vy/norm_v, vz/norm_v\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0.0; vy_ = 1.0; vz_ = 0.0\n                else:\n                    vx_ = -uy; vy_ = ux; vz_ = 0.0\n                norm_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                vx_ /= norm_; vy_ /= norm_; vz_ /= norm_\n                wx = uy*vz_ - uz*vy_\n                wy = uz*vx_ - ux*vz_\n                wz = ux*vy_ - uy*vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        rotation_mat_cache = None\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat_cache\n\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat_cache is None:\n                rotation_mat_cache = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = (rotation_mat_cache[0][0] * sample_scaled[0] +\n                             rotation_mat_cache[0][1] * sample_scaled[1])\n                    y_rot = (rotation_mat_cache[1][0] * sample_scaled[0] +\n                             rotation_mat_cache[1][1] * sample_scaled[1])\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat_cache[0][0] * sample_scaled[0] +\n                             rotation_mat_cache[0][1] * sample_scaled[1] +\n                             rotation_mat_cache[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat_cache[1][0] * sample_scaled[0] +\n                             rotation_mat_cache[1][1] * sample_scaled[1] +\n                             rotation_mat_cache[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat_cache[2][0] * sample_scaled[0] +\n                             rotation_mat_cache[2][1] * sample_scaled[1] +\n                             rotation_mat_cache[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            current = min(other_tree, key=lambda n: dist_func(n.position, new_node.position))\n            while True:\n                new_pos = steer(current.position, new_node.position)\n                new_pos = clamp(new_pos)\n\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + dist_func(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist_func(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    return None\n\n                current = conn_node\n\n        def path_shortcut(path, trials=self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                # Time limit reached - return best found path so far\n                if best_path:\n                    smoothed = path_shortcut(best_path)\n                    success_state = True\n                else:\n                    smoothed = []\n                    success_state = False\n\n                all_nodes = tree_start + tree_goal\n                all_edges.clear()\n                for n in all_nodes:\n                    for c in n.children:\n                        all_edges.append((n, c))\n                return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n            # Sample point with goal bias or informed sampling after first solution\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    while True:\n                        candidate = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample = candidate\n                            break\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    smoothed_path = path_shortcut(best_path)\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Maximum iterations reached without time out\n        if best_path:\n            smoothed = path_shortcut(best_path)\n            success_state = True\n        else:\n            smoothed = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.59493,
          "time_improvement": 19.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1486.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03465654850006104,
                    "num_nodes_avg": 76.1,
                    "path_length_avg": 162.21557346570654,
                    "smoothness_avg": 0.050691134714433005,
                    "success_improvement": 0.0,
                    "time_improvement": -39.60582702181484,
                    "length_improvement": 11.087073713192737,
                    "smoothness_improvement": 693.4263358417613,
                    "objective_score": -6.197201684697097
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.060128068923950194,
                    "num_nodes_avg": 260.7,
                    "path_length_avg": 231.1362884249126,
                    "smoothness_avg": 0.09791701174369438,
                    "success_improvement": 0.0,
                    "time_improvement": 62.33502042264701,
                    "length_improvement": 22.840054034581318,
                    "smoothness_improvement": 2419.475238938102,
                    "objective_score": 35.36589312840088
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03244462013244629,
                    "num_nodes_avg": 170.4,
                    "path_length_avg": 121.89955495622988,
                    "smoothness_avg": 0.11349209395327017,
                    "success_improvement": 0.0,
                    "time_improvement": 33.633362546190696,
                    "length_improvement": 19.04011983110768,
                    "smoothness_improvement": 1343.611057970618,
                    "objective_score": 20.616088019931837
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines bidirectional RRT* principles with adaptive neighbor radius, informed ellipsoidal sampling after an initial solution, robust incremental extend-and-rewire steps, recursive cost and parent-child updates, and randomized path smoothing. It operates under a strict 30-second maximum planning time, enforcing collision checks on nodes and edges, clamps samples within map bounds, dynamically adapts search radius based on node count and dimension, and alternates tree growth from start and goal with early exit upon solution discovery.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal alternately. It initially samples uniformly with goal bias, switching to ellipsoidal informed sampling after the first solution to concentrate the search in promising regions. Each iteration extends one tree toward a sampled point by steering and rewiring nearby nodes within an adaptive radius. Then it incrementally tries connecting the opposite tree to the new node through incremental extend-and-rewire steps. If connected, the combined path is smoothed by removing unnecessary waypoints. The process halts after max time or iterations, returning the best solution found. All node expansions and edge additions undergo collision validation, and bounds clamping ensures valid workspace navigation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = None                # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children = []                # List[Node]\n        self.valid = True                 # Collision validity flag\n\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children's costs\n        dist_func = math.dist\n        for c in self.children:\n            c.update_parent(self, self.cost + dist_func(self.position, c.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 neighbor_radius_min: float=10.0,\n                 neighbor_radius_max: float=30.0,\n                 max_planning_time: float=30.0,\n                 smoothing_trials: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = math.dist\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist_func(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            factor = self.step_size / d\n            return tuple(from_pos[d] + factor * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def clamp_to_bounds(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 30.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree_nodes if (dist_func(node.position, pos) ** 2) <= r_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        # Rotation matrix for ellipsoidal sampling\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx * kx + ky * ky + kz * kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k\n                ky /= norm_k\n                kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1 - cos_theta*cos_theta))\n                K = [[0, -kz, ky],[kz,0,-kx],[-ky,kx,0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A, B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A, B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        self._rotation_matrix = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-14 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x/norm for x in pt)\n\n        self._unit_ball_sample = unit_ball_sample\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def informed_sample(c_best):\n            # Ellipsoidal informed sampling focused between start and goal\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple(0.5*(start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = self._rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = self._unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2]\n                    z_rot = R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist_func(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist_func(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                new_pos = clamp_to_bounds(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist_func(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through_nbr = nbr.cost + dist_func(nbr.position, new_pos)\n                    if cost_through_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + dist_func(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                if dist_func(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_start = True\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n\n                    combined_cost = new_node.cost + connected_node.cost + dist_func(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed = path_smoothing(best_path, self.smoothing_trials)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = (len(best_path) > 0)\n        smoothed = path_smoothing(best_path, self.smoothing_trials) if success_state else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.3892,
          "time_improvement": 18.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1544.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018298864364624023,
                    "num_nodes_avg": 77.9,
                    "path_length_avg": 164.46744972645791,
                    "smoothness_avg": 0.037878274583291835,
                    "success_improvement": 0.0,
                    "time_improvement": 26.287290461747688,
                    "length_improvement": 9.85278465141208,
                    "smoothness_improvement": 492.8772512182955,
                    "objective_score": 12.321130324898201
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03920965194702149,
                    "num_nodes_avg": 240.4,
                    "path_length_avg": 236.16633697666703,
                    "smoothness_avg": 0.10324832276515669,
                    "success_improvement": 0.0,
                    "time_improvement": 75.43858024631434,
                    "length_improvement": 21.160879046085782,
                    "smoothness_improvement": 2556.653711508442,
                    "objective_score": 39.64701844065367
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07202651500701904,
                    "num_nodes_avg": 360.4,
                    "path_length_avg": 124.29238523033521,
                    "smoothness_avg": 0.13221952260563,
                    "success_improvement": 0.0,
                    "time_improvement": -47.33282710719068,
                    "length_improvement": 17.45091589738023,
                    "smoothness_improvement": 1581.822568113642,
                    "objective_score": -2.800552112112946
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner enhanced with adaptive neighbor radius, ellipsoidal informed sampling after the initial solution discovery, recursive cost propagation through parent-child relationships, incremental tree connection with rewiring, and randomized path smoothing. The goal is to minimize planning time while improving path quality and robustness within a maximum 30-second planning time.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling points either uniformly or informed by the best current path cost. It extends and rewires neighbors adaptively, incrementally connects opposite trees with rewiring, and updates costs recursively for correctness. Once a connection yields a better path, ellipsoidal informed sampling is enabled, and the planner tries early termination. Upon completion or timeout, the path is extracted and smoothed using randomized shortcutting.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children: List['Node'] = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + self._distance(parent))\n\n    def _distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def add_child(self, child: 'Node') -> None:\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node') -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float) -> None:\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update recursively to children\n        for c in self.children:\n            c.update_parent(self, new_cost + c._distance(self))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 max_planning_time: float=30.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=5.0, neighbor_radius_max: float=30.0,\n                 smoothing_trials: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp_to_bounds(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> bool:\n            resolution = self.step_size / 5.0 if self.step_size > 0 else 0.5\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d, resolution)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            val = (2.0 * (1 + 1/dim)) ** (1/dim) * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            radius = val * (max(bounds) if max(bounds) > 0 else 10.0)  # scale according to map size\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, radius))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r2 = radius * radius\n            return [node for node in tree if (math.dist(node.position, pos) ** 2) <= r2]\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling_enabled = False\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                c, s = math.cos(angle), math.sin(angle)\n                return [[c, -s], [s, c]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                vx /= norm_v\n                vy /= norm_v\n                vz /= norm_v\n                arbitrary = (1.0, 0.0, 0.0) if abs(vx) < 0.9 else (0.0, 1.0, 0.0)\n                wx = vy*arbitrary[2] - vz*arbitrary[1]\n                wy = vz*arbitrary[0] - vx*arbitrary[2]\n                wz = vx*arbitrary[1] - vy*arbitrary[0]\n                norm_w = math.sqrt(wx*wx + wy*wy + wz*wz)\n                if norm_w < 1e-12:\n                    wx, wy, wz = 0.0, 0.0, 1.0\n                else:\n                    wx /= norm_w\n                    wy /= norm_w\n                    wz /= norm_w\n                ux, uy, uz = vx, vy, vz\n                vx_, vy_, vz_ = wx, wy, wz\n                wx_, wy_, wz_ = uy*wz - uz*vy_, uz*vx_ - ux*wz, ux*vy_ - uy*vx_\n                return [\n                    [ux, vx_, wx_],\n                    [uy, vy_, wy_],\n                    [uz, vz_, wz_]\n                ]\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                return sample_free()\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1] + [a_minor]*(dim-1)\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                r = random.random() ** (1.0 / n)\n                sample_unit = tuple(r * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = sum(R[0][i]*sample_scaled[i] for i in range(n))\n                    y_rot = sum(R[1][i]*sample_scaled[i] for i in range(n))\n                    z_rot = sum(R[2][i]*sample_scaled[i] for i in range(n))\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp_to_bounds(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def sample_free() -> Tuple[float, ...]:\n            for _ in range(30):\n                pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]) -> None:\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend_and_rewire(tree: List[Node], sample_pt: Tuple[float, ...]) -> Optional[Node]:\n            if not tree:\n                return None\n            nearest_node = min(tree, key=lambda n: math.dist(n.position, sample_pt))\n            new_pos = steer(nearest_node.position, sample_pt)\n            new_pos = clamp_to_bounds(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            n_radius = adaptive_neighbor_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, n_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                tentative_cost = nbr.cost + math.dist(nbr.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect_and_rewire(new_node: Node, other_tree: List[Node]) -> Optional[Node]:\n            if not other_tree:\n                return None\n            current_node = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            while True:\n                step_pos = steer(current_node.position, new_node.position)\n                step_pos = clamp_to_bounds(step_pos)\n                if not collision_free_node(step_pos) or not collision_free_edge(current_node.position, step_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, step_pos, radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, step_pos)\n                best_parent = current_node\n                for nbr in neighbors:\n                    if nbr == current_node:\n                        continue\n                    tentative_cost = nbr.cost + math.dist(nbr.position, step_pos)\n                    if tentative_cost + 1e-9 < min_cost and collision_free_edge(nbr.position, step_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                connect_node = Node(step_pos)\n                connect_node.update_parent(best_parent, min_cost)\n                other_tree.append(connect_node)\n                rewire(other_tree, connect_node, neighbors)\n\n                dist_to_new = math.dist(connect_node.position, new_node.position)\n                if dist_to_new <= self.step_size:\n                    if collision_free_edge(connect_node.position, new_node.position):\n                        return connect_node\n                    else:\n                        return None\n                current_node = connect_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], max_trials: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if collision_free_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialize trees\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        best_path_nodes: List[Tuple[float, ...]] = []\n        best_path_cost = math.inf\n\n        grow_start = True\n        start_time = time.perf_counter()\n        edges: List[Tuple[Node, Node]] = []\n\n        for iter_count in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed >= self.max_planning_time:\n                # Time limit exceeded, return best path found so far if any\n                if best_path_nodes:\n                    smoothed = path_smoothing(best_path_nodes, self.smoothing_trials)\n                    all_nodes = tree_start + tree_goal\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(True, smoothed, all_nodes, edges)\n                else:\n                    all_nodes = tree_start + tree_goal\n                    edges.clear()\n                    for node in all_nodes:\n                        for c in node.children:\n                            edges.append((node, c))\n                    return PlannerResult(False, [], all_nodes, edges)\n\n            # Sample point\n            if informed_sampling_enabled:\n                sample_pt = informed_sample(best_path_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = sample_free()\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connect_node = incremental_connect_and_rewire(new_node, other_tree)\n            if connect_node is not None:\n                if grow_start:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_b = new_node.path_from_root()\n                    path_a = connect_node.path_from_root()\n\n                # Avoid duplicated node when combining\n                if path_b and path_b[0] == new_node.position:\n                    path_b = path_b[1:]\n                combined_path = path_a + path_b[::-1]\n\n                # Compute combined cost\n                total_cost = sum(math.dist(combined_path[i], combined_path[i+1]) for i in range(len(combined_path)-1))\n                if total_cost + 1e-9 < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = combined_path\n                    informed_sampling_enabled = True  # enable informed sampling\n\n                # Early return upon first found path to reduce planning time\n                smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n                all_nodes = tree_start + tree_goal\n                edges.clear()\n                for node in all_nodes:\n                    for c in node.children:\n                        edges.append((node, c))\n                return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            grow_start = not grow_start\n\n        # Max iterations reached\n        if best_path_nodes:\n            smoothed_path = path_smoothing(best_path_nodes, self.smoothing_trials)\n            all_nodes = tree_start + tree_goal\n            edges.clear()\n            for node in all_nodes:\n                for c in node.children:\n                    edges.append((node, c))\n            return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n        all_nodes = tree_start + tree_goal\n        edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.14874,
          "time_improvement": 15.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1361.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030020666122436524,
                    "num_nodes_avg": 68.2,
                    "path_length_avg": 159.0788022516029,
                    "smoothness_avg": 0.04711080061185578,
                    "success_improvement": 0.0,
                    "time_improvement": -20.93125551037343,
                    "length_improvement": 12.806387720963622,
                    "smoothness_improvement": 637.3863323164837,
                    "objective_score": -0.5311674473368853
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05448329448699951,
                    "num_nodes_avg": 220.2,
                    "path_length_avg": 226.58721277246187,
                    "smoothness_avg": 0.09072106820488227,
                    "success_improvement": 0.0,
                    "time_improvement": 65.87097821559428,
                    "length_improvement": 24.358666425251982,
                    "smoothness_improvement": 2234.318428655835,
                    "objective_score": 35.804618893007856
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04841036796569824,
                    "num_nodes_avg": 221.4,
                    "path_length_avg": 121.79551877288058,
                    "smoothness_avg": 0.1031211519944687,
                    "success_improvement": 0.0,
                    "time_improvement": 0.9748510948969299,
                    "length_improvement": 19.109215710417594,
                    "smoothness_improvement": 1211.6934417579703,
                    "objective_score": 10.172765679342449
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling, rewiring, and incremental connection between two trees grown from start and goal positions. It uses goal biasing and ellipsoidal informed sampling after finding a feasible path, adaptively adjusts neighbor radius for optimal rewiring, performs rigorous collision checks, and applies randomized path smoothing to improve path quality within a strict 30-second planning time limit.",
          "planning_mechanism": "A planner that alternately grows two trees from start and goal, samples points using uniform, goal bias, or informed ellipsoidal distribution based on current best cost, extends and rewires nodes using adaptive neighborhood radius, and incrementally connects the trees to find shorter, collision-free paths efficiently. Once a path is found, it smooths the path and returns early if time allows, otherwise terminates after 30 seconds returning the best solution found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                    # Cost from root to this node\n        self.children = []\n        self.valid = True                   # Collision-free flag\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            c.update_parent(self, self.cost + self._dist(self.position, c.position))\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 15000, step_size: float = 5.0, max_planning_time: float = 30.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius_min: float = 5.0, neighbor_radius_max: float = 30.0,\n                 smoothing_trials: int = 150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        rotation_mat_cache = None\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0.0; vy_ = 1.0; vz_ = 0.0\n                else:\n                    vx_ = -uy; vy_ = ux; vz_ = 0.0\n                norm_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_; vy_ /= norm_; vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat_cache\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat_cache is None:\n                rotation_mat_cache = rotation_matrix(direction)\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = rotation_mat_cache[0][0] * sample_scaled[0] + rotation_mat_cache[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat_cache[1][0] * sample_scaled[0] + rotation_mat_cache[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = rotation_mat_cache[0][0] * sample_scaled[0] + rotation_mat_cache[0][1] * sample_scaled[1] + rotation_mat_cache[0][2] * sample_scaled[2]\n                    y_rot = rotation_mat_cache[1][0] * sample_scaled[0] + rotation_mat_cache[1][1] * sample_scaled[1] + rotation_mat_cache[1][2] * sample_scaled[2]\n                    z_rot = rotation_mat_cache[2][0] * sample_scaled[0] + rotation_mat_cache[2][1] * sample_scaled[1] + rotation_mat_cache[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            current = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(current.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    else:\n                        return None\n\n                current = conn_node\n\n        def path_shortcut(path, trials=self.smoothing_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        all_nodes = tree_start + tree_goal\n\n        grow_start = True\n        iteration = 0\n        t_start = time.perf_counter()\n\n        informed_sampling = False\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    while True:\n                        candidate = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample = candidate\n                            break\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path_1 = new_node.path_from_root()\n                path_2 = connected_node.path_from_root()\n                if path_2 and path_2[0] == new_node.position:\n                    path_2 = path_2[1:]\n                combined_path = path_1 + path_2[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    smoothed = path_shortcut(best_path)\n                    # Early return to save time and return best path\n                    return PlannerResult(True, smoothed, all_nodes, [(n, c) for n in all_nodes for c in n.children])\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed = path_shortcut(best_path) if success else []\n\n        edges = [(n, c) for n in all_nodes for c in n.children]\n\n        return PlannerResult(success, smoothed, all_nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -13.62871,
          "time_improvement": 9.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1488.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03388102054595947,
                    "num_nodes_avg": 60.3,
                    "path_length_avg": 166.10845693488557,
                    "smoothness_avg": 0.042511824242989306,
                    "success_improvement": 0.0,
                    "time_improvement": -36.48179343806963,
                    "length_improvement": 8.953322597049631,
                    "smoothness_improvement": 565.4023653066935,
                    "objective_score": -6.326861685477494
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04967365264892578,
                    "num_nodes_avg": 194.3,
                    "path_length_avg": 229.5597724757294,
                    "smoothness_avg": 0.10988305211737452,
                    "success_improvement": 0.0,
                    "time_improvement": 68.8837984316327,
                    "length_improvement": 23.366340435914243,
                    "smoothness_improvement": 2727.370076543399,
                    "objective_score": 38.975257999389655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.052152490615844725,
                    "num_nodes_avg": 212.0,
                    "path_length_avg": 117.51371533457231,
                    "smoothness_avg": 0.09986035321798678,
                    "success_improvement": 0.0,
                    "time_improvement": -6.679795383198063,
                    "length_improvement": 21.952985676572606,
                    "smoothness_improvement": 1170.2163220082493,
                    "objective_score": 8.237740130396348
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -12.754228290907717,
          "time_improvement": 43.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015238714218139649,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 39.24994606082438,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 11.516619843324023
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028333163261413573,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 82.41154890775475,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 25.104532592995444
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04547352790832519,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 7.545520778648536,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 1.641532436403683
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements an enhanced bidirectional informed RRT* planner that combines efficient informed sampling within an ellipsoidal subset, adaptive neighbor radius based rewiring for cost optimization, incremental connection attempts between start and goal trees, and collision-checked edge validations. It applies randomized shortcut path smoothing after initial path discovery and enforces a strict 30-second time limit to guarantee timely planning response.",
          "planning_mechanism": "The planner initializes two trees growing from start and goal positions alternately. Sampling is biased towards the goal and constricted inside an informed ellipsoidal region after finding a feasible path to improve convergence speed. Adaptive neighbor radius dynamically adjusts rewiring scope based on tree size and space dimensionality, enhancing path quality. Incremental tree connection with collision-checked edges and rewiring optimizes path costs. The process stops when the time limit is exceeded or a path is found, returning the best smooth path discovered.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Cumulative cost from root\n        self.children = []                 # List[Node]\n        self.valid = True                  # Collision validity flag\n        if parent is not None:\n            self.set_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def set_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            try:\n                self.parent.remove_child(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            dist_c = math.dist(c.position, self.position)\n            c.set_parent(self, self.cost + dist_c)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0           # seconds\n        self.goal_sample_rate = 0.2              # goal bias probability\n        self.neighbor_radius_min = self.step_size * 2.0\n        self.neighbor_radius_max = self.step_size * 15.0\n        self.smooth_trials = 150\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        rotation_mat = None\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                # Construct orthonormal basis\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0\n                    vy_ = 1\n                    vz_ = 0\n                else:\n                    vx_ = -uy\n                    vy_ = ux\n                    vz_ = 0\n                norm_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_\n                vy_ /= norm_\n                vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1] + rotation_mat[0][2] * sample_scaled[2]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1] + rotation_mat[1][2] * sample_scaled[2]\n                    z_rot = rotation_mat[2][0] * sample_scaled[0] + rotation_mat[2][1] * sample_scaled[1] + rotation_mat[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree: list, new_node: Node, neighbors: list):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.set_parent(new_node, cost_via_new)\n\n        def extend(tree: list, sample_pt: tuple) -> Node or None:\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node: Node, other_tree: list) -> Node or None:\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    else:\n                        return None\n                curr = conn_node\n\n        def path_shortcut(path: list, trials: int = None) -> list:\n            if trials is None:\n                trials = self.smooth_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iter_count = 0\n        t_start = time.perf_counter()\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    # limit number of sampling attempts for free space\n                    for _ in range(20):\n                        candidate = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample = candidate\n                            break\n                    else:\n                        grow_start = not grow_start\n                        continue\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    current_nodes = tree_start + tree_goal\n                    for nd in current_nodes:\n                        for c in nd.children:\n                            all_edges.append((nd, c))\n\n                    # Return immediately to improve planning time with smoothing\n                    smooth_path = path_shortcut(best_path)\n                    return PlannerResult(True, smooth_path, current_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = best_path != []\n        if success_state:\n            final_path = path_shortcut(best_path)\n        else:\n            final_path = []\n\n        all_edges.clear()\n        current_nodes = tree_start + tree_goal\n        for nd in current_nodes:\n            for c in nd.children:\n                all_edges.append((nd, c))\n\n        return PlannerResult(success_state, final_path, current_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -8.53925,
          "time_improvement": -7.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1323.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.046105480194091795,
                    "num_nodes_avg": 75.7,
                    "path_length_avg": 153.6629753651883,
                    "smoothness_avg": 0.04427282360514312,
                    "success_improvement": 0.0,
                    "time_improvement": -85.72517954933548,
                    "length_improvement": 15.774888256676311,
                    "smoothness_improvement": 592.9658293957219,
                    "objective_score": -19.59774706648677
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0734133005142212,
                    "num_nodes_avg": 229.6,
                    "path_length_avg": 231.5113430777698,
                    "smoothness_avg": 0.08307874601130612,
                    "success_improvement": 0.0,
                    "time_improvement": 54.01298405123367,
                    "length_improvement": 22.71484999610797,
                    "smoothness_improvement": 2037.6759740729394,
                    "objective_score": 30.935245084956392
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04303014278411865,
                    "num_nodes_avg": 172.2,
                    "path_length_avg": 120.47210977619234,
                    "smoothness_avg": 0.11302771497482314,
                    "success_improvement": 0.0,
                    "time_improvement": 11.9802952205522,
                    "length_improvement": 19.98816095205351,
                    "smoothness_improvement": 1337.7041916416624,
                    "objective_score": 14.280241714784673
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius, goal-biased sampling, incremental tree extension and rewiring, and randomized path smoothing. It grows two trees from start and goal points alternately, dynamically rewires to reduce path costs, and employs collision checks on nodes and edges to ensure path validity. The planner enforces a 30-second execution limit and returns the best path found within that time.",
          "planning_mechanism": "The planner samples points biased towards the goal and adapts its neighbor search radius based on iteration and tree size. It extends one tree towards the sample with incremental rewiring to optimize cost, then attempts to incrementally connect the other tree. On successful connection, it performs randomized shortcut smoothing and returns the optimized path. The process alternates tree growth until success, max iterations, or timeout.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = None               # Node or None\n        self.cost = cost                 # Cost from root\n        self.children = []               # List[Node]\n        self.valid = True                # For collision state\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._distance(parent.position, position))\n\n    def add_child(self, child_node: 'Node'):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Detach from current parent\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update cost for descendants\n        for child in self.children:\n            child.update_parent(self, self.cost + self._distance(self.position, child.position))\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            resolution = self.step_size / 5.0\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def adaptive_radius(n_nodes, iter_num):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 30.0\n            base_r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            factor = min(1.0, iter_num / self.max_iter)\n            r = base_r * (1.0 - 0.6 * factor)\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree_nodes if (math.dist(n.position, pos) ** 2) <= r_sq]\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes + 1, iter_num)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_through = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_through\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n            return new_node\n\n        def incremental_connect(tree: List[Node], target_pos: Tuple[float, ...], iter_num: int) -> Node:\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_pos))\n            current = nearest\n\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes + 1, iter_num)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_through = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost_through < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if cost_through_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_through_new)\n\n                dist_to_target = math.dist(new_node.position, target_pos)\n                if dist_to_target <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n                current = new_node\n\n        def path_smoothing(path: List[Tuple[float, ...]], trials: int = 150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_cost = math.inf\n        best_path = []\n        grow_start = True\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_planning_time:\n                break\n\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal_pos if grow_start else start_pos\n            else:\n                sample_pt = sample_uniform()\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt, iter_count)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_goal, new_node.position, iter_count)\n                if connect_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                    best_path = path_smoothing(best_path)\n                    return self._build_result(True, best_path, tree_start + tree_goal)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt, iter_count)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n                connect_node = incremental_connect(tree_start, new_node.position, iter_count)\n                if connect_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                    best_path = path_smoothing(best_path)\n                    return self._build_result(True, best_path, tree_start + tree_goal)\n\n            grow_start = not grow_start\n\n        # Timeout or iteration reached without final connection\n        success = len(best_path) > 0\n        if success:\n            best_path = path_smoothing(best_path)\n        return self._build_result(success, best_path, tree_start + tree_goal)\n\n    def _build_result(self, success, path, nodes):\n        edges = []\n        for node in nodes:\n            for c in node.children:\n                edges.append((node, c))\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -8.31356,
          "time_improvement": -7.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1427.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018069934844970704,
                    "num_nodes_avg": 67.7,
                    "path_length_avg": 164.63825310145506,
                    "smoothness_avg": 0.04151129616604261,
                    "success_improvement": 0.0,
                    "time_improvement": 27.209479667082203,
                    "length_improvement": 9.759164615023467,
                    "smoothness_improvement": 549.7419282209837,
                    "objective_score": 12.863386464234273
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03850798606872559,
                    "num_nodes_avg": 234.1,
                    "path_length_avg": 232.9451236606953,
                    "smoothness_avg": 0.10150927981529603,
                    "success_improvement": 0.0,
                    "time_improvement": 75.87811258868122,
                    "length_improvement": 22.23621276844159,
                    "smoothness_improvement": 2511.9068838265202,
                    "objective_score": 39.77021074942529
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11020479202270508,
                    "num_nodes_avg": 321.9,
                    "path_length_avg": 121.6367415852742,
                    "smoothness_avg": 0.1036562598515085,
                    "success_improvement": 0.0,
                    "time_improvement": -125.4278659446848,
                    "length_improvement": 19.21466795826856,
                    "smoothness_improvement": 1218.4999742019631,
                    "objective_score": -27.69292632074191
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements a bidirectional informed RRT* planner with adaptive neighborhood radius and heuristic-driven sampling to minimize path length. It manages parent-child relationships with recursive cost updates and uses rewiring to continuously optimize the trees. Sampling switches to an ellipsoidal informed subset after a first solution is found. The planner alternates growth from start and goal trees, attempts incremental connections, applies shortcut-based path smoothing, and enforces a strict 30-second time limit with early termination on improved solutions.",
          "planning_mechanism": "The planner initializes two trees at start and goal, grows them alternately with adaptive radius rewiring, and guides sampling informed by the current best path. It tries to incrementally connect the two trees with collision-checked edges and rewiring for cost optimization. When a feasible path is found, informed sampling focuses exploration within an ellipsoid bounded by the cost, improving path quality. A randomized shortcut smoothing is applied before returning. The process aborts and returns the best path if time expires.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist = math.dist(child.position, self.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 20000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0  # seconds\n        self.goal_sample_rate = 0.1     # 10% goal bias\n        self.smooth_trials = 120\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            r = max(self.step_size, min(self.step_size * 15.0, r))\n            return r\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        rotation_mat = None\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ux, uy, uz = vx/norm_v, vy/norm_v, vz/norm_v\n                # Create orthonormal basis\n                if abs(ux)<1e-6 and abs(uy)<1e-6:\n                    vx_ = 0; vy_ = 1; vz_ = 0\n                else:\n                    vx_ = -uy; vy_ = ux; vz_ = 0\n                norm_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                vx_ /= norm_; vy_ /= norm_; vz_ /= norm_\n                wx = uy*vz_ - uz*vy_\n                wy = uz*vx_ - ux*vz_\n                wz = ux*vy_ - uy*vx_\n                return [[ux, vx_, wx],[uy, vy_, wy],[uz, vz_, wz]]\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best/2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0]*sample_scaled[0] + rotation_mat[0][1]*sample_scaled[1]\n                    y_rot = rotation_mat[1][0]*sample_scaled[0] + rotation_mat[1][1]*sample_scaled[1]\n                    rotated = (x_rot,y_rot)\n                else:\n                    x_rot = (rotation_mat[0][0]*sample_scaled[0] +\n                             rotation_mat[0][1]*sample_scaled[1] +\n                             rotation_mat[0][2]*sample_scaled[2])\n                    y_rot = (rotation_mat[1][0]*sample_scaled[0] +\n                             rotation_mat[1][1]*sample_scaled[1] +\n                             rotation_mat[1][2]*sample_scaled[2])\n                    z_rot = (rotation_mat[2][0]*sample_scaled[0] +\n                             rotation_mat[2][1]*sample_scaled[1] +\n                             rotation_mat[2][2]*sample_scaled[2])\n                    rotated = (x_rot,y_rot,z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius*radius\n            return [node for node in tree if (dist(node.position, position)**2) <= radius_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree)+1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    return None\n                curr = conn_node\n\n        def path_shortcut(path, trials=self.smooth_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        iter_count = 0\n        grow_start = True\n        informed_sampling = False\n        t_start = time.perf_counter()\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                if best_path:\n                    smooth_path = path_shortcut(best_path)\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, all_edges)\n\n            sample_pt = None\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    while True:\n                        cand = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(cand):\n                            sample_pt = cand\n                            break\n\n            active_tree = tree_start if grow_start else tree_goal\n            opposite_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, opposite_tree)\n            if connected_node is not None:\n                path_1 = new_node.path_from_root()\n                path_2 = connected_node.path_from_root()\n                if path_2 and path_2[0] == new_node.position:\n                    path_2 = path_2[1:]\n                combined = path_1 + path_2[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined\n                    informed_sampling = True\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    smooth_path = path_shortcut(best_path)\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # End reached without time out or max iter exceeded\n        if best_path:\n            smooth_path = path_shortcut(best_path)\n            success_state = True\n        else:\n            smooth_path = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(success_state, smooth_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -8.2469,
          "time_improvement": -5.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1233.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0533411979675293,
                    "num_nodes_avg": 81.3,
                    "path_length_avg": 161.00940670887172,
                    "smoothness_avg": 0.04789510123120933,
                    "success_improvement": 0.0,
                    "time_improvement": -114.87258191848393,
                    "length_improvement": 11.748192825549255,
                    "smoothness_improvement": 649.6623401454214,
                    "objective_score": -28.86382430970822
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06928157806396484,
                    "num_nodes_avg": 256.4,
                    "path_length_avg": 227.55406281513925,
                    "smoothness_avg": 0.08068735269649945,
                    "success_improvement": 0.0,
                    "time_improvement": 56.60114702558473,
                    "length_improvement": 24.035904051770824,
                    "smoothness_improvement": 1976.143701631981,
                    "objective_score": 31.668243426189488
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02742946147918701,
                    "num_nodes_avg": 134.3,
                    "path_length_avg": 124.93952281345389,
                    "smoothness_avg": 0.09220851935269885,
                    "success_improvement": 0.0,
                    "time_improvement": 43.892049957399955,
                    "length_improvement": 17.02111792805305,
                    "smoothness_improvement": 1072.8855600414115,
                    "objective_score": 21.936266373037654
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation enhances a bidirectional informed RRT* planner focused on minimizing path length while improving efficiency, robustness, and smoothness. It incorporates adaptive neighborhood radius for efficient rewiring, recursive cost propagation on parent updates, goal-biased and ellipsoidal informed sampling, incremental tree connection with rewiring, and randomized shortcut smoothing. Early termination on time limits or improved solution accelerates practical usability while maintaining high path quality.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points biased by the goal and informed ellipsoids once a solution exists. Each extension rewires the tree locally within an adaptive radius minimizing path costs. Trees connect incrementally with rewiring optimizing path quality. The algorithm stops early upon finding better solutions or exceeding a time limit, returning the shortest collision-free smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.children = []\n        self.cost = cost\n        self.valid = True\n        if parent is not None:\n            self.set_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def set_parent(self, new_parent, new_cost):\n        # Remove from old parent's children list\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost changes recursively to children\n        for child in self.children:\n            dist = math.dist(child.position, self.position)\n            child.set_parent(self, self.cost + dist)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0  # seconds\n        self.goal_sample_rate = 0.1    # goal bias rate\n        self.smooth_trials = 150       # shortcut smoothing attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            r = max(self.step_size, min(self.step_size * 15.0, r))\n            return r\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        rotation_mat = None  # Lazy initialized for informed sampling\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0\n                    vy_ = 1\n                    vz_ = 0\n                else:\n                    vx_ = -uy\n                    vy_ = ux\n                    vz_ = 0\n                norm_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_\n                vy_ /= norm_\n                vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat[0][0] * sample_scaled[0] +\n                             rotation_mat[0][1] * sample_scaled[1] +\n                             rotation_mat[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat[1][0] * sample_scaled[0] +\n                             rotation_mat[1][1] * sample_scaled[1] +\n                             rotation_mat[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat[2][0] * sample_scaled[0] +\n                             rotation_mat[2][1] * sample_scaled[1] +\n                             rotation_mat[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position) ** 2) <= r_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.set_parent(new_node, cost_new)\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(new_node, other_tree):\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                # Check if close enough to new_node to connect\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    return None\n                curr = conn_node\n\n        def path_shortcut(path, trials=None):\n            if trials is None:\n                trials = self.smooth_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        informed_sampling = False\n        iteration = 0\n        t_start = time.perf_counter()\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                if best_path:\n                    smooth = path_shortcut(best_path)\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n                    return PlannerResult(True, smooth, all_nodes, all_edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, all_edges)\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    sample_pt = None\n                    for _ in range(10):\n                        candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample_pt = candidate\n                            break\n                    if sample_pt is None:\n                        grow_start = not grow_start\n                        continue\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend_and_rewire(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = connect_and_rewire(new_node, other_tree)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                # If the connecting nodes overlap, avoid duplication\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    smoothed = path_shortcut(best_path)\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        if best_path:\n            success = True\n            smoothed = path_shortcut(best_path)\n        else:\n            success = False\n            smoothed = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.62536,
          "time_improvement": -10.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1361.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.035140705108642575,
                    "num_nodes_avg": 51.5,
                    "path_length_avg": 151.00243359626307,
                    "smoothness_avg": 0.0425745504428125,
                    "success_improvement": 0.0,
                    "time_improvement": -41.556139060216005,
                    "length_improvement": 17.233173359206425,
                    "smoothness_improvement": 566.3841665460495,
                    "objective_score": -6.188286213493267
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0801279067993164,
                    "num_nodes_avg": 277.7,
                    "path_length_avg": 230.78182893732932,
                    "smoothness_avg": 0.08973491856619993,
                    "success_improvement": 0.0,
                    "time_improvement": 49.806870116027284,
                    "length_improvement": 22.958382814087273,
                    "smoothness_improvement": 2208.944088157664,
                    "objective_score": 30.578458038413956
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06824440956115722,
                    "num_nodes_avg": 253.0,
                    "path_length_avg": 121.74127153244274,
                    "smoothness_avg": 0.11062621915034457,
                    "success_improvement": 0.0,
                    "time_improvement": -39.596394382352884,
                    "length_improvement": 19.145244144540406,
                    "smoothness_improvement": 1307.157342014278,
                    "objective_score": -1.5140827757263935
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with goal biasing, adaptive neighbor radius, incremental extension, and dynamic rewiring to minimize path length and reduce planning time. It maintains two trees grown from start and goal, applies collision and edge checks, rewires nodes in the neighborhood to optimize costs, and performs early termination upon connection or time expiration. The design emphasizes robustness, path smoothness through path shortening post-processing, and computational efficiency within a 30-second planning time limit.",
          "planning_mechanism": "The planner simultaneously grows two search trees from start and goal points by iterative biased sampling and stepwise steering. It attempts incremental extension and rewiring for cost improvements at each iteration and tries to connect both trees once new nodes are added. Upon successful connection, it merges the two trees\u2019 paths and performs smoothing to produce an optimized, collision-free path. The algorithm enforces obstacle and boundary validity, dynamically adjusts neighbor radius based on iteration count, and halts early either when a feasible path is found or the time limit is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 max_time_sec: float = 30.0, neighbor_radius_min: float = 10.0, neighbor_radius_max: float = 25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time_sec = max_time_sec\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success_state = False\n        best_path_cost = math.inf\n        best_path_nodes = (None, None)\n        extracted_path = []\n\n        def within_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dimension))\n\n        def sample_free():\n            # Goal biasing with goal_sample_rate\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def calc_neighbor_radius(iter_num):\n            # Adaptive radius between min and max over iterations\n            r_min = self.neighbor_radius_min\n            r_max = self.neighbor_radius_max\n            return r_min + (r_max - r_min) * min(1.0, iter_num / self.max_iter)\n\n        # Incrementally extend tree by adding one node toward point with rewiring\n        def try_extend_and_rewire(tree, point, iter_num):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (\n                not within_bounds(new_pos) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                return None\n\n            neighbor_radius = calc_neighbor_radius(iter_num)\n            neighbors = near_nodes(tree, new_pos, neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire the neighbors through the new node if it reduces cost\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n\n            return new_node\n\n        # Incrementally try to connect other tree from given node with rewiring\n        def try_connect_and_rewire(tree, connecting_node, iter_num):\n            current_node = nearest(tree, connecting_node.position)\n\n            while True:\n                dist = math.dist(current_node.position, connecting_node.position)\n                if dist <= self.step_size:\n                    new_pos = connecting_node.position\n                else:\n                    new_pos = steer(current_node.position, connecting_node.position)\n\n                if (\n                    not within_bounds(new_pos) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d)\n                ):\n                    return None\n\n                neighbor_radius = calc_neighbor_radius(iter_num)\n                neighbors = near_nodes(tree, new_pos, neighbor_radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    if neighbor == current_node:\n                        continue\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                new_node_goal = Node(new_pos)\n                best_parent.add_child(new_node_goal)\n                new_node_goal.cost = min_cost\n                tree.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((best_parent, new_node_goal))\n\n                # Rewire neighbors through the new node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_thru_new = new_node_goal.cost + math.dist(new_node_goal.position, neighbor.position)\n                    if cost_thru_new < neighbor.cost and not self._is_edge_in_obstacle(new_node_goal.position, neighbor.position, obstacles, is_3d):\n                        neighbor.update_parent(new_node_goal, cost_thru_new)\n                        edges.append((new_node_goal, neighbor))\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n\n                if new_node_goal.position == connecting_node.position:\n                    return new_node_goal\n                current_node = new_node_goal\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]  # Avoid duplicating middle node\n\n        def path_smoothing(path, max_iter_smooth=100):\n            # Random shortcut smoothing with collision checks\n            if len(path) < 3:\n                return path[:]\n            for _ in range(max_iter_smooth):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    # Shortcut possible: remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        iter_num = 0\n        while iter_num < self.max_iter:\n            if time.perf_counter() - start_time > self.max_time_sec:\n                # Time over: return best if any\n                if success_state and best_path_nodes[0] and best_path_nodes[1]:\n                    extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n                    extracted_path = path_smoothing(extracted_path)\n                break\n\n            rnd_point = sample_free()\n\n            new_node_start = try_extend_and_rewire(tree_start, rnd_point, iter_num)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                iter_num += 1\n                continue\n\n            connect_node_goal = try_connect_and_rewire(tree_goal, new_node_start, iter_num)\n            if connect_node_goal:\n                total_cost = new_node_start.cost + connect_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                    best_path_nodes = (new_node_start, connect_node_goal)\n                    extracted_path = merge_paths(new_node_start, connect_node_goal)\n                    extracted_path = path_smoothing(extracted_path)\n                    success_state = True\n\n                # Early break on success\n                if success_state:\n                    break\n\n            # Swap the trees for balanced growth\n            tree_start, tree_goal = tree_goal, tree_start\n            iter_num += 1\n\n        # Final fallback if no solution but best found\n        if not success_state and best_path_nodes[0] and best_path_nodes[1]:\n            extracted_path = merge_paths(best_path_nodes[0], best_path_nodes[1])\n            extracted_path = path_smoothing(extracted_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.3953,
          "time_improvement": -15.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1341.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01731138229370117,
                    "num_nodes_avg": 88.6,
                    "path_length_avg": 170.72535292944107,
                    "smoothness_avg": 0.038492850070451404,
                    "success_improvement": 0.0,
                    "time_improvement": 30.26513179756785,
                    "length_improvement": 6.42272874303504,
                    "smoothness_improvement": 502.4966921643737,
                    "objective_score": 12.876568748699231
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04029557704925537,
                    "num_nodes_avg": 280.0,
                    "path_length_avg": 234.35659650316103,
                    "smoothness_avg": 0.0841520175069426,
                    "success_improvement": 0.0,
                    "time_improvement": 74.75834308702845,
                    "length_improvement": 21.76502250663338,
                    "smoothness_improvement": 2065.2920227018776,
                    "objective_score": 37.106967540944595
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.12199552059173584,
                    "num_nodes_avg": 485.9,
                    "path_length_avg": 122.06880526658986,
                    "smoothness_avg": 0.12233857307605467,
                    "success_improvement": 0.0,
                    "time_improvement": -149.54622532330438,
                    "length_improvement": 18.927711833800288,
                    "smoothness_improvement": 1456.1376194332715,
                    "objective_score": -33.797637133064896
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates bidirectional RRT* features with dynamic informed sampling, incremental extend-and-rewire expansions, adaptive neighbor radius, and path smoothing, enforcing rigorous collision and boundary checks. It combines rapid convergence from dual-tree growth and goal bias with continuous path cost optimization and robustness under a fixed 30-second time budget.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions using goal-biased and adaptive informed sampling once a path is found. New nodes are connected by incremental extend-and-rewire steps with adaptive neighbor radius rewiring to reduce path cost dynamically. The algorithm rapidly attempts to connect trees each iteration and performs path smoothing on the best found path. Planning halts once a path is found or after 30 seconds, returning the current best valid path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = 0.0\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            child.update_parent(self, self.cost + math.dist(self.position, child.position))\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, \n                 goal_sample_rate: float = 0.2,\n                 neighbor_radius_min: float = 10.0,\n                 neighbor_radius_max: float = 30.0,\n                 max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import time\n        start_time = time.perf_counter()\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            f = self.step_size / d\n            return tuple(from_pos[d] + f * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma_rrt = 27.0\n            r = gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: list, pos: tuple, radius: float) -> list:\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos)**2 <= radius_sq]\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(pt):\n                    return pt\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                kx, ky, kz = -vy, vx, 0.0\n                norm_k = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if norm_k < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                kx /= norm_k; ky /= norm_k; kz /= norm_k\n                cos_theta = vx\n                sin_theta = math.sqrt(max(0,1-cos_theta*cos_theta))\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                def mat_add(A,B):\n                    return [[A[i][j]+B[i][j] for j in range(3)] for i in range(3)]\n                def mat_scale(A, s):\n                    return [[A[i][j]*s for j in range(3)] for i in range(3)]\n                def mat_mul(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n\n                K2 = mat_mul(K, K)\n                return mat_add(mat_add(I, mat_scale(K, sin_theta)), mat_scale(K2, 1-cos_theta))\n\n        rot_mat = rotation_matrix\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1,1) for _ in range(n)]\n                norm_sq = sum(x*x for x in pt)\n                if 1e-10 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        def informed_sample(c_best):\n            if c_best == math.inf or c_best < c_min - 1e-10:\n                return sample_free()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            R = rot_mat(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                direction_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in direction_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1]\n                    y_rot = R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2])\n                    y_rot = (R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2])\n                    z_rot = (R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = tuple(max(0.0, min(bounds[d], sample_pt[d])) for d in range(n))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def extend_and_rewire(tree: list, sample: tuple):\n            nearest = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_neighbor_radius(n_nodes + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n            \n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n            return new_node\n\n        def incremental_connect(tree: list, target_pos: tuple):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target_pos))\n            current = nearest\n            while True:\n                new_pos = steer(current.position, target_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(current.position, new_pos):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_neighbor_radius(n_nodes + 1)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n\n                for nbr in neighbors:\n                    if nbr is new_node.parent:\n                        continue\n                    cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                    if cost_thru_new < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                        nbr.update_parent(new_node, cost_thru_new)\n\n                if dist(new_node.position, target_pos) <= self.step_size:\n                    if collision_free_edge(new_node.position, target_pos):\n                        return new_node\n                    else:\n                        return None\n\n                current = new_node\n\n        def path_smoothing(path: list, trials: int = 100) -> list:\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        grow_start = True\n        iter_count = 0\n        success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        while iter_count < self.max_iter:\n            if time.perf_counter() - start_time > self.max_planning_time:\n                break\n            iter_count += 1\n\n            sample_pt = informed_sample(best_cost) if informed_sampling else (\n                goal_pos if random.random() < self.goal_sample_rate else sample_free())\n\n            if grow_start:\n                new_node = extend_and_rewire(tree_start, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_goal, new_node.position)\n                if connected_node:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    if path_goal and path_goal[0] == new_node.position:\n                        path_goal = path_goal[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return type(self).PlannerResult(True, smoothed, all_nodes, all_edges)\n            else:\n                new_node = extend_and_rewire(tree_goal, sample_pt)\n                if new_node is None:\n                    grow_start = not grow_start\n                    continue\n\n                connected_node = incremental_connect(tree_start, new_node.position)\n                if connected_node:\n                    path_goal = new_node.path_from_root()\n                    path_start = connected_node.path_from_root()\n                    if path_start and path_start[0] == new_node.position:\n                        path_start = path_start[1:]\n                    combined_path = path_start + path_goal[::-1]\n                    combined_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        best_path = combined_path\n                        informed_sampling = True\n                        success = True\n\n                        all_nodes = tree_start + tree_goal\n                        all_edges.clear()\n                        for node in all_nodes:\n                            for c in node.children:\n                                all_edges.append((node, c))\n                        smoothed = path_smoothing(best_path)\n                        return type(self).PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Timeout or max_iter hit\n        if best_path:\n            smoothed = path_smoothing(best_path)\n            success = True\n        else:\n            smoothed = []\n            success = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return type(self).PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    PlannerResult = PlannerResult",
          "objective": -5.36949,
          "time_improvement": -18.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1481.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022114109992980958,
                    "num_nodes_avg": 101.0,
                    "path_length_avg": 158.24041305104072,
                    "smoothness_avg": 0.04131330514952262,
                    "success_improvement": 0.0,
                    "time_improvement": 10.918462800297343,
                    "length_improvement": 13.265922126918788,
                    "smoothness_improvement": 546.642938868072,
                    "objective_score": 8.66193795981332
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0474644660949707,
                    "num_nodes_avg": 288.4,
                    "path_length_avg": 239.11822107390904,
                    "smoothness_avg": 0.10252411669282843,
                    "success_improvement": 0.0,
                    "time_improvement": 70.26766070970658,
                    "length_improvement": 20.175455169153683,
                    "smoothness_improvement": 2538.019367642886,
                    "objective_score": 37.80548608495714
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11561157703399658,
                    "num_nodes_avg": 400.9,
                    "path_length_avg": 122.03148725389255,
                    "smoothness_avg": 0.11473094638392571,
                    "success_improvement": 0.0,
                    "time_improvement": -136.48763915732366,
                    "length_improvement": 18.95249668094104,
                    "smoothness_improvement": 1359.369169445982,
                    "objective_score": -30.35894656377898
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* with adaptive informed sampling and rewiring. It grows two trees from start and goal positions, alternately expanding towards sampled points biased by goal and informed ellipsoidal regions once a solution is found. The planner incrementally rewires nearby nodes to optimize path costs, performs robust collision checks for nodes and edges, applies randomized path shortcut smoothing, and respects strict 30-second time limits for timely return of the best solution.",
          "planning_mechanism": "The planning mechanism samples configurations within bounds, switching from uniform and goal-biased sampling to ellipsoidal informed sampling after the first feasible path is found. It extends and rewires nodes in the active tree, attempts incremental connection to the opposite tree, and upon connection extracts and smooths the combined path. The algorithm balances exploration and exploitation via adaptive neighbor radius and goal bias, terminating early when time expires or better solutions emerge.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                    # Path cost from root\n        self.children = []\n        self.valid = True                   # Collision validity flag\n        if parent is not None:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children cost\n        for child in self.children:\n            child.update_parent(self, self.cost + self._dist(self.position, child.position))\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 15000, step_size: float = 5.0, max_planning_time: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = max_planning_time\n        self.goal_sample_rate = 0.1\n        self.smooth_trials = 120\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.step_size, min(self.step_size * 15.0, r))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                # Find orthogonal vectors\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0\n                    vy_ = 1\n                    vz_ = 0\n                else:\n                    vx_ = -uy\n                    vy_ = ux\n                    vz_ = 0\n                norm_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_\n                vy_ /= norm_\n                vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        rotation_mat = None  # Cached rotation matrix for informed sampling\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple(0.5 * (start_pos[d] + goal_pos[d]) for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat[0][0] * sample_scaled[0] +\n                             rotation_mat[0][1] * sample_scaled[1] +\n                             rotation_mat[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat[1][0] * sample_scaled[0] +\n                             rotation_mat[1][1] * sample_scaled[1] +\n                             rotation_mat[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat[2][0] * sample_scaled[0] +\n                             rotation_mat[2][1] * sample_scaled[1] +\n                             rotation_mat[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position) ** 2) <= r_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tent_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tent_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tent_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    tent_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tent_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tent_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    else:\n                        return None\n                curr = conn_node\n\n        def path_shortcut(path, trials=self.smooth_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        grow_start = True\n        informed_sampling = False\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - time.perf_counter()\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(pt):\n                            sample_pt = pt\n                            break\n\n            active_tree = tree_start if grow_start else tree_goal\n            opposite_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            connected_node = incremental_connect(new_node, opposite_tree)\n            if connected_node is not None:\n                path_1 = new_node.path_from_root()\n                path_2 = connected_node.path_from_root()\n                if path_2 and path_2[0] == new_node.position:\n                    path_2 = path_2[1:]\n                combined_path = path_1 + path_2[::-1]\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    smoothed = path_shortcut(best_path)\n                    # Early return on improvement\n                    return PlannerResult(True, smoothed, tree_start + tree_goal,\n                                         [(n, c) for n in tree_start + tree_goal for c in n.children])\n\n            grow_start = not grow_start\n\n        success = bool(best_path)\n        smoothed = path_shortcut(best_path) if success else []\n\n        all_nodes = tree_start + tree_goal\n        all_edges = [(n, c) for n in all_nodes for c in n.children]\n\n        return PlannerResult(success, smoothed, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -3.90297,
          "time_improvement": -21.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1349.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.056294918060302734,
                    "num_nodes_avg": 83.4,
                    "path_length_avg": 159.96880981794226,
                    "smoothness_avg": 0.04601774740912985,
                    "success_improvement": 0.0,
                    "time_improvement": -126.77095478564529,
                    "length_improvement": 12.318560470780632,
                    "smoothness_improvement": 620.2776760908024,
                    "objective_score": -32.46618596108345
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06217710971832276,
                    "num_nodes_avg": 223.4,
                    "path_length_avg": 227.4063577931576,
                    "smoothness_avg": 0.0886336640301373,
                    "success_improvement": 0.0,
                    "time_improvement": 61.05147546511945,
                    "length_improvement": 24.085212239561628,
                    "smoothness_improvement": 2180.6080157431916,
                    "objective_score": 34.03552516616412
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04812886714935303,
                    "num_nodes_avg": 197.7,
                    "path_length_avg": 124.6354101690692,
                    "smoothness_avg": 0.10581420616346005,
                    "success_improvement": 0.0,
                    "time_improvement": 1.5506711397940107,
                    "length_improvement": 17.22309506616541,
                    "smoothness_improvement": 1245.9488920069587,
                    "objective_score": 10.139564815206079
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "The planner implements a bidirectional informed RRT* with adaptive neighbor radius and goal biasing, focusing sampling within an informed ellipsoid once a solution is found to minimize path length. It dynamically rewires neighbors to improve path cost, incrementally connects two growing trees from start and goal while performing rigorous collision checks on nodes and edges. The algorithm enforces a 30-second execution limit, returning the best smoothed path found within this time, optimizing for minimal path length, smoothness, and computational efficiency.",
          "planning_mechanism": "The mechanism grows two trees alternately from start and goal positions using goal-biased and informed sampling. At each iteration, nodes extend toward sampled points with collision-checked edges, rewiring neighbors within an adaptive radius to minimize cost. It attempts incremental connection between trees to find feasible paths early. Upon finding new best paths, it applies shortcut smoothing for refinement. Execution halts if the time limit or iteration cap is reached, returning the best valid path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.children = []\n        self.cost = cost\n        self.valid = True\n        if parent is not None:\n            self.set_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def set_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update to children recursively\n        for child in self.children:\n            dist_child = math.dist(child.position, self.position)\n            child.set_parent(self, self.cost + dist_child)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0     # seconds\n        self.goal_sample_rate = 0.15      # goal bias rate\n        self.smooth_trials = 100          # shortcut smoothing attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(\n                p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            # RRT* gamma constants adjusted for efficient rewiring\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.step_size, min(self.step_size * 15.0, r))\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n\n        # Lazily initialized rotation matrix for informed sampling\n        rotation_mat = None\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                # Build orthonormal basis\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0\n                    vy_ = 1\n                    vz_ = 0\n                else:\n                    vx_ = -uy\n                    vy_ = ux\n                    vz_ = 0\n                norm_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_\n                vy_ /= norm_\n                vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                # Uniform free-space sample\n                for _ in range(100):\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            for _ in range(100):\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat[0][0] * sample_scaled[0] +\n                             rotation_mat[0][1] * sample_scaled[1] +\n                             rotation_mat[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat[1][0] * sample_scaled[0] +\n                             rotation_mat[1][1] * sample_scaled[1] +\n                             rotation_mat[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat[2][0] * sample_scaled[0] +\n                             rotation_mat[2][1] * sample_scaled[1] +\n                             rotation_mat[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n            # Fallback uniform if no informed sample found\n            for _ in range(100):\n                sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample_pt):\n                    return sample_pt\n            return start_pos  # fallback\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position) ** 2) <= r_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.set_parent(new_node, new_cost)\n\n        def extend(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr is curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    return None\n                curr = conn_node\n\n        def path_shortcut(path: List[Tuple[float, ...]], trials=None) -> List[Tuple[float, ...]]:\n            if trials is None:\n                trials = self.smooth_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_start = True\n        informed_sampling_active = False\n        iteration = 0\n        t_start = time.perf_counter()\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                # Time limit reached \u2192 return best path found\n                if best_path:\n                    smooth_path = path_shortcut(best_path)\n                    all_nodes = tree_start + tree_goal\n                    all_edges.clear()\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, all_edges)\n\n            # Sampling\n            if informed_sampling_active:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    for _ in range(20):\n                        candidate = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample_pt = candidate\n                            break\n                    else:\n                        # No valid sample found in 20 tries, switch tree growth\n                        grow_start = not grow_start\n                        continue\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n                # Avoid duplicate connecting node when joining paths\n                if path_from_goal and path_from_goal[0] == new_node.position:\n                    path_from_goal = path_from_goal[1:]\n                combined_path = path_from_start + path_from_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling_active = True\n\n                    # Update edges\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for node in all_nodes:\n                        for c in node.children:\n                            all_edges.append((node, c))\n\n                    smoothed_path = path_shortcut(best_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Finished iterations without timing out or early success\n        if best_path:\n            success_state = True\n            smoothed_path = path_shortcut(best_path)\n        else:\n            success_state = False\n            smoothed_path = []\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for node in all_nodes:\n            for c in node.children:\n                all_edges.append((node, c))\n\n        return PlannerResult(success_state, smoothed_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                           for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -1.12944,
          "time_improvement": -31.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1366.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06252074241638184,
                    "num_nodes_avg": 95.9,
                    "path_length_avg": 162.54032534539448,
                    "smoothness_avg": 0.046518081328648,
                    "success_improvement": 0.0,
                    "time_improvement": -151.85023693405225,
                    "length_improvement": 10.909072061912935,
                    "smoothness_improvement": 628.1089884237575,
                    "objective_score": -40.2327117257143
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06001381874084473,
                    "num_nodes_avg": 222.5,
                    "path_length_avg": 229.43600875029696,
                    "smoothness_avg": 0.08872127357706355,
                    "success_improvement": 0.0,
                    "time_improvement": 62.406588176117005,
                    "length_improvement": 23.40765632980491,
                    "smoothness_improvement": 2182.86227248821,
                    "objective_score": 34.31781908123713
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05114150047302246,
                    "num_nodes_avg": 215.3,
                    "path_length_avg": 118.55695231218701,
                    "smoothness_avg": 0.10903724110538957,
                    "success_improvement": 0.0,
                    "time_improvement": -4.611778682612297,
                    "length_improvement": 21.260117349647455,
                    "smoothness_improvement": 1286.9456585686094,
                    "objective_score": 9.30321815798885
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a anytime, bidirectional RRT* variant with adaptive sampling radius, heuristic goal biasing, incremental rewiring, and fast path shortcut smoothing. It combines efficient exploration with strategic exploitation of the search space using bidirectional growth and ellipsoidal informed sampling after initial solution, optimized for balanced planning time and high-quality paths within a 30-second limit.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately with adaptive neighbor radius for rewiring. It uses uniform and goal bias sampling initially, switching to ellipsoidal informed sampling post solution discovery. Connections between trees are attempted incrementally to facilitate better bridging. Upon finding a solution, repeated path shortcut smoothing is applied. The process respects collision and boundary constraints and terminates early on timeout or max iteration, returning the best found path and statistics.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []              # List[Node]\n        self.valid = True               # Validity flag\n\n        if parent:\n            self.update_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        dist = self._dist\n        for child in self.children:\n            child.update_parent(self, self.cost + dist(self.position, child.position))\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.10,\n                 neighbor_radius_min: float = 3.0,\n                 neighbor_radius_max: float = 25.0,\n                 max_planning_time: float = 30.0,\n                 smoothing_trials: int = 200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.max_planning_time = max_planning_time\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = math.dist\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/4.0)\n\n        def adaptive_radius(number_nodes):\n            if number_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.step_size * 25.0\n            r = gamma * ((math.log(number_nodes) / number_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos)**2) <= r_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                sample = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(v*v for v in sample)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(v / norm for v in sample)\n\n        rotation_mat_cache = None\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx*vx + vy*vy + vz*vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ux, uy, uz = vx/norm_v, vy/norm_v, vz/norm_v\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0.0; vy_ = 1.0; vz_ = 0.0\n                else:\n                    vx_ = -uy; vy_ = ux; vz_ = 0.0\n                norm_ = math.sqrt(vx_*vx_ + vy_*vy_ + vz_*vz_)\n                vx_ /= norm_; vy_ /= norm_; vz_ /= norm_\n                wx = uy*vz_ - uz*vy_\n                wy = uz*vx_ - ux*vz_\n                wz = ux*vy_ - uy*vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat_cache\n            # If no good solution yet, sample uniformly\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat_cache is None:\n                rotation_mat_cache = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            while True:\n                sample_dir = unit_ball_sample(dim)\n                radius_sample = random.random() ** (1.0 / dim)\n                sample_unit = tuple(radius_sample * d for d in sample_dir)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(dim))\n\n                if dim == 2:\n                    x_rot = rotation_mat_cache[0][0] * sample_scaled[0] + rotation_mat_cache[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat_cache[1][0] * sample_scaled[0] + rotation_mat_cache[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat_cache[0][0] * sample_scaled[0] +\n                             rotation_mat_cache[0][1] * sample_scaled[1] +\n                             rotation_mat_cache[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat_cache[1][0] * sample_scaled[0] +\n                             rotation_mat_cache[1][1] * sample_scaled[1] +\n                             rotation_mat_cache[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat_cache[2][0] * sample_scaled[0] +\n                             rotation_mat_cache[2][1] * sample_scaled[1] +\n                             rotation_mat_cache[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                pt = tuple(center[d] + rotated[d] for d in range(dim))\n                pt = clamp(pt)\n                if collision_free_node(pt):\n                    return pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_thru_new)\n\n        def extend(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree)+1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            current = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(current.position, new_node.position)\n                new_pos = clamp(new_pos)\n\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nbr in neighbors:\n                    if nbr is current:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    else:\n                        return None\n\n                current = conn_node\n\n        def path_shortcut(path, trials=None):\n            if trials is None:\n                trials = self.smoothing_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        iteration = 0\n        success_state = False\n        extracted_path = []\n\n        t_start = time.perf_counter()\n\n        while iteration < self.max_iter:\n            iteration += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                if best_path:\n                    success_state = True\n                    extracted_path = path_shortcut(best_path)\n                else:\n                    success_state = False\n                    extracted_path = []\n\n                all_edges.clear()\n                for n in all_nodes:\n                    for c in n.children:\n                        all_edges.append((n, c))\n\n                return PlannerResult(success_state, extracted_path, all_nodes, all_edges)\n\n            # Sample point selection\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    while True:\n                        candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample = candidate\n                            break\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path1 = new_node.path_from_root()\n                path2 = connected_node.path_from_root()\n                if path2 and path2[0] == new_node.position:\n                    path2 = path2[1:]\n                combined = path1 + path2[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined\n                    informed_sampling = True\n                    smoothed = path_shortcut(best_path)\n\n                    all_edges.clear()\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    return PlannerResult(True, smoothed, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # End of iterations limit without timeout\n        if best_path:\n            extracted_path = path_shortcut(best_path)\n            success_state = True\n        else:\n            extracted_path = []\n            success_state = False\n\n        all_edges.clear()\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(success_state, extracted_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            factor = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -1.02573,
          "time_improvement": -31.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1305.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.045254850387573244,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 161.64189397427648,
                    "smoothness_avg": 0.04181971016484641,
                    "success_improvement": 0.0,
                    "time_improvement": -82.29861565973697,
                    "length_improvement": 11.401516532978823,
                    "smoothness_improvement": 554.5692770339809,
                    "objective_score": -19.636435006155416
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06235878467559815,
                    "num_nodes_avg": 261.4,
                    "path_length_avg": 228.1902445904847,
                    "smoothness_avg": 0.09029342069415087,
                    "success_improvement": 0.0,
                    "time_improvement": 60.93767198401733,
                    "length_improvement": 23.82352826368342,
                    "smoothness_improvement": 2223.3147501826643,
                    "objective_score": 34.162580998855205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08393139839172363,
                    "num_nodes_avg": 351.3,
                    "path_length_avg": 117.61029418875569,
                    "smoothness_avg": 0.09714953037895038,
                    "success_improvement": 0.0,
                    "time_improvement": -71.68469426720839,
                    "length_improvement": 21.88884260021484,
                    "smoothness_improvement": 1135.7348555878345,
                    "objective_score": -11.448965482180377
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid algorithm combines bidirectional RRT* with informed sampling inside ellipsoidal regions after a first feasible path is found, adaptive neighbor radius scaling by node count and dimension, incremental connect & rewiring with recursive parent-child cost updates, and randomized shortcut path smoothing. It enforces a strict 30-second execution limit, prioritizes computational efficiency through early termination, and rigorously validates node and edge collision constraints to maintain path quality and robustness.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, using goal-biased and informed sampling. It incrementally extends trees toward sampled points, rewires neighbor nodes to optimize costs, and tries to connect the trees incrementally. Once a path is found, focused sampling shrinks to an ellipsoidal informed subset. The best path is smoothed by repeated random shortcuts. The process stops on time expiration or early successful connection, returning the best smooth feasible path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = None                  # Node or None\n        self.cost = cost                   # Cumulative cost from root\n        self.children: List[Node] = []\n        self.valid = True\n\n        if parent:\n            self.set_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def set_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not None:\n            try:\n                self.parent.remove_child(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update costs of children\n        for c in self.children:\n            dist_c = math.dist(c.position, self.position)\n            c.set_parent(self, self.cost + dist_c)\n\n    def add_child(self, child: 'Node'):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0           # seconds max time limit\n        self.goal_sample_rate = 0.2              # goal bias probability\n        self.neighbor_radius_min = self.step_size * 2.0\n        self.neighbor_radius_max = self.step_size * 15.0\n        self.smooth_trials = 150\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d_] + factor * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def collision_free_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def unit_ball_sample(n: int) -> Tuple[float, ...]:\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        informed_sampling = False\n        rotation_mat = None\n\n        def rotation_matrix(direction: Tuple[float, ...]) -> List[List[float]]:\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                # Create orthonormal basis\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0; vy_ = 1; vz_ = 0\n                else:\n                    vx_ = -uy; vy_ = ux; vz_ = 0\n                norm_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_; vy_ /= norm_; vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        def informed_sample(c_best: float) -> Tuple[float, ...]:\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1] + rotation_mat[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1] + rotation_mat[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat[2][0] * sample_scaled[0] + rotation_mat[2][1] * sample_scaled[1] + rotation_mat[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.set_parent(new_node, cost_via_new)\n\n        def extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node: Node, other_tree: List[Node]) -> Node or None:\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    else:\n                        return None\n                curr = conn_node\n\n        def path_shortcut(path: List[Tuple[float, ...]], trials: int = None) -> List[Tuple[float, ...]]:\n            if trials is None:\n                trials = self.smooth_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges: List[Tuple[Node, Node]] = []\n\n        grow_start = True\n        iter_count = 0\n        t_start = time.perf_counter()\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    # limit number of sampling attempts for free space\n                    for _ in range(20):\n                        candidate = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample = candidate\n                            break\n                    else:\n                        grow_start = not grow_start\n                        continue\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    # Update edges\n                    all_edges.clear()\n                    current_nodes = tree_start + tree_goal\n                    for nd in current_nodes:\n                        for c in nd.children:\n                            all_edges.append((nd, c))\n\n                    # Early return with smoothing for best path found\n                    smooth_path = path_shortcut(best_path)\n                    return PlannerResult(True, smooth_path, current_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # Timeout or max_iter reached, return best found path if any\n        success_state = best_path != []\n        if success_state:\n            final_path = path_shortcut(best_path)\n        else:\n            final_path = []\n\n        all_edges.clear()\n        current_nodes = tree_start + tree_goal\n        for nd in current_nodes:\n            for c in nd.children:\n                all_edges.append((nd, c))\n\n        return PlannerResult(success_state, final_path, current_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -0.97593,
          "time_improvement": -32.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1391.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06076898574829102,
                    "num_nodes_avg": 90.0,
                    "path_length_avg": 161.3494120983342,
                    "smoothness_avg": 0.04926679347705789,
                    "success_improvement": 0.0,
                    "time_improvement": -144.79369353968139,
                    "length_improvement": 11.5618304838547,
                    "smoothness_improvement": 671.1323024703386,
                    "objective_score": -37.770080452781784
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.057598114013671875,
                    "num_nodes_avg": 210.6,
                    "path_length_avg": 228.63879473929833,
                    "smoothness_avg": 0.0879621592986141,
                    "success_improvement": 0.0,
                    "time_improvement": 63.91981603861433,
                    "length_improvement": 23.673789313209255,
                    "smoothness_improvement": 2163.329715335791,
                    "objective_score": 34.72735125090511
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.055847883224487305,
                    "num_nodes_avg": 209.2,
                    "path_length_avg": 123.82733605786555,
                    "smoothness_avg": 0.11305445719223606,
                    "success_improvement": 0.0,
                    "time_improvement": -14.238853880603777,
                    "length_improvement": 17.75977941447269,
                    "smoothness_improvement": 1338.0443506732497,
                    "objective_score": 5.970521472079653
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional informed RRT* planner with adaptive neighbor radius rewiring, ellipsoidal informed sampling, incremental tree connections, and randomized shortcut path smoothing. It balances exploration and exploitation, applies strict collision checking, and terminates early either on success or when a 30-second time budget expires, yielding high-quality, smooth paths in 2D or 3D obstacle environments.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, initially sampling uniformly with goal biasing, then switching to ellipsoidal informed sampling after the first solution. It extends and rewires nodes with an adaptive neighbor radius, incrementally connects trees, and upon improvement smooths the path. Time-based termination ensures efficient planning within computational constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.set_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def set_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            dist_c = self._dist(c.position, self.position)\n            c.set_parent(self, self.cost + dist_c)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.max_planning_time = 30.0  # seconds\n        self.neighbor_radius_min = self.step_size * 2.0\n        self.neighbor_radius_max = self.step_size * 15.0\n        self.smooth_trials = 150\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        rotation_mat = None\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0\n                    vy_ = 1\n                    vz_ = 0\n                else:\n                    vx_ = -uy\n                    vy_ = ux\n                    vz_ = 0\n                norm_ = math.sqrt(vx_**2 + vy_**2 + vz_**2)\n                vx_ /= norm_\n                vy_ /= norm_\n                vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1] + rotation_mat[0][2] * sample_scaled[2]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1] + rotation_mat[1][2] * sample_scaled[2]\n                    z_rot = rotation_mat[2][0] * sample_scaled[0] + rotation_mat[2][1] * sample_scaled[1] + rotation_mat[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.set_parent(new_node, cost_via_new)\n\n        def extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n            if not collision_free_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(curr.position, new_pos):\n                    return None\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n                rewire(other_tree, conn_node, neighbors)\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    else:\n                        return None\n                curr = conn_node\n\n        def path_shortcut(path, trials=None):\n            if trials is None:\n                trials = self.smooth_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        grow_start = True\n        iter_count = 0\n        t_start = time.perf_counter()\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    attempts = 0\n                    while attempts < 20:\n                        candidate = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample = candidate\n                            break\n                        attempts += 1\n                    else:\n                        grow_start = not grow_start\n                        continue\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    all_edges.clear()\n                    current_nodes = tree_start + tree_goal\n                    for nd in current_nodes:\n                        for c in nd.children:\n                            all_edges.append((nd, c))\n\n                    smooth_path = path_shortcut(best_path)\n                    return PlannerResult(True, smooth_path, current_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = best_path != []\n        final_path = path_shortcut(best_path) if success_state else []\n\n        all_edges.clear()\n        current_nodes = tree_start + tree_goal\n        for nd in current_nodes:\n            for c in nd.children:\n                all_edges.append((nd, c))\n\n        return PlannerResult(success_state, final_path, current_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 0.76171,
          "time_improvement": -36.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1210.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05033085346221924,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 153.63432628219226,
                    "smoothness_avg": 0.04605038262133378,
                    "success_improvement": 0.0,
                    "time_improvement": -102.74611080484586,
                    "length_improvement": 15.790591273040203,
                    "smoothness_improvement": 620.7884880302914,
                    "objective_score": -24.561772546694257
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06940414905548095,
                    "num_nodes_avg": 241.4,
                    "path_length_avg": 227.59416143798575,
                    "smoothness_avg": 0.0782017847416547,
                    "success_improvement": 0.0,
                    "time_improvement": 56.5243670129409,
                    "length_improvement": 24.0225179772898,
                    "smoothness_improvement": 1912.1882478715918,
                    "objective_score": 31.32275493869819
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07868292331695556,
                    "num_nodes_avg": 247.8,
                    "path_length_avg": 122.31716714148097,
                    "smoothness_avg": 0.09411964177435614,
                    "success_improvement": 0.0,
                    "time_improvement": -60.94874972384338,
                    "length_improvement": 18.76276170221921,
                    "smoothness_improvement": 1097.194896180509,
                    "objective_score": -9.046098095806627
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This implementation enhances path quality, planning efficiency, and path smoothness by executing a bidirectional informed RRT* algorithm with an adaptive neighborhood radius and ellipsoidal heuristic sampling after initial solution detection. It maintains consistent parent-child relationships with recursive cost updates and aggressively rewires nodes to optimize path cost. A shortcut smoothing procedure improves path smoothness. The planning strictly respects a 30-second time budget, performing early termination and returning the best feasible path found so far.",
          "planning_mechanism": "The planner initializes two trees from start and goal, expands them alternately using a sampling strategy that transitions from uniform/goal bias to informed ellipsoidal sampling upon finding a first path. It incrementally extends and rewires each tree, connects them to find better paths, and maintains shared parent-child cost integrity. Path shortcutting smooths the solution before return. The algorithm terminates early upon time expiration or path improvement to ensure efficient runtime and high-quality, smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            self.update_parent(parent, parent.cost + math.dist(parent.position, position))\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Recursively update children cost and parents\n        for child in self.children:\n            dist_child = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist_child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 15000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_planning_time = 30.0  # seconds\n        self.goal_sample_rate = 0.1     # 10 % goal bias\n        self.smooth_trials = 120\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            scale = self.step_size / d\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            r = max(self.step_size, min(self.step_size * 15.0, r))\n            return r\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n\n                # Find vector orthogonal to ux\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0\n                    vy_ = 1\n                    vz_ = 0\n                else:\n                    vx_ = -uy\n                    vy_ = ux\n                    vz_ = 0\n                norm_ = math.sqrt(vx_ * vx_ + vy_ * vy_ + vz_ * vz_)\n                vx_ /= norm_\n                vy_ /= norm_\n                vz_ /= norm_\n\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        rotation_mat = None  # Will be computed once informed sampling triggered\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                # Uniform random sample inside bounds and free space\n                while True:\n                    sample_pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample_pt):\n                        return sample_pt\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = (rotation_mat[0][0] * sample_scaled[0] +\n                             rotation_mat[0][1] * sample_scaled[1] +\n                             rotation_mat[0][2] * sample_scaled[2])\n                    y_rot = (rotation_mat[1][0] * sample_scaled[0] +\n                             rotation_mat[1][1] * sample_scaled[1] +\n                             rotation_mat[1][2] * sample_scaled[2])\n                    z_rot = (rotation_mat[2][0] * sample_scaled[0] +\n                             rotation_mat[2][1] * sample_scaled[1] +\n                             rotation_mat[2][2] * sample_scaled[2])\n                    rotated = (x_rot, y_rot, z_rot)\n\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, position) ** 2) <= radius_sq]\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.update_parent(new_node, cost_through_new)\n\n        def extend(tree, sample_pt):\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if not collision_free_node(new_pos) or not collision_free_edge(curr.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if tentative_cost + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    return None\n                curr = conn_node\n\n        def path_shortcut(path, trials=self.smooth_trials):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees with root nodes\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        grow_start = True\n        informed_sampling = False\n        iter_count = 0\n        t_start = time.perf_counter()\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                # Time exceeded: return best path found so far if any\n                if best_path:\n                    smooth_path = path_shortcut(best_path)\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n                else:\n                    return PlannerResult(False, [], all_nodes, all_edges)\n\n            # Sampling strategy\n            if informed_sampling:\n                sample_pt = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if grow_start else start_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(pt):\n                            sample_pt = pt\n                            break\n\n            active_tree = tree_start if grow_start else tree_goal\n            opposite_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample_pt)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, opposite_tree)\n            if connected_node is not None:\n                path_1 = new_node.path_from_root()\n                path_2 = connected_node.path_from_root()\n                if path_2 and path_2[0] == new_node.position:\n                    path_2 = path_2[1:]\n                combined = path_1 + path_2[::-1]\n\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined\n                    informed_sampling = True\n\n                    all_edges.clear()\n                    all_nodes = tree_start + tree_goal\n                    for n in all_nodes:\n                        for c in n.children:\n                            all_edges.append((n, c))\n\n                    # Early return on improved path found\n                    smooth_path = path_shortcut(best_path)\n                    return PlannerResult(True, smooth_path, all_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        # No improved path found within max_iter or time\n        if best_path:\n            smooth_path = path_shortcut(best_path)\n            success_state = True\n        else:\n            smooth_path = []\n            success_state = False\n\n        all_nodes = tree_start + tree_goal\n        all_edges.clear()\n        for n in all_nodes:\n            for c in n.children:\n                all_edges.append((n, c))\n\n        return PlannerResult(success_state, smooth_path, all_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.59962,
          "time_improvement": -44.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1363.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07346773147583008,
                    "num_nodes_avg": 104.8,
                    "path_length_avg": 159.185598829889,
                    "smoothness_avg": 0.04414991981246032,
                    "success_improvement": 0.0,
                    "time_improvement": -195.9476305634363,
                    "length_improvement": 12.747850824104937,
                    "smoothness_improvement": 591.0421181503785,
                    "objective_score": -53.279508413458004
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07438075542449951,
                    "num_nodes_avg": 264.3,
                    "path_length_avg": 227.46881030655277,
                    "smoothness_avg": 0.08608020057908214,
                    "success_improvement": 0.0,
                    "time_improvement": 53.406958112104796,
                    "length_improvement": 24.064363792994396,
                    "smoothness_improvement": 2114.905561962159,
                    "objective_score": 31.409488002041112
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.044040870666503903,
                    "num_nodes_avg": 194.4,
                    "path_length_avg": 119.1062769785669,
                    "smoothness_avg": 0.11663987859897021,
                    "success_improvement": 0.0,
                    "time_improvement": 9.912814983123369,
                    "length_improvement": 20.8952820622676,
                    "smoothness_improvement": 1383.650646318629,
                    "objective_score": 14.071154138983676
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional informed RRT* planner with adaptive neighbor radius rewiring, ellipsoidal informed sampling, incremental tree connections, and path shortcut smoothing within a 30-second time budget. It balances exploration and exploitation to efficiently find high-quality, smooth paths in 2D/3D obstacle environments.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately with goal biasing and uniform sampling. After finding an initial path, it performs informed sampling inside an ellipsoidal subset defined by current best path cost. Adaptive neighbor radius with rewiring optimizes node connections. Incremental connections and rewiring between trees improve path cost. Randomized shortcut path smoothing prunes unnecessary waypoints. The search is bounded by a 30-second max time, returning the best path found on timeout or success.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.set_parent(parent, parent.cost + self._dist(parent.position, position))\n\n    def set_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for c in self.children:\n            dist_c = self._dist(c.position, self.position)\n            c.set_parent(self, self.cost + dist_c)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _dist(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.max_planning_time = 30.0  # seconds\n        self.neighbor_radius_min = self.step_size * 2.0\n        self.neighbor_radius_max = self.step_size * 15.0\n        self.smooth_trials = 150\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def clamp(pos):\n            return tuple(max(0.0, min(bounds[d], pos[d])) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            factor = self.step_size / d\n            return tuple(from_p[d] + factor * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            # resolution small for finer collision check\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size / 5)\n\n        def adaptive_neighbor_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = self.step_size * 30.0\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.neighbor_radius_min, min(self.neighbor_radius_max, r))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if (dist(n.position, pos) ** 2) <= radius_sq]\n\n        def unit_ball_sample(n):\n            while True:\n                pt = [random.uniform(-1, 1) for _ in range(n)]\n                norm_sq = sum(x * x for x in pt)\n                if 1e-12 < norm_sq <= 1.0:\n                    norm = math.sqrt(norm_sq)\n                    return tuple(x / norm for x in pt)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = math.inf\n        best_path = []\n        informed_sampling = False\n        rotation_mat = None\n\n        def rotation_matrix(direction):\n            if dim == 2:\n                dx, dy = direction\n                angle = math.atan2(dy, dx)\n                cos_a, sin_a = math.cos(angle), math.sin(angle)\n                return [[cos_a, -sin_a], [sin_a, cos_a]]\n            else:\n                vx, vy, vz = direction\n                norm_v = math.sqrt(vx * vx + vy * vy + vz * vz)\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                ux, uy, uz = vx / norm_v, vy / norm_v, vz / norm_v\n                # Create orthonormal basis\n                # Use Gram-Schmidt or heuristic\n                if abs(ux) < 1e-6 and abs(uy) < 1e-6:\n                    vx_ = 0\n                    vy_ = 1\n                    vz_ = 0\n                else:\n                    vx_ = -uy\n                    vy_ = ux\n                    vz_ = 0\n                norm_ = math.sqrt(vx_**2 + vy_**2 + vz_**2)\n                vx_ /= norm_\n                vy_ /= norm_\n                vz_ /= norm_\n                wx = uy * vz_ - uz * vy_\n                wy = uz * vx_ - ux * vz_\n                wz = ux * vy_ - uy * vx_\n                return [[ux, vx_, wx], [uy, vy_, wy], [uz, vz_, wz]]\n\n        def informed_sample(c_best):\n            nonlocal rotation_mat\n            if c_best == math.inf or c_best < c_min - 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(pt):\n                        return pt\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            direction = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            if rotation_mat is None:\n                rotation_mat = rotation_matrix(direction)\n\n            if dim == 2:\n                a1 = c_best / 2.0\n                a2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a2]\n            else:\n                a1 = c_best / 2.0\n                a_minor = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [a1, a_minor, a_minor]\n\n            n = dim\n            while True:\n                dir_sample = unit_ball_sample(n)\n                radius_sample = random.random() ** (1.0 / n)\n                sample_unit = tuple(radius_sample * d for d in dir_sample)\n                sample_scaled = tuple(sample_unit[d] * radii[d] for d in range(n))\n                if dim == 2:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1]\n                    rotated = (x_rot, y_rot)\n                else:\n                    x_rot = rotation_mat[0][0] * sample_scaled[0] + rotation_mat[0][1] * sample_scaled[1] + rotation_mat[0][2] * sample_scaled[2]\n                    y_rot = rotation_mat[1][0] * sample_scaled[0] + rotation_mat[1][1] * sample_scaled[1] + rotation_mat[1][2] * sample_scaled[2]\n                    z_rot = rotation_mat[2][0] * sample_scaled[0] + rotation_mat[2][1] * sample_scaled[1] + rotation_mat[2][2] * sample_scaled[2]\n                    rotated = (x_rot, y_rot, z_rot)\n                sample_pt = tuple(center[d] + rotated[d] for d in range(n))\n                sample_pt = clamp(sample_pt)\n                if collision_free_node(sample_pt):\n                    return sample_pt\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-12 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    nbr.set_parent(new_node, cost_via_new)\n\n        def extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, sample_pt))\n            new_pos = steer(nearest.position, sample_pt)\n            new_pos = clamp(new_pos)\n            if (not collision_free_node(new_pos)) or (not collision_free_edge(nearest.position, new_pos)):\n                return None\n            radius = adaptive_neighbor_radius(len(tree) + 1)\n            neighbors = near_nodes(tree, new_pos, radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                    min_cost = cost_thru_nbr\n                    best_parent = nbr\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def incremental_connect(new_node, other_tree):\n            if not other_tree:\n                return None\n            curr = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                new_pos = steer(curr.position, new_node.position)\n                new_pos = clamp(new_pos)\n                if (not collision_free_node(new_pos)) or (not collision_free_edge(curr.position, new_pos)):\n                    return None\n                radius = adaptive_neighbor_radius(len(other_tree) + 1)\n                neighbors = near_nodes(other_tree, new_pos, radius)\n                min_cost = curr.cost + dist(curr.position, new_pos)\n                best_parent = curr\n                for nbr in neighbors:\n                    if nbr == curr:\n                        continue\n                    cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_thru_nbr + 1e-12 < min_cost and collision_free_edge(nbr.position, new_pos):\n                        min_cost = cost_thru_nbr\n                        best_parent = nbr\n                conn_node = Node(new_pos)\n                best_parent.add_child(conn_node)\n                conn_node.cost = min_cost\n                other_tree.append(conn_node)\n                rewire(other_tree, conn_node, neighbors)\n\n                if dist(conn_node.position, new_node.position) <= self.step_size:\n                    if collision_free_edge(conn_node.position, new_node.position):\n                        return conn_node\n                    else:\n                        return None\n                curr = conn_node\n\n        def path_shortcut(path, trials=None):\n            if trials is None:\n                trials = self.smooth_trials\n            if len(path) < 3:\n                return path[:]\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n        grow_start = True\n        iter_count = 0\n        t_start = time.perf_counter()\n\n        while iter_count < self.max_iter:\n            iter_count += 1\n            elapsed = time.perf_counter() - t_start\n            if elapsed > self.max_planning_time:\n                break\n\n            if informed_sampling:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if grow_start else start_pos\n                else:\n                    attempted = 0\n                    while attempted < 20:\n                        candidate = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free_node(candidate):\n                            sample = candidate\n                            break\n                        attempted += 1\n                    else:\n                        grow_start = not grow_start\n                        continue\n\n            active_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                grow_start = not grow_start\n                continue\n            all_nodes.append(new_node)\n\n            connected_node = incremental_connect(new_node, other_tree)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_goal and path_goal[0] == new_node.position:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n                total_cost = new_node.cost + connected_node.cost + dist(new_node.position, connected_node.position)\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = combined_path\n                    informed_sampling = True\n\n                    all_edges.clear()\n                    current_nodes = tree_start + tree_goal\n                    for nd in current_nodes:\n                        for c in nd.children:\n                            all_edges.append((nd, c))\n\n                    smooth_path = path_shortcut(best_path)\n                    return PlannerResult(True, smooth_path, current_nodes, all_edges)\n\n            grow_start = not grow_start\n\n        success_state = best_path != []\n        final_path = path_shortcut(best_path) if success_state else []\n\n        all_edges.clear()\n        current_nodes = tree_start + tree_goal\n        for nd in current_nodes:\n            for c in nd.children:\n                all_edges.append((nd, c))\n\n        return PlannerResult(success_state, final_path, current_nodes, all_edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 9.83663,
          "time_improvement": -70.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1483.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.061602234840393066,
                    "num_nodes_avg": 88.8,
                    "path_length_avg": 164.94236660842756,
                    "smoothness_avg": 0.040498709886326034,
                    "success_improvement": 0.0,
                    "time_improvement": -148.15024327278246,
                    "length_improvement": 9.59247518286494,
                    "smoothness_improvement": 533.8927540771188,
                    "objective_score": -39.85711417487616
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07646501064300537,
                    "num_nodes_avg": 261.8,
                    "path_length_avg": 231.80235238077825,
                    "smoothness_avg": 0.1043227432514193,
                    "success_improvement": 0.0,
                    "time_improvement": 52.10135439583868,
                    "length_improvement": 22.617702714525397,
                    "smoothness_improvement": 2584.299324493775,
                    "objective_score": 33.07544348412556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10390822887420655,
                    "num_nodes_avg": 334.4,
                    "path_length_avg": 117.58786955220322,
                    "smoothness_avg": 0.11250769357193839,
                    "success_improvement": 0.0,
                    "time_improvement": -112.54801954871742,
                    "length_improvement": 21.903735976066546,
                    "smoothness_improvement": 1331.0895577809556,
                    "objective_score": -22.728210880497137
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with adaptive neighbor radius, dynamic rewiring with recursive cost propagation, and goal-biased sampling towards the opposite tree's root. It enforces a 30-second time limit and performs comprehensive collision checking for nodes and edges. The planner alternates tree growth from start and goal, incrementally extends and rewires neighboring nodes to minimize path cost, and attempts incremental connections between trees. Upon success or timeout, the path is extracted and smoothed with randomized shortcuts to improve path smoothness and minimize length.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal points using goal-biased random sampling towards the opposite tree\u2019s root. Each extension attempts to connect nearby neighbors within an adaptive radius, rewiring them if a better path cost is found. Incremental connection attempts to bridge the two trees ensure low-cost paths. The bidirectional strategy combined with adaptive neighborhood rewiring, robust collision checks, and time limit enforcement accelerates convergence, improves solution quality, and guarantees timely termination.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, new_cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius_min: float=8.0, neighbor_radius_max: float=20.0,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 50.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def sample_free(tree_from, tree_to_root):\n            # Biased sampling towards opposite tree's root\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to_root\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def try_extend_and_rewire(tree, sample):\n            node_near = nearest(tree, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent is not None:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr.position, target_pos) / self.step_size) + 2\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent is not None:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.remove_child(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def path_smoothing(path, max_iters=150):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        start_time = time.perf_counter()\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b[0].position)\n            new_node_a = try_extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined = path_a + path_b[::-1]\n                    extracted_path = path_smoothing(combined)\n                    success_state = True\n                    break  # Early stop on better solution\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or no early success but found a connection before\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined = path_a + path_b[::-1]\n            extracted_path = path_smoothing(combined)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 31.90999,
          "time_improvement": 22.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1471.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.033406972885131836,
                    "num_nodes_avg": 118.6,
                    "path_length_avg": 175.84292592386615,
                    "smoothness_avg": 0.04415733752494997,
                    "success_improvement": 0.0,
                    "time_improvement": -34.57220293924999,
                    "length_improvement": 3.617705891657172,
                    "smoothness_improvement": 591.1582214586622,
                    "objective_score": -6.692328596150251
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03637235164642334,
                    "num_nodes_avg": 215.7,
                    "path_length_avg": 233.02857421288087,
                    "smoothness_avg": 0.09935200536442047,
                    "success_improvement": 0.0,
                    "time_improvement": 77.21590088523277,
                    "length_improvement": 22.208354572131075,
                    "smoothness_improvement": 2456.3986583835112,
                    "objective_score": 39.888434471913605
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.0376129150390625,
                    "num_nodes_avg": 208.3,
                    "path_length_avg": 95.43974133235943,
                    "smoothness_avg": 0.11529624361096728,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 23.061429420712457,
                    "length_improvement": 36.61346815915501,
                    "smoothness_improvement": 1366.5597084480498,
                    "objective_score": -128.92607899971503
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 39.61883567338838,
          "time_improvement": 86.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003355741500854492,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011129325160179355,
                    "success_improvement": 0.0,
                    "time_improvement": 86.622133976358,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 74.19810647320995,
                    "objective_score": 27.614580380018808
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.01458899974822998,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "smoothness_avg": 0.007463600028392253,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 90.94354886572171,
                    "length_improvement": 7.7415071625852105,
                    "smoothness_improvement": 92.0438045443411,
                    "objective_score": -120.70841488504477
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.009033989906311036,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "smoothness_avg": 0.013133862024542206,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 81.6325481989705,
                    "length_improvement": -2.9387287619347555,
                    "smoothness_improvement": 67.06175551132456,
                    "objective_score": -25.762672515139172
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 40.39266236737459,
          "time_improvement": 66.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 435.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012287211418151856,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "smoothness_avg": 0.026937243959899278,
                    "success_improvement": 0.0,
                    "time_improvement": 51.01629010627205,
                    "length_improvement": 13.535578613534014,
                    "smoothness_improvement": 321.6263631339301,
                    "objective_score": 19.620134570258067
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.03516378402709961,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "smoothness_avg": 0.022356480598334835,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 78.17128677540894,
                    "length_improvement": 26.89673749844109,
                    "smoothness_improvement": 475.2483485172534,
                    "objective_score": -68.79302472510281
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.016010403633117676,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "smoothness_avg": 0.047735234271590925,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 67.4484563192967,
                    "length_improvement": 26.122114372505884,
                    "smoothness_improvement": 507.18865648615576,
                    "objective_score": -72.00509694727903
               }
          ],
          "success_rate": 0.8666666666666667
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner with goal biasing, dynamic neighbor radius, incremental connection attempts, and post-processing path smoothing. It balances exploration and exploitation via alternating tree growth, adaptive rewiring based on node density, and informed sampling within map bounds. Collision checks ensure feasibility, and the planner enforces a 30-second time budget, returning the best path found so far with improved path length, smoothness, and planning speed.",
          "planning_mechanism": "The planner concurrently grows two trees from start and goal by sampling points biased towards the opposite root, extending each tree incrementally with adaptive neighbor radius rewiring. Incremental connect attempts bridge the two trees. Upon success or timeout, the path is extracted, shortcut-smoothed, and returned. Efficient parent-child cost updates and collision validations maintain robustness and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        self._update_descendants_costs()\n\n    def _update_descendants_costs(self):\n        # Recursively update children costs based on parent's cost\n        for child in self.children:\n            new_cost = self.cost + math.dist(self.position, child.position)\n            if abs(child.cost - new_cost) > 1e-6:\n                child.cost = new_cost\n                child._update_descendants_costs()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=4.5,\n                 goal_sample_rate: float=0.15, neighbor_radius_min: float=8.0,\n                 neighbor_radius_max: float=25.0, time_limit_sec: float=30.0,\n                 smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_min = neighbor_radius_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.time_limit_sec = time_limit_sec\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from, tree_to):\n            if random.random() < self.goal_sample_rate:\n                # Bias sample to opposite tree root\n                return tree_to[0].position\n            for _ in range(30):  # Limited trials to find free sample\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback\n            return tree_to[0].position\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(min(max(0.0, new_p[d]), bounds[d]) for d in range(dim))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= radius_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.neighbor_radius_max\n            gamma = 25.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.neighbor_radius_min, min(r, self.neighbor_radius_max))\n\n        def try_extend(tree, sample):\n            node_near = nearest(tree, sample)\n            new_pos = steer(node_near.position, sample)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(node_near.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = node_near.cost + math.dist(node_near.position, new_pos)\n            best_parent = node_near\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            curr = nearest(tree, target_pos)\n            total_dist = math.dist(curr.position, target_pos)\n            max_steps = max(2, int(total_dist / self.step_size))\n            last_node = curr\n            for _ in range(max_steps):\n                new_pos = steer(last_node.position, target_pos)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                n_nodes = len(tree)\n                radius = adaptive_radius(n_nodes)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                best_parent = last_node\n                for neighbor in neighbors:\n                    cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_try < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n                last_node = new_node\n\n                if math.dist(last_node.position, target_pos) <= self.step_size:\n                    return last_node\n            return None\n\n        def merge_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Avoid duplicate middle node\n            return path_start + path_goal[::-1][1:]\n\n        def path_smoothing(path, max_iters=self.smoothing_iters):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n            return path\n\n        import time\n        start_time = time.time()\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            current_time = time.time()\n            if current_time - start_time > self.time_limit_sec:\n                break\n\n            sample = sample_free(tree_a, tree_b)\n            new_node_a = try_extend(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    extracted_path = merge_paths(new_node_a, new_node_b)\n                    extracted_path = path_smoothing(extracted_path)\n                    success_state = True\n                    # Early break upon successful better path\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            extracted_path = merge_paths(node_a, node_b)\n            extracted_path = path_smoothing(extracted_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 41.44452,
          "time_improvement": 47.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 1400.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.022593760490417482,
                    "num_nodes_avg": 70.5,
                    "path_length_avg": 158.45784888506742,
                    "smoothness_avg": 0.032904265078229036,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 8.986302580247362,
                    "length_improvement": 13.146742100797477,
                    "smoothness_improvement": 415.0232012295428,
                    "objective_score": -42.599644799618574
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.051462411880493164,
                    "num_nodes_avg": 262.8,
                    "path_length_avg": 239.514416752833,
                    "smoothness_avg": 0.08725720874180212,
                    "success_improvement": 0.0,
                    "time_improvement": 67.763297122818,
                    "length_improvement": 20.043193647668552,
                    "smoothness_improvement": 2145.1908297536565,
                    "objective_score": 35.0635820151474
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.0175706148147583,
                    "num_nodes_avg": 108.8,
                    "path_length_avg": 107.04646172804203,
                    "smoothness_avg": 0.1368551264759344,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 64.0586754139423,
                    "length_improvement": 28.90483712497519,
                    "smoothness_improvement": 1640.7871071792285,
                    "objective_score": -116.79749441492615
               }
          ],
          "success_rate": 0.8666666666666666
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 52.65283770558538,
          "time_improvement": -175.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -0.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05725030899047852,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "smoothness_avg": 0.006355076380337696,
                    "success_improvement": 0.0,
                    "time_improvement": -128.23181204264569,
                    "length_improvement": -0.19475103354660056,
                    "smoothness_improvement": -0.5292543784741947,
                    "objective_score": -38.511140091395404
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.4293047904968262,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "smoothness_avg": 0.003864811977420653,
                    "success_improvement": 0.0,
                    "time_improvement": -166.50064596222919,
                    "length_improvement": -1.7774346542982573,
                    "smoothness_improvement": -0.5556041094177198,
                    "objective_score": -50.308458740075494
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1626889228820801,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "smoothness_avg": 0.007923257886236853,
                    "success_improvement": 0.0,
                    "time_improvement": -230.7708975311676,
                    "length_improvement": 0.4421934833534218,
                    "smoothness_improvement": 0.7832554788707086,
                    "objective_score": -69.13891428528525
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner implements a bidirectional RRT* with adaptive neighbor radius, goal-biased sampling, incremental extend-and-rewire steps, and early termination within a 30-second limit. It dynamically rewires neighbors to minimize path costs and ensures validity through rigorous collision checks. The planner incrementally connects two trees grown from start and goal, applying path smoothing on the best found path to improve path length and smoothness while minimizing planning time.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling points biased towards the opposite tree's root. It incrementally extends trees in small steps, adapts neighbor radius based on tree size and dimension, rewires neighbors for cost optimality, and tries incremental connections between the two trees. On successful connection or timeout, it reconstructs the combined path and applies randomized shortcut path smoothing before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        if parent is not None:\n            parent.add_child(self)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float = 4.0, goal_sample_rate: float = 0.15,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0, max_time_sec: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free(tree_from_root, tree_to_root):\n            if random.random() < self.goal_sample_rate:\n                return tree_to_root\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tree_to_root\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= r_sq]\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 25.0  # Tuned constant for neighbor radius\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def valid_node(pos):\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def valid_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def add_node(tree, pos, parent_node, cost):\n            new_node = Node(pos)\n            parent_node.add_child(new_node)\n            new_node.cost = cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                dist_edge = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist_edge\n                if new_cost < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend_and_rewire(tree, sample):\n            if len(tree) == 0:\n                return None\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not valid_node(new_pos):\n                return None\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_through_neighbor < min_cost and valid_edge(neighbor.position, new_pos):\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            return add_node(tree, new_pos, best_parent, min_cost)\n\n        def incremental_connect_and_rewire(tree, target_pos):\n            if len(tree) == 0:\n                return None\n            curr_node = nearest(tree, target_pos)\n            max_steps = int(math.dist(curr_node.position, target_pos) / self.step_size) + 3\n            for _ in range(max_steps):\n                new_pos = steer(curr_node.position, target_pos)\n                if not valid_node(new_pos) or not valid_edge(curr_node.position, new_pos):\n                    return None\n\n                radius = adaptive_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    cost_through = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost_through < min_cost and valid_edge(neighbor.position, new_pos):\n                        min_cost = cost_through\n                        best_parent = neighbor\n\n                new_node = add_node(tree, new_pos, best_parent, min_cost)\n                rewire(tree, new_node, neighbors)\n\n                curr_node = new_node\n                if math.dist(curr_node.position, target_pos) <= self.step_size:\n                    return curr_node\n            return None\n\n        def path_smoothing(path: list, max_iters=100):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            smoothed_path = path[:]\n            for _ in range(max_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if valid_edge(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                    length = len(smoothed_path)\n            return smoothed_path\n\n        start_time = time.time()\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = math.inf\n        best_connection = None\n        extracted_path = []\n        success_state = False\n\n        # Alternate expansion between start_tree (tree_a) and goal_tree (tree_b)\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.time() - start_time > self.max_time_sec:\n                break\n\n            sample = sample_free(tree_a[0].position, tree_b[0].position)\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = incremental_connect_and_rewire(tree_b, new_node_a.position)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost + math.dist(new_node_a.position, new_node_b.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    combined_path = path_a + path_b[::-1][1:]\n                    extracted_path = path_smoothing(combined_path, max_iters=150)\n                    success_state = True\n                    # Early stop for faster planning with a valid path\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or no early finish but best path exists, reconstruct path\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            combined_path = path_a + path_b[::-1][1:]\n            extracted_path = path_smoothing(combined_path, max_iters=150)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 53.13048,
          "time_improvement": 58.0,
          "length_improvement": 26.0,
          "smoothness_improvement": 1533.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01663832664489746,
                    "num_nodes_avg": 72.4,
                    "path_length_avg": 154.68402492552553,
                    "smoothness_avg": 0.03592273054042734,
                    "success_improvement": 0.0,
                    "time_improvement": 32.97637958621538,
                    "length_improvement": 15.215234813089804,
                    "smoothness_improvement": 462.2687404156091,
                    "objective_score": 15.24730454056062
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04345295429229736,
                    "num_nodes_avg": 280.5,
                    "path_length_avg": 235.9739642410745,
                    "smoothness_avg": 0.09869696919916007,
                    "success_improvement": 0.0,
                    "time_improvement": 72.78052222057772,
                    "length_improvement": 21.225098602368746,
                    "smoothness_improvement": 2439.544106047882,
                    "objective_score": 38.27689691688648
               },
               {
                    "map_id": 2,
                    "success_rate": 0.5,
                    "time_avg": 0.01584310531616211,
                    "num_nodes_avg": 128.3,
                    "path_length_avg": 87.87517046627008,
                    "smoothness_avg": 0.1411824859080123,
                    "success_improvement": -50.0,
                    "time_improvement": 67.59235822863768,
                    "length_improvement": 41.63749594225553,
                    "smoothness_improvement": 1695.830799742812,
                    "objective_score": -212.91563934424354
               }
          ],
          "success_rate": 0.8333333333333334
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 106.30795071221966,
          "time_improvement": -370.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 159.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0857201099395752,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "smoothness_avg": 0.014115946270353475,
                    "success_improvement": 0.0,
                    "time_improvement": -241.72839177615288,
                    "length_improvement": 13.538080892453477,
                    "smoothness_improvement": 120.9452123989805,
                    "objective_score": -69.20617529236027
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.7973393440246582,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "smoothness_avg": 0.011462143624438778,
                    "success_improvement": 0.0,
                    "time_improvement": -394.9664083360431,
                    "length_improvement": 24.746264827685106,
                    "smoothness_improvement": 194.92921130515853,
                    "objective_score": -112.5660234787501
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.28233766555786133,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "smoothness_avg": 0.020633789931938304,
                    "success_improvement": 0.0,
                    "time_improvement": -474.0346754346548,
                    "length_improvement": 21.232239201581347,
                    "smoothness_improvement": 162.46028490630954,
                    "objective_score": -137.1516533655486
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional informed RRT* planner with adaptive rewiring, ellipsoidal informed sampling, goal biasing, and path smoothing. It grows two trees from start and goal positions, incrementally extends and rewires them to optimize path costs while rigorously checking collisions on nodes and edges. The planner enforces a 30-second timeout to ensure efficient termination, returning the best path found.",
          "planning_mechanism": "The planner alternates growth between the start and goal trees, sampling points globally initially and from an ellipsoidal informed subset after a path is found. Each extension rewires nearby nodes to minimize path cost. Incremental connection attempts and rewiring bridge the two trees, and when a connection is found, the path is extracted and smoothed. The algorithm balances exploration and exploitation via adaptive neighbor radius, goal biasing, and rigorous collision checks to provide robust, high-quality, and efficient path planning.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = None\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 15000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 25.0,\n                 max_time_sec: float = 30.0,\n                 smoothing_iters: int = 150,\n                 collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 35.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= r_sq]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.collision_resolution)\n\n        def informed_sample(start, goal, c_best):\n            if c_best == float('inf'):\n                # Uniform random sample in space\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = math.dist(start, goal)\n            if c_best < c_min:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            import numpy as np\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)]).reshape((dim,1))\n            U, _, _ = np.linalg.svd(a1)\n            rot = U\n            r1 = c_best / 2.0\n            r_rest = 0 if dim == 1 else math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n            radii = np.array([r1] + [r_rest] * (dim - 1))\n            while True:\n                sample_unit = np.random.normal(0, 1, (dim,))\n                norm = np.linalg.norm(sample_unit)\n                if norm == 0:\n                    continue\n                sample_unit /= norm\n                u = random.random() ** (1.0 / dim)\n                sample_ball = sample_unit * u\n                sample_ellipsoid = sample_ball * radii\n                sample_world = rot @ sample_ellipsoid + center\n                sample_tuple = tuple(sample_world.flatten())\n                if in_bounds(sample_tuple) and not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                    return sample_tuple\n\n        def add_node_and_rewire(tree, new_pos):\n            n = len(tree)\n            radius = adaptive_radius(n)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Find best parent candidate\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    if collision_free_node(new_pos):\n                        min_cost = cost_try\n                        best_parent = neighbor\n\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if lower cost via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_try = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_try < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_try)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def incremental_connect(tree, target_pos):\n            current_node = nearest(tree, target_pos)\n            max_steps = int(math.ceil(math.dist(current_node.position, target_pos) / self.step_size)) + 5\n            for _ in range(max_steps):\n                new_pos = steer(current_node.position, target_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                new_node = add_node_and_rewire(tree, new_pos)\n                if new_node is None:\n                    return None\n\n                current_node = new_node\n                if math.dist(current_node.position, target_pos) <= self.step_size:\n                    return current_node\n            return None\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            smoothed_path = path[:]\n            length = len(smoothed_path)\n            for _ in range(self.smoothing_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if collision_free_edge(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                    length = len(smoothed_path)\n            return smoothed_path\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        tree_a, tree_b = start_tree, goal_tree\n        c_best = float('inf')\n\n        for _ in range(self.max_iter):\n            if time.perf_counter() - start_time > self.max_time_sec:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position\n            else:\n                sample = informed_sample(start_position, goal_position, c_best)\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = add_node_and_rewire(tree_a, new_pos)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = incremental_connect(tree_b, new_node.position)\n            if connect_node:\n                total_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    c_best = best_cost\n                    best_connection = (new_node, connect_node)\n\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                    combined_path = path_from_start + path_from_goal[::-1][1:]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n\n                    if time.perf_counter() - start_time > 0.1 and best_cost < float('inf'):\n                        break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If timeout or max iterations without early stop but path found\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_from_start = node_a.path_from_root()\n            path_from_goal = node_b.path_from_root()\n            combined_path = path_from_start + path_from_goal[::-1][1:]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 178.5565,
          "time_improvement": -521.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 1370.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.17346565723419188,
                    "num_nodes_avg": 294.7,
                    "path_length_avg": 155.47907423965995,
                    "smoothness_avg": 0.04272814735917477,
                    "success_improvement": 0.0,
                    "time_improvement": -598.7659644762191,
                    "length_improvement": 14.779455685650142,
                    "smoothness_improvement": 568.7882918281614,
                    "objective_score": -173.8299567465949
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.8762366771697998,
                    "num_nodes_avg": 1140.5,
                    "path_length_avg": 219.82537882773286,
                    "smoothness_avg": 0.09602257889550683,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -448.8856891823818,
                    "length_improvement": 26.615961224601147,
                    "smoothness_improvement": 2370.730117249409,
                    "objective_score": -167.48886392354726
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.3013651132583618,
                    "num_nodes_avg": 709.2,
                    "path_length_avg": 114.91454316719766,
                    "smoothness_avg": 0.09983422268392517,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -516.4531787148976,
                    "length_improvement": 23.679232070864444,
                    "smoothness_improvement": 1169.883943543741,
                    "objective_score": -194.35068748257765
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner implements an informed bidirectional RRT* algorithm with adaptive neighbor radius, ellipsoidal informed sampling focused between start and goal, incremental extend-and-rewire expansions, and rigorous collision checks on both nodes and edges. The algorithm alternately grows two trees from start and goal, seeks to dynamically connect and rewire the trees incrementally, and applies path smoothing to reduce unnecessary waypoints. It enforces a strict 30-second planning timeout, returning the best feasible path found, optimizing both planning speed and path quality.",
          "planning_mechanism": "The planner samples points either within an ellipsoidal informed subset (once an initial path is found) or globally otherwise, with goal biasing to accelerate convergence. Trees are extended incrementally towards samples with collision-free steps and adaptive neighborhood rewiring to optimize path costs. Incremental connections attempt bridging the two trees, with rewiring maintaining consistent and low-cost trees. Upon finding a connection or timeout, the combined path is smoothed by shortcutting. The planner tracks explored nodes and edges, ensuring robust tree structure and collision safety throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = None              # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Collision validity flag\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost updates recursively to children\n        for child in self.children:\n            dist = math.dist(self.position, child.position)\n            child.update_parent(self, self.cost + dist)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 15000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 25.0,\n                 max_time_sec: float = 30.0,\n                 smoothing_iters: int = 150,\n                 collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.max_time_sec = max_time_sec\n        self.smoothing_iters = smoothing_iters\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles // 2D or 3D\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # Adaptive neighbor radius based on number of nodes and dimension\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = 35.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (math.dist(node.position, position) ** 2) <= r_sq]\n\n        def collision_free_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.collision_resolution)\n\n        # Ellipsoidal informed sampling between start and goal\n        def informed_sample(start, goal, c_best):\n            # If no solution found yet, uniform random sampling\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = math.dist(start, goal)\n            if c_best < c_min:\n                # No better path possible\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Create ellipsoid parameters\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]  # unit vector from start to goal\n\n            # Create rotation matrix to align with a1\n            # Using numpy for stable and efficient computation\n            import numpy as np\n            iden = np.eye(dim)\n            a1_np = np.array(a1).reshape((dim,1))\n            U, _, _ = np.linalg.svd(a1_np)\n            rot = U  # rotation matrix to align x-axis to a1\n\n            # Ellipsoid radii: major axis = c_best/2, other axes = sqrt(c_best^2 - c_min^2)/2\n            r1 = c_best / 2.0\n            if dim > 1:\n                r_rest = math.sqrt(c_best**2 - c_min**2) / 2.0\n            else:\n                r_rest = 0\n\n            radii = np.array([r1] + [r_rest] * (dim -1))\n\n            # Sample uniformly in unit n-ball (hypersphere)\n            while True:\n                sample_unit = np.random.normal(0,1,(dim,))\n                norm = np.linalg.norm(sample_unit)\n                if norm == 0:\n                    continue\n                sample_unit /= norm\n                u = random.random() ** (1.0/dim)\n                sample_ball = sample_unit * u  # inside unit ball\n\n                # Scale by radii\n                sample_ellipsoid = sample_ball * radii\n\n                # Rotate and translate\n                sample_world = rot @ sample_ellipsoid + np.array(center)\n\n                sample_tuple = tuple(sample_world.flatten())\n                if in_bounds(sample_tuple) and not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                    return sample_tuple\n\n        # Adds a node and connections to the tree with rewiring\n        def add_node_and_rewire(tree, new_pos):\n            n = len(tree)\n            radius = adaptive_radius(n)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Choose best parent by minimum cost + edge cost\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in neighbors:\n                cost_try = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost_try < min_cost and collision_free_edge(neighbor.position, new_pos):\n                    min_cost = cost_try\n                    best_parent = neighbor\n\n            if best_parent is None:\n                return None\n\n            if not collision_free_node(new_pos):\n                return None\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if new_node offers lower cost path\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_try = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_try < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.parent.remove_child(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_try)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Incrementally connect tree towards target position with rewiring\n        def incremental_connect(tree, target_pos):\n            current_node = nearest(tree, target_pos)\n\n            max_steps = int(math.ceil(math.dist(current_node.position, target_pos) / self.step_size)) + 5\n            for _ in range(max_steps):\n                new_pos = steer(current_node.position, target_pos)\n                if not collision_free_node(new_pos):\n                    return None\n                if not collision_free_edge(current_node.position, new_pos):\n                    return None\n\n                new_node = add_node_and_rewire(tree, new_pos)\n                if new_node is None:\n                    return None\n\n                current_node = new_node\n                if math.dist(current_node.position, target_pos) <= self.step_size:\n                    return current_node\n            return None\n\n        # Path smoothing by random shortcutting respecting obstacles\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            length = len(path)\n            smoothed_path = path[:]\n            for _ in range(self.smoothing_iters):\n                if length <= 2:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if collision_free_edge(smoothed_path[i], smoothed_path[j]):\n                    smoothed_path = smoothed_path[:i + 1] + smoothed_path[j:]\n                    length = len(smoothed_path)\n            return smoothed_path\n\n        start_time = time.perf_counter()\n\n        nodes = []\n        edges = []\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        tree_a, tree_b = start_tree, goal_tree\n        c_best = float('inf')  # Current best path cost for informed sampling\n\n        for _ in range(self.max_iter):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > self.max_time_sec:\n                break\n\n            # Sample with goal biasing and informed sample if path found\n            if random.random() < self.goal_sample_rate:\n                sample = tree_b[0].position  # bias towards opposite root\n            else:\n                sample = informed_sample(start_position, goal_position, c_best)\n\n            # Try to extend tree_a towards sample\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = add_node_and_rewire(tree_a, new_pos)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Try to incrementally connect tree_b to new_node\n            connect_node = incremental_connect(tree_b, new_node.position)\n            if connect_node:\n                total_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    c_best = best_cost\n                    best_connection = (new_node, connect_node)\n\n                    # Build combined path without duplicate node\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                    combined_path = path_from_start + path_from_goal[::-1][1:]\n                    extracted_path = path_smoothing(combined_path)\n                    success_state = True\n\n                    # Early stop for improved solution\n                    if elapsed > 0.1 and best_cost < float('inf'):\n                        break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # On time out or max iteration without early success but best path found\n        if not success_state and best_connection is not None:\n            node_a, node_b = best_connection\n            path_from_start = node_a.path_from_root()\n            path_from_goal = node_b.path_from_root()\n            combined_path = path_from_start + path_from_goal[::-1][1:]\n            extracted_path = path_smoothing(combined_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 338.95206,
          "time_improvement": -947.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 1470.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.19697656631469726,
                    "num_nodes_avg": 340.0,
                    "path_length_avg": 152.7967523779916,
                    "smoothness_avg": 0.039588881223796564,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -693.474181199326,
                    "length_improvement": 16.24967880214043,
                    "smoothness_improvement": 519.6519597839692,
                    "objective_score": -252.19405880044982
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 1.0181169033050537,
                    "num_nodes_avg": 1131.0,
                    "path_length_avg": 229.43789582941685,
                    "smoothness_avg": 0.09087956054669113,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -537.7612495562486,
                    "length_improvement": 23.40702636847813,
                    "smoothness_improvement": 2238.3965507679964,
                    "objective_score": -195.45498683933894
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.8360244989395141,
                    "num_nodes_avg": 1487.8,
                    "path_length_avg": 108.6540497308993,
                    "smoothness_avg": 0.1377507248365339,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -1610.1181828334713,
                    "length_improvement": 27.83715371859191,
                    "smoothness_improvement": 1652.1790522198596,
                    "objective_score": -569.2071288452236
               }
          ],
          "success_rate": 0.8666666666666667
     }
]